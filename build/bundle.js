/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 58);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var bind = __webpack_require__(38);
var isBuffer = __webpack_require__(76);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && !isArray(obj)) {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge() /* obj1, obj2, obj3, ... */{
  var result = {};
  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(45);

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate
    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(195)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(59);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsNative = __webpack_require__(98),
    getValue = __webpack_require__(129);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * vuex v2.4.1
 * (c) 2017 Evan You
 * @license MIT
 */
var applyMixin = function applyMixin(Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if (options === void 0) options = {};

      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit() {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = typeof options.store === 'function' ? options.store() : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
};

var devtoolHook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin(store) {
  if (!devtoolHook) {
    return;
  }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */

/**
 * forEach for object
 */
function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function (key) {
    return fn(obj[key], key);
  });
}

function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

function isPromise(val) {
  return val && typeof val.then === 'function';
}

function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}

var Module = function Module(rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = { namespaced: { configurable: true } };

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced;
};

Module.prototype.addChild = function addChild(key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};

Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties(Module.prototype, prototypeAccessors$1);

var ModuleCollection = function ModuleCollection(rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get(path) {
  return path.reduce(function (module, key) {
    return module.getChild(key);
  }, this.root);
};

ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '');
  }, '');
};

ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1 = this;
  if (runtime === void 0) runtime = true;

  if (true) {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (!parent.getChild(key).runtime) {
    return;
  }

  parent.removeChild(key);
};

function update(path, targetModule, newModule) {
  if (true) {
    assertRawModule(path, newModule);
  }

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (true) {
          console.warn("[vuex] trying to add a new module '" + key + "' on hot reloading, " + 'manual reload is needed');
        }
        return;
      }
      update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
    }
  }
}

function assertRawModule(path, rawModule) {
  ['getters', 'actions', 'mutations'].forEach(function (key) {
    if (!rawModule[key]) {
      return;
    }

    forEachValue(rawModule[key], function (value, type) {
      assert(typeof value === 'function', makeAssertionMessage(path, key, type, value));
    });
  });
}

function makeAssertionMessage(path, key, type, value) {
  var buf = key + " should be function but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + path.join('.') + "\"";
  }
  buf += " is " + JSON.stringify(value) + ".";

  return buf;
}

var Vue; // bind on install

var Store = function Store(options) {
  var this$1 = this;
  if (options === void 0) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if (true) {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "Store must be called with the new operator.");
  }

  var plugins = options.plugins;if (plugins === void 0) plugins = [];
  var strict = options.strict;if (strict === void 0) strict = false;

  var state = options.state;if (state === void 0) state = {};
  if (typeof state === 'function') {
    state = state();
  }

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch(type, payload) {
    return dispatch.call(store, type, payload);
  };
  this.commit = function boundCommit(type, payload, options) {
    return commit.call(store, type, payload, options);
  };

  // strict mode
  this.strict = strict;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.forEach(function (plugin) {
    return plugin(this$1);
  });

  if (Vue.config.devtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors = { state: { configurable: true } };

prototypeAccessors.state.get = function () {
  return this._vm._data.$$state;
};

prototypeAccessors.state.set = function (v) {
  if (true) {
    assert(false, "Use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
  var type = ref.type;
  var payload = ref.payload;
  var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if (true) {
      console.error("[vuex] unknown mutation type: " + type);
    }
    return;
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });
  this._subscribers.forEach(function (sub) {
    return sub(mutation, this$1.state);
  });

  if ("development" !== 'production' && options && options.silent) {
    console.warn("[vuex] mutation type: " + type + ". Silent option has been removed. " + 'Use the filter functionality in the vue-devtools');
  }
};

Store.prototype.dispatch = function dispatch(_type, _payload) {
  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
  var type = ref.type;
  var payload = ref.payload;

  var entry = this._actions[type];
  if (!entry) {
    if (true) {
      console.error("[vuex] unknown action type: " + type);
    }
    return;
  }
  return entry.length > 1 ? Promise.all(entry.map(function (handler) {
    return handler(payload);
  })) : entry[0](payload);
};

Store.prototype.subscribe = function subscribe(fn) {
  var subs = this._subscribers;
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  };
};

Store.prototype.watch = function watch(getter, cb, options) {
  var this$1 = this;

  if (true) {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }
  return this._watcherVM.$watch(function () {
    return getter(this$1.state, this$1.getters);
  }, cb, options);
};

Store.prototype.replaceState = function replaceState(state) {
  var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule(path, rawModule) {
  if (typeof path === 'string') {
    path = [path];
  }

  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path));
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1 = this;

  if (typeof path === 'string') {
    path = [path];
  }

  if (true) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties(Store.prototype, prototypeAccessors);

function resetStore(store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM(store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = function () {
      return fn(store);
    };
    Object.defineProperty(store.getters, key, {
      get: function get() {
        return store._vm[key];
      },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () {
      return oldVm.$destroy();
    });
  }
}

function installModule(store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var namespacedType = namespace + key;
    registerAction(store, namespacedType, action, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext(store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if ("development" !== 'production' && !store._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }

      return store.dispatch(type, payload);
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if ("development" !== 'production' && !store._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function () {
        return store.getters;
      } : function () {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function get() {
        return getNestedState(store.state, path);
      }
    }
  });

  return local;
}

function makeLocalGetters(store, namespace) {
  var gettersProxy = {};

  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) {
      return;
    }

    // extract local getter type
    var localType = type.slice(splitPos);

    // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.
    Object.defineProperty(gettersProxy, localType, {
      get: function get() {
        return store.getters[type];
      },
      enumerable: true
    });
  });

  return gettersProxy;
}

function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler(payload, cb) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err;
      });
    } else {
      return res;
    }
  });
}

function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (true) {
      console.error("[vuex] duplicate getter key: " + type);
    }
    return;
  }
  store._wrappedGetters[type] = function wrappedGetter(store) {
    return rawGetter(local.state, // local state
    local.getters, // local getters
    store.state, // root state
    store.getters // root getters
    );
  };
}

function enableStrictMode(store) {
  store._vm.$watch(function () {
    return this._data.$$state;
  }, function () {
    if (true) {
      assert(store._committing, "Do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, sync: true });
}

function getNestedState(state, path) {
  return path.length ? path.reduce(function (state, key) {
    return state[key];
  }, state) : state;
}

function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if (true) {
    assert(typeof type === 'string', "Expects string as the type, but found " + (typeof type === 'undefined' ? 'undefined' : _typeof(type)) + ".");
  }

  return { type: type, payload: payload, options: options };
}

function install(_Vue) {
  if (Vue && _Vue === Vue) {
    if (true) {
      console.error('[vuex] already installed. Vue.use(Vuex) should be called only once.');
    }
    return;
  }
  Vue = _Vue;
  applyMixin(Vue);
}

var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return;
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function' ? val.call(this, state, getters) : state[val];
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res;
});

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return;
        }
        commit = module.context.commit;
      }
      return typeof val === 'function' ? val.apply(this, [commit].concat(args)) : commit.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return;
      }
      if ("development" !== 'production' && !(val in this.$store.getters)) {
        console.error("[vuex] unknown getter: " + val);
        return;
      }
      return this.$store.getters[val];
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res;
});

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return;
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function' ? val.apply(this, [dispatch].concat(args)) : dispatch.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});

var createNamespacedHelpers = function createNamespacedHelpers(namespace) {
  return {
    mapState: mapState.bind(null, namespace),
    mapGetters: mapGetters.bind(null, namespace),
    mapMutations: mapMutations.bind(null, namespace),
    mapActions: mapActions.bind(null, namespace)
  };
};

function normalizeMap(map) {
  return Array.isArray(map) ? map.map(function (key) {
    return { key: key, val: key };
  }) : Object.keys(map).map(function (key) {
    return { key: key, val: map[key] };
  });
}

function normalizeNamespace(fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map);
  };
}

function getModuleByNamespace(store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if ("development" !== 'production' && !module) {
    console.error("[vuex] module namespace not found in " + helper + "(): " + namespace);
  }
  return module;
}

var index_esm = {
  Store: Store,
  install: install,
  version: '2.4.1',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers
};

exports.Store = Store;
exports.install = install;
exports.mapState = mapState;
exports.mapMutations = mapMutations;
exports.mapGetters = mapGetters;
exports.mapActions = mapActions;
exports.createNamespacedHelpers = createNamespacedHelpers;
exports.default = index_esm;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(1);

/** Built-in value references. */
var _Symbol = root.Symbol;

module.exports = _Symbol;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(9),
    getRawTag = __webpack_require__(126),
    objectToString = __webpack_require__(155);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(14);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var baseGetTag = __webpack_require__(10),
    isObjectLike = __webpack_require__(13);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var listCacheClear = __webpack_require__(141),
    listCacheDelete = __webpack_require__(142),
    listCacheGet = __webpack_require__(143),
    listCacheHas = __webpack_require__(144),
    listCacheSet = __webpack_require__(145);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var eq = __webpack_require__(30);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isKeyable = __webpack_require__(138);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(7);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(50),
    isLength = __webpack_require__(32);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Vue.js v2.4.4
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}

/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

var _toString = Object.prototype.toString;

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
  var n = parseFloat(val);
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,is');

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});

/**
 * Simple bind, faster than native
 */
function bind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn;
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop(a, b, c) {}

/**
 * Always return false.
 */
var no = function no(a, b, c) {
  return false;
};

/**
 * Return same value
 */
var identity = function identity(_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  if (a === b) {
    return true;
  }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = ['component', 'directive', 'filter'];

var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */

var warn = noop;
var tip = noop;
var formatComponentName = null; // work around flow check

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function classify(str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function warn(msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function tip(msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function formatComponentName(vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;

    var file = vm._isVue && vm.$options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function repeat(str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) {
        res += str;
      }
      if (n > 1) {
        str += str;
      }
      n >>= 1;
    }
    return res;
  };

  var generateComponentTrace = function generateComponentTrace(vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}

/*  */

function handleError(err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (true) {
      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }
}

/*  */
/* globals MutationObserver */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = {}.watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function isServerRendering() {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function logError(err) {
      console.error(err);
    };
    timerFunc = function timerFunc() {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
  } else if (!isIE && typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function timerFunc() {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function timerFunc() {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve, reject) {
        _resolve = resolve;
      });
    }
  };
}();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

/*  */

var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;
    while (len--) {
      args[len] = arguments[len];
    }var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value)) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1(obj, key, val, customSetter, shallow) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if ("development" !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    "development" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    "development" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this) : childVal, typeof parentVal === 'function' ? parentVal.call(this) : parentVal);
    };
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "development" !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

      return parentVal;
    }
    return mergeDataOrFn.call(this, parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal ? extend(res, childVal) : res;
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }
  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal) {
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) {
    extend(ret, childVal);
  }
  return ret;
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function defaultStrat(parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options) {
  var inject = options.inject;
  if (Array.isArray(inject)) {
    var normalized = options.inject = {};
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = inject[i];
    }
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child);
  normalizeInject(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ("development" !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (true) {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ("development" !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isType(type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type);
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true;
    }
  }
  /* istanbul ignore next */
  return false;
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function warnNonPresent(target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function mark(tag) {
      return perf.mark(tag);
    };
    measure = function measure(name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function createEmptyVNode(text) {
  if (text === void 0) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode, deep) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.isCloned = true;
  if (deep && vnode.children) {
    cloned.children = cloneVNodes(vnode.children);
  }
  return cloned;
}

function cloneVNodes(vnodes, deep) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i], deep);
  }
  return res;
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  var plain = !(passive || once$$1 || capture);
  return {
    name: name,
    plain: plain,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

// #6552
function prioritizePlainEvents(a, b) {
  return a.plain ? -1 : b.plain ? 1 : 0;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, cur, old, event;
  var toAdd = [];
  var hasModifier = false;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (!event.plain) {
      hasModifier = true;
    }
    if (isUndef(cur)) {
      "development" !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      event.handler = cur;
      toAdd.push(event);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  if (toAdd.length) {
    if (hasModifier) {
      toAdd.sort(prioritizePlainEvents);
    }
    for (var i = 0; i < toAdd.length; i++) {
      var event$1 = toAdd[i];
      add(event$1.name, event$1.handler, event$1.once, event$1.capture, event$1.passive);
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        last.text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function ensureCtor(comp, base) {
  if (comp.__esModule && comp.default) {
    comp = comp.default;
  }
  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node;
}

function resolveAsyncComponent(factory, baseCtor, context) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function forceRender() {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "development" !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject( true ? "timeout (" + res.timeout + "ms)" : null);
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}

/*  */

function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}

/*  */

function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}

/*  */

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm;
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break;
        }
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, "event handler for \"" + event + "\"");
        }
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  var defaultSlot = [];
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) && data && data.slot != null) {
      var name = child.data.slot;
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment || node.text === ' ';
}

function resolveScopedSlots(fns, // see flow/vnode
res) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res;
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ("development" !== 'production' && config.performance && mark) {
    updateComponent = function updateComponent() {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function updateComponent() {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (true) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data && parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ("development" !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "development" !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse(val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function checkOptionType(vm, name) {
  var option = vm.$options[name];
  if (!isPlainObject(option)) {
    warn("component option \"" + name + "\" should be an object.", vm);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function loop(key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      if (isReservedAttribute(key) || config.isReservedAttr(key)) {
        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive$$1(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) {
    loop(key);
  }observerState.shouldConvert = true;
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "development" !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }
    if (props && hasOwn(props, key)) {
      "development" !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData(data, vm) {
  try {
    return data.call(vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  "development" !== 'production' && checkOptionType(vm, 'computed');
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ("development" !== 'production' && getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  if ("development" !== 'production' && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  "development" !== 'production' && checkOptionType(vm, 'methods');
  var props = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (methods[key] == null) {
        warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }
      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  "development" !== 'production' && checkOptionType(vm, 'watch');
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, keyOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (true) {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {
        defineReactive$$1(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
      /* istanbul ignore next */
      return Object.getOwnPropertyDescriptor(inject, key).enumerable;
    }) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break;
        }
        source = source.$parent;
      }
      if ("development" !== 'production' && !source) {
        warn("Injection \"" + key + "\" not found", vm);
      }
    }
    return result;
  }
}

/*  */

function createFunctionalComponent(Ctor, propsData, data, context, children) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }
    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function h(a, b, c, d) {
    return createElement(_context, a, b, c, d, true);
  };
  var vnode = Ctor.options.render.call(null, h, {
    data: data,
    props: props,
    children: children,
    parent: context,
    listeners: data.on || emptyObject,
    injections: resolveInject(Ctor.options.inject, context),
    slots: function slots() {
      return resolveSlots(children, context);
    }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    vnode.functionalOptions = Ctor.options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options);
}

function mergeHooks(data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1(one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  };
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    "development" !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // warn against non-primitive key
  if ("development" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) {
      applyNS(vnode, ns);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && isUndef(child.ns)) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    ret._isVList = true;
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      props = extend(extend({}, bindObject), props);
    }
    return scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && "development" !== 'production') {
      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      slotNodes._rendered = true;
    }
    return slotNodes || fallback;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes(eventKeyCode, key, builtInAlias) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1;
  } else {
    return keyCodes !== eventKeyCode;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
      "development" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function loop(key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) {
        loop(key);
      }
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "development" !== 'production' && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(ours, existing) : ours;
      }
    }
  }
  return data;
}

/*  */

function initRender(vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (true) {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin(Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // if the parent didn't update, the slot nodes will be the ones from
      // last render. They need to be cloned to ensure "freshness" for this render.
      for (var key in vm.$slots) {
        var slot = vm.$slots[key];
        if (slot._rendered) {
          vm.$slots[key] = cloneVNodes(slot, true /* deep */);
        }
      }
    }

    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (true) {
        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ("development" !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
  Vue.prototype._g = bindObjectListeners;
}

/*  */

var uid = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      startTag = "vue-perf-init:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue$3(options) {
  if ("development" !== 'production' && !(this instanceof Vue$3)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (true) {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
      }
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (true) {
          if (type === 'component' && config.isReservedTag(id)) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp, Array];

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(cache, current, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        if (cachedNode !== current) {
          pruneCacheEntry(cachedNode);
        }
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry(vnode) {
  if (vnode) {
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created() {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include(val) {
      pruneCache(this.cache, this._vnode, function (name) {
        return matches(val, name);
      });
    },
    exclude: function exclude(val) {
      pruneCache(this.cache, this._vnode, function (name) {
        return !matches(val, name);
      });
    }
  },

  render: function render() {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
        return vnode;
      }
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode;
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (true) {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
});

Vue$3.version = '2.4.4';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function mustUseProp(tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function isXlink(name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function getXlinkProp(name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function isFalsyAttrValue(val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }
  if (isObject(value)) {
    return stringifyObject(value);
  }
  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */
  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }
      res += stringified;
    }
  }
  return res;
}

function stringifyObject(value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }
      res += key;
    }
  }
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isReservedTag = function isReservedTag(tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      "development" !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setAttribute(node, key, val) {
  node.setAttribute(key, val);
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          inPre++;
        }
        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if ("development" !== 'production' && data && data.pre) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if ("development" !== 'production' && !elmToMove) {
            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return;
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue) {
    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.elm = elm;
      vnode.isAsyncPlaceholder = true;
      return true;
    }
    if (true) {
      if (!assertNodeMatch(elm, vnode)) {
        return false;
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ("development" !== 'production' && typeof console !== 'undefined' && !bailed) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
                childrenMatch = false;
                break;
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ("development" !== 'production' && typeof console !== 'undefined' && !bailed) {
                bailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false;
            }
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (true) {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            }
            ancestor = ancestor.parent;
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function callInsert() {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  /* istanbul ignore if */
  if (isIE9 && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + "," + args;
  }
}

/*  */

/*  */

/**
 * Cross-platform code generation for component v-model
 */

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */

/**
 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
 *
 * for loop possible cases:
 *
 * - test
 * - test[idx]
 * - test[test1[idx]]
 * - test["a"][idx]
 * - xxx.test[a[a].test1[idx]]
 * - test.xxx.a["asa"][test1[idx]]
 *
 */

var str;
var index$1;

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  var event;
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    // Chrome fires microtasks in between click/change, leads to #4521
    event = isChrome ? 'click' : 'change';
    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function add$1(event, _handler, once$$1, capture, passive) {
  if (once$$1) {
    var oldHandler = _handler;
    var _target = target$1; // save current target element in closure
    _handler = function handler(ev) {
      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, _handler, capture, _target);
      }
    };
  }
  target$1.addEventListener(event, _handler, supportsPassive ? { capture: capture, passive: passive } : capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, vnode, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, vnode, checkVal) {
  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
}

function isDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}
  return notInFocus && elm.value !== checkVal;
}

function isInputChanged(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers) && modifiers.number) {
    return toNumber(value) !== toNumber(newVal);
  }
  if (isDef(modifiers) && modifiers.trim) {
    return value.trim() !== newVal.trim();
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function setProp(el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */
  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function end() {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function onEnd(e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return;
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if ("development" !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return rm();
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if ("development" !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    "development" !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$options._renderChildren;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag || isAsyncPlaceholder(c);
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if ("development" !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if ("development" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }
        var delayedLeave;
        var performLeave = function performLeave() {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    var body = document.body;
    var f = body.offsetHeight; // eslint-disable-line

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
setTimeout(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if ("development" !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
  }
  if ("development" !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
  }
}, 0);

/*  */

exports.default = Vue$3;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(52)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(0);
var normalizeHeaderName = __webpack_require__(73);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(34);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(34);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {/* Ignore */}
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(185)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(7),
    root = __webpack_require__(1);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var mapCacheClear = __webpack_require__(146),
    mapCacheDelete = __webpack_require__(147),
    mapCacheGet = __webpack_require__(148),
    mapCacheHas = __webpack_require__(149),
    mapCacheSet = __webpack_require__(150);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var castPath = __webpack_require__(28),
    toKey = __webpack_require__(11);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var baseMatches = __webpack_require__(102),
    baseMatchesProperty = __webpack_require__(103),
    identity = __webpack_require__(20),
    isArray = __webpack_require__(2),
    property = __webpack_require__(176);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArray = __webpack_require__(2),
    isKey = __webpack_require__(29),
    stringToPath = __webpack_require__(169),
    toString = __webpack_require__(184);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isArray = __webpack_require__(2),
    isSymbol = __webpack_require__(14);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsArguments = __webpack_require__(95),
    isObjectLike = __webpack_require__(13);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
    return arguments;
}()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayLikeKeys = __webpack_require__(86),
    baseKeys = __webpack_require__(100),
    isArrayLike = __webpack_require__(21);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var settle = __webpack_require__(65);
var buildURL = __webpack_require__(68);
var parseHeaders = __webpack_require__(74);
var isURLSameOrigin = __webpack_require__(72);
var createError = __webpack_require__(37);
var btoa = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || __webpack_require__(67);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if ("development" !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || request.readyState !== 4 && !xDomain) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(70);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(64);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ListCache = __webpack_require__(15),
    stackClear = __webpack_require__(164),
    stackDelete = __webpack_require__(165),
    stackGet = __webpack_require__(166),
    stackHas = __webpack_require__(167),
    stackSet = __webpack_require__(168);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsEqualDeep = __webpack_require__(96),
    isObjectLike = __webpack_require__(13);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SetCache = __webpack_require__(81),
    arraySome = __webpack_require__(87),
    cacheHas = __webpack_require__(115);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(52)))

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(12);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

module.exports = matchesStrictComparable;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var root = __webpack_require__(1),
    stubFalse = __webpack_require__(180);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)(module)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(10),
    isObject = __webpack_require__(12);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsTypedArray = __webpack_require__(99),
    baseUnary = __webpack_require__(43),
    nodeUtil = __webpack_require__(154);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(224)
}
var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(190),
  /* template */
  __webpack_require__(215),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasysx/client/components/register.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] register.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5fb4fc4a", Component.options)
  } else {
    hotAPI.reload("data-v-5fb4fc4a", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRouter = createRouter;

var _vue = __webpack_require__(22);

var _vue2 = _interopRequireDefault(_vue);

var _vueRouter = __webpack_require__(194);

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _leaderboard = __webpack_require__(204);

var _leaderboard2 = _interopRequireDefault(_leaderboard);

var _register = __webpack_require__(54);

var _register2 = _interopRequireDefault(_register);

var _myteam = __webpack_require__(206);

var _myteam2 = _interopRequireDefault(_myteam);

var _rules = __webpack_require__(208);

var _rules2 = _interopRequireDefault(_rules);

var _stattracker = __webpack_require__(209);

var _stattracker2 = _interopRequireDefault(_stattracker);

var _suggestions = __webpack_require__(210);

var _suggestions2 = _interopRequireDefault(_suggestions);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vueRouter2.default);

function createRouter() {
  return new _vueRouter2.default({
    mode: 'history',
    routes: [{ path: "/", component: _leaderboard2.default }, { path: "/register", component: _register2.default }, { path: "/myteam", component: _myteam2.default }, { path: "/rules", component: _rules2.default }, { path: "/live", component: _stattracker2.default }, { path: "/suggestions", component: _suggestions2.default }, { path: "/home", component: _leaderboard2.default }]
  });
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(22);

var _vue2 = _interopRequireDefault(_vue);

var _vuex = __webpack_require__(8);

var _vuex2 = _interopRequireDefault(_vuex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vuex2.default);

var state = {
  user: {
    username: ''
  },
  isLoggedIn: false,
  modalControl: {
    showLoginModal: false,
    showRegisterModal: false
  }
};

var getters = {
  getUserData: function getUserData() {
    return state.user;
  },
  ShowLoginModal: function ShowLoginModal() {
    return state.modalControl.showLoginModal;
  },
  ShowRegisterModal: function ShowRegisterModal() {
    return state.modalControl.showRegisterModal;
  },
  GetAuthStatus: function GetAuthStatus() {
    return state.isLoggedIn;
  }
};

var mutations = {
  changeTeam: function changeTeam(state, riderArray) {
    state.user.riders = riderArray;
  },
  setLoginModal: function setLoginModal(state, _ref) {
    var show = _ref.show;

    state.modalControl.showLoginModal = show;
  },
  setRegisterModal: function setRegisterModal(state, _ref2) {
    var show = _ref2.show;

    state.modalControl.showRegisterModal = show;
  },
  setUserData: function setUserData(state, _ref3) {
    var userData = _ref3.userData;

    state.user = userData;
  },
  setLoggedIn: function setLoggedIn(state, _ref4) {
    var loggedIn = _ref4.loggedIn;

    state.isLoggedIn = loggedIn;
  },
  logout: function logout(state) {
    state.user.riders = [];
    state.user = {};
    state.isLoggedIn = false;
  }
};

exports.default = new _vuex2.default.Store({
  state: state,
  getters: getters,
  mutations: mutations
});

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(223)
}
var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(193),
  /* template */
  __webpack_require__(214),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasysx/index.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] index.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4fc005b0", Component.options)
  } else {
    hotAPI.reload("data-v-4fc005b0", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _vue = __webpack_require__(22);

var _vue2 = _interopRequireDefault(_vue);

var _index = __webpack_require__(57);

var _index2 = _interopRequireDefault(_index);

var _router = __webpack_require__(55);

var _store = __webpack_require__(56);

var _store2 = _interopRequireDefault(_store);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var router = (0, _router.createRouter)();
var app = new _vue2.default({
  el: "#app",
  router: router,
  store: _store2.default,
  render: function render(h) {
    return h(_index2.default);
  }
}).$mount("#app");

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var bind = __webpack_require__(38);
var Axios = __webpack_require__(61);
var defaults = __webpack_require__(23);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(35);
axios.CancelToken = __webpack_require__(60);
axios.isCancel = __webpack_require__(36);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(75);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(35);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(23);
var utils = __webpack_require__(0);
var InterceptorManager = __webpack_require__(62);
var dispatchRequest = __webpack_require__(63);
var isAbsoluteURL = __webpack_require__(71);
var combineURLs = __webpack_require__(69);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
  config.method = config.method.toLowerCase();

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var transformData = __webpack_require__(66);
var isCancel = __webpack_require__(36);
var defaults = __webpack_require__(23);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(config.data, config.headers, config.transformRequest);

  // Flatten headers
  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});

  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(response.data, response.headers, config.transformResponse);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(37);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error();
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
  // initialize result and counter
  var block, charCode, idx = 0, map = chars;
  // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1);
  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },

    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },

    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() :

// Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
  );
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;

  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :

// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(7),
    root = __webpack_require__(1);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hashClear = __webpack_require__(131),
    hashDelete = __webpack_require__(132),
    hashGet = __webpack_require__(133),
    hashHas = __webpack_require__(134),
    hashSet = __webpack_require__(135);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(7),
    root = __webpack_require__(1);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(7),
    root = __webpack_require__(1);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MapCache = __webpack_require__(25),
    setCacheAdd = __webpack_require__(159),
    setCacheHas = __webpack_require__(160);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new MapCache();
    while (++index < length) {
        this.add(values[index]);
    }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(1);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(7),
    root = __webpack_require__(1);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseTimes = __webpack_require__(112),
    isArguments = __webpack_require__(31),
    isArray = __webpack_require__(2),
    isBuffer = __webpack_require__(49),
    isIndex = __webpack_require__(18),
    isTypedArray = __webpack_require__(51);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseForOwn = __webpack_require__(92),
    createBaseEach = __webpack_require__(119);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayPush = __webpack_require__(41),
    isFlattenable = __webpack_require__(136);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createBaseFor = __webpack_require__(120);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFor = __webpack_require__(91),
    keys = __webpack_require__(33);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayPush = __webpack_require__(41),
    isArray = __webpack_require__(2);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(10),
    isObjectLike = __webpack_require__(13);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Stack = __webpack_require__(39),
    equalArrays = __webpack_require__(44),
    equalByTag = __webpack_require__(122),
    equalObjects = __webpack_require__(123),
    getTag = __webpack_require__(128),
    isArray = __webpack_require__(2),
    isBuffer = __webpack_require__(49),
    isTypedArray = __webpack_require__(51);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Stack = __webpack_require__(39),
    baseIsEqual = __webpack_require__(42);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(50),
    isMasked = __webpack_require__(139),
    isObject = __webpack_require__(12),
    toSource = __webpack_require__(48);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(10),
    isLength = __webpack_require__(32),
    isObjectLike = __webpack_require__(13);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isPrototype = __webpack_require__(140),
    nativeKeys = __webpack_require__(153);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseEach = __webpack_require__(88),
    isArrayLike = __webpack_require__(21);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsMatch = __webpack_require__(97),
    getMatchData = __webpack_require__(125),
    matchesStrictComparable = __webpack_require__(47);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsEqual = __webpack_require__(42),
    get = __webpack_require__(172),
    hasIn = __webpack_require__(173),
    isKey = __webpack_require__(29),
    isStrictComparable = __webpack_require__(46),
    matchesStrictComparable = __webpack_require__(47),
    toKey = __webpack_require__(11);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayMap = __webpack_require__(40),
    baseIteratee = __webpack_require__(27),
    baseMap = __webpack_require__(101),
    baseSortBy = __webpack_require__(111),
    baseUnary = __webpack_require__(43),
    compareMultiple = __webpack_require__(117),
    identity = __webpack_require__(20);

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));

  var result = baseMap(collection, function (value, key, collection) {
    var criteria = arrayMap(iteratees, function (iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function (object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGet = __webpack_require__(26);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseUnset = __webpack_require__(114),
    isIndex = __webpack_require__(18);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * The base implementation of `_.pullAt` without support for individual
 * indexes or capturing the removed elements.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {number[]} indexes The indexes of elements to remove.
 * @returns {Array} Returns `array`.
 */
function basePullAt(array, indexes) {
  var length = array ? indexes.length : 0,
      lastIndex = length - 1;

  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex(index)) {
        splice.call(array, index, 1);
      } else {
        baseUnset(array, index);
      }
    }
  }
  return array;
}

module.exports = basePullAt;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var identity = __webpack_require__(20),
    overRest = __webpack_require__(157),
    setToString = __webpack_require__(162);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var constant = __webpack_require__(170),
    defineProperty = __webpack_require__(121),
    identity = __webpack_require__(20);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(9),
    arrayMap = __webpack_require__(40),
    isArray = __webpack_require__(2),
    isSymbol = __webpack_require__(14);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var castPath = __webpack_require__(28),
    last = __webpack_require__(174),
    parent = __webpack_require__(158),
    toKey = __webpack_require__(11);

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(14);

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compareAscending = __webpack_require__(116);

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(1);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArrayLike = __webpack_require__(21);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(7);

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(9),
    Uint8Array = __webpack_require__(82),
    eq = __webpack_require__(30),
    equalArrays = __webpack_require__(44),
    mapToArray = __webpack_require__(151),
    setToArray = __webpack_require__(161);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getAllKeys = __webpack_require__(124);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetAllKeys = __webpack_require__(93),
    getSymbols = __webpack_require__(127),
    keys = __webpack_require__(33);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isStrictComparable = __webpack_require__(46),
    keys = __webpack_require__(33);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
}

module.exports = getMatchData;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(9);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayFilter = __webpack_require__(85),
    stubArray = __webpack_require__(179);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DataView = __webpack_require__(77),
    Map = __webpack_require__(24),
    Promise = __webpack_require__(79),
    Set = __webpack_require__(80),
    WeakMap = __webpack_require__(83),
    baseGetTag = __webpack_require__(10),
    toSource = __webpack_require__(48);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
            switch (ctorString) {
                case dataViewCtorString:
                    return dataViewTag;
                case mapCtorString:
                    return mapTag;
                case promiseCtorString:
                    return promiseTag;
                case setCtorString:
                    return setTag;
                case weakMapCtorString:
                    return weakMapTag;
            }
        }
        return result;
    };
}

module.exports = getTag;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var castPath = __webpack_require__(28),
    isArguments = __webpack_require__(31),
    isArray = __webpack_require__(2),
    isIndex = __webpack_require__(18),
    isLength = __webpack_require__(32),
    toKey = __webpack_require__(11);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(19);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(19);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(19);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(19);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(9),
    isArguments = __webpack_require__(31),
    isArray = __webpack_require__(2);

/** Built-in value references. */
var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var eq = __webpack_require__(30),
    isArrayLike = __webpack_require__(21),
    isIndex = __webpack_require__(18),
    isObject = __webpack_require__(12);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index === 'undefined' ? 'undefined' : _typeof(index);
  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var coreJsData = __webpack_require__(118);

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(16);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(16);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(16);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(16);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Hash = __webpack_require__(78),
    ListCache = __webpack_require__(15),
    Map = __webpack_require__(24);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(17);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(17);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(17);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(17);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var memoize = __webpack_require__(175);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var overArg = __webpack_require__(156);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(45);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)(module)))

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = __webpack_require__(84);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGet = __webpack_require__(26),
    baseSlice = __webpack_require__(110);

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseSetToString = __webpack_require__(109),
    shortOut = __webpack_require__(163);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ListCache = __webpack_require__(15);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ListCache = __webpack_require__(15),
    Map = __webpack_require__(24),
    MapCache = __webpack_require__(25);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var memoizeCapped = __webpack_require__(152);

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function (string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function (match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

module.exports = stringToPath;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFindIndex = __webpack_require__(89),
    baseIteratee = __webpack_require__(27),
    toInteger = __webpack_require__(182);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGet = __webpack_require__(26);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseHasIn = __webpack_require__(94),
    hasPath = __webpack_require__(130);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MapCache = __webpack_require__(25);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseProperty = __webpack_require__(105),
    basePropertyDeep = __webpack_require__(106),
    isKey = __webpack_require__(29),
    toKey = __webpack_require__(11);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIteratee = __webpack_require__(27),
    basePullAt = __webpack_require__(107);

/**
 * Removes all elements from `array` that `predicate` returns truthy for
 * and returns an array of the removed elements. The predicate is invoked
 * with three arguments: (value, index, array).
 *
 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
 * to pull elements from an array by value.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = [1, 2, 3, 4];
 * var evens = _.remove(array, function(n) {
 *   return n % 2 == 0;
 * });
 *
 * console.log(array);
 * // => [1, 3]
 *
 * console.log(evens);
 * // => [2, 4]
 */
function remove(array, predicate) {
  var result = [];
  if (!(array && array.length)) {
    return result;
  }
  var index = -1,
      indexes = [],
      length = array.length;

  predicate = baseIteratee(predicate, 3);
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result.push(value);
      indexes.push(index);
    }
  }
  basePullAt(array, indexes);
  return result;
}

module.exports = remove;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFlatten = __webpack_require__(90),
    baseOrderBy = __webpack_require__(104),
    baseRest = __webpack_require__(108),
    isIterateeCall = __webpack_require__(137);

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 */
var sortBy = baseRest(function (collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toNumber = __webpack_require__(183);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toFinite = __webpack_require__(181);

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? remainder ? result - remainder : result : 0;
}

module.exports = toInteger;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(12),
    isSymbol = __webpack_require__(14);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseToString = __webpack_require__(113);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _axios = __webpack_require__(6);

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      doneLoading: false,
      results: [],
      mainLeagueUsers: [],
      weeklyteams: []
    };
  },

  computed: {
    standings: function standings() {
      return this.mainLeagueUsers.sort(function (a, b) {
        var aPoints = 0;
        var bPoints = 0;
        a.weeklyteams.forEach(function (team) {
          aPoints += team.place;
        });
        b.weeklyteams.forEach(function (team) {
          bPoints += team.place;
        });
        return aPoints - bPoints;
      });
    },
    newstandings: function newstandings() {}
  },
  created: function created() {
    var _this = this;

    console.log("environment", "development");
    _axios2.default.get('/MainLeagueStandings').then(function (data) {
      _this.mainLeagueUsers = data.data;
      _this.mainLeagueUsers.forEach(function (user) {
        user.totalpoints = 0;
        user.weeklyteams.forEach(function (wt) {
          user.totalpoints += wt.place;
        });
        user.weeklyteams.sort(function (a, b) {
          return a - b;
        });
      });
      _this.doneLoading = true;
    });
  },

  methods: {
    pointsbehind: function pointsbehind(user) {
      var objIndex = this.standings.indexOf(user);
      if (objIndex != 0) {
        return user.totalpoints - this.standings[0].totalpoints;
      }
      return '-';
    }
    // beforeCreate() {
    //    setTimeout(() => {
    //      axios.get('/RaceResults')
    //      .then(data => {
    //        console.time();
    //        var results = data.data.B;
    //        console.log(results);
    //        this.mainLeagueUsers.forEach(user => {
    //          user.totalpoints = 0;
    //          user.riders.forEach(rider => {
    //            results.forEach(result => {
    //              if (result.F.slice(0, -1) == rider.name) {
    //                rider.points = result.A;
    //              }
    //            })
    //            user.totalpoints += rider.points;
    //          })
    //        })
    //       console.timeEnd();
    //       this.doneLoading = true;
    //       console.log(this.mainLeagueUsers)
    //     })
    //    }, 3000);
    //   axios.get('/getMainLeagueInfo')
    //   .then(data => {
    //     console.log(data.data);
    //     data.data.forEach(user => {
    //       this.mainLeagueUsers.push(user)
    //     })
    //   })
    // }
  } }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(6);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      username: '',
      password: '',
      isLoading: false
    };
  },

  computed: (0, _vuex.mapGetters)(['ShowLoginModal']),
  props: {
    show: {
      type: Boolean,
      required: true
    }
  },
  methods: _extends({}, (0, _vuex.mapMutations)(['setLoginModal', 'setUserData', 'setLoggedIn']), {
    submit: function submit(e) {
      var _this = this;

      e.preventDefault();
      this.isLoading = true;
      _axios2.default.post('/login', {
        username: this.username,
        password: this.password,
        captcha: grecaptcha.getResponse()
      }).then(function (data) {
        _this.isLoading = false;
        _this.setUserData({ userData: data.data });
        _this.setLoggedIn({ loggedIn: true });
        _this.setLoginModal({ show: false });
      }).catch(function (err) {
        _this.isLoading = false;
        console.log("Login error: ", err);
      });
    }
  })
};

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(6);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(8);

var _findIndex2 = __webpack_require__(171);

var _findIndex3 = _interopRequireDefault(_findIndex2);

var _sortBy2 = __webpack_require__(178);

var _sortBy3 = _interopRequireDefault(_sortBy2);

var _remove2 = __webpack_require__(177);

var _remove3 = _interopRequireDefault(_remove2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      currentweek: 0,
      selectedriders: [],
      availableRiders: [],
      CostSortByAsc: true,
      page: 1,
      isLoading: false,
      showSaveMessage: false,
      showFailMessage: false
    };
  },

  computed: _extends({}, (0, _vuex.mapGetters)(['getUserData']), {
    dollars: function dollars() {
      var total = 10000;
      this.selectedriders.forEach(function (rider) {
        total -= rider.cost;
      });
      return total;
    },
    hidePrevious: function hidePrevious() {
      return this.page <= 1;
    },
    hideNext: function hideNext() {
      return this.page >= this.paginationPages;
    },
    paginatedRiders: function paginatedRiders() {
      if (this.page == 1) {
        console.log("entire array", this.availableRiders);
        console.log(this.availableRiders.slice(0, 10));
        return this.availableRiders.slice(0, 10);
      } else {
        var beginSlice = this.page * 10 - 9;
        var endSlice = beginSlice + 10;
        console.log(this.availableRiders);
        console.log(this.availableRiders.slice(beginSlice, endSlice));
        return this.availableRiders.slice(beginSlice, endSlice);
      }
    },
    paginationPages: function paginationPages() {
      return Math.ceil(this.availableRiders.length / 10);
    },
    hasOpenSlots: function hasOpenSlots() {
      return this.selectedriders.some(function (rider) {
        return rider.name == "OPEN SLOT";
      });
    },
    showRemoveAll: function showRemoveAll() {
      return this.selectedriders.some(function (rider) {
        return rider.name != "OPEN SLOT";
      });
    },
    showSelect: function showSelect() {
      var openSlots = this.selectedriders.some(function (rider) {
        return rider.name == "OPEN SLOT";
      });
      var lowestCostAvailable = (0, _sortBy3.default)(this.availableRiders, function (o) {
        return o.cost;
      });
      console.log("showSelect", lowestCostAvailable[0]);
      if (this.dollars >= lowestCostAvailable[0].cost && openSlots) {
        return true;
      }
      return false;
    }
  }),
  methods: {
    removeRacer: function removeRacer(racer) {
      console.log("removed racers", racer);
      var selectedRacerIndex = (0, _findIndex3.default)(this.selectedriders, function (o) {
        return o.riderid === racer.riderid;
      });
      var openSpace = {
        id: this.selectedriders[selectedRacerIndex].id,
        avatar_url: 'http://www.shopaardvark.com/media/catalog/product/W/S/WS-18655.jpg',
        cost: 0,
        highestFinish: '-',
        lowestFinish: '-',
        name: 'OPEN SLOT',
        rider_number: 0,
        riderid: 0,
        leagueid: 1,
        season_weeksid: this.currentweek
      };
      this.availableRiders.push(racer);
      this.$set(this.selectedriders, selectedRacerIndex, openSpace);
      console.log("My new team", this.selectedriders);
    },
    addRacer: function addRacer(racer) {
      var openSlotIndex = (0, _findIndex3.default)(this.selectedriders, function (o) {
        return o.name == "OPEN SLOT";
      });
      (0, _remove3.default)(this.paginatedRiders, function (o) {
        return o.riderid == racer.riderid;
      });
      (0, _remove3.default)(this.availableRiders, function (o) {
        return o.riderid == racer.riderid;
      });
      racer.id = this.selectedriders[openSlotIndex].id;
      this.$set(this.selectedriders, openSlotIndex, racer);
      console.log("Racers to Add", this.selectedriders);
    },
    sortByPrice: function sortByPrice() {
      if (this.CostSortByAsc) {
        this.CostSortByAsc = false;
        this.paginatedRiders = this.paginatedRiders.sort(function (a, b) {
          if (a.cost > b.cost) {
            return -1;
          }
          if (a.cost < b.cost) {
            return 1;
          }
          return 0;
        });
      } else {
        this.CostSortByAsc = true;
        this.paginatedRiders = this.paginatedRiders.sort(function (a, b) {
          if (a.cost > b.cost) {
            return 1;
          }
          if (a.cost < b.cost) {
            return -1;
          }
          return 0;
        });
      }
    },
    SaveTeam: function SaveTeam() {
      var _this = this;

      this.isLoading = true;
      _axios2.default.post("/SaveTeam", this.selectedriders).then(function (data) {
        _this.isLoading = false;
        _this.SaveMessage();
        console.log(data);
      }).catch(function (error) {
        console.log(error);
        _this.isLoading = false;
        _this.FailMessage();
      });
    },
    SaveMessage: function SaveMessage() {
      var _this2 = this;

      this.showSaveMessage = true;
      setTimeout(function () {
        _this2.showSaveMessage = false;
      }, 5000);
    },
    FailMessage: function FailMessage() {
      var _this3 = this;

      this.showFailMessage = true;
      setTimeout(function () {
        _this3.showFailMessage = false;
      }, 5000);
    },
    RemoveAll: function RemoveAll() {
      var _this4 = this;

      this.selectedriders.forEach(function (racer) {
        if (racer.name != "OPEN SLOT") {
          _this4.removeRacer(racer);
        }
      });
    }
  },
  beforeCreate: function beforeCreate() {
    var _this5 = this;

    _axios2.default.get('/CurrentMyTeamModel').then(function (data) {
      console.log("data", data.data);
      _this5.currentweek = data.data.CurrentWeek;
      console.log(_this5.currentweek);
      _this5.availableRiders = (0, _sortBy3.default)(data.data.AvailableRiders, function (o) {
        return o.cost;
      });
      _this5.selectedriders = data.data.CurrentTeam;
    });
  },
  mounted: function mounted() {
    console.log("mounted", this.getUserData);
  }
};

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(6);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(8);

var _register = __webpack_require__(54);

var _register2 = _interopRequireDefault(_register);

var _login = __webpack_require__(205);

var _login2 = _interopRequireDefault(_login);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      username: '',
      password: '',
      showRegisterModal: false
    };
  },

  computed: (0, _vuex.mapGetters)(['ShowLoginModal', 'ShowRegisterModal', 'getUserData', 'GetAuthStatus']),
  mounted: function mounted() {
    // Get all "navbar-burger" elements
    var $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
    console.log($navbarBurgers);
    // Check if there are any nav burgers
    if ($navbarBurgers.length > 0) {

      // Add a click event on each of them
      $navbarBurgers.forEach(function ($el) {
        $el.addEventListener('click', function () {

          // Get the target from the "data-target" attribute
          var target = $el.dataset.target;
          var $target = document.getElementById(target);

          // Toggle the class on both the "navbar-burger" and the "navbar-menu"
          $el.classList.toggle('is-active');
          $target.classList.toggle('is-active');
        });
      });
    }
  },
  created: function created() {
    var _this = this;

    _axios2.default.get('/loginrefresh').then(function (data) {
      console.log(data.data);
      if (typeof data.data.username != 'undefined') {
        console.log("User Is Authenticated");
        _this.setUserData({ userData: data.data });
        _this.setLoggedIn({ loggedIn: true });
      }
    }).catch(function (err) {
      console.log("login refresh error", err);
    });
  },

  methods: _extends({}, (0, _vuex.mapMutations)(['setRegisterModal', 'setLoginModal', 'setLoggedIn', 'setUserData', 'logout']), {
    logout: function logout() {
      var _this2 = this;

      _axios2.default.get('logout').then(function (data) {
        _this2.$router.push("/");
      });
    }
  }),
  components: {
    'register': _register2.default,
    'login': _login2.default
  }
};

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _vuex = __webpack_require__(8);

var _axios = __webpack_require__(6);

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      username: '',
      email: '',
      password: '',
      errorMessage: [],
      invalidUsername: false,
      invalidEmail: false,
      blankPassword: false,
      isLoading: false
    };
  },

  computed: (0, _vuex.mapGetters)(['ShowRegisterModal', 'getUserData']),
  methods: _extends({}, (0, _vuex.mapMutations)(['setRegisterModal', 'setUserData', 'setLoggedIn']), {
    Register: function Register() {
      var _this = this;

      this.isLoading = true;
      this.errorMessage = [];
      this.invalidEmail = false;
      this.blankPassword = false;
      this.invalidUsername = false;
      if (this.RegistrationIsValid()) {

        _axios2.default.post('/register', {
          username: this.username,
          email: this.email,
          password: this.password
        }).then(function (data) {
          console.log(data);
          _this.isLoading = false;
          var isFalse = !data.data.ErrorMessage;
          console.log("isFalse", isFalse);
          if (!data.data.ErrorMessage) {
            _this.setUserData({ userData: data.data });
            console.log("getUserData", _this.getUserData);
            _this.setRegisterModal({ show: false });
            _this.setLoggedIn({ loggedIn: true });
            console.log(_this.$store.state);
          } else {
            _this.errorMessage.push(data.data.ErrorMessage);
            _this.errorMessage.forEach(function (msg) {
              if (msg.indexOf("Username") > -1) {
                _this.invalidUsername = true;
              }
              if (msg.indexOf("Email") > -1) {
                _this.invalidEmail = true;
              }
            });
          }
        });
      }
    },
    RegistrationIsValid: function RegistrationIsValid() {
      var emailValidation = this.email.match(new RegExp(/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/), "i");
      console.log(emailValidation);
      if (this.email == "") {
        this.errorMessage.push("Username cannot be left empty.");
        this.invalidUsername = true;
      }
      if (emailValidation == null) {
        this.errorMessage.push("Please enter a valid email.");
        this.invalidEmail = true;
      }
      if (this.password == '' || this.password.length < 6) {
        this.errorMessage.push("Password cannot be left empty and must be at least 6 characters.");
        this.blankPassword = true;
      }
      if (this.errorMessage.length > 0) {
        this.isLoading = false;
        return false;
      }
      return true;
    }
  })
};

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(6);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      leagueData: [],
      raceData: [],
      isLoading: true,
      ws: null
    };
  },

  computed: _extends({}, (0, _vuex.mapGetters)(['getUserData']), {
    standings: function standings() {
      return this.leagueData.sort(function (a, b) {
        return a.total - b.total;
      });
    }
  }),
  created: function created() {
    console.log("development");
    this.ws =  false ? new WebSocket("wss://fantasysx.herokuapp.com/tracker") : new WebSocket("wss://localhost:3000/tracker");

    var v = this;
    this.ws.onmessage = function (e) {
      var data = JSON.parse(e.data);
      v.isLoading = false;
      v.leagueData = data.LeagueData;
      v.raceData = data.RaceData;
      console.log(data);
    };
    this.ws.onerror = function (e) {
      console.log("Error", e);
    };
  },

  methods: {
    pointsbehind: function pointsbehind(user) {
      var objIndex = this.leagueData.indexOf(user);
      if (objIndex != 0) {
        return user.total - this.leagueData[0].total;
      }
      return '-';
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.ws.close();
  }
};

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _axios = __webpack_require__(6);

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      Username: '',
      ReportType: '',
      Registered: false,
      feature: '',
      bugreport: '',
      feedback: ''
    };
  },

  methods: {
    submit: function submit() {
      var data = {
        Username: this.Username,
        ReportType: this.ReportType,
        Registered: this.Registered,
        Feature: this.feature,
        BugReport: this.bugreport,
        Feedback: this.feedback
      };
      _axios2.default.post('/feedback', data).then(function (res) {
        console.log(res);
      });
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _navbar = __webpack_require__(207);

var _navbar2 = _interopRequireDefault(_navbar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  computed: {
    username: function username() {
      return this.$store.state.username;
    },
    isLoggedIn: function isLoggedIn() {
      return this.$store.state.isLoggedIn;
    }
  },
  components: {
    'navigation': _navbar2.default
  }
}; //
//
//
//
//
//
//
//
//
//

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
  * vue-router v2.7.0
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if ("development" !== 'production' && !condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

function isError(err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1;
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent && parent._routerRoot !== parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name];

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (val && current !== vm || !val && current === vm) {
        matched.instances[name] = val;
      }
    }

    // also regiseter instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // resolve props
    data.props = resolveProps(route, matched.props && matched.props[name]);

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config === 'undefined' ? 'undefined' : _typeof(config)) {
    case 'undefined':
      return;
    case 'object':
      return config;
    case 'function':
      return config(route);
    case 'boolean':
      return config ? route.params : undefined;
    default:
      if (true) {
        warn(false, "props in \"" + route.path + "\" is a " + (typeof config === 'undefined' ? 'undefined' : _typeof(config)) + ", " + "expecting an object, function or boolean.");
      }
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function encodeReserveReplacer(c) {
  return '%' + c.charCodeAt(0).toString(16);
};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function encode(str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery, _parseQuery) {
  if (extraQuery === void 0) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    "development" !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    var val = extraQuery[key];
    parsedQuery[key] = Array.isArray(val) ? val.slice() : val;
  }
  return parsedQuery;
}

function parseQuery(query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom, router) {
  var stringifyQuery$$1 = router && router.options.stringifyQuery;
  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: location.query || {},
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }
  return Object.freeze(route);
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res;
}

function getFullPath(ref, _stringifyQuery) {
  var path = ref.path;
  var query = ref.query;if (query === void 0) query = {};
  var hash = ref.hash;if (hash === void 0) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {};

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key];
    // check nested equality
    if ((typeof aVal === 'undefined' ? 'undefined' : _typeof(aVal)) === 'object' && (typeof bVal === 'undefined' ? 'undefined' : _typeof(bVal)) === 'object') {
      return isObjectEqual(aVal, bVal);
    }
    return String(aVal) === String(bVal);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;
    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;
    var compareTarget = location.path ? createRoute(null, location, null, router) : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);

    var handler = function handler(e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {
    return;
  }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) {
    return;
  }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) {
    return;
  }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) {
      return;
    }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true;
}

function findAnchor(children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child;
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed) {
    return;
  }
  install.installed = true;

  _Vue = Vue;

  var isDef = function isDef(v) {
    return v !== undefined;
  };

  var registerInstance = function registerInstance(vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = this.$parent && this.$parent._routerRoot || this;
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed() {
      registerInstance(this);
    }
  });

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this._routerRoot._router;
    }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this._routerRoot._route;
    }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath(relative, base, append) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative;
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative;
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

var index$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var index = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (_typeof(tokens[i]) === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (index$1(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!index$1(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!index$1(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (index$1(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

index.parse = parse_1;
index.compile = compile_1;
index.tokensToFunction = tokensToFunction_1;
index.tokensToRegExp = tokensToRegExp_1;

/*  */

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = index.compile(path));
    return filler(params || {}, { pretty: true });
  } catch (e) {
    if (true) {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }
    return '';
  }
}

/*  */

function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  var pathMap = oldPathMap || Object.create(null);
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;
  if (true) {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var normalizedPath = normalizePath(path, parent);
  var pathToRegexpOptions = route.pathToRegexpOptions || {};

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (true) {
      if (route.name && !route.redirect && route.children.some(function (child) {
        return (/^\/?$/.test(child.path)
        );
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];

    aliases.forEach(function (alias) {
      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs
      );
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if ("development" !== 'production' && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function compileRouteRegex(path, pathToRegexpOptions) {
  var regex = index(path, [], pathToRegexpOptions);
  if (true) {
    var keys = {};
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], "Duplicate param keys in route with path: \"" + path + "\"");
      keys[key.name] = true;
    });
  }
  return regex;
}

function normalizePath(path, parent) {
  path = path.replace(/\/$/, '');
  if (path[0] === '/') {
    return path;
  }
  if (parent == null) {
    return path;
  }
  return cleanPath(parent.path + "/" + path);
}

/*  */

function normalizeLocation(raw, current, append, router) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next;
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (true) {
      warn(false, "relative params navigation requires a current route.");
    }
    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;

  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
}

/*  */

function createMatcher(routes, router) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (true) {
        warn(record, "Route with name '" + name + "' does not exist");
      }
      if (!record) {
        return _createRoute(null, location);
      }
      var paramNames = record.regex.keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (_typeof(location.params) !== 'object') {
        location.params = {};
      }

      if (currentRoute && _typeof(currentRoute.params) === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom);
        }
      }
    }
    // no match
    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || (typeof redirect === 'undefined' ? 'undefined' : _typeof(redirect)) !== 'object') {
      if (true) {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (true) {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\"");
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      if (true) {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }
    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }
    return createRoute(record, location, redirectedFrom, router);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(regex, path, params) {
  var m = path.match(regex);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}

/*  */

var positionStore = Object.create(null);

function setupScroll() {
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return;
  }

  if (true) {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);
    if (!shouldScroll) {
      return;
    }
    var isObject = (typeof shouldScroll === 'undefined' ? 'undefined' : _typeof(shouldScroll)) === 'object';
    if (isObject && typeof shouldScroll.selector === 'string') {
      var el = document.querySelector(shouldScroll.selector);
      if (el) {
        var offset = shouldScroll.offset && _typeof(shouldScroll.offset) === 'object' ? shouldScroll.offset : {};
        offset = normalizeOffset(offset);
        position = getElementPosition(el, offset);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject && isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();
  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function normalizeOffset(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

/*  */

var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}

/*  */

function runQueue(queue, fn, cb) {
  var step = function step(index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

function resolveAsyncComponents(matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          if (resolvedDef.__esModule && resolvedDef.default) {
            resolvedDef = resolvedDef.default;
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          "development" !== 'production' && warn(false, msg);
          if (!error) {
            error = isError(reason) ? reason : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) {
      next();
    }
  };
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once(fn) {
  var called = false;
  return function () {
    var args = [],
        len = arguments.length;
    while (len--) {
      args[len] = arguments[len];
    }if (called) {
      return;
    }
    called = true;
    return fn.apply(this, args);
  };
}

/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError(errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }
    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) {
        cb(err);
      });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;

  var current = this.current;
  var abort = function abort(err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  if (isSameRoute(route, current) &&
  // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;

  var queue = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),
  // global before hooks
  this.router.beforeHooks,
  // in-component update hooks
  extractUpdateHooks(updated),
  // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }),
  // async components
  resolveAsyncComponents(activated));

  this.pending = route;
  var iterator = function iterator(hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }
    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (typeof to === 'string' || (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();
          if ((typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function isValid() {
      return this$1.current === route;
    };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/';
      // strip full URL origin
      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  if (instance) {
    return function boundRouteGuard() {
      return guard.apply(instance, arguments);
    };
  }
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

/*  */

var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    window.addEventListener('popstate', function (e) {
      var current = this$1.current;
      this$1.transitionTo(getLocation(this$1.base), function (route) {
        if (expectScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash;
}

/*  */

var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return;
    }
    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    window.addEventListener('hashchange', function () {
      if (!ensureSlash()) {
        return;
      }
      this$1.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath);
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true;
  }
  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1);
}

function pushHash(path) {
  window.location.hash = path;
}

function replaceHash(path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  window.location.replace(base + "#" + path);
}

/*  */

var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {
    // noop
  };

  return AbstractHistory;
}(History);

/*  */

var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;
    default:
      if (true) {
        assert(false, "invalid mode: " + mode);
      }
  }
};

var prototypeAccessors = { currentRoute: {} };

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app /* Vue component instance */) {
  var this$1 = this;

  "development" !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return;
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function setupHashListener() {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  return registerHook(this.beforeHooks, fn);
};

VueRouter.prototype.beforeResolve = function beforeResolve(fn) {
  return registerHook(this.resolveHooks, fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  return registerHook(this.afterHooks, fn);
};

VueRouter.prototype.onReady = function onReady(cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError(errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;
  if (!route) {
    return [];
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append, this);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function registerHook(list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) {
      list.splice(i, 1);
    }
  };
}

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '2.7.0';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

exports.default = VueRouter;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] });
    } else {
      newStyles[id].parts.push(part);
    }
  }
  return styles;
};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(true);
// imports


// module
exports.push([module.i, "\nbody {\n  font-family: \"Open Sans Condensed\";\n  height: 100%;\n  min-height: 100vh;\n  background:\n    linear-gradient(to bottom right, rgba(251, 109, 8, .8)0%, rgba(204, 66, 0, 1)100%),\n    url('https://images.pexels.com/photos/37527/sports-games-fun-holiday-37527.jpeg?w=1260&h=750&auto=compress&cs=tinysrgb');\n  background-size: cover;\n  background-position:center;\n  background-repeat: no-repeat;\n}\n.leaderboard-table .title > th {\n  border-bottom: 1px solid #f5f5a2;\n  font-size: 16pt;\n  padding: .5rem;\n}\n.leaderboard-table {\n  background-color: rgba(255, 255, 255, .8);\n  color: #7b7b7b;\n  box-shadow: 1px 1px 10px #222;\n}\n.leaderboard-table thead th, tfoot th {\n  color: #fff;\n  font-size: 12pt;\n}\n.leaderboard-table thead, tfoot {\n  background: linear-gradient(rgba(255, 106, 0, 1)0%, rgba(156, 52, 0, 1)100%);\n}\n.leaderboard-table td {\n  border: none;\n}\n.leaderboard-table tr:hover {\n  background-color: rgba(255, 233, 120, .2);\n}\n.pointsback {\n    font-weight: bolder;\n    color: #ff3860;\n}\n.leaderboard {\n    margin-top: 50px;\n}\ntable td, th {\n    text-align: center !important;\n}\n.leaderboard-main {\n    margin-top: 25px;\n}\n", "", {"version":3,"sources":["/Users/Seth/Projects/fantasysx/client/components/leaderboard.vue?10258718"],"names":[],"mappings":";AA2HA;EACA,mCAAA;EACA,aAAA;EACA,kBAAA;EACA;;6HAEA;EACA,uBAAA;EACA,2BAAA;EACA,6BAAA;CACA;AACA;EACA,iCAAA;EACA,gBAAA;EACA,eAAA;CACA;AACA;EACA,0CAAA;EACA,eAAA;EACA,8BAAA;CACA;AACA;EACA,YAAA;EACA,gBAAA;CACA;AACA;EACA,6EAAA;CACA;AACA;EACA,aAAA;CACA;AACA;EACA,0CAAA;CACA;AACA;IACA,oBAAA;IACA,eAAA;CACA;AACA;IACA,iBAAA;CACA;AACA;IACA,8BAAA;CACA;AACA;IACA,iBAAA;CACA","file":"leaderboard.vue","sourcesContent":["<template>\n  <div>\n    <div class=\"columns leaderboard\">\n      <div class=\"column is-half is-offset-one-quarter\">\n        <table class=\"leaderboard-table\" v-if=\"doneLoading\">\n          <thead>\n            <tr class=\"title\">\n              <th colspan=\"4\">2018 Fantasy SX: Main League Standings</th>\n            </tr>\n            <tr>\n              <th>Position</th>\n              <th>Total Points</th>\n              <th>Username</th>\n              <th>Points Back</th>\n            </tr>\n          </thead>\n          <tfoot>\n            <tr>\n              <th>Position</th>\n              <th>Total Points</th>\n              <th>Username</th>\n              <th>Points Back</th>\n            </tr>\n          </tfoot>\n          <tbody>\n            <tr v-for=\"(user, index) in standings\">\n              <td>{{ index + 1 }}.</td>\n              <td>{{user.totalpoints}}</td>\n              <td>{{user.weeklyteams[0].username}}</td>\n              <td v-bind:class=\"{ 'pointsback': index > 0 }\">{{ pointsbehind(user) }}</td>\n            </tr>\n          </tbody>\n        </table>\n        <div v-if=\"!doneLoading\">\n          <p>\"This data doesn't fetch itself.. Loading Race Tracker.\"</p>\n        </div>\n      </div>\n    </div>\n</div>\n</template>\n<script>\nimport axios from 'axios';\n  export default {\n    data() {\n      return {\n        doneLoading: false,\n        results: [],\n        mainLeagueUsers: [],\n        weeklyteams: []\n      }\n    },\n    computed: {\n      standings: function() {\n        return this.mainLeagueUsers.sort((a, b) => {\n          var aPoints = 0;\n          var bPoints = 0;\n          a.weeklyteams.forEach(team => { aPoints += team.place })\n          b.weeklyteams.forEach(team => { bPoints += team.place })\n          return aPoints - bPoints;\n        })\n      },\n      newstandings: function() {\n\n      }\n    },\n    created() {\n      console.log(\"environment\", process.env.NODE_ENV)\n      axios.get('/MainLeagueStandings')\n      .then(data => {\n        this.mainLeagueUsers = data.data;\n        this.mainLeagueUsers.forEach((user) => {\n          user.totalpoints = 0\n          user.weeklyteams.forEach(wt => { user.totalpoints += wt.place })\n          user.weeklyteams.sort((a, b) => {\n            return a - b;\n          })\n        })\n        this.doneLoading = true;\n      })\n    },\n    methods: {\n      pointsbehind: function(user) {\n        var objIndex = this.standings.indexOf(user);\n        if (objIndex != 0) {\n          return user.totalpoints - this.standings[0].totalpoints;\n        }\n        return '-'\n      }\n    }\n    // beforeCreate() {\n    //    setTimeout(() => {\n    //      axios.get('/RaceResults')\n    //      .then(data => {\n    //        console.time();\n    //        var results = data.data.B;\n    //        console.log(results);\n    //        this.mainLeagueUsers.forEach(user => {\n    //          user.totalpoints = 0;\n    //          user.riders.forEach(rider => {\n    //            results.forEach(result => {\n    //              if (result.F.slice(0, -1) == rider.name) {\n    //                rider.points = result.A;\n    //              }\n    //            })\n    //            user.totalpoints += rider.points;\n    //          })\n    //        })\n    //       console.timeEnd();\n    //       this.doneLoading = true;\n    //       console.log(this.mainLeagueUsers)\n    //     })\n    //    }, 3000);\n    //   axios.get('/getMainLeagueInfo')\n    //   .then(data => {\n    //     console.log(data.data);\n    //     data.data.forEach(user => {\n    //       this.mainLeagueUsers.push(user)\n    //     })\n    //   })\n    // }\n  }\n</script>\n<style>\nbody {\n  font-family: \"Open Sans Condensed\";\n  height: 100%;\n  min-height: 100vh;\n  background:\n    linear-gradient(to bottom right, rgba(251, 109, 8, .8)0%, rgba(204, 66, 0, 1)100%),\n    url('https://images.pexels.com/photos/37527/sports-games-fun-holiday-37527.jpeg?w=1260&h=750&auto=compress&cs=tinysrgb');\n  background-size: cover;\n  background-position:center;\n  background-repeat: no-repeat;\n}\n.leaderboard-table .title > th {\n  border-bottom: 1px solid #f5f5a2;\n  font-size: 16pt;\n  padding: .5rem;\n}\n.leaderboard-table {\n  background-color: rgba(255, 255, 255, .8);\n  color: #7b7b7b;\n  box-shadow: 1px 1px 10px #222;\n}\n.leaderboard-table thead th, tfoot th {\n  color: #fff;\n  font-size: 12pt;\n}\n.leaderboard-table thead, tfoot {\n  background: linear-gradient(rgba(255, 106, 0, 1)0%, rgba(156, 52, 0, 1)100%);\n}\n.leaderboard-table td {\n  border: none;\n}\n.leaderboard-table tr:hover {\n  background-color: rgba(255, 233, 120, .2);\n}\n  .pointsback {\n    font-weight: bolder;\n    color: #ff3860;\n  }\n  .leaderboard {\n    margin-top: 50px;\n  }\n  table td, th {\n    text-align: center !important;\n  }\n  .leaderboard-main {\n    margin-top: 25px;\n  }\n</style>\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(true);
// imports


// module
exports.push([module.i, "\n.suggestions-container {\n  display: flex;\n  justify-content: center;\n  margin-top: 3rem;\n}\n", "", {"version":3,"sources":["/Users/Seth/Projects/fantasysx/client/components/suggestions.vue?a78db056"],"names":[],"mappings":";AAsGA;EACA,cAAA;EACA,wBAAA;EACA,iBAAA;CACA","file":"suggestions.vue","sourcesContent":["<template>\n  <div class=\"container suggestions-container\">\n      <section>\n        <div class=\"field\">\n          <div class=\"control\">\n            <label>Are you a registered user?</label>\n            <label class=\"radio\">\n              <input type=\"radio\" name=\"Registered\" value=\"true\" v-model=\"Registered\">\n              Yes\n            </label>\n            <label class=\"radio\">\n              <input type=\"radio\" name=\"Registered\" value=\"false\" v-model=\"Registered\">\n              No\n            </label>\n          </div>\n        </div>\n        <div class=\"field\">\n          <div class=\"control\">\n            <label>Is this feedback or a bug report?</label>\n            <label class=\"radio\">\n              <input type=\"radio\" name=\"feedback\" v-model=\"ReportType\" value=\"feedback\">\n              Feedback\n            </label>\n            <label class=\"radio\">\n              <input type=\"radio\" name=\"feedback\" v-model=\"ReportType\" value=\"bug\">\n              Bug Report\n            </label>\n          </div>\n        </div>\n        <div class=\"field\">\n          <label class=\"label\">Username</label>\n            <div class=\"control\">\n              <input class=\"input\" type=\"text\" placeholder=\"Username\" v-model=\"Username\">\n            </div>\n        </div>\n        <div class=\"field\" v-if=\"ReportType == 'feedback'\">\n          <label class=\"label\">Suggest Features</label>\n          <div class=\"control\">\n            <div class=\"select\">\n              <select v-model=\"feature\">\n                <option disabled value=\"\">SELECT CATEGORY</option>\n                <option>User Interface</option>\n                <option>Navigation Content</option>\n                <option>My Team</option>\n                <option>Scoring</option>\n                <option>New Features</option>\n                <option>Stat Tracker</option>\n                <option>Account</option>\n              </select>\n            </div>\n          </div>\n        </div>\n        <div class=\"field\" v-if=\"ReportType == 'feedback'\">\n          <label class=\"label\">Feedback</label>\n          <div class=\"control\">\n            <textarea class=\"textarea\" v-model=\"feedback\" placeholder=\"Describe your suggestions here.\"></textarea>\n          </div>\n        </div>\n        <div class=\"field\" v-if=\"ReportType == 'bug'\">\n          <label class=\"label\">Report Bug</label>\n          <div class=\"control\">\n            <textarea class=\"textarea\" v-model=\"bugreport\" placeholder=\"Describe the actions you took, your desired outcome and the actual outcome of those actions. We should be able to replicate the bug based off the steps you provide here.\"></textarea>\n          </div>\n        </div>\n        <div class=\"field\">\n          <button class=\"button is-primary\" v-on:click=\"submit\" type=\"button\">Submit</button>\n        </div>\n      </section>\n  </div>\n</template>\n<script>\nimport axios from 'axios';\n  export default {\n    data() {\n      return {\n        Username: '',\n        ReportType: '',\n        Registered: false,\n        feature: '',\n        bugreport: '',\n        feedback: ''\n      }\n    },\n    methods: {\n      submit() {\n        var data = {\n          Username: this.Username,\n          ReportType: this.ReportType,\n          Registered: this.Registered,\n          Feature: this.feature,\n          BugReport: this.bugreport,\n          Feedback: this.feedback\n        }\n        axios.post('/feedback', data)\n        .then(res => {\n          console.log(res)\n        })\n      }\n    }\n  }\n</script>\n<style>\n  .suggestions-container {\n    display: flex;\n    justify-content: center;\n    margin-top: 3rem;\n  }\n</style>\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(true);
// imports


// module
exports.push([module.i, "\n.successful-save {\n  text-align: center;\n  color: #00d1b2;\n}\n.myteam-table table td {\n  border: none;\n}\n.myteam-table {\n  background-color: rgba(255, 255, 255, .8);\n  color: #7b7b7b;\n  box-shadow: 1px 1px 10px #222;\n}\n.myteam-table thead, tfoot {\n  background: linear-gradient(rgba(255, 106, 0, 1)0%, rgba(156, 52, 0, 1)100%);\n}\n.myteam-title {\n  color: #868686;\n  font-size: 16pt;\n}\n.myteam-table thead th, tfoot th {\n  color: #fff;\n  font-size: 12pt;\n}\n.myteam-table tr:hover {\n  background: rgba(255, 233, 120, .2);\n}\n.failure-save {\n  text-align: center;\n  color: #ff2b56;\n}\n.fade-enter-active, .fade-leave-active {\n  transition: opacity 1s;\n}\n.fade-enter, .fade-leave-to {\n  opacity: 0;\n}\n.page-header-container {\n  display: flex;\n  justify-content: center;\n}\nbutton {\n  margin-bottom: 0.25rem;\n}\n.page-header-block {\n  width: 15%;\n  min-width: 260px;\n}\n.riders-container {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n}\n.rider-block {\n    min-width: 15rem;\n    border: 1px solid #dedede;\n    margin: 1rem;\n    box-shadow: 1px 1px 1px #cecece;\n    padding: 1rem;\n    max-width: 15rem;\n}\n.page-title {\n    text-align: center;\n    text-decoration: underline;\n    font-weight: 700;\n}\n.page-title {\n    text-align: center;\n    text-decoration: underline;\n    font-weight: 700;\n}\n.page-subheader {\n    text-align:center;\n}\n.card-footer {\n    flex-direction: column;\n    border: 1px solid #eee;\n}\n.card-content {\n    min-height: 11rem;\n    max-height: 11rem;\n    overflow: hidden;\n    margin-bottom: 1rem;\n}\n.card-footer div:nth-child(even) {\n    background-color: #eee;\n}\n.footer-row {\n    display:flex;\n    justify-content: space-between;\n}\np.card-header-title {\n    display:flex;\n    justify-content: space-around;\n}\np span.icon {\n    color: #ff3860;\n}\nth:hover {\n    cursor: pointer;\n}\n.hide-pagination-button {\n    visibility: hidden;\n}\n.custom-pagination {\n    display: flex;\n    justify-content: space-between;\n}\n.lastRow {\n    border-bottom: 2px solid rgb(208, 83, 1);\n}\n.minus-icon {\n    color: #ff3860;\n}\n.plus-icon {\n    color: #23d160;\n}\n.boldest-header {\n    color: #fffc7f;\n    font-weight: 700;\n    font-size: xx-large;\n}\n.right {\n    float: right;\n}\n.lh-4r {\n    height: 4rem;\n    line-height: 4rem;\n    font-size: 1.75rem;\n    color:white;\n}\n.lh-4r:first-of-type {\n    border-bottom: 1px solid #ffe978;\n}\n.lh-4r:last-of-type {\n    margin-bottom: 2rem;\n}\n", "", {"version":3,"sources":["/Users/Seth/Projects/fantasysx/client/components/myteam.vue?6745d382"],"names":[],"mappings":";AAyQA;EACA,mBAAA;EACA,eAAA;CACA;AACA;EACA,aAAA;CACA;AACA;EACA,0CAAA;EACA,eAAA;EACA,8BAAA;CACA;AACA;EACA,6EAAA;CACA;AACA;EACA,eAAA;EACA,gBAAA;CACA;AACA;EACA,YAAA;EACA,gBAAA;CACA;AACA;EACA,oCAAA;CACA;AACA;EACA,mBAAA;EACA,eAAA;CACA;AACA;EACA,uBAAA;CACA;AACA;EACA,WAAA;CACA;AACA;EACA,cAAA;EACA,wBAAA;CACA;AACA;EACA,uBAAA;CACA;AACA;EACA,WAAA;EACA,iBAAA;CACA;AACA;IACA,cAAA;IACA,gBAAA;IACA,wBAAA;CACA;AACA;IACA,iBAAA;IACA,0BAAA;IACA,aAAA;IACA,gCAAA;IACA,cAAA;IACA,iBAAA;CACA;AACA;IACA,mBAAA;IACA,2BAAA;IACA,iBAAA;CACA;AACA;IACA,mBAAA;IACA,2BAAA;IACA,iBAAA;CACA;AACA;IACA,kBAAA;CACA;AACA;IACA,uBAAA;IACA,uBAAA;CACA;AACA;IACA,kBAAA;IACA,kBAAA;IACA,iBAAA;IACA,oBAAA;CACA;AACA;IACA,uBAAA;CACA;AACA;IACA,aAAA;IACA,+BAAA;CACA;AACA;IACA,aAAA;IACA,8BAAA;CACA;AACA;IACA,eAAA;CACA;AACA;IACA,gBAAA;CACA;AACA;IACA,mBAAA;CACA;AACA;IACA,cAAA;IACA,+BAAA;CACA;AACA;IACA,yCAAA;CACA;AACA;IACA,eAAA;CACA;AACA;IACA,eAAA;CACA;AACA;IACA,eAAA;IACA,iBAAA;IACA,oBAAA;CACA;AACA;IACA,aAAA;CACA;AACA;IACA,aAAA;IACA,kBAAA;IACA,mBAAA;IACA,YAAA;CACA;AACA;IACA,iCAAA;CACA;AACA;IACA,oBAAA;CACA","file":"myteam.vue","sourcesContent":["<template>\n  <div>\n    <div class=\"page-header-container\">\n      <div class=\"page-header-block\">\n        <div class=\"lh-4r\">Week: <span class=\"boldest-header right\">{{currentweek}}</span></div>\n        <div class=\"lh-4r\">Balance Remaining:<span class=\"boldest-header right\"> ${{dollars}}</span></div>\n      </div>\n    </div>\n    <div class=\"container\">\n      <transition name=\"fade\" mode=\"out-in\">\n        <p v-if=\"showSaveMessage\" class=\"successful-save\">Your team has been successfully saved!</p>\n        <p v-if=\"showFailMessage\" class=\"failure-save\">Oops! Something Went Wrong. Please try again later.</p>\n      </transition>\n      <table class=\"myteam-table\">\n        <thead>\n          <tr>\n            <th>Action</th>\n            <th @click=\"sortByPrice\">Price\n              <span class=\"icon\">\n                <i class=\"fa fa-caret-up\" v-if=\"CostSortByAsc\" aria-hidden=\"true\"></i>\n                <i class=\"fa fa-caret-down\" v-else aria-hidden=\"true\"></i>\n              </span>\n            </th>\n            <th>Racer Name</th>\n            <th>Racer Number</th>\n            <th>Highest Finish</th>\n            <th>Lowest Finish</th>\n            <th>Average Finish</th>\n          </tr>\n        </thead>\n        <tfoot>\n          <tr>\n            <th>Action</th>\n            <th>Price</th>\n            <th>Racer Name</th>\n            <th>Racer Number</th>\n            <th>Highest Finish</th>\n            <th>Lowest Finish</th>\n            <th>Average Finish</th>\n          </tr>\n        </tfoot>\n        <tbody>\n          <tr v-for=\"(racer, index) in selectedriders\">\n            <td>\n              <a href=\"#!\" v-if=\"racer.name != 'OPEN SLOT'\" @click=\"removeRacer(racer)\">\n                <span class=\"icon minus-icon\">\n                  <i class=\"fa fa-minus\" aria-hidden=\"true\"></i>\n                </span>\n              </a>\n            </td>\n            <td>${{racer.cost}}</td>\n            <td>{{racer.name}}</td>\n            <td>{{racer.rider_number}}</td>\n            <td>{{racer.highestFinish}}</td>\n            <td>{{racer.lowestFinish}}</td>\n            <td>{{racer.averageFinish}}</td>\n          </tr>\n          <tr class=\"lastRow\">\n            <td colspan=\"5\"></td>\n            <td colspan=\"1\">\n              <button class=\"button is-danger\" @click=\"RemoveAll\" :disabled=\"!showRemoveAll\">Remove All</button>\n            </td>\n            <td colspan=\"1\">\n              <button class=\"button is-success\" @click=\"SaveTeam\" :disabled=\"hasOpenSlots\" v-bind:class=\"{'is-loading':isLoading}\">Save Team</button>\n            </td>\n          </tr>\n          <tr v-for=\"rider in paginatedRiders\">\n            <td>\n              <a href=\"#!\" v-if=\"showSelect && rider.cost <= dollars\" @click=\"addRacer(rider)\">\n                <span class=\"icon plus-icon\">\n                  <i class=\"fa fa-plus\" aria-hidden=\"true\"></i>\n                </span>\n              </a>\n            </td>\n            <td>${{rider.cost}}</td>\n            <td>{{rider.name}}</td>\n            <td>{{rider.rider_number}}</td>\n            <td>{{rider.highestFinish}}</td>\n            <td>{{rider.lowestFinish}}</td>\n            <td>{{rider.averageFinish}}</td>\n          </tr>\n        </tbody>\n      </table>\n      <div class=\"custom-pagination\">\n        <div>\n          <a class=\"pagination-previous\" @click=\"page--\" v-bind:class=\"{ 'hide-pagination-button' : hidePrevious }\">Previous</a>\n        </div>\n        <div>\n          <a class=\"pagination-number\">{{page}}/{{paginationPages}}</a>\n        </div>\n        <div>\n          <a class=\"pagination-next\" @click=\"page++\" v-bind:class=\"{ 'hide-pagination-button' : hideNext }\">Next page</a>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport axios from 'axios';\nimport { mapGetters } from 'vuex';\nimport _findIndex from 'lodash/findIndex';\nimport _sortBy from 'lodash/sortBy';\nimport _remove from 'lodash/remove';\n  export default {\n    data() {\n      return {\n        currentweek: 0,\n        selectedriders: [],\n        availableRiders: [],\n        CostSortByAsc: true,\n        page: 1,\n        isLoading: false,\n        showSaveMessage: false,\n        showFailMessage: false\n      }\n    },\n    computed: {\n      ...mapGetters([\n        'getUserData'\n      ]),\n      dollars() {\n        var total = 10000;\n        this.selectedriders.forEach(rider => {\n          total -= rider.cost;\n        })\n        return total;\n      },\n      hidePrevious() {\n        return this.page <= 1;\n      },\n      hideNext() {\n        return this.page >= this.paginationPages;\n      },\n      paginatedRiders() {\n        if (this.page == 1) {\n          console.log(\"entire array\", this.availableRiders)\n          console.log(this.availableRiders.slice(0, 10));\n          return this.availableRiders.slice(0, 10);\n        } else {\n          var beginSlice = this.page * 10 - 9;\n          var endSlice = beginSlice + 10;\n          console.log(this.availableRiders)\n          console.log(this.availableRiders.slice(beginSlice, endSlice))\n          return this.availableRiders.slice(beginSlice, endSlice);\n        }\n      },\n      paginationPages() {\n        return Math.ceil(this.availableRiders.length / 10);\n      },\n      hasOpenSlots() {\n        return this.selectedriders.some(rider => { return rider.name == \"OPEN SLOT\" })\n      },\n      showRemoveAll() {\n        return this.selectedriders.some(rider => { return rider.name != \"OPEN SLOT\" })\n      },\n      showSelect() {\n        var openSlots = this.selectedriders.some((rider) => {return rider.name == \"OPEN SLOT\"});\n        var lowestCostAvailable = _sortBy(this.availableRiders, o => { return o.cost });\n        console.log(\"showSelect\", lowestCostAvailable[0])\n        if ((this.dollars >= lowestCostAvailable[0].cost) && openSlots) {\n          return true;\n        }\n        return false;\n      }\n    },\n    methods: {\n      removeRacer(racer) {\n        console.log(\"removed racers\", racer);\n        var selectedRacerIndex = _findIndex(this.selectedriders, o => { return o.riderid === racer.riderid });\n        var openSpace = {\n          id: this.selectedriders[selectedRacerIndex].id,\n          avatar_url: 'http://www.shopaardvark.com/media/catalog/product/W/S/WS-18655.jpg',\n          cost: 0,\n          highestFinish: '-',\n          lowestFinish: '-',\n          name: 'OPEN SLOT',\n          rider_number: 0,\n          riderid: 0,\n          leagueid: 1,\n          season_weeksid: this.currentweek\n        }\n        this.availableRiders.push(racer)\n        this.$set(this.selectedriders, selectedRacerIndex, openSpace)\n        console.log(\"My new team\", this.selectedriders)\n      },\n      addRacer(racer) {\n        var openSlotIndex = _findIndex(this.selectedriders, o => { return o.name == \"OPEN SLOT\" });\n        _remove(this.paginatedRiders, o => { return o.riderid == racer.riderid })\n        _remove(this.availableRiders, o => { return o.riderid == racer.riderid })\n        racer.id = this.selectedriders[openSlotIndex].id;\n        this.$set(this.selectedriders, openSlotIndex, racer);\n        console.log(\"Racers to Add\", this.selectedriders)\n      },\n      sortByPrice() {\n        if (this.CostSortByAsc) {\n          this.CostSortByAsc = false;\n          this.paginatedRiders = this.paginatedRiders.sort((a, b) => {\n            if (a.cost > b.cost) {\n              return -1\n            }\n            if (a.cost < b.cost) {\n              return 1\n            }\n            return 0\n          })\n        } else {\n          this.CostSortByAsc = true;\n          this.paginatedRiders = this.paginatedRiders.sort((a, b) => {\n            if (a.cost > b.cost) {\n              return 1\n            }\n            if (a.cost < b.cost) {\n              return -1\n            }\n            return 0\n          })\n        }\n      },\n      SaveTeam() {\n        this.isLoading = true;\n        axios.post(\"/SaveTeam\", this.selectedriders)\n        .then(data => {\n          this.isLoading = false;\n          this.SaveMessage();\n          console.log(data);\n        })\n        .catch(error => {\n          console.log(error);\n          this.isLoading = false;\n          this.FailMessage();\n        })\n      },\n      SaveMessage() {\n        this.showSaveMessage = true;\n        setTimeout(() => { this.showSaveMessage = false }, 5000)\n      },\n      FailMessage() {\n        this.showFailMessage = true;\n        setTimeout(() => { this.showFailMessage = false }, 5000)\n      },\n      RemoveAll() {\n        this.selectedriders.forEach(racer => {\n          if (racer.name != \"OPEN SLOT\") {\n            this.removeRacer(racer)\n          }\n        })\n      }\n    },\n    beforeCreate() {\n      axios.get('/CurrentMyTeamModel')\n      .then(data => {\n        console.log(\"data\", data.data);\n        this.currentweek = data.data.CurrentWeek;\n        console.log(this.currentweek);\n        this.availableRiders = _sortBy(data.data.AvailableRiders, o => { return o.cost });\n        this.selectedriders = data.data.CurrentTeam;\n      })\n    },\n    mounted() {\n      console.log(\"mounted\", this.getUserData)\n    }\n  }\n</script>\n<style>\n.successful-save {\n  text-align: center;\n  color: #00d1b2;\n}\n.myteam-table table td {\n  border: none;\n}\n.myteam-table {\n  background-color: rgba(255, 255, 255, .8);\n  color: #7b7b7b;\n  box-shadow: 1px 1px 10px #222;\n}\n.myteam-table thead, tfoot {\n  background: linear-gradient(rgba(255, 106, 0, 1)0%, rgba(156, 52, 0, 1)100%);\n}\n.myteam-title {\n  color: #868686;\n  font-size: 16pt;\n}\n.myteam-table thead th, tfoot th {\n  color: #fff;\n  font-size: 12pt;\n}\n.myteam-table tr:hover {\n  background: rgba(255, 233, 120, .2);\n}\n.failure-save {\n  text-align: center;\n  color: #ff2b56;\n}\n.fade-enter-active, .fade-leave-active {\n  transition: opacity 1s;\n}\n.fade-enter, .fade-leave-to {\n  opacity: 0;\n}\n.page-header-container {\n  display: flex;\n  justify-content: center;\n}\nbutton {\n  margin-bottom: 0.25rem;\n}\n.page-header-block {\n  width: 15%;\n  min-width: 260px;\n}\n  .riders-container {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n  }\n  .rider-block {\n    min-width: 15rem;\n    border: 1px solid #dedede;\n    margin: 1rem;\n    box-shadow: 1px 1px 1px #cecece;\n    padding: 1rem;\n    max-width: 15rem;\n  }\n  .page-title {\n    text-align: center;\n    text-decoration: underline;\n    font-weight: 700;\n  }\n  .page-title {\n    text-align: center;\n    text-decoration: underline;\n    font-weight: 700;\n  }\n  .page-subheader {\n    text-align:center;\n  }\n  .card-footer {\n    flex-direction: column;\n    border: 1px solid #eee;\n  }\n  .card-content {\n    min-height: 11rem;\n    max-height: 11rem;\n    overflow: hidden;\n    margin-bottom: 1rem;\n  }\n  .card-footer div:nth-child(even) {\n    background-color: #eee;\n  }\n  .footer-row {\n    display:flex;\n    justify-content: space-between;\n  }\n  p.card-header-title {\n    display:flex;\n    justify-content: space-around;\n  }\n  p span.icon {\n    color: #ff3860;\n  }\n  th:hover {\n    cursor: pointer;\n  }\n  .hide-pagination-button {\n    visibility: hidden;\n  }\n  .custom-pagination {\n    display: flex;\n    justify-content: space-between;\n  }\n  .lastRow {\n    border-bottom: 2px solid rgb(208, 83, 1);\n  }\n  .minus-icon {\n    color: #ff3860;\n  }\n  .plus-icon {\n    color: #23d160;\n  }\n  .boldest-header {\n    color: #fffc7f;\n    font-weight: 700;\n    font-size: xx-large;\n  }\n  .right {\n    float: right;\n  }\n  .lh-4r {\n    height: 4rem;\n    line-height: 4rem;\n    font-size: 1.75rem;\n    color:white;\n  }\n  .lh-4r:first-of-type {\n    border-bottom: 1px solid #ffe978;\n  }\n  .lh-4r:last-of-type {\n    margin-bottom: 2rem;\n  }\n</style>\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(true);
// imports


// module
exports.push([module.i, "\n\n\n\n\n\n\n\n", "", {"version":3,"sources":[],"names":[],"mappings":"","file":"index.vue","sourceRoot":""}]);

// exports


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(true);
// imports


// module
exports.push([module.i, "\n.errorMessage {\n  color: #ff3860;\n}\n", "", {"version":3,"sources":["/Users/Seth/Projects/fantasysx/client/components/register.vue?600cf352"],"names":[],"mappings":";AA8IA;EACA,eAAA;CACA","file":"register.vue","sourcesContent":["<template>\n  <div class=\"modal\" v-bind:class=\"{'is-active': ShowRegisterModal}\" id=\"registerModal\">\n    <div class=\"modal-background\"></div>\n    <div class=\"modal-card\">\n      <header class=\"modal-card-head\">\n        <p class=\"modal-card-title\">New User Registration</p>\n        <button class=\"delete\" @click=\"setRegisterModal({ show: !ShowRegisterModal})\"></button>\n      </header>\n      <section class=\"modal-card-body\">\n        <div class=\"content\">\n            <div class=\"field\">\n              <label class=\"label\">Username: </label>\n              <div class=\"control has-icons-left\">\n                <input type=\"text\" class=\"input\" v-bind:class=\"{ 'is-danger': invalidUsername }\" id=\"reg-username\" v-model=\"username\" placeholder=\"Username\" required>\n                <span class=\"icon is-small is-left\">\n                  <i class=\"fa fa-user\"></i>\n                </span>\n              </div>\n            </div>\n            <div class=\"field\">\n              <label class=\"label\">Email: </label>\n              <div class=\"control has-icons-left\">\n                <input type=\"email\" class=\"input\" v-bind:class=\"{ 'is-danger': invalidEmail }\"  id=\"reg-email\" v-model=\"email\" placeholder=\"Email\" required>\n                <span class=\"icon is-small is-left\">\n                  <i class=\"fa fa-envelope\"></i>\n                </span>\n              </div>\n            </div>\n            <div class=\"field\">\n              <label class=\"label\">Password: </label>\n              <div class=\"control has-icons-left\">\n                <input type=\"password\" class=\"input\" v-bind:class=\"{ 'is-danger': blankPassword }\" id=\"reg-password\" v-model=\"password\" placeholder=\"Password\" required>\n                <span class=\"icon is-small is-left\">\n                  <i class=\"fa fa-lock\"></i>\n                </span>\n              </div>\n            </div>\n            <div class=\"field\">\n              RECAPTCHA PLACEHOLDER\n            </div>\n            <div class=\"errorMessage\" v-for=\"error in errorMessage\" v-if=\"errorMessage != ''\">\n              {{ error }}\n            </div>\n        </div>\n      </section>\n      <footer class=\"modal-card-foot\">\n        <button class=\"button is-success\" @click=\"Register\" v-bind:class=\"{ 'is-loading': isLoading }\">Register</button>\n        <button class=\"button\" @click=\"setRegisterModal({ show: !ShowRegisterModal })\">Cancel</button>\n      </footer>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { mapGetters, mapMutations } from 'vuex';\nimport axios from 'axios';\n  export default {\n    data() {\n      return {\n        username: '',\n        email: '',\n        password: '',\n        errorMessage: [],\n        invalidUsername: false,\n        invalidEmail: false,\n        blankPassword: false,\n        isLoading: false\n      }\n    },\n    computed: mapGetters([\n      'ShowRegisterModal',\n      'getUserData'\n    ]),\n    methods: {\n      ...mapMutations([\n        'setRegisterModal',\n        'setUserData',\n        'setLoggedIn'\n      ]),\n      Register() {\n        this.isLoading = true;\n        this.errorMessage = [];\n        this.invalidEmail = false;\n        this.blankPassword = false;\n        this.invalidUsername = false;\n        if (this.RegistrationIsValid()) {\n\n          axios.post('/register', {\n            username: this.username,\n            email: this.email,\n            password: this.password\n          }).then(data => {\n            console.log(data);\n            this.isLoading = false;\n            var isFalse = !data.data.ErrorMessage;\n            console.log(\"isFalse\", isFalse)\n            if (!data.data.ErrorMessage) {\n              this.setUserData({ userData: data.data })\n              console.log(\"getUserData\", this.getUserData)\n              this.setRegisterModal({ show: false })\n              this.setLoggedIn({ loggedIn: true })\n              console.log(this.$store.state);\n            } else {\n              this.errorMessage.push(data.data.ErrorMessage);\n              this.errorMessage.forEach(msg => {\n                if (msg.indexOf(\"Username\") > -1) {\n                  this.invalidUsername = true;\n                }\n                if (msg.indexOf(\"Email\") >-1) {\n                  this.invalidEmail = true;\n                }\n              })\n            }\n          })\n\n        }\n      },\n      RegistrationIsValid() {\n        var emailValidation = this.email.match(new RegExp(/^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/), \"i\");\n        console.log(emailValidation);\n        if (this.email == \"\") {\n          this.errorMessage.push(\"Username cannot be left empty.\")\n          this.invalidUsername = true;\n        }\n        if (emailValidation == null) {\n          this.errorMessage.push(\"Please enter a valid email.\")\n          this.invalidEmail = true;\n        }\n        if (this.password == '' || this.password.length < 6) {\n          this.errorMessage.push(\"Password cannot be left empty and must be at least 6 characters.\")\n          this.blankPassword = true;\n        }\n        if (this.errorMessage.length > 0) {\n          this.isLoading = false;\n          return false;\n        }\n        return true;\n      }\n    }\n  }\n</script>\n<style>\n  .errorMessage {\n    color: #ff3860;\n  }\n</style>\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(true);
// imports


// module
exports.push([module.i, "\nh1 {\n  text-align: center;\n}\n/* Acordeon styles */\n.tab {\n  position: relative;\n  margin-bottom: 1px;\n  width: 100%;\n  color: #fff;\n  overflow: hidden;\n}\ninput {\n  position: absolute;\n  opacity: 0;\n  z-index: -1;\n}\nlabel {\n  position: relative;\n  display: block;\n  padding: 0 0 0 1em;\n  background: rgba(255, 255, 255, 0.3);\n  font-weight: bold;\n  line-height: 3;\n  cursor: pointer;\n  color: #fffc7f;\n}\n.tab-content {\n  max-height: 0;\n  overflow: hidden;\n  background: transparent;\n  -webkit-transition: max-height .35s;\n  -o-transition: max-height .35s;\n  transition: max-height .35s;\n  color: #fff;\n}\n.tab-content p {\n  margin: 1em;\n}\n/* :checked */\ninput:checked ~ .tab-content {\n  max-height: 10em;\n}\n/* Icon */\nlabel::after {\n  position: absolute;\n  right: 0;\n  top: 0;\n  display: block;\n  width: 3em;\n  height: 3em;\n  line-height: 3;\n  text-align: center;\n  -webkit-transition: all .35s;\n  -o-transition: all .35s;\n  transition: all .35s;\n}\ninput[type=checkbox] + label::after {\n  content: \"+\";\n}\ninput[type=radio] + label::after {\n  content: \"\\25BC\";\n}\ninput[type=checkbox]:checked + label::after {\n  transform: rotate(315deg);\n}\ninput[type=radio]:checked + label::after {\n  transform: rotateX(180deg);\n}\n", "", {"version":3,"sources":["/Users/Seth/Projects/fantasysx/client/components/rules.vue?6712a805"],"names":[],"mappings":";AAmCA;EACA,mBAAA;CACA;AACA,qBAAA;AACA;EACA,mBAAA;EACA,mBAAA;EACA,YAAA;EACA,YAAA;EACA,iBAAA;CACA;AACA;EACA,mBAAA;EACA,WAAA;EACA,YAAA;CACA;AACA;EACA,mBAAA;EACA,eAAA;EACA,mBAAA;EACA,qCAAA;EACA,kBAAA;EACA,eAAA;EACA,gBAAA;EACA,eAAA;CACA;AACA;EACA,cAAA;EACA,iBAAA;EACA,wBAAA;EACA,oCAAA;EACA,+BAAA;EACA,4BAAA;EACA,YAAA;CACA;AACA;EACA,YAAA;CACA;AACA,cAAA;AACA;EACA,iBAAA;CACA;AACA,UAAA;AACA;EACA,mBAAA;EACA,SAAA;EACA,OAAA;EACA,eAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,mBAAA;EACA,6BAAA;EACA,wBAAA;EACA,qBAAA;CACA;AACA;EACA,aAAA;CACA;AACA;EACA,iBAAA;CACA;AACA;EACA,0BAAA;CACA;AACA;EACA,2BAAA;CACA","file":"rules.vue","sourcesContent":["<template>\n  <div class=\"container\">\n    <div class=\"\">\n      <p>Rules</p>\n      <div class=\"tab\">\n        <input id=\"tab-one\" type=\"checkbox\" name=\"tabs\">\n        <label for=\"tab-one\">How does scoring work?</label>\n        <div class=\"tab-content\">\n          <p>Right now, scoring is set by racer finish. If a selected racer for that week finishes in first, that racer is awarded 1 point. If a racer finishes in fourth, that racer is awarded 4 points. The lower the point total the better score.</p>\n        </div>\n      </div>\n      <div class=\"tab\">\n        <input id=\"tab-two\" type=\"checkbox\" name=\"tabs\">\n        <label for=\"tab-two\">How does team selection work?</label>\n        <div class=\"tab-content\">\n          <p>As of now, each user is REQUIRED to select 4 racers for each week. The deadline for making racer selection is 3am Mountain Time on the day of the scheduled race. After that time\n            users will no longer be able to select racers for that week's race; the team selection for the next week will be available for selection</p>\n          <p>Users may only SAVE a roster if ALL 4 roster slots have a racer chosen. The SAVE button is disabled if an OPEN SLOT still exists for a weekly lineup.</p>\n          <p>Each user begins each week with $8 credits to spend on filling out their weekly lineup, and that credit is used to select racers for their week's lineup from the available racers pool.\n            The selected racer's cost, once selected, will be deducted from the current week's available credits. You are NOT REQUIRED to spend all $8 credits each week.</p>\n        </div>\n      </div>\n      <div class=\"tab\">\n        <input id=\"tab-three\" type=\"checkbox\" name=\"tabs\">\n        <label for=\"tab-three\">Live Stat Tracker & Custom Leagues</label>\n        <div class=\"tab-content\">\n          <p>Right now the application is configured where every registered user competes against each other in an open Main League. The live stat tracker (to see the standings update with live position changes) is not available for the ALPHA test.\n          This feature will be testable during the BETA version of the application.</p>\n          <p>Currently, the application does not support custom / private leagues, however, this feature will be available for testing in the BETA version of the application.</p>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n<style>\nh1 {\n  text-align: center;\n}\n/* Acordeon styles */\n.tab {\n  position: relative;\n  margin-bottom: 1px;\n  width: 100%;\n  color: #fff;\n  overflow: hidden;\n}\ninput {\n  position: absolute;\n  opacity: 0;\n  z-index: -1;\n}\nlabel {\n  position: relative;\n  display: block;\n  padding: 0 0 0 1em;\n  background: rgba(255, 255, 255, 0.3);\n  font-weight: bold;\n  line-height: 3;\n  cursor: pointer;\n  color: #fffc7f;\n}\n.tab-content {\n  max-height: 0;\n  overflow: hidden;\n  background: transparent;\n  -webkit-transition: max-height .35s;\n  -o-transition: max-height .35s;\n  transition: max-height .35s;\n  color: #fff;\n}\n.tab-content p {\n  margin: 1em;\n}\n/* :checked */\ninput:checked ~ .tab-content {\n  max-height: 10em;\n}\n/* Icon */\nlabel::after {\n  position: absolute;\n  right: 0;\n  top: 0;\n  display: block;\n  width: 3em;\n  height: 3em;\n  line-height: 3;\n  text-align: center;\n  -webkit-transition: all .35s;\n  -o-transition: all .35s;\n  transition: all .35s;\n}\ninput[type=checkbox] + label::after {\n  content: \"+\";\n}\ninput[type=radio] + label::after {\n  content: \"\\25BC\";\n}\ninput[type=checkbox]:checked + label::after {\n  transform: rotate(315deg);\n}\ninput[type=radio]:checked + label::after {\n  transform: rotateX(180deg);\n}\n</style>\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(true);
// imports


// module
exports.push([module.i, "\n.flex-center {\n  display:flex;\n  justify-content:center;\n}\n.live-header-box {\n  min-width: 360px;\n}\n.live-header {\n  color: white;\n  font-size: 12pt;\n  margin-top: 3rem;\n  font-weight: 700;\n}\n.text-highlight {\n    font-size: 12pt;\n    font-weight: 700;\n    color: #fffc7f;\n}\n.fl-right {\n  float: right;\n}\n.myRow {\n    background-color:rgba(255, 233, 120, .35) !important;\n}\n.table-live table td {\n    border: none;\n}\n.table-live {\n    background-color: rgba(255, 255, 255, .8);\n    color: #7b7b7b;\n    box-shadow: 1px 1px 10px #222;\n}\n.table-live thead, tfoot {\n    background: linear-gradient(rgba(255, 106, 0, 1)0%, rgba(156, 52, 0, 1)100%);\n}\n.table-live thead th, tfoot th {\n    color: #fff;\n    font-size: 12pt;\n}\n.table-live tr:hover {\n    background: rgba(255, 233, 120, .2);\n}\n", "", {"version":3,"sources":["/Users/Seth/Projects/fantasysx/client/components/stattracker.vue?4fb93524"],"names":[],"mappings":";AAgGA;EACA,aAAA;EACA,uBAAA;CACA;AACA;EACA,iBAAA;CACA;AACA;EACA,aAAA;EACA,gBAAA;EACA,iBAAA;EACA,iBAAA;CACA;AACA;IACA,gBAAA;IACA,iBAAA;IACA,eAAA;CACA;AACA;EACA,aAAA;CACA;AACA;IACA,qDAAA;CACA;AACA;IACA,aAAA;CACA;AACA;IACA,0CAAA;IACA,eAAA;IACA,8BAAA;CACA;AACA;IACA,6EAAA;CACA;AACA;IACA,YAAA;IACA,gBAAA;CACA;AACA;IACA,oCAAA;CACA","file":"stattracker.vue","sourcesContent":["<template>\n  <div>\n    <div class=\"flex-center fl live-header\" v-if=\"!isLoading\">\n      <div class=\"live-header-box\">\n        <div>Session Event: <span class=\"text-highlight fl-right\">{{raceData.raceData.S}}</span></div>\n        <div>Season Event:<span class=\"text-highlight fl-right\"> {{raceData.raceData.E}}</span></div>\n        <div>Session Status:<span class=\"text-highlight fl-right\"> {{raceData.raceDetails.B}}</span></div>\n      </div>\n    </div>\n    <div class=\"columns leaderboard\">\n      <div class=\"column is-half is-offset-one-quarter\">\n        <table class=\"table-live\" v-if=\"!isLoading\">\n          <thead>\n            <tr>\n              <th>Position</th>\n              <th>Total Points</th>\n              <th>Username</th>\n              <th>Points Back</th>\n            </tr>\n          </thead>\n          <tfoot>\n            <tr>\n              <th>Position</th>\n              <th>Total Points</th>\n              <th>Username</th>\n              <th>Points Back</th>\n            </tr>\n          </tfoot>\n          <tbody>\n            <tr v-for=\"(user, index) in standings\" v-bind:class=\"[ user.username == getUserData.username ? 'myRow' : '']\">\n              <td>{{ index + 1 }}.</td>\n              <td>{{user.total}}</td>\n              <td>{{user.username}}</td>\n              <td class=\"pointsback\">{{ pointsbehind(user) }}</td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n    </div>\n  </div>\n</template>\n<script>\nimport axios from 'axios';\nimport { mapGetters } from 'vuex';\n  export default {\n    data() {\n      return {\n        leagueData: [],\n        raceData: [],\n        isLoading: true,\n        ws: null\n      }\n    },\n    computed: {\n      ...mapGetters([\n        'getUserData'\n      ]),\n      standings: function() {\n        return this.leagueData.sort((a, b) => {\n          return a.total - b.total;\n        })\n      }\n    },\n    created() {\n      console.log(process.env.NODE_ENV)\n      this.ws = process.env.NODE_ENV == 'production'\n        ? new WebSocket(\"wss://fantasysx.herokuapp.com/tracker\")\n        : new WebSocket(\"wss://localhost:3000/tracker\");\n\n      var v = this;\n      this.ws.onmessage = function (e) {\n        var data = JSON.parse(e.data);\n        v.isLoading = false;\n        v.leagueData = data.LeagueData;\n        v.raceData = data.RaceData;\n        console.log(data)\n      }\n      this.ws.onerror = function (e) {\n        console.log(\"Error\", e)\n      }\n    },\n    methods:  {\n      pointsbehind: function(user) {\n        var objIndex = this.leagueData.indexOf(user);\n        if (objIndex != 0) {\n          return user.total - this.leagueData[0].total;\n        }\n        return '-'\n      }\n    },\n    beforeDestroy() {\n      this.ws.close();\n    }\n  }\n</script>\n<style>\n.flex-center {\n  display:flex;\n  justify-content:center;\n}\n.live-header-box {\n  min-width: 360px;\n}\n.live-header {\n  color: white;\n  font-size: 12pt;\n  margin-top: 3rem;\n  font-weight: 700;\n}\n.text-highlight {\n    font-size: 12pt;\n    font-weight: 700;\n    color: #fffc7f;\n}\n.fl-right {\n  float: right;\n}\n  .myRow {\n    background-color:rgba(255, 233, 120, .35) !important;\n  }\n  .table-live table td {\n    border: none;\n  }\n  .table-live {\n    background-color: rgba(255, 255, 255, .8);\n    color: #7b7b7b;\n    box-shadow: 1px 1px 10px #222;\n  }\n  .table-live thead, tfoot {\n    background: linear-gradient(rgba(255, 106, 0, 1)0%, rgba(156, 52, 0, 1)100%);\n  }\n  .table-live thead th, tfoot th {\n    color: #fff;\n    font-size: 12pt;\n  }\n  .table-live tr:hover {\n    background: rgba(255, 233, 120, .2);\n  }\n</style>\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(4)(true);
// imports


// module
exports.push([module.i, "\n.navbar-menu {\n  padding: 0 100px 0 50px;\n}\n.navbar {\n  background: transparent;\n}\na {\n  color: white;\n  font-size: 16pt;\n}\n.router-link-active {\n  border-bottom: 1px solid #fffc7f;\n}\n", "", {"version":3,"sources":["/Users/Seth/Projects/fantasysx/client/components/navbar.vue?5f98f060"],"names":[],"mappings":";AAmIA;EACA,wBAAA;CACA;AACA;EACA,wBAAA;CACA;AACA;EACA,aAAA;EACA,gBAAA;CACA;AACA;EACA,iCAAA;CACA","file":"navbar.vue","sourcesContent":["\n  <template>\n    <nav class=\"navbar\">\n       <div class=\"navbar-brand\">\n        <div class=\"navbar-item\">\n          //ALPHA TEST//\n        </div>\n        <div class=\"navbar-burger burger\" data-target=\"navMenu\">\n          <span></span>\n          <span></span>\n          <span></span>\n        </div>\n      </div>\n      <div class=\"navbar-menu\" id=\"navMenu\">\n        <div class=\"navbar-start\">\n          <div class=\"navbar-item\">\n            <router-link to=\"/home\" exact>Home</router-link>\n          </div>\n          <div class=\"navbar-item\" v-if=\"GetAuthStatus\">\n            <router-link to=\"/myteam\">My Team</router-link>\n          </div>\n          <div class=\"navbar-item\" v-if=\"GetAuthStatus\">\n            <router-link to=\"/live\">Stat Tracker</router-link>\n          </div>\n          <div class=\"navbar-item\">\n            <router-link to=\"/rules\">Info</router-link>\n          </div>\n          <div class=\"navbar-item\">\n            <router-link to=\"/suggestions\">Suggestions</router-link>\n          </div>\n        </div>\n        <div class=\"navbar-end\">\n          <div class=\"navbar-item\" v-if=\"!GetAuthStatus\" @click=\"setRegisterModal({ show: !ShowRegisterModal })\">\n            <a href=\"#!\">Register</a>\n          </div>\n          <div class=\"navbar-item\" v-if=\"!GetAuthStatus\" @click=\"setLoginModal({ show: !ShowLoginModal })\">\n            <span class=\"icon\">\n              <i class=\"fa fa-sign-in\"></i>\n            </span>\n            <a href=\"#!\">Login</a>\n          </div>\n          <div class=\"navbar-item\" v-if=\"GetAuthStatus\">\n            <a href=\"#!\">Welcome, {{ getUserData.username }}!</a>\n          </div>\n          <div class=\"navbar-item\" v-if=\"GetAuthStatus\" @click=\"setLoggedIn({ isLoggedIn: !GetAuthStatus })\">\n            <span class=\"icon\" v-if=\"GetAuthStatus\">\n              <i class=\"fa fa-sign-out\" aria-hidden=\"true\"></i>\n            </span>\n            <a href=\"#!\" @click=\"logout\">Logout</a>\n          </div>\n        </div>\n      </div>\n      <register :show=\"ShowRegisterModal\"></register>\n      <login v-bind:show=\"ShowLoginModal\"></login>\n    </nav>\n  </template>\n  <script>\n    import axios from 'axios';\n    import { mapGetters, mapMutations } from 'vuex';\n    import register from './register.vue';\n    import login from './login.vue';\n    export default {\n      data() {\n        return  {\n          username: '',\n          password: '',\n          showRegisterModal: false,\n        }\n      },\n      computed: mapGetters([\n        'ShowLoginModal',\n        'ShowRegisterModal',\n        'getUserData',\n        'GetAuthStatus'\n      ]),\n      mounted() {\n        // Get all \"navbar-burger\" elements\n        var $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);\n        console.log($navbarBurgers);\n        // Check if there are any nav burgers\n        if ($navbarBurgers.length > 0) {\n\n          // Add a click event on each of them\n          $navbarBurgers.forEach(function ($el) {\n            $el.addEventListener('click', () => {\n\n              // Get the target from the \"data-target\" attribute\n              var target = $el.dataset.target;\n              var $target = document.getElementById(target);\n\n              // Toggle the class on both the \"navbar-burger\" and the \"navbar-menu\"\n              $el.classList.toggle('is-active');\n              $target.classList.toggle('is-active');\n\n            });\n          });\n        }\n      },\n      created() {\n        axios.get('/loginrefresh').then(data => {\n          console.log(data.data)\n          if (typeof data.data.username != 'undefined') {\n            console.log(\"User Is Authenticated\")\n            this.setUserData({ userData: data.data })\n            this.setLoggedIn({ loggedIn: true })\n          }\n        }).catch(err => {\n          console.log(\"login refresh error\", err);\n        })\n      },\n      methods: {\n        ...mapMutations([\n          'setRegisterModal',\n          'setLoginModal',\n          'setLoggedIn',\n          'setUserData',\n          'logout'\n        ]),\n        logout() {\n          axios.get('logout').then(data => {\n            this.$router.push(\"/\");\n          })\n        }\n      },\n      components: {\n        'register': register,\n        'login': login\n      }\n    }\n  </script>\n  <style>\n    .navbar-menu {\n      padding: 0 100px 0 50px;\n    }\n    .navbar {\n      background: transparent;\n    }\n    a {\n      color: white;\n      font-size: 16pt;\n    }\n    .router-link-active {\n      border-bottom: 1px solid #fffc7f;\n    }\n  </style>\n})\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(220)
}
var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(186),
  /* template */
  __webpack_require__(211),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasysx/client/components/leaderboard.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] leaderboard.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2e4a70a6", Component.options)
  } else {
    hotAPI.reload("data-v-2e4a70a6", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(187),
  /* template */
  __webpack_require__(216),
  /* styles */
  null,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasysx/client/components/login.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] login.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-70e2f95c", Component.options)
  } else {
    hotAPI.reload("data-v-70e2f95c", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(222)
}
var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(188),
  /* template */
  __webpack_require__(213),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasysx/client/components/myteam.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] myteam.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-49361c70", Component.options)
  } else {
    hotAPI.reload("data-v-49361c70", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(227)
}
var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(189),
  /* template */
  __webpack_require__(219),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasysx/client/components/navbar.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] navbar.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-ef297a12", Component.options)
  } else {
    hotAPI.reload("data-v-ef297a12", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(225)
}
var Component = __webpack_require__(3)(
  /* script */
  null,
  /* template */
  __webpack_require__(217),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasysx/client/components/rules.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] rules.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-9b3b3440", Component.options)
  } else {
    hotAPI.reload("data-v-9b3b3440", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(226)
}
var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(191),
  /* template */
  __webpack_require__(218),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasysx/client/components/stattracker.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] stattracker.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-c6e7efe6", Component.options)
  } else {
    hotAPI.reload("data-v-c6e7efe6", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(221)
}
var Component = __webpack_require__(3)(
  /* script */
  __webpack_require__(192),
  /* template */
  __webpack_require__(212),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasysx/client/components/suggestions.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] suggestions.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-3fb77718", Component.options)
  } else {
    hotAPI.reload("data-v-3fb77718", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('div', {
    staticClass: "columns leaderboard"
  }, [_c('div', {
    staticClass: "column is-half is-offset-one-quarter"
  }, [(_vm.doneLoading) ? _c('table', {
    staticClass: "leaderboard-table"
  }, [_vm._m(0), _vm._v(" "), _vm._m(1), _vm._v(" "), _c('tbody', _vm._l((_vm.standings), function(user, index) {
    return _c('tr', [_c('td', [_vm._v(_vm._s(index + 1) + ".")]), _vm._v(" "), _c('td', [_vm._v(_vm._s(user.totalpoints))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(user.weeklyteams[0].username))]), _vm._v(" "), _c('td', {
      class: {
        'pointsback': index > 0
      }
    }, [_vm._v(_vm._s(_vm.pointsbehind(user)))])])
  }))]) : _vm._e(), _vm._v(" "), (!_vm.doneLoading) ? _c('div', [_c('p', [_vm._v("\"This data doesn't fetch itself.. Loading Race Tracker.\"")])]) : _vm._e()])])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', {
    staticClass: "title"
  }, [_c('th', {
    attrs: {
      "colspan": "4"
    }
  }, [_vm._v("2018 Fantasy SX: Main League Standings")])]), _vm._v(" "), _c('tr', [_c('th', [_vm._v("Position")]), _vm._v(" "), _c('th', [_vm._v("Total Points")]), _vm._v(" "), _c('th', [_vm._v("Username")]), _vm._v(" "), _c('th', [_vm._v("Points Back")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('tfoot', [_c('tr', [_c('th', [_vm._v("Position")]), _vm._v(" "), _c('th', [_vm._v("Total Points")]), _vm._v(" "), _c('th', [_vm._v("Username")]), _vm._v(" "), _c('th', [_vm._v("Points Back")])])])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-2e4a70a6", module.exports)
  }
}

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "container suggestions-container"
  }, [_c('section', [_c('div', {
    staticClass: "field"
  }, [_c('div', {
    staticClass: "control"
  }, [_c('label', [_vm._v("Are you a registered user?")]), _vm._v(" "), _c('label', {
    staticClass: "radio"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.Registered),
      expression: "Registered"
    }],
    attrs: {
      "type": "radio",
      "name": "Registered",
      "value": "true"
    },
    domProps: {
      "checked": _vm._q(_vm.Registered, "true")
    },
    on: {
      "__c": function($event) {
        _vm.Registered = "true"
      }
    }
  }), _vm._v("\n            Yes\n          ")]), _vm._v(" "), _c('label', {
    staticClass: "radio"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.Registered),
      expression: "Registered"
    }],
    attrs: {
      "type": "radio",
      "name": "Registered",
      "value": "false"
    },
    domProps: {
      "checked": _vm._q(_vm.Registered, "false")
    },
    on: {
      "__c": function($event) {
        _vm.Registered = "false"
      }
    }
  }), _vm._v("\n            No\n          ")])])]), _vm._v(" "), _c('div', {
    staticClass: "field"
  }, [_c('div', {
    staticClass: "control"
  }, [_c('label', [_vm._v("Is this feedback or a bug report?")]), _vm._v(" "), _c('label', {
    staticClass: "radio"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.ReportType),
      expression: "ReportType"
    }],
    attrs: {
      "type": "radio",
      "name": "feedback",
      "value": "feedback"
    },
    domProps: {
      "checked": _vm._q(_vm.ReportType, "feedback")
    },
    on: {
      "__c": function($event) {
        _vm.ReportType = "feedback"
      }
    }
  }), _vm._v("\n            Feedback\n          ")]), _vm._v(" "), _c('label', {
    staticClass: "radio"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.ReportType),
      expression: "ReportType"
    }],
    attrs: {
      "type": "radio",
      "name": "feedback",
      "value": "bug"
    },
    domProps: {
      "checked": _vm._q(_vm.ReportType, "bug")
    },
    on: {
      "__c": function($event) {
        _vm.ReportType = "bug"
      }
    }
  }), _vm._v("\n            Bug Report\n          ")])])]), _vm._v(" "), _c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label"
  }, [_vm._v("Username")]), _vm._v(" "), _c('div', {
    staticClass: "control"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.Username),
      expression: "Username"
    }],
    staticClass: "input",
    attrs: {
      "type": "text",
      "placeholder": "Username"
    },
    domProps: {
      "value": (_vm.Username)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.Username = $event.target.value
      }
    }
  })])]), _vm._v(" "), (_vm.ReportType == 'feedback') ? _c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label"
  }, [_vm._v("Suggest Features")]), _vm._v(" "), _c('div', {
    staticClass: "control"
  }, [_c('div', {
    staticClass: "select"
  }, [_c('select', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.feature),
      expression: "feature"
    }],
    on: {
      "change": function($event) {
        var $$selectedVal = Array.prototype.filter.call($event.target.options, function(o) {
          return o.selected
        }).map(function(o) {
          var val = "_value" in o ? o._value : o.value;
          return val
        });
        _vm.feature = $event.target.multiple ? $$selectedVal : $$selectedVal[0]
      }
    }
  }, [_c('option', {
    attrs: {
      "disabled": "",
      "value": ""
    }
  }, [_vm._v("SELECT CATEGORY")]), _vm._v(" "), _c('option', [_vm._v("User Interface")]), _vm._v(" "), _c('option', [_vm._v("Navigation Content")]), _vm._v(" "), _c('option', [_vm._v("My Team")]), _vm._v(" "), _c('option', [_vm._v("Scoring")]), _vm._v(" "), _c('option', [_vm._v("New Features")]), _vm._v(" "), _c('option', [_vm._v("Stat Tracker")]), _vm._v(" "), _c('option', [_vm._v("Account")])])])])]) : _vm._e(), _vm._v(" "), (_vm.ReportType == 'feedback') ? _c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label"
  }, [_vm._v("Feedback")]), _vm._v(" "), _c('div', {
    staticClass: "control"
  }, [_c('textarea', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.feedback),
      expression: "feedback"
    }],
    staticClass: "textarea",
    attrs: {
      "placeholder": "Describe your suggestions here."
    },
    domProps: {
      "value": (_vm.feedback)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.feedback = $event.target.value
      }
    }
  })])]) : _vm._e(), _vm._v(" "), (_vm.ReportType == 'bug') ? _c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label"
  }, [_vm._v("Report Bug")]), _vm._v(" "), _c('div', {
    staticClass: "control"
  }, [_c('textarea', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.bugreport),
      expression: "bugreport"
    }],
    staticClass: "textarea",
    attrs: {
      "placeholder": "Describe the actions you took, your desired outcome and the actual outcome of those actions. We should be able to replicate the bug based off the steps you provide here."
    },
    domProps: {
      "value": (_vm.bugreport)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.bugreport = $event.target.value
      }
    }
  })])]) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "field"
  }, [_c('button', {
    staticClass: "button is-primary",
    attrs: {
      "type": "button"
    },
    on: {
      "click": _vm.submit
    }
  }, [_vm._v("Submit")])])])])
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-3fb77718", module.exports)
  }
}

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('div', {
    staticClass: "page-header-container"
  }, [_c('div', {
    staticClass: "page-header-block"
  }, [_c('div', {
    staticClass: "lh-4r"
  }, [_vm._v("Week: "), _c('span', {
    staticClass: "boldest-header right"
  }, [_vm._v(_vm._s(_vm.currentweek))])]), _vm._v(" "), _c('div', {
    staticClass: "lh-4r"
  }, [_vm._v("Balance Remaining:"), _c('span', {
    staticClass: "boldest-header right"
  }, [_vm._v(" $" + _vm._s(_vm.dollars))])])])]), _vm._v(" "), _c('div', {
    staticClass: "container"
  }, [_c('transition', {
    attrs: {
      "name": "fade",
      "mode": "out-in"
    }
  }, [(_vm.showSaveMessage) ? _c('p', {
    staticClass: "successful-save"
  }, [_vm._v("Your team has been successfully saved!")]) : _vm._e(), _vm._v(" "), (_vm.showFailMessage) ? _c('p', {
    staticClass: "failure-save"
  }, [_vm._v("Oops! Something Went Wrong. Please try again later.")]) : _vm._e()]), _vm._v(" "), _c('table', {
    staticClass: "myteam-table"
  }, [_c('thead', [_c('tr', [_c('th', [_vm._v("Action")]), _vm._v(" "), _c('th', {
    on: {
      "click": _vm.sortByPrice
    }
  }, [_vm._v("Price\n            "), _c('span', {
    staticClass: "icon"
  }, [(_vm.CostSortByAsc) ? _c('i', {
    staticClass: "fa fa-caret-up",
    attrs: {
      "aria-hidden": "true"
    }
  }) : _c('i', {
    staticClass: "fa fa-caret-down",
    attrs: {
      "aria-hidden": "true"
    }
  })])]), _vm._v(" "), _c('th', [_vm._v("Racer Name")]), _vm._v(" "), _c('th', [_vm._v("Racer Number")]), _vm._v(" "), _c('th', [_vm._v("Highest Finish")]), _vm._v(" "), _c('th', [_vm._v("Lowest Finish")]), _vm._v(" "), _c('th', [_vm._v("Average Finish")])])]), _vm._v(" "), _vm._m(0), _vm._v(" "), _c('tbody', [_vm._l((_vm.selectedriders), function(racer, index) {
    return _c('tr', [_c('td', [(racer.name != 'OPEN SLOT') ? _c('a', {
      attrs: {
        "href": "#!"
      },
      on: {
        "click": function($event) {
          _vm.removeRacer(racer)
        }
      }
    }, [_vm._m(1, true)]) : _vm._e()]), _vm._v(" "), _c('td', [_vm._v("$" + _vm._s(racer.cost))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(racer.name))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(racer.rider_number))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(racer.highestFinish))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(racer.lowestFinish))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(racer.averageFinish))])])
  }), _vm._v(" "), _c('tr', {
    staticClass: "lastRow"
  }, [_c('td', {
    attrs: {
      "colspan": "5"
    }
  }), _vm._v(" "), _c('td', {
    attrs: {
      "colspan": "1"
    }
  }, [_c('button', {
    staticClass: "button is-danger",
    attrs: {
      "disabled": !_vm.showRemoveAll
    },
    on: {
      "click": _vm.RemoveAll
    }
  }, [_vm._v("Remove All")])]), _vm._v(" "), _c('td', {
    attrs: {
      "colspan": "1"
    }
  }, [_c('button', {
    staticClass: "button is-success",
    class: {
      'is-loading': _vm.isLoading
    },
    attrs: {
      "disabled": _vm.hasOpenSlots
    },
    on: {
      "click": _vm.SaveTeam
    }
  }, [_vm._v("Save Team")])])]), _vm._v(" "), _vm._l((_vm.paginatedRiders), function(rider) {
    return _c('tr', [_c('td', [(_vm.showSelect && rider.cost <= _vm.dollars) ? _c('a', {
      attrs: {
        "href": "#!"
      },
      on: {
        "click": function($event) {
          _vm.addRacer(rider)
        }
      }
    }, [_vm._m(2, true)]) : _vm._e()]), _vm._v(" "), _c('td', [_vm._v("$" + _vm._s(rider.cost))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(rider.name))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(rider.rider_number))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(rider.highestFinish))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(rider.lowestFinish))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(rider.averageFinish))])])
  })], 2)]), _vm._v(" "), _c('div', {
    staticClass: "custom-pagination"
  }, [_c('div', [_c('a', {
    staticClass: "pagination-previous",
    class: {
      'hide-pagination-button': _vm.hidePrevious
    },
    on: {
      "click": function($event) {
        _vm.page--
      }
    }
  }, [_vm._v("Previous")])]), _vm._v(" "), _c('div', [_c('a', {
    staticClass: "pagination-number"
  }, [_vm._v(_vm._s(_vm.page) + "/" + _vm._s(_vm.paginationPages))])]), _vm._v(" "), _c('div', [_c('a', {
    staticClass: "pagination-next",
    class: {
      'hide-pagination-button': _vm.hideNext
    },
    on: {
      "click": function($event) {
        _vm.page++
      }
    }
  }, [_vm._v("Next page")])])])], 1)])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('tfoot', [_c('tr', [_c('th', [_vm._v("Action")]), _vm._v(" "), _c('th', [_vm._v("Price")]), _vm._v(" "), _c('th', [_vm._v("Racer Name")]), _vm._v(" "), _c('th', [_vm._v("Racer Number")]), _vm._v(" "), _c('th', [_vm._v("Highest Finish")]), _vm._v(" "), _c('th', [_vm._v("Lowest Finish")]), _vm._v(" "), _c('th', [_vm._v("Average Finish")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('span', {
    staticClass: "icon minus-icon"
  }, [_c('i', {
    staticClass: "fa fa-minus",
    attrs: {
      "aria-hidden": "true"
    }
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('span', {
    staticClass: "icon plus-icon"
  }, [_c('i', {
    staticClass: "fa fa-plus",
    attrs: {
      "aria-hidden": "true"
    }
  })])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-49361c70", module.exports)
  }
}

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    attrs: {
      "id": "app"
    }
  }, [_c('navigation'), _vm._v(" "), _c('router-view')], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-4fc005b0", module.exports)
  }
}

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "modal",
    class: {
      'is-active': _vm.ShowRegisterModal
    },
    attrs: {
      "id": "registerModal"
    }
  }, [_c('div', {
    staticClass: "modal-background"
  }), _vm._v(" "), _c('div', {
    staticClass: "modal-card"
  }, [_c('header', {
    staticClass: "modal-card-head"
  }, [_c('p', {
    staticClass: "modal-card-title"
  }, [_vm._v("New User Registration")]), _vm._v(" "), _c('button', {
    staticClass: "delete",
    on: {
      "click": function($event) {
        _vm.setRegisterModal({
          show: !_vm.ShowRegisterModal
        })
      }
    }
  })]), _vm._v(" "), _c('section', {
    staticClass: "modal-card-body"
  }, [_c('div', {
    staticClass: "content"
  }, [_c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label"
  }, [_vm._v("Username: ")]), _vm._v(" "), _c('div', {
    staticClass: "control has-icons-left"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.username),
      expression: "username"
    }],
    staticClass: "input",
    class: {
      'is-danger': _vm.invalidUsername
    },
    attrs: {
      "type": "text",
      "id": "reg-username",
      "placeholder": "Username",
      "required": ""
    },
    domProps: {
      "value": (_vm.username)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.username = $event.target.value
      }
    }
  }), _vm._v(" "), _vm._m(0)])]), _vm._v(" "), _c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label"
  }, [_vm._v("Email: ")]), _vm._v(" "), _c('div', {
    staticClass: "control has-icons-left"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.email),
      expression: "email"
    }],
    staticClass: "input",
    class: {
      'is-danger': _vm.invalidEmail
    },
    attrs: {
      "type": "email",
      "id": "reg-email",
      "placeholder": "Email",
      "required": ""
    },
    domProps: {
      "value": (_vm.email)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.email = $event.target.value
      }
    }
  }), _vm._v(" "), _vm._m(1)])]), _vm._v(" "), _c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label"
  }, [_vm._v("Password: ")]), _vm._v(" "), _c('div', {
    staticClass: "control has-icons-left"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.password),
      expression: "password"
    }],
    staticClass: "input",
    class: {
      'is-danger': _vm.blankPassword
    },
    attrs: {
      "type": "password",
      "id": "reg-password",
      "placeholder": "Password",
      "required": ""
    },
    domProps: {
      "value": (_vm.password)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.password = $event.target.value
      }
    }
  }), _vm._v(" "), _vm._m(2)])]), _vm._v(" "), _c('div', {
    staticClass: "field"
  }, [_vm._v("\n            RECAPTCHA PLACEHOLDER\n          ")]), _vm._v(" "), _vm._l((_vm.errorMessage), function(error) {
    return (_vm.errorMessage != '') ? _c('div', {
      staticClass: "errorMessage"
    }, [_vm._v("\n            " + _vm._s(error) + "\n          ")]) : _vm._e()
  })], 2)]), _vm._v(" "), _c('footer', {
    staticClass: "modal-card-foot"
  }, [_c('button', {
    staticClass: "button is-success",
    class: {
      'is-loading': _vm.isLoading
    },
    on: {
      "click": _vm.Register
    }
  }, [_vm._v("Register")]), _vm._v(" "), _c('button', {
    staticClass: "button",
    on: {
      "click": function($event) {
        _vm.setRegisterModal({
          show: !_vm.ShowRegisterModal
        })
      }
    }
  }, [_vm._v("Cancel")])])])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('span', {
    staticClass: "icon is-small is-left"
  }, [_c('i', {
    staticClass: "fa fa-user"
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('span', {
    staticClass: "icon is-small is-left"
  }, [_c('i', {
    staticClass: "fa fa-envelope"
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('span', {
    staticClass: "icon is-small is-left"
  }, [_c('i', {
    staticClass: "fa fa-lock"
  })])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-5fb4fc4a", module.exports)
  }
}

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "modal",
    class: {
      'is-active': _vm.show
    },
    attrs: {
      "id": "loginModal"
    }
  }, [_c('div', {
    staticClass: "modal-background"
  }), _vm._v(" "), _c('div', {
    staticClass: "modal-card"
  }, [_c('header', {
    staticClass: "modal-card-head"
  }, [_c('p', {
    staticClass: "modal-card-title"
  }, [_vm._v("User Login")]), _vm._v(" "), _c('button', {
    staticClass: "delete",
    on: {
      "click": function($event) {
        _vm.setLoginModal({
          show: !_vm.ShowLoginModal
        })
      }
    }
  })]), _vm._v(" "), _c('section', {
    staticClass: "modal-card-body"
  }, [_c('div', {
    staticClass: "content"
  }, [_c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label",
    attrs: {
      "for": "reg-username"
    }
  }, [_vm._v("Username: ")]), _vm._v(" "), _c('div', {
    staticClass: "control"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.username),
      expression: "username"
    }],
    staticClass: "input",
    attrs: {
      "type": "text"
    },
    domProps: {
      "value": (_vm.username)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.username = $event.target.value
      }
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label",
    attrs: {
      "for": "reg-password"
    }
  }, [_vm._v("Password: ")]), _vm._v(" "), _c('div', {
    staticClass: "control"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.password),
      expression: "password"
    }],
    staticClass: "input",
    attrs: {
      "type": "password",
      "id": "reg-password"
    },
    domProps: {
      "value": (_vm.password)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.password = $event.target.value
      }
    }
  })])])]), _vm._v(" "), _c('div', {
    staticClass: "g-recaptcha",
    attrs: {
      "data-sitekey": "6LcSfDIUAAAAAO3jhHna-D8qTwX-nbFbxAk2q5_7"
    }
  })]), _vm._v(" "), _c('footer', {
    staticClass: "modal-card-foot"
  }, [_c('div', {
    staticClass: "field"
  }, [_c('button', {
    staticClass: "button is-primary",
    class: {
      'is-loading': _vm.isLoading
    },
    attrs: {
      "type": "button",
      "value": "Login",
      "id": "submit-login"
    },
    on: {
      "click": _vm.submit
    }
  }, [_vm._v("Login")]), _vm._v(" "), _c('a', {
    staticClass: "button",
    on: {
      "click": function($event) {
        _vm.setLoginModal({
          show: !_vm.ShowLoginModal
        })
      }
    }
  }, [_vm._v("Cancel")])])])])])
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-70e2f95c", module.exports)
  }
}

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _vm._m(0)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "container"
  }, [_c('div', {}, [_c('p', [_vm._v("Rules")]), _vm._v(" "), _c('div', {
    staticClass: "tab"
  }, [_c('input', {
    attrs: {
      "id": "tab-one",
      "type": "checkbox",
      "name": "tabs"
    }
  }), _vm._v(" "), _c('label', {
    attrs: {
      "for": "tab-one"
    }
  }, [_vm._v("How does scoring work?")]), _vm._v(" "), _c('div', {
    staticClass: "tab-content"
  }, [_c('p', [_vm._v("Right now, scoring is set by racer finish. If a selected racer for that week finishes in first, that racer is awarded 1 point. If a racer finishes in fourth, that racer is awarded 4 points. The lower the point total the better score.")])])]), _vm._v(" "), _c('div', {
    staticClass: "tab"
  }, [_c('input', {
    attrs: {
      "id": "tab-two",
      "type": "checkbox",
      "name": "tabs"
    }
  }), _vm._v(" "), _c('label', {
    attrs: {
      "for": "tab-two"
    }
  }, [_vm._v("How does team selection work?")]), _vm._v(" "), _c('div', {
    staticClass: "tab-content"
  }, [_c('p', [_vm._v("As of now, each user is REQUIRED to select 4 racers for each week. The deadline for making racer selection is 3am Mountain Time on the day of the scheduled race. After that time\n          users will no longer be able to select racers for that week's race; the team selection for the next week will be available for selection")]), _vm._v(" "), _c('p', [_vm._v("Users may only SAVE a roster if ALL 4 roster slots have a racer chosen. The SAVE button is disabled if an OPEN SLOT still exists for a weekly lineup.")]), _vm._v(" "), _c('p', [_vm._v("Each user begins each week with $8 credits to spend on filling out their weekly lineup, and that credit is used to select racers for their week's lineup from the available racers pool.\n          The selected racer's cost, once selected, will be deducted from the current week's available credits. You are NOT REQUIRED to spend all $8 credits each week.")])])]), _vm._v(" "), _c('div', {
    staticClass: "tab"
  }, [_c('input', {
    attrs: {
      "id": "tab-three",
      "type": "checkbox",
      "name": "tabs"
    }
  }), _vm._v(" "), _c('label', {
    attrs: {
      "for": "tab-three"
    }
  }, [_vm._v("Live Stat Tracker & Custom Leagues")]), _vm._v(" "), _c('div', {
    staticClass: "tab-content"
  }, [_c('p', [_vm._v("Right now the application is configured where every registered user competes against each other in an open Main League. The live stat tracker (to see the standings update with live position changes) is not available for the ALPHA test.\n        This feature will be testable during the BETA version of the application.")]), _vm._v(" "), _c('p', [_vm._v("Currently, the application does not support custom / private leagues, however, this feature will be available for testing in the BETA version of the application.")])])])])])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-9b3b3440", module.exports)
  }
}

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [(!_vm.isLoading) ? _c('div', {
    staticClass: "flex-center fl live-header"
  }, [_c('div', {
    staticClass: "live-header-box"
  }, [_c('div', [_vm._v("Session Event: "), _c('span', {
    staticClass: "text-highlight fl-right"
  }, [_vm._v(_vm._s(_vm.raceData.raceData.S))])]), _vm._v(" "), _c('div', [_vm._v("Season Event:"), _c('span', {
    staticClass: "text-highlight fl-right"
  }, [_vm._v(" " + _vm._s(_vm.raceData.raceData.E))])]), _vm._v(" "), _c('div', [_vm._v("Session Status:"), _c('span', {
    staticClass: "text-highlight fl-right"
  }, [_vm._v(" " + _vm._s(_vm.raceData.raceDetails.B))])])])]) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "columns leaderboard"
  }, [_c('div', {
    staticClass: "column is-half is-offset-one-quarter"
  }, [(!_vm.isLoading) ? _c('table', {
    staticClass: "table-live"
  }, [_vm._m(0), _vm._v(" "), _vm._m(1), _vm._v(" "), _c('tbody', _vm._l((_vm.standings), function(user, index) {
    return _c('tr', {
      class: [user.username == _vm.getUserData.username ? 'myRow' : '']
    }, [_c('td', [_vm._v(_vm._s(index + 1) + ".")]), _vm._v(" "), _c('td', [_vm._v(_vm._s(user.total))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(user.username))]), _vm._v(" "), _c('td', {
      staticClass: "pointsback"
    }, [_vm._v(_vm._s(_vm.pointsbehind(user)))])])
  }))]) : _vm._e()])])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', [_vm._v("Position")]), _vm._v(" "), _c('th', [_vm._v("Total Points")]), _vm._v(" "), _c('th', [_vm._v("Username")]), _vm._v(" "), _c('th', [_vm._v("Points Back")])])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('tfoot', [_c('tr', [_c('th', [_vm._v("Position")]), _vm._v(" "), _c('th', [_vm._v("Total Points")]), _vm._v(" "), _c('th', [_vm._v("Username")]), _vm._v(" "), _c('th', [_vm._v("Points Back")])])])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-c6e7efe6", module.exports)
  }
}

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('nav', {
    staticClass: "navbar"
  }, [_vm._m(0), _vm._v(" "), _c('div', {
    staticClass: "navbar-menu",
    attrs: {
      "id": "navMenu"
    }
  }, [_c('div', {
    staticClass: "navbar-start"
  }, [_c('div', {
    staticClass: "navbar-item"
  }, [_c('router-link', {
    attrs: {
      "to": "/home",
      "exact": ""
    }
  }, [_vm._v("Home")])], 1), _vm._v(" "), (_vm.GetAuthStatus) ? _c('div', {
    staticClass: "navbar-item"
  }, [_c('router-link', {
    attrs: {
      "to": "/myteam"
    }
  }, [_vm._v("My Team")])], 1) : _vm._e(), _vm._v(" "), (_vm.GetAuthStatus) ? _c('div', {
    staticClass: "navbar-item"
  }, [_c('router-link', {
    attrs: {
      "to": "/live"
    }
  }, [_vm._v("Stat Tracker")])], 1) : _vm._e(), _vm._v(" "), _c('div', {
    staticClass: "navbar-item"
  }, [_c('router-link', {
    attrs: {
      "to": "/rules"
    }
  }, [_vm._v("Info")])], 1), _vm._v(" "), _c('div', {
    staticClass: "navbar-item"
  }, [_c('router-link', {
    attrs: {
      "to": "/suggestions"
    }
  }, [_vm._v("Suggestions")])], 1)]), _vm._v(" "), _c('div', {
    staticClass: "navbar-end"
  }, [(!_vm.GetAuthStatus) ? _c('div', {
    staticClass: "navbar-item",
    on: {
      "click": function($event) {
        _vm.setRegisterModal({
          show: !_vm.ShowRegisterModal
        })
      }
    }
  }, [_c('a', {
    attrs: {
      "href": "#!"
    }
  }, [_vm._v("Register")])]) : _vm._e(), _vm._v(" "), (!_vm.GetAuthStatus) ? _c('div', {
    staticClass: "navbar-item",
    on: {
      "click": function($event) {
        _vm.setLoginModal({
          show: !_vm.ShowLoginModal
        })
      }
    }
  }, [_vm._m(1), _vm._v(" "), _c('a', {
    attrs: {
      "href": "#!"
    }
  }, [_vm._v("Login")])]) : _vm._e(), _vm._v(" "), (_vm.GetAuthStatus) ? _c('div', {
    staticClass: "navbar-item"
  }, [_c('a', {
    attrs: {
      "href": "#!"
    }
  }, [_vm._v("Welcome, " + _vm._s(_vm.getUserData.username) + "!")])]) : _vm._e(), _vm._v(" "), (_vm.GetAuthStatus) ? _c('div', {
    staticClass: "navbar-item",
    on: {
      "click": function($event) {
        _vm.setLoggedIn({
          isLoggedIn: !_vm.GetAuthStatus
        })
      }
    }
  }, [(_vm.GetAuthStatus) ? _c('span', {
    staticClass: "icon"
  }, [_c('i', {
    staticClass: "fa fa-sign-out",
    attrs: {
      "aria-hidden": "true"
    }
  })]) : _vm._e(), _vm._v(" "), _c('a', {
    attrs: {
      "href": "#!"
    },
    on: {
      "click": _vm.logout
    }
  }, [_vm._v("Logout")])]) : _vm._e()])]), _vm._v(" "), _c('register', {
    attrs: {
      "show": _vm.ShowRegisterModal
    }
  }), _vm._v(" "), _c('login', {
    attrs: {
      "show": _vm.ShowLoginModal
    }
  })], 1)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "navbar-brand"
  }, [_c('div', {
    staticClass: "navbar-item"
  }, [_vm._v("\n      //ALPHA TEST//\n    ")]), _vm._v(" "), _c('div', {
    staticClass: "navbar-burger burger",
    attrs: {
      "data-target": "navMenu"
    }
  }, [_c('span'), _vm._v(" "), _c('span'), _vm._v(" "), _c('span')])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('span', {
    staticClass: "icon"
  }, [_c('i', {
    staticClass: "fa fa-sign-in"
  })])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-ef297a12", module.exports)
  }
}

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(196);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(5)("2413922e", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-2e4a70a6\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./leaderboard.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-2e4a70a6\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./leaderboard.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(197);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(5)("50ccdf4a", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3fb77718\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./suggestions.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3fb77718\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./suggestions.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(198);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(5)("748fb925", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-49361c70\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./myteam.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-49361c70\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./myteam.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(199);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(5)("6e3cef14", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-4fc005b0\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./index.vue", function() {
     var newContent = require("!!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-4fc005b0\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./index.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(200);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(5)("0b3868c5", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-5fb4fc4a\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./register.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-5fb4fc4a\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./register.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(201);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(5)("f321a066", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-9b3b3440\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./rules.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-9b3b3440\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./rules.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(202);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(5)("53bb81be", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-c6e7efe6\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./stattracker.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-c6e7efe6\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./stattracker.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(203);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(5)("100dc47e", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-ef297a12\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./navbar.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-ef297a12\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./navbar.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZWFiZjBhZjBkMGNmZWE5MmIyZjYiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzIiwid2VicGFjazovLy8uL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovLy8uL34vdnVleC9kaXN0L3Z1ZXguZXNtLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3RvS2V5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jYXN0UGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gva2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1N0YWNrLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYXJyYXlQdXNoLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19lcXVhbEFycmF5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXRjaGVzU3RyaWN0Q29tcGFyYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL3JlZ2lzdGVyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9yb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3RvcmUvc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vaW5kZXgudnVlIiwid2VicGFjazovLy8uL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9idG9hLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2lzLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1NldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fU2V0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1dlYWtNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FwcGx5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYXJyYXlTb21lLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlSGFzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZU1hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZU1hdGNoZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VPcmRlckJ5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VQdWxsQXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VTbGljZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVNvcnRCeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VVbnNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NvbXBhcmVBc2NlbmRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NvbXBhcmVNdWx0aXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19lcXVhbEJ5VGFnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19lcXVhbE9iamVjdHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXRTeW1ib2xzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldFZhbHVlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNQYXRoLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2hhc2hTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzSXRlcmF0ZWVDYWxsLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc1Byb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWFwQ2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXBDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fb3ZlclJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3BhcmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zZXRUb0FycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zdGFja0dldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvZmluZEluZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2dldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9oYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9sYXN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL21lbW9pemUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvcmVtb3ZlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3NvcnRCeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9zdHViQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3RvRmluaXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3RvSW50ZWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC90b051bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC90b1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vbGVhZGVyYm9hcmQudnVlIiwid2VicGFjazovLy9sb2dpbi52dWUiLCJ3ZWJwYWNrOi8vL215dGVhbS52dWUiLCJ3ZWJwYWNrOi8vL25hdmJhci52dWUiLCJ3ZWJwYWNrOi8vL3JlZ2lzdGVyLnZ1ZSIsIndlYnBhY2s6Ly8vc3RhdHRyYWNrZXIudnVlIiwid2VicGFjazovLy9zdWdnZXN0aW9ucy52dWUiLCJ3ZWJwYWNrOi8vL2luZGV4LnZ1ZSIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWU/ZDY4ZSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9zdWdnZXN0aW9ucy52dWU/NThlOSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9teXRlYW0udnVlPzkxNmUiLCJ3ZWJwYWNrOi8vLy4vaW5kZXgudnVlPzc5NDIiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlPzY3M2EiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvcnVsZXMudnVlP2QwNjgiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvc3RhdHRyYWNrZXIudnVlP2E5OTMiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZT84NWRkIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL2xlYWRlcmJvYXJkLnZ1ZSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9sb2dpbi52dWUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbXl0ZWFtLnZ1ZSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXIudnVlIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL3J1bGVzLnZ1ZSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9zdGF0dHJhY2tlci52dWUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvc3VnZ2VzdGlvbnMudnVlIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL2xlYWRlcmJvYXJkLnZ1ZT8yZWE0Iiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL3N1Z2dlc3Rpb25zLnZ1ZT9jZjljIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL215dGVhbS52dWU/NzI1MyIsIndlYnBhY2s6Ly8vLi9pbmRleC52dWU/ZjIzMCIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWU/NDI5YSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9sb2dpbi52dWU/YjQ3NyIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9ydWxlcy52dWU/NmZkOSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9zdGF0dHJhY2tlci52dWU/OThlZiIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXIudnVlPzhkZTIiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbGVhZGVyYm9hcmQudnVlPzZlOWUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvc3VnZ2VzdGlvbnMudnVlPzA5NjkiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbXl0ZWFtLnZ1ZT8xM2JmIiwid2VicGFjazovLy8uL2luZGV4LnZ1ZT8wYTEzIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL3JlZ2lzdGVyLnZ1ZT8wMzg4Iiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL3J1bGVzLnZ1ZT9kNzgxIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL3N0YXR0cmFja2VyLnZ1ZT83NDczIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL25hdmJhci52dWU/MzJkMyJdLCJuYW1lcyI6WyJiaW5kIiwicmVxdWlyZSIsImlzQnVmZmVyIiwidG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJpc0FycmF5IiwidmFsIiwiY2FsbCIsImlzQXJyYXlCdWZmZXIiLCJpc0Zvcm1EYXRhIiwiRm9ybURhdGEiLCJpc0FycmF5QnVmZmVyVmlldyIsInJlc3VsdCIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnVmZmVyIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzVW5kZWZpbmVkIiwiaXNPYmplY3QiLCJpc0RhdGUiLCJpc0ZpbGUiLCJpc0Jsb2IiLCJpc0Z1bmN0aW9uIiwiaXNTdHJlYW0iLCJwaXBlIiwiaXNVUkxTZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ0cmltIiwic3RyIiwicmVwbGFjZSIsImlzU3RhbmRhcmRCcm93c2VyRW52IiwibmF2aWdhdG9yIiwicHJvZHVjdCIsIndpbmRvdyIsImRvY3VtZW50IiwiZm9yRWFjaCIsIm9iaiIsImZuIiwiaSIsImwiLCJsZW5ndGgiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lcmdlIiwiYXNzaWduVmFsdWUiLCJhcmd1bWVudHMiLCJleHRlbmQiLCJhIiwiYiIsInRoaXNBcmciLCJtb2R1bGUiLCJleHBvcnRzIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwic2VsZiIsInJvb3QiLCJGdW5jdGlvbiIsIkFycmF5IiwidXNlU291cmNlTWFwIiwibGlzdCIsIm1hcCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsImpvaW4iLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJpZCIsInB1c2giLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJjb25jYXQiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIiwiYmFzZUlzTmF0aXZlIiwiZ2V0VmFsdWUiLCJnZXROYXRpdmUiLCJvYmplY3QiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImFwcGx5TWl4aW4iLCJWdWUiLCJ2ZXJzaW9uIiwiTnVtYmVyIiwic3BsaXQiLCJtaXhpbiIsImJlZm9yZUNyZWF0ZSIsInZ1ZXhJbml0IiwiX2luaXQiLCJvcHRpb25zIiwiaW5pdCIsIiRvcHRpb25zIiwic3RvcmUiLCIkc3RvcmUiLCJwYXJlbnQiLCJkZXZ0b29sSG9vayIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJkZXZ0b29sUGx1Z2luIiwiX2RldnRvb2xIb29rIiwiZW1pdCIsIm9uIiwidGFyZ2V0U3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJzdWJzY3JpYmUiLCJtdXRhdGlvbiIsInN0YXRlIiwiZm9yRWFjaFZhbHVlIiwia2V5cyIsImlzUHJvbWlzZSIsInRoZW4iLCJhc3NlcnQiLCJjb25kaXRpb24iLCJtc2ciLCJFcnJvciIsIk1vZHVsZSIsInJhd01vZHVsZSIsInJ1bnRpbWUiLCJfY2hpbGRyZW4iLCJjcmVhdGUiLCJfcmF3TW9kdWxlIiwicmF3U3RhdGUiLCJwcm90b3R5cGVBY2Nlc3NvcnMkMSIsIm5hbWVzcGFjZWQiLCJjb25maWd1cmFibGUiLCJnZXQiLCJhZGRDaGlsZCIsInJlbW92ZUNoaWxkIiwiZ2V0Q2hpbGQiLCJ1cGRhdGUiLCJhY3Rpb25zIiwibXV0YXRpb25zIiwiZ2V0dGVycyIsImZvckVhY2hDaGlsZCIsImZvckVhY2hHZXR0ZXIiLCJmb3JFYWNoQWN0aW9uIiwiZm9yRWFjaE11dGF0aW9uIiwiZGVmaW5lUHJvcGVydGllcyIsIk1vZHVsZUNvbGxlY3Rpb24iLCJyYXdSb290TW9kdWxlIiwicmVnaXN0ZXIiLCJwYXRoIiwicmVkdWNlIiwiZ2V0TmFtZXNwYWNlIiwibmFtZXNwYWNlIiwidXBkYXRlJDEiLCJ0aGlzJDEiLCJhc3NlcnRSYXdNb2R1bGUiLCJuZXdNb2R1bGUiLCJzbGljZSIsInJhd0NoaWxkTW9kdWxlIiwidW5yZWdpc3RlciIsInRhcmdldE1vZHVsZSIsImNvbnNvbGUiLCJ3YXJuIiwidHlwZSIsIm1ha2VBc3NlcnRpb25NZXNzYWdlIiwiYnVmIiwiU3RvcmUiLCJpbnN0YWxsIiwiUHJvbWlzZSIsInBsdWdpbnMiLCJzdHJpY3QiLCJfY29tbWl0dGluZyIsIl9hY3Rpb25zIiwiX211dGF0aW9ucyIsIl93cmFwcGVkR2V0dGVycyIsIl9tb2R1bGVzIiwiX21vZHVsZXNOYW1lc3BhY2VNYXAiLCJfc3Vic2NyaWJlcnMiLCJfd2F0Y2hlclZNIiwicmVmIiwiZGlzcGF0Y2giLCJjb21taXQiLCJib3VuZERpc3BhdGNoIiwicGF5bG9hZCIsImJvdW5kQ29tbWl0IiwiaW5zdGFsbE1vZHVsZSIsInJlc2V0U3RvcmVWTSIsInBsdWdpbiIsImNvbmZpZyIsImRldnRvb2xzIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiX3ZtIiwiX2RhdGEiLCIkJHN0YXRlIiwic2V0IiwidiIsIl90eXBlIiwiX3BheWxvYWQiLCJfb3B0aW9ucyIsInVuaWZ5T2JqZWN0U3R5bGUiLCJlbnRyeSIsImVycm9yIiwiX3dpdGhDb21taXQiLCJjb21taXRJdGVyYXRvciIsImhhbmRsZXIiLCJzdWIiLCJzaWxlbnQiLCJhbGwiLCJzdWJzIiwiaW5kZXhPZiIsInNwbGljZSIsIndhdGNoIiwiZ2V0dGVyIiwiY2IiLCIkd2F0Y2giLCJyZWdpc3Rlck1vZHVsZSIsInVucmVnaXN0ZXJNb2R1bGUiLCJwYXJlbnRTdGF0ZSIsImdldE5lc3RlZFN0YXRlIiwiZGVsZXRlIiwicmVzZXRTdG9yZSIsImhvdFVwZGF0ZSIsIm5ld09wdGlvbnMiLCJjb21taXR0aW5nIiwiaG90Iiwib2xkVm0iLCJ3cmFwcGVkR2V0dGVycyIsImNvbXB1dGVkIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZW5hYmxlU3RyaWN0TW9kZSIsIm5leHRUaWNrIiwiJGRlc3Ryb3kiLCJyb290U3RhdGUiLCJpc1Jvb3QiLCJtb2R1bGVOYW1lIiwibG9jYWwiLCJjb250ZXh0IiwibWFrZUxvY2FsQ29udGV4dCIsIm5hbWVzcGFjZWRUeXBlIiwicmVnaXN0ZXJNdXRhdGlvbiIsImFjdGlvbiIsInJlZ2lzdGVyQWN0aW9uIiwicmVnaXN0ZXJHZXR0ZXIiLCJjaGlsZCIsIm5vTmFtZXNwYWNlIiwiYXJncyIsIm1ha2VMb2NhbEdldHRlcnMiLCJnZXR0ZXJzUHJveHkiLCJzcGxpdFBvcyIsImxvY2FsVHlwZSIsIndyYXBwZWRNdXRhdGlvbkhhbmRsZXIiLCJ3cmFwcGVkQWN0aW9uSGFuZGxlciIsInJlcyIsInJvb3RHZXR0ZXJzIiwicmVzb2x2ZSIsImNhdGNoIiwiZXJyIiwicmF3R2V0dGVyIiwid3JhcHBlZEdldHRlciIsImRlZXAiLCJzeW5jIiwiX1Z1ZSIsIm1hcFN0YXRlIiwibm9ybWFsaXplTmFtZXNwYWNlIiwic3RhdGVzIiwibm9ybWFsaXplTWFwIiwibWFwcGVkU3RhdGUiLCJnZXRNb2R1bGVCeU5hbWVzcGFjZSIsInZ1ZXgiLCJtYXBNdXRhdGlvbnMiLCJtYXBwZWRNdXRhdGlvbiIsImxlbiIsImFwcGx5IiwibWFwR2V0dGVycyIsIm1hcHBlZEdldHRlciIsIm1hcEFjdGlvbnMiLCJtYXBwZWRBY3Rpb24iLCJjcmVhdGVOYW1lc3BhY2VkSGVscGVycyIsImNoYXJBdCIsImhlbHBlciIsImluZGV4X2VzbSIsIlN5bWJvbCIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJiYXNlR2V0VGFnIiwiaXNTeW1ib2wiLCJJTkZJTklUWSIsInRvS2V5IiwiaXNPYmplY3RMaWtlIiwic3ltYm9sVGFnIiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJlbnRyaWVzIiwiaW5kZXgiLCJjbGVhciIsImhhcyIsImVxIiwiYXNzb2NJbmRleE9mIiwiYXJyYXkiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwiX19kYXRhX18iLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJpc0luZGV4IiwidGVzdCIsIm5hdGl2ZUNyZWF0ZSIsImlkZW50aXR5IiwiaXNMZW5ndGgiLCJpc0FycmF5TGlrZSIsImlzVW5kZWYiLCJpc0RlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsIl90b1N0cmluZyIsImlzUGxhaW5PYmplY3QiLCJpc1JlZ0V4cCIsImlzVmFsaWRBcnJheUluZGV4IiwibiIsInBhcnNlRmxvYXQiLCJNYXRoIiwiZmxvb3IiLCJpc0Zpbml0ZSIsIlN0cmluZyIsInRvTnVtYmVyIiwiaXNOYU4iLCJtYWtlTWFwIiwiZXhwZWN0c0xvd2VyQ2FzZSIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsImhhc093biIsImNhY2hlZCIsImNhY2hlIiwiY2FjaGVkRm4iLCJoaXQiLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwiY3R4IiwiYm91bmRGbiIsIl9sZW5ndGgiLCJ0b0FycmF5Iiwic3RhcnQiLCJyZXQiLCJ0byIsIl9mcm9tIiwidG9PYmplY3QiLCJub29wIiwibm8iLCJsb29zZUVxdWFsIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiaXNBcnJheUEiLCJpc0FycmF5QiIsImV2ZXJ5IiwiZSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInByb2R1Y3Rpb25UaXAiLCJwZXJmb3JtYW5jZSIsImVycm9ySGFuZGxlciIsIndhcm5IYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsIl9saWZlY3ljbGVIb29rcyIsImVtcHR5T2JqZWN0IiwiZnJlZXplIiwiaXNSZXNlcnZlZCIsImNoYXJDb2RlQXQiLCJkZWYiLCJ3cml0YWJsZSIsImJhaWxSRSIsInBhcnNlUGF0aCIsInNlZ21lbnRzIiwidGlwIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJ2bSIsInRyYWNlIiwiZ2VuZXJhdGVDb21wb25lbnRUcmFjZSIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJuYW1lIiwiX2lzVnVlIiwiX2NvbXBvbmVudFRhZyIsImZpbGUiLCJfX2ZpbGUiLCJtYXRjaCIsInJlcGVhdCIsIiRwYXJlbnQiLCJ0cmVlIiwiY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlIiwibGFzdCIsImNvbnN0cnVjdG9yIiwiaGFuZGxlRXJyb3IiLCJpbmZvIiwiaW5Ccm93c2VyIiwiaGFzUHJvdG8iLCJVQSIsInVzZXJBZ2VudCIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJuYXRpdmVXYXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJnbG9iYWwiLCJlbnYiLCJWVUVfRU5WIiwiaXNOYXRpdmUiLCJDdG9yIiwiaGFzU3ltYm9sIiwiUmVmbGVjdCIsIm93bktleXMiLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwidGltZXJGdW5jIiwibmV4dFRpY2tIYW5kbGVyIiwiY29waWVzIiwicCIsImxvZ0Vycm9yIiwic2V0VGltZW91dCIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJjb3VudGVyIiwib2JzZXJ2ZXIiLCJ0ZXh0Tm9kZSIsImNyZWF0ZVRleHROb2RlIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJxdWV1ZU5leHRUaWNrIiwiX3Jlc29sdmUiLCJyZWplY3QiLCJfU2V0IiwiU2V0IiwiYWRkIiwidWlkJDEiLCJEZXAiLCJhZGRTdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsIm9iIiwiX19vYl9fIiwiaW5zZXJ0ZWQiLCJvYnNlcnZlQXJyYXkiLCJkZXAiLCJhcnJheUtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwib2JzZXJ2ZXJTdGF0ZSIsInNob3VsZENvbnZlcnQiLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUkJDEiLCJpdGVtcyIsInNyYyIsIl9fcHJvdG9fXyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJzaGFsbG93IiwicHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJzZXR0ZXIiLCJjaGlsZE9iIiwicmVhY3RpdmVHZXR0ZXIiLCJkZXBlbmRBcnJheSIsInJlYWN0aXZlU2V0dGVyIiwibmV3VmFsIiwibWF4IiwicHJvY2VzcyIsImRlbCIsInN0cmF0cyIsImVsIiwicHJvcHNEYXRhIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsIm1lcmdlZERhdGFGbiIsIm1lcmdlZEluc3RhbmNlRGF0YUZuIiwiaW5zdGFuY2VEYXRhIiwiZGVmYXVsdERhdGEiLCJtZXJnZUhvb2siLCJob29rIiwibWVyZ2VBc3NldHMiLCJwcm9wcyIsIm1ldGhvZHMiLCJpbmplY3QiLCJwcm92aWRlIiwiY2hlY2tDb21wb25lbnRzIiwiY29tcG9uZW50cyIsImxvd2VyIiwibm9ybWFsaXplUHJvcHMiLCJub3JtYWxpemVJbmplY3QiLCJub3JtYWxpemVkIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwibWVyZ2VPcHRpb25zIiwiZXh0ZW5kc0Zyb20iLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwidCIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsImhhbmRsZXJzIiwicmVuZGVyIiwiX3dpdGhTdHJpcHBlZCIsIl9yZW5kZXJQcm94eSIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwidGFnIiwic3RhcnRUYWciLCJlbmRUYWciLCJWTm9kZSIsImNoaWxkcmVuIiwidGV4dCIsImVsbSIsImNvbXBvbmVudE9wdGlvbnMiLCJhc3luY0ZhY3RvcnkiLCJucyIsImZ1bmN0aW9uYWxDb250ZXh0IiwiY29tcG9uZW50SW5zdGFuY2UiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJjbG9uZWQiLCJjbG9uZVZOb2RlcyIsInZub2RlcyIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjYXB0dXJlIiwicGxhaW4iLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJwcmlvcml0aXplUGxhaW5FdmVudHMiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbGRPbiIsInJlbW92ZSQkMSIsImN1ciIsIm9sZCIsImV2ZW50IiwidG9BZGQiLCJoYXNNb2RpZmllciIsInNvcnQiLCJldmVudCQxIiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5Iiwib2xkSG9vayIsIndyYXBwZWRIb29rIiwibWVyZ2VkIiwiZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSIsImF0dHJzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJoYXNoIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsIl9pc1ZMaXN0IiwiZW5zdXJlQ3RvciIsImNvbXAiLCJiYXNlIiwiX19lc01vZHVsZSIsImNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIiLCJmYWN0b3J5IiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwiYmFzZUN0b3IiLCJlcnJvckNvbXAiLCJyZXNvbHZlZCIsImxvYWRpbmciLCJsb2FkaW5nQ29tcCIsImNvbnRleHRzIiwiZm9yY2VSZW5kZXIiLCIkZm9yY2VVcGRhdGUiLCJyZWFzb24iLCJjb21wb25lbnQiLCJkZWxheSIsInRpbWVvdXQiLCJnZXRGaXJzdENvbXBvbmVudENoaWxkIiwiaW5pdEV2ZW50cyIsIl9ldmVudHMiLCJfaGFzSG9va0V2ZW50IiwibGlzdGVuZXJzIiwiX3BhcmVudExpc3RlbmVycyIsInVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyIsIiRvbmNlIiwiJG9uIiwicmVtb3ZlJDEiLCIkb2ZmIiwib2xkTGlzdGVuZXJzIiwiZXZlbnRzTWl4aW4iLCJob29rUkUiLCJjYnMiLCJpJDEiLCIkZW1pdCIsImxvd2VyQ2FzZUV2ZW50IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJkZWZhdWx0U2xvdCIsInNsb3QiLCJpc1doaXRlc3BhY2UiLCJyZXNvbHZlU2NvcGVkU2xvdHMiLCJhY3RpdmVJbnN0YW5jZSIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsImluaXRMaWZlY3ljbGUiLCJhYnN0cmFjdCIsIiRjaGlsZHJlbiIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNNb3VudGVkIiwiX2lzRGVzdHJveWVkIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJoeWRyYXRpbmciLCJjYWxsSG9vayIsInByZXZFbCIsIiRlbCIsInByZXZWbm9kZSIsIl92bm9kZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9wYXJlbnRFbG0iLCJfcmVmRWxtIiwiX192dWVfXyIsIiR2bm9kZSIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJydW4iLCJ1c2VyIiwiZXhwcmVzc2lvbiIsImFjdGl2YXRlZFF1ZXVlIiwidXBkYXRlZFF1ZXVlIiwiY2FsbEFjdGl2YXRlZEhvb2tzIiwiY2FsbFVwZGF0ZWRIb29rcyIsInF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50IiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwibGF6eSIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImNoZWNrT3B0aW9uVHlwZSIsIm9wdGlvbiIsInByb3BzT3B0aW9ucyIsImxvb3AiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsIiRkYXRhIiwic2hvdWxkQ2FjaGUiLCJjcmVhdGVDb21wdXRlZEdldHRlciIsImNvbXB1dGVkR2V0dGVyIiwiY3JlYXRlV2F0Y2hlciIsImtleU9yRm4iLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJmaWx0ZXIiLCJwcm92aWRlS2V5IiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJfY29udGV4dCIsImgiLCJkIiwiY3JlYXRlRWxlbWVudCIsImluamVjdGlvbnMiLCJmdW5jdGlvbmFsT3B0aW9ucyIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsIm9sZFZub2RlIiwiaW5zZXJ0IiwiZGVzdHJveSIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsIl9iYXNlIiwiY2lkIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJtZXJnZUhvb2tzIiwidm5vZGVDb21wb25lbnRPcHRpb25zIiwiX2lzQ29tcG9uZW50IiwiaW5saW5lVGVtcGxhdGUiLCJzdGF0aWNSZW5kZXJGbnMiLCJmcm9tUGFyZW50Iiwib3VycyIsIm1lcmdlSG9vayQxIiwib25lIiwidHdvIiwiY2FsbGJhY2siLCJTSU1QTEVfTk9STUFMSVpFIiwiQUxXQVlTX05PUk1BTElaRSIsIm5vcm1hbGl6YXRpb25UeXBlIiwiYWx3YXlzTm9ybWFsaXplIiwiX2NyZWF0ZUVsZW1lbnQiLCJpcyIsImFwcGx5TlMiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsInNsb3ROb2RlcyIsIl9yZW5kZXJlZCIsInJlc29sdmVGaWx0ZXIiLCJjaGVja0tleUNvZGVzIiwiZXZlbnRLZXlDb2RlIiwiYnVpbHRJbkFsaWFzIiwiYmluZE9iamVjdFByb3BzIiwiYXNQcm9wIiwiaXNTeW5jIiwiZG9tUHJvcHMiLCIkZXZlbnQiLCJyZW5kZXJTdGF0aWMiLCJpc0luRm9yIiwiX3N0YXRpY1RyZWVzIiwibWFya1N0YXRpYyIsIm1hcmtPbmNlIiwibWFya1N0YXRpY05vZGUiLCJiaW5kT2JqZWN0TGlzdGVuZXJzIiwiZXhpc3RpbmciLCJpbml0UmVuZGVyIiwicmVuZGVyQ29udGV4dCIsIl9jIiwiJGNyZWF0ZUVsZW1lbnQiLCJwYXJlbnREYXRhIiwicmVuZGVyTWl4aW4iLCIkbmV4dFRpY2siLCJyZW5kZXJFcnJvciIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsInVpZCIsImluaXRNaXhpbiIsImluaXRJbnRlcm5hbENvbXBvbmVudCIsIl9zZWxmIiwic3VwZXIiLCJzdXBlck9wdGlvbnMiLCJjYWNoZWRTdXBlck9wdGlvbnMiLCJtb2RpZmllZE9wdGlvbnMiLCJyZXNvbHZlTW9kaWZpZWRPcHRpb25zIiwiZXh0ZW5kT3B0aW9ucyIsIm1vZGlmaWVkIiwibGF0ZXN0IiwiZXh0ZW5kZWQiLCJzZWFsZWQiLCJzZWFsZWRPcHRpb25zIiwiZGVkdXBlIiwiVnVlJDMiLCJpbml0VXNlIiwidXNlIiwiaW5zdGFsbGVkUGx1Z2lucyIsIl9pbnN0YWxsZWRQbHVnaW5zIiwidW5zaGlmdCIsImluaXRNaXhpbiQxIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJwYXR0ZXJuVHlwZXMiLCJSZWdFeHAiLCJnZXRDb21wb25lbnROYW1lIiwibWF0Y2hlcyIsInBhdHRlcm4iLCJwcnVuZUNhY2hlIiwiY3VycmVudCIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiZXhjbHVkZSIsImNyZWF0ZWQiLCJkZXN0cm95ZWQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVmaW5lUmVhY3RpdmUiLCJzc3JDb250ZXh0IiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImlzRmFsc3lBdHRyVmFsdWUiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImNsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZnlBcnJheSIsInN0cmluZ2lmeU9iamVjdCIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwicXVlcnkiLCJzZWxlY3RlZCIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVDb21tZW50IiwiaW5zZXJ0QmVmb3JlIiwibmV3Tm9kZSIsInJlZmVyZW5jZU5vZGUiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsImhvb2tzIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpblByZSIsImNyZWF0ZUVsbSIsImluc2VydGVkVm5vZGVRdWV1ZSIsIm5lc3RlZCIsInByZSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImFuY2VzdG9yIiwiX3Njb3BlSWQiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJlbG1Ub01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImZpbmRJZHhJbk9sZCIsImVuZCIsImh5ZHJhdGUiLCJwb3N0cGF0Y2giLCJpbnZva2VJbnNlcnRIb29rIiwiaW5pdGlhbCIsImJhaWxlZCIsImlzUmVuZGVyZWRNb2R1bGUiLCJhc3NlcnROb2RlTWF0Y2giLCJoYXNDaGlsZE5vZGVzIiwiaW5uZXJIVE1MIiwiY2hpbGRyZW5NYXRjaCIsImZpcnN0Q2hpbGQiLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsInBhcmVudEVsbSQxIiwiX2xlYXZlQ2IiLCJwYXRjaGFibGUiLCJpJDIiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiZGlyIiwiY2FsbEhvb2skMSIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwidXBkYXRlQ2xhc3MiLCJvbGREYXRhIiwiY2xzIiwidHJhbnNpdGlvbkNsYXNzIiwiX3RyYW5zaXRpb25DbGFzc2VzIiwiX3ByZXZDbGFzcyIsImtsYXNzIiwidmFsaWREaXZpc2lvbkNoYXJSRSIsIndyYXBGaWx0ZXIiLCJleHAiLCJpbmRleCQxIiwiUkFOR0VfVE9LRU4iLCJDSEVDS0JPWF9SQURJT19UT0tFTiIsIm5vcm1hbGl6ZUV2ZW50cyIsInRhcmdldCQxIiwiYWRkJDEiLCJvbGRIYW5kbGVyIiwiZXYiLCJyZW1vdmUkMiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJldmVudHMiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzRGlydHkiLCJpc0lucHV0Q2hhbmdlZCIsIm5vdEluRm9jdXMiLCJhY3RpdmVFbGVtZW50IiwiX3ZNb2RpZmllcnMiLCJudW1iZXIiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJzdHlsZSIsIm5vcm1hbGl6ZVN0eWxlQmluZGluZyIsInN0YXRpY1N0eWxlIiwiYmluZGluZ1N0eWxlIiwiZ2V0U3R5bGUiLCJjaGVja0NoaWxkIiwic3R5bGVEYXRhIiwiY3NzVmFyUkUiLCJpbXBvcnRhbnRSRSIsInNldFByb3AiLCJzZXRQcm9wZXJ0eSIsIm5vcm1hbGl6ZWROYW1lIiwibm9ybWFsaXplIiwidmVuZG9yTmFtZXMiLCJlbXB0eVN0eWxlIiwiY2FwTmFtZSIsInVwZGF0ZVN0eWxlIiwib2xkU3RhdGljU3R5bGUiLCJvbGRTdHlsZUJpbmRpbmciLCJub3JtYWxpemVkU3R5bGUiLCJvbGRTdHlsZSIsIm5ld1N0eWxlIiwiYWRkQ2xhc3MiLCJjbGFzc0xpc3QiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVDbGFzcyIsInRhciIsInJlc29sdmVUcmFuc2l0aW9uIiwiZGVmJCQxIiwiY3NzIiwiYXV0b0Nzc1RyYW5zaXRpb24iLCJlbnRlckNsYXNzIiwiZW50ZXJUb0NsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImxlYXZlQ2xhc3MiLCJsZWF2ZVRvQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwiaGFzVHJhbnNpdGlvbiIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJ0cmFuc2l0aW9uUHJvcCIsInRyYW5zaXRpb25FbmRFdmVudCIsImFuaW1hdGlvblByb3AiLCJhbmltYXRpb25FbmRFdmVudCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ud2Via2l0dHJhbnNpdGlvbmVuZCIsIm9uYW5pbWF0aW9uZW5kIiwib253ZWJraXRhbmltYXRpb25lbmQiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJ0cmFuc2l0aW9uQ2xhc3NlcyIsInJlbW92ZVRyYW5zaXRpb25DbGFzcyIsIndoZW5UcmFuc2l0aW9uRW5kcyIsImdldFRyYW5zaXRpb25JbmZvIiwicHJvcENvdW50IiwiZW5kZWQiLCJvbkVuZCIsInRyYW5zZm9ybVJFIiwic3R5bGVzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInRyYW5zaXRpb25EZWxheXMiLCJ0cmFuc2l0aW9uRHVyYXRpb25zIiwidHJhbnNpdGlvblRpbWVvdXQiLCJnZXRUaW1lb3V0IiwiYW5pbWF0aW9uRGVsYXlzIiwiYW5pbWF0aW9uRHVyYXRpb25zIiwiYW5pbWF0aW9uVGltZW91dCIsImhhc1RyYW5zZm9ybSIsImRlbGF5cyIsImR1cmF0aW9ucyIsInRvTXMiLCJzIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJhcHBlYXJDbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsImJlZm9yZUVudGVyIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkIiwiYmVmb3JlQXBwZWFyIiwiYXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJhcHBlYXJDYW5jZWxsZWQiLCJkdXJhdGlvbiIsInRyYW5zaXRpb25Ob2RlIiwiaXNBcHBlYXIiLCJzdGFydENsYXNzIiwiYWN0aXZlQ2xhc3MiLCJ0b0NsYXNzIiwiYmVmb3JlRW50ZXJIb29rIiwiZW50ZXJIb29rIiwiYWZ0ZXJFbnRlckhvb2siLCJlbnRlckNhbmNlbGxlZEhvb2siLCJleHBsaWNpdEVudGVyRHVyYXRpb24iLCJjaGVja0R1cmF0aW9uIiwiZXhwZWN0c0NTUyIsInVzZXJXYW50c0NvbnRyb2wiLCJnZXRIb29rQXJndW1lbnRzTGVuZ3RoIiwic2hvdyIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImJlZm9yZUxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsInBlcmZvcm1MZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJ2bW9kZWwiLCJ0cmlnZ2VyIiwibW9kZWwkMSIsImJpbmRpbmciLCJzZXRTZWxlY3RlZCIsIl92T3B0aW9ucyIsIm9uQ29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJzb21lIiwibyIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJhY3R1YWxseVNldFNlbGVjdGVkIiwiaXNNdWx0aXBsZSIsInNlbGVjdGVkSW5kZXgiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwidHJhbnNpdGlvbiQkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJrZXkkMSIsInBsYWNlaG9sZGVyIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsImtlcHQiLCJyZW1vdmVkIiwiYyQxIiwicG9zIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYmVmb3JlVXBkYXRlIiwidXBkYXRlZCIsImhhc01vdmUiLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwiYXBwbHlUcmFuc2xhdGlvbiIsImJvZHkiLCJmIiwib2Zmc2V0SGVpZ2h0IiwibW92ZWQiLCJ0cmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiX2hhc01vdmUiLCJjbG9uZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwibGVmdCIsImR5IiwidG9wIiwicGxhdGZvcm1Db21wb25lbnRzIiwidXRpbHMiLCJub3JtYWxpemVIZWFkZXJOYW1lIiwiREVGQVVMVF9DT05URU5UX1RZUEUiLCJzZXRDb250ZW50VHlwZUlmVW5zZXQiLCJoZWFkZXJzIiwiZ2V0RGVmYXVsdEFkYXB0ZXIiLCJhZGFwdGVyIiwiWE1MSHR0cFJlcXVlc3QiLCJkZWZhdWx0cyIsInRyYW5zZm9ybVJlcXVlc3QiLCJ0cmFuc2Zvcm1SZXNwb25zZSIsInBhcnNlIiwieHNyZkNvb2tpZU5hbWUiLCJ4c3JmSGVhZGVyTmFtZSIsIm1heENvbnRlbnRMZW5ndGgiLCJ2YWxpZGF0ZVN0YXR1cyIsInN0YXR1cyIsImNvbW1vbiIsImZvckVhY2hNZXRob2ROb0RhdGEiLCJmb3JFYWNoTWV0aG9kV2l0aERhdGEiLCJNYXAiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJtYXBDYWNoZUdldCIsIm1hcENhY2hlSGFzIiwibWFwQ2FjaGVTZXQiLCJNYXBDYWNoZSIsImNhc3RQYXRoIiwiYmFzZUdldCIsImJhc2VNYXRjaGVzIiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSIsImJhc2VJdGVyYXRlZSIsImlzS2V5Iiwic3RyaW5nVG9QYXRoIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsIm90aGVyIiwiYmFzZUlzQXJndW1lbnRzIiwib2JqZWN0UHJvdG8iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImlzQXJndW1lbnRzIiwiYXJyYXlMaWtlS2V5cyIsImJhc2VLZXlzIiwic2V0dGxlIiwiYnVpbGRVUkwiLCJwYXJzZUhlYWRlcnMiLCJpc1VSTFNhbWVPcmlnaW4iLCJjcmVhdGVFcnJvciIsInhockFkYXB0ZXIiLCJkaXNwYXRjaFhoclJlcXVlc3QiLCJyZXF1ZXN0RGF0YSIsInJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdCIsImxvYWRFdmVudCIsInhEb21haW4iLCJYRG9tYWluUmVxdWVzdCIsInVybCIsIm9ucHJvZ3Jlc3MiLCJoYW5kbGVQcm9ncmVzcyIsIm9udGltZW91dCIsImhhbmRsZVRpbWVvdXQiLCJhdXRoIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIkF1dGhvcml6YXRpb24iLCJvcGVuIiwicGFyYW1zIiwicGFyYW1zU2VyaWFsaXplciIsImhhbmRsZUxvYWQiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VVUkwiLCJyZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZSIsInN0YXR1c1RleHQiLCJvbmVycm9yIiwiY29va2llcyIsInhzcmZWYWx1ZSIsIndpdGhDcmVkZW50aWFscyIsInJlYWQiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25Eb3dubG9hZFByb2dyZXNzIiwib25VcGxvYWRQcm9ncmVzcyIsInVwbG9hZCIsImNhbmNlbFRva2VuIiwicHJvbWlzZSIsIm9uQ2FuY2VsZWQiLCJjYW5jZWwiLCJhYm9ydCIsInNlbmQiLCJDYW5jZWwiLCJtZXNzYWdlIiwiX19DQU5DRUxfXyIsImlzQ2FuY2VsIiwiZW5oYW5jZUVycm9yIiwiY29kZSIsIndyYXAiLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJTdGFjayIsInNpemUiLCJhcnJheU1hcCIsIml0ZXJhdGVlIiwiYXJyYXlQdXNoIiwidmFsdWVzIiwib2Zmc2V0IiwiYmFzZUlzRXF1YWxEZWVwIiwiYmFzZUlzRXF1YWwiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsInN0YWNrIiwiYmFzZVVuYXJ5IiwiZnVuYyIsIlNldENhY2hlIiwiYXJyYXlTb21lIiwiY2FjaGVIYXMiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJlcXVhbEFycmF5cyIsImVxdWFsRnVuYyIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsInN0YWNrZWQiLCJhcnJWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJvdGhJbmRleCIsImlzU3RyaWN0Q29tcGFyYWJsZSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwic3JjVmFsdWUiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJ0b1NvdXJjZSIsInN0dWJGYWxzZSIsImZyZWVFeHBvcnRzIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJuYXRpdmVJc0J1ZmZlciIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiYmFzZUlzVHlwZWRBcnJheSIsIm5vZGVVdGlsIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImciLCJldmFsIiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwicGF0aHMiLCJjcmVhdGVSb3V0ZXIiLCJyb3V0ZXMiLCJpc0xvZ2dlZEluIiwibW9kYWxDb250cm9sIiwic2hvd0xvZ2luTW9kYWwiLCJzaG93UmVnaXN0ZXJNb2RhbCIsImdldFVzZXJEYXRhIiwiU2hvd0xvZ2luTW9kYWwiLCJTaG93UmVnaXN0ZXJNb2RhbCIsIkdldEF1dGhTdGF0dXMiLCJjaGFuZ2VUZWFtIiwicmlkZXJBcnJheSIsInJpZGVycyIsInNldExvZ2luTW9kYWwiLCJzZXRSZWdpc3Rlck1vZGFsIiwic2V0VXNlckRhdGEiLCJ1c2VyRGF0YSIsInNldExvZ2dlZEluIiwibG9nZ2VkSW4iLCJsb2dvdXQiLCJyb3V0ZXIiLCJhcHAiLCJBeGlvcyIsImNyZWF0ZUluc3RhbmNlIiwiZGVmYXVsdENvbmZpZyIsImluc3RhbmNlIiwiYXhpb3MiLCJpbnN0YW5jZUNvbmZpZyIsIkNhbmNlbFRva2VuIiwicHJvbWlzZXMiLCJzcHJlYWQiLCJleGVjdXRvciIsIlR5cGVFcnJvciIsInJlc29sdmVQcm9taXNlIiwicHJvbWlzZUV4ZWN1dG9yIiwidG9rZW4iLCJ0aHJvd0lmUmVxdWVzdGVkIiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiZGlzcGF0Y2hSZXF1ZXN0IiwiaXNBYnNvbHV0ZVVSTCIsImNvbWJpbmVVUkxzIiwiaW50ZXJjZXB0b3JzIiwiYmFzZVVSTCIsImNoYWluIiwidW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMiLCJpbnRlcmNlcHRvciIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwicHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzIiwic2hpZnQiLCJlamVjdCIsImZvckVhY2hIYW5kbGVyIiwidHJhbnNmb3JtRGF0YSIsInRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQiLCJjbGVhbkhlYWRlckNvbmZpZyIsIm9uQWRhcHRlclJlc29sdXRpb24iLCJvbkFkYXB0ZXJSZWplY3Rpb24iLCJjaGFycyIsIkUiLCJpbnB1dCIsIm91dHB1dCIsImJsb2NrIiwiY2hhckNvZGUiLCJpZHgiLCJlbmNvZGUiLCJzZXJpYWxpemVkUGFyYW1zIiwicGFydHMiLCJzZXJpYWxpemUiLCJwYXJzZVZhbHVlIiwidG9JU09TdHJpbmciLCJyZWxhdGl2ZVVSTCIsInN0YW5kYXJkQnJvd3NlckVudiIsIndyaXRlIiwiZXhwaXJlcyIsImRvbWFpbiIsInNlY3VyZSIsImNvb2tpZSIsIkRhdGUiLCJ0b0dNVFN0cmluZyIsImRlY29kZVVSSUNvbXBvbmVudCIsIm5vdyIsIm5vblN0YW5kYXJkQnJvd3NlckVudiIsIm1zaWUiLCJ1cmxQYXJzaW5nTm9kZSIsIm9yaWdpblVSTCIsInJlc29sdmVVUkwiLCJocmVmIiwicHJvdG9jb2wiLCJob3N0Iiwic2VhcmNoIiwiaG9zdG5hbWUiLCJwb3J0IiwicGF0aG5hbWUiLCJsb2NhdGlvbiIsInJlcXVlc3RVUkwiLCJwYXJzZWQiLCJwcm9jZXNzSGVhZGVyIiwicGFyc2VyIiwibGluZSIsInN1YnN0ciIsImlzU2xvd0J1ZmZlciIsIl9pc0J1ZmZlciIsInJlYWRGbG9hdExFIiwiRGF0YVZpZXciLCJoYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSGFzaCIsInNldENhY2hlQWRkIiwic2V0Q2FjaGVIYXMiLCJVaW50OEFycmF5IiwiV2Vha01hcCIsImFycmF5RmlsdGVyIiwicHJlZGljYXRlIiwicmVzSW5kZXgiLCJiYXNlVGltZXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNCdWZmIiwic2tpcEluZGV4ZXMiLCJiYXNlRm9yT3duIiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRWFjaCIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJmcm9tUmlnaHQiLCJpc0ZsYXR0ZW5hYmxlIiwiYmFzZUZsYXR0ZW4iLCJkZXB0aCIsImlzU3RyaWN0IiwiY3JlYXRlQmFzZUZvciIsImJhc2VGb3IiLCJiYXNlR2V0QWxsS2V5cyIsImtleXNGdW5jIiwic3ltYm9sc0Z1bmMiLCJiYXNlSGFzSW4iLCJhcmdzVGFnIiwiZXF1YWxCeVRhZyIsImVxdWFsT2JqZWN0cyIsImdldFRhZyIsImFycmF5VGFnIiwib2JqZWN0VGFnIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJvYmpJc1dyYXBwZWQiLCJvdGhJc1dyYXBwZWQiLCJvYmpVbndyYXBwZWQiLCJvdGhVbndyYXBwZWQiLCJiYXNlSXNNYXRjaCIsIm1hdGNoRGF0YSIsIm5vQ3VzdG9taXplciIsIm9ialZhbHVlIiwiaXNNYXNrZWQiLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJyZUlzTmF0aXZlIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJpc1Byb3RvdHlwZSIsIm5hdGl2ZUtleXMiLCJiYXNlTWFwIiwiY29sbGVjdGlvbiIsImdldE1hdGNoRGF0YSIsImhhc0luIiwiYmFzZVNvcnRCeSIsImNvbXBhcmVNdWx0aXBsZSIsImJhc2VPcmRlckJ5IiwiaXRlcmF0ZWVzIiwib3JkZXJzIiwiY3JpdGVyaWEiLCJiYXNlUHJvcGVydHkiLCJiYXNlUHJvcGVydHlEZWVwIiwiYmFzZVVuc2V0IiwiYmFzZVB1bGxBdCIsImluZGV4ZXMiLCJsYXN0SW5kZXgiLCJwcmV2aW91cyIsIm92ZXJSZXN0Iiwic2V0VG9TdHJpbmciLCJiYXNlUmVzdCIsImNvbnN0YW50IiwiYmFzZVNldFRvU3RyaW5nIiwic3RyaW5nIiwiYmFzZVNsaWNlIiwiY29tcGFyZXIiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwiYmFzZVRvU3RyaW5nIiwiY29tcGFyZUFzY2VuZGluZyIsInZhbElzRGVmaW5lZCIsInZhbElzTnVsbCIsInZhbElzUmVmbGV4aXZlIiwidmFsSXNTeW1ib2wiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwib2JqQ3JpdGVyaWEiLCJvdGhDcml0ZXJpYSIsIm9yZGVyc0xlbmd0aCIsIm9yZGVyIiwiY29yZUpzRGF0YSIsImVhY2hGdW5jIiwiaXRlcmFibGUiLCJtYXBUb0FycmF5Iiwic2V0VG9BcnJheSIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwiYnl0ZUxlbmd0aCIsImJ5dGVPZmZzZXQiLCJjb252ZXJ0IiwiZ2V0QWxsS2V5cyIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiZ2V0U3ltYm9scyIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwiaXNPd24iLCJ1bm1hc2tlZCIsInN0dWJBcnJheSIsIm5hdGl2ZUdldFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2wiLCJwcm9taXNlVGFnIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwiY3RvclN0cmluZyIsImhhc1BhdGgiLCJoYXNGdW5jIiwiSEFTSF9VTkRFRklORUQiLCJzcHJlYWRhYmxlU3ltYm9sIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwiaXNJdGVyYXRlZUNhbGwiLCJtYXNrU3JjS2V5IiwiZXhlYyIsIklFX1BST1RPIiwicHJvdG8iLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQiLCJvdmVyQXJnIiwiZnJlZVByb2Nlc3MiLCJhcmciLCJuYXRpdmVNYXgiLCJvdGhlckFyZ3MiLCJzaG9ydE91dCIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93IiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJMQVJHRV9BUlJBWV9TSVpFIiwicGFpcnMiLCJyZUxlYWRpbmdEb3QiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwicXVvdGUiLCJ0b0ludGVnZXIiLCJmaW5kSW5kZXgiLCJkZWZhdWx0VmFsdWUiLCJGVU5DX0VSUk9SX1RFWFQiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiQ2FjaGUiLCJzb3J0QnkiLCJNQVhfSU5URUdFUiIsInRvRmluaXRlIiwic2lnbiIsInJlbWFpbmRlciIsIk5BTiIsInJlVHJpbSIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc09jdGFsIiwiZnJlZVBhcnNlSW50IiwicGFyc2VJbnQiLCJpc0JpbmFyeSIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwiSXRlbSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9ucyIsImFkZExpc3RlbmVyIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwiY3dkIiwiY2hkaXIiLCJ1bWFzayIsImlzRXJyb3IiLCJWaWV3Iiwicm91dGVyVmlldyIsInJvdXRlIiwiJHJvdXRlIiwiX3JvdXRlclZpZXdDYWNoZSIsImluYWN0aXZlIiwiX3JvdXRlclJvb3QiLCJyb3V0ZXJWaWV3RGVwdGgiLCJtYXRjaGVkIiwicmVnaXN0ZXJSb3V0ZUluc3RhbmNlIiwiaW5zdGFuY2VzIiwicmVzb2x2ZVByb3BzIiwiZW5jb2RlUmVzZXJ2ZVJFIiwiZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyIiwiY29tbWFSRSIsImRlY29kZSIsInJlc29sdmVRdWVyeSIsImV4dHJhUXVlcnkiLCJfcGFyc2VRdWVyeSIsInBhcnNlUXVlcnkiLCJwYXJzZWRRdWVyeSIsInBhcmFtIiwic3RyaW5naWZ5UXVlcnkiLCJ2YWwyIiwieCIsInRyYWlsaW5nU2xhc2hSRSIsImNyZWF0ZVJvdXRlIiwicmVjb3JkIiwicmVkaXJlY3RlZEZyb20iLCJzdHJpbmdpZnlRdWVyeSQkMSIsIm1ldGEiLCJmdWxsUGF0aCIsImdldEZ1bGxQYXRoIiwiZm9ybWF0TWF0Y2giLCJTVEFSVCIsIl9zdHJpbmdpZnlRdWVyeSIsImlzU2FtZVJvdXRlIiwiaXNPYmplY3RFcXVhbCIsImFLZXlzIiwiYktleXMiLCJhVmFsIiwiYlZhbCIsImlzSW5jbHVkZWRSb3V0ZSIsInF1ZXJ5SW5jbHVkZXMiLCJ0b1R5cGVzIiwiZXZlbnRUeXBlcyIsIkxpbmsiLCJleGFjdCIsImFwcGVuZCIsImV4YWN0QWN0aXZlQ2xhc3MiLCIkcm91dGVyIiwiY2xhc3NlcyIsImdsb2JhbEFjdGl2ZUNsYXNzIiwibGlua0FjdGl2ZUNsYXNzIiwiZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyIsImxpbmtFeGFjdEFjdGl2ZUNsYXNzIiwiYWN0aXZlQ2xhc3NGYWxsYmFjayIsImV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayIsImNvbXBhcmVUYXJnZXQiLCJndWFyZEV2ZW50IiwiY2xpY2siLCJmaW5kQW5jaG9yIiwiYURhdGEiLCJhQXR0cnMiLCJtZXRhS2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiZGVmYXVsdFByZXZlbnRlZCIsImJ1dHRvbiIsImN1cnJlbnRUYXJnZXQiLCJwcmV2ZW50RGVmYXVsdCIsImluc3RhbGxlZCIsInJlZ2lzdGVySW5zdGFuY2UiLCJjYWxsVmFsIiwiX3JvdXRlciIsImhpc3RvcnkiLCJfcm91dGUiLCJiZWZvcmVSb3V0ZUVudGVyIiwiYmVmb3JlUm91dGVMZWF2ZSIsImJlZm9yZVJvdXRlVXBkYXRlIiwicmVzb2x2ZVBhdGgiLCJyZWxhdGl2ZSIsImZpcnN0Q2hhciIsInNlZ21lbnQiLCJoYXNoSW5kZXgiLCJxdWVyeUluZGV4IiwiY2xlYW5QYXRoIiwicGF0aFRvUmVnZXhwIiwicGFyc2VfMSIsImNvbXBpbGVfMSIsImNvbXBpbGUiLCJ0b2tlbnNUb0Z1bmN0aW9uXzEiLCJ0b2tlbnNUb0Z1bmN0aW9uIiwidG9rZW5zVG9SZWdFeHBfMSIsInRva2Vuc1RvUmVnRXhwIiwiUEFUSF9SRUdFWFAiLCJ0b2tlbnMiLCJkZWZhdWx0RGVsaW1pdGVyIiwiZGVsaW1pdGVyIiwibSIsImVzY2FwZWQiLCJuZXh0IiwicHJlZml4IiwiZ3JvdXAiLCJtb2RpZmllciIsImFzdGVyaXNrIiwicGFydGlhbCIsIm9wdGlvbmFsIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJlbmNvZGVBc3RlcmlzayIsInByZXR0eSIsImF0dGFjaEtleXMiLCJyZSIsImZsYWdzIiwic2Vuc2l0aXZlIiwicmVnZXhwVG9SZWdleHAiLCJncm91cHMiLCJhcnJheVRvUmVnZXhwIiwicmVnZXhwIiwic3RyaW5nVG9SZWdleHAiLCJlbmRzV2l0aERlbGltaXRlciIsInJlZ2V4cENvbXBpbGVDYWNoZSIsImZpbGxQYXJhbXMiLCJyb3V0ZU1zZyIsImZpbGxlciIsImNyZWF0ZVJvdXRlTWFwIiwib2xkUGF0aExpc3QiLCJvbGRQYXRoTWFwIiwib2xkTmFtZU1hcCIsInBhdGhMaXN0IiwicGF0aE1hcCIsIm5hbWVNYXAiLCJhZGRSb3V0ZVJlY29yZCIsIm1hdGNoQXMiLCJub3JtYWxpemVkUGF0aCIsIm5vcm1hbGl6ZVBhdGgiLCJwYXRoVG9SZWdleHBPcHRpb25zIiwiY2FzZVNlbnNpdGl2ZSIsInJlZ2V4IiwiY29tcGlsZVJvdXRlUmVnZXgiLCJyZWRpcmVjdCIsImNoaWxkTWF0Y2hBcyIsImFsaWFzIiwiYWxpYXNlcyIsImFsaWFzUm91dGUiLCJub3JtYWxpemVMb2NhdGlvbiIsIl9ub3JtYWxpemVkIiwiYXNzaWduIiwicmF3UGF0aCIsInBhcnNlZFBhdGgiLCJiYXNlUGF0aCIsImNyZWF0ZU1hdGNoZXIiLCJhZGRSb3V0ZXMiLCJjdXJyZW50Um91dGUiLCJfY3JlYXRlUm91dGUiLCJwYXJhbU5hbWVzIiwicmVjb3JkJDEiLCJtYXRjaFJvdXRlIiwib3JpZ2luYWxSZWRpcmVjdCIsInRhcmdldFJlY29yZCIsInJlc29sdmVSZWNvcmRQYXRoIiwicmVzb2x2ZWRQYXRoIiwiYWxpYXNlZFBhdGgiLCJhbGlhc2VkTWF0Y2giLCJhbGlhc2VkUmVjb3JkIiwicG9zaXRpb25TdG9yZSIsInNldHVwU2Nyb2xsIiwic2F2ZVNjcm9sbFBvc2l0aW9uIiwic2V0U3RhdGVLZXkiLCJoYW5kbGVTY3JvbGwiLCJpc1BvcCIsImJlaGF2aW9yIiwic2Nyb2xsQmVoYXZpb3IiLCJwb3NpdGlvbiIsImdldFNjcm9sbFBvc2l0aW9uIiwic2hvdWxkU2Nyb2xsIiwic2VsZWN0b3IiLCJub3JtYWxpemVPZmZzZXQiLCJnZXRFbGVtZW50UG9zaXRpb24iLCJpc1ZhbGlkUG9zaXRpb24iLCJub3JtYWxpemVQb3NpdGlvbiIsInNjcm9sbFRvIiwieSIsImdldFN0YXRlS2V5IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImRvY0VsIiwiZG9jdW1lbnRFbGVtZW50IiwiZG9jUmVjdCIsImVsUmVjdCIsInN1cHBvcnRzUHVzaFN0YXRlIiwidWEiLCJUaW1lIiwiX2tleSIsImdlbktleSIsInRvRml4ZWQiLCJwdXNoU3RhdGUiLCJydW5RdWV1ZSIsInN0ZXAiLCJyZXNvbHZlQXN5bmNDb21wb25lbnRzIiwiaGFzQXN5bmMiLCJmbGF0TWFwQ29tcG9uZW50cyIsInJlc29sdmVkRGVmIiwiZmxhdHRlbiIsIkhpc3RvcnkiLCJub3JtYWxpemVCYXNlIiwicmVhZHkiLCJyZWFkeUNicyIsInJlYWR5RXJyb3JDYnMiLCJlcnJvckNicyIsImxpc3RlbiIsIm9uUmVhZHkiLCJlcnJvckNiIiwib25FcnJvciIsInRyYW5zaXRpb25UbyIsIm9uQ29tcGxldGUiLCJvbkFib3J0IiwiY29uZmlybVRyYW5zaXRpb24iLCJ1cGRhdGVSb3V0ZSIsImVuc3VyZVVSTCIsInJlc29sdmVRdWV1ZSIsImRlYWN0aXZhdGVkIiwiYWN0aXZhdGVkIiwiZXh0cmFjdExlYXZlR3VhcmRzIiwiYmVmb3JlSG9va3MiLCJleHRyYWN0VXBkYXRlSG9va3MiLCJpdGVyYXRvciIsInBvc3RFbnRlckNicyIsImlzVmFsaWQiLCJlbnRlckd1YXJkcyIsImV4dHJhY3RFbnRlckd1YXJkcyIsInJlc29sdmVIb29rcyIsInByZXYiLCJhZnRlckhvb2tzIiwiYmFzZUVsIiwiZXh0cmFjdEd1YXJkcyIsInJlY29yZHMiLCJyZXZlcnNlIiwiZ3VhcmRzIiwiZ3VhcmQiLCJleHRyYWN0R3VhcmQiLCJiaW5kR3VhcmQiLCJib3VuZFJvdXRlR3VhcmQiLCJiaW5kRW50ZXJHdWFyZCIsInJvdXRlRW50ZXJHdWFyZCIsInBvbGwiLCJIVE1MNUhpc3RvcnkiLCJIaXN0b3J5JCQxIiwiZXhwZWN0U2Nyb2xsIiwiZ2V0TG9jYXRpb24iLCJnbyIsImZyb21Sb3V0ZSIsImdldEN1cnJlbnRMb2NhdGlvbiIsIkhhc2hIaXN0b3J5IiwiY2hlY2tGYWxsYmFjayIsImVuc3VyZVNsYXNoIiwic2V0dXBMaXN0ZW5lcnMiLCJnZXRIYXNoIiwicmVwbGFjZUhhc2giLCJwdXNoSGFzaCIsIkFic3RyYWN0SGlzdG9yeSIsInRhcmdldEluZGV4IiwiVnVlUm91dGVyIiwiYXBwcyIsIm1hdGNoZXIiLCJzZXR1cEhhc2hMaXN0ZW5lciIsImJlZm9yZUVhY2giLCJyZWdpc3Rlckhvb2siLCJiZWZvcmVSZXNvbHZlIiwiYWZ0ZXJFYWNoIiwiYmFjayIsImZvcndhcmQiLCJnZXRNYXRjaGVkQ29tcG9uZW50cyIsImNyZWF0ZUhyZWYiLCJub3JtYWxpemVkVG8iLCJsaXN0VG9TdHlsZXMiLCJwYXJlbnRJZCIsIm5ld1N0eWxlcyIsIm1lZGlhIiwicGFydCJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBMkMsY0FBYzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQ2hFQTs7OztBQUVBLElBQUlBLE9BQU8sbUJBQUFDLENBQVEsRUFBUixDQUFYO0FBQ0EsSUFBSUMsV0FBVyxtQkFBQUQsQ0FBUSxFQUFSLENBQWY7O0FBRUE7O0FBRUE7O0FBRUEsSUFBSUUsV0FBV0MsT0FBT0MsU0FBUCxDQUFpQkYsUUFBaEM7O0FBRUE7Ozs7OztBQU1BLFNBQVNHLE9BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCO0FBQ3BCLFNBQU9KLFNBQVNLLElBQVQsQ0FBY0QsR0FBZCxNQUF1QixnQkFBOUI7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU0UsYUFBVCxDQUF1QkYsR0FBdkIsRUFBNEI7QUFDMUIsU0FBT0osU0FBU0ssSUFBVCxDQUFjRCxHQUFkLE1BQXVCLHNCQUE5QjtBQUNEOztBQUVEOzs7Ozs7QUFNQSxTQUFTRyxVQUFULENBQW9CSCxHQUFwQixFQUF5QjtBQUN2QixTQUFRLE9BQU9JLFFBQVAsS0FBb0IsV0FBckIsSUFBc0NKLGVBQWVJLFFBQTVEO0FBQ0Q7O0FBRUQ7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF1SDtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBOEw7QUFDOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF1SDtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBOEw7QUFDOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF1SDtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBOEw7QUFDOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF1SDtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7Ozs7OztBQ3JDQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUMsK0JBQStCLGFBQWEsMEJBQTBCO0FBQ3ZFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsYUFBYSxhQUFhLDBCQUEwQjtBQUNyRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7QUMvQkEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7QUNuT0EsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsK0JBQStCLGFBQWEsMEJBQTBCO0FBQ3ZFO0FBQ0EsQ0FBQyxhQUFhLGFBQWEsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxhQUFhLGFBQWEsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7OztBQ3JKQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7QUNiQSxnQkFBZ0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQywrQkFBK0IsYUFBYSwwQkFBMEI7QUFDdkU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDLGFBQWEsYUFBYSwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDLGFBQWEsYUFBYSwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7O0FDakxBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSSxtRkFBbUY7QUFDdk4sNklBQTZJLG1GQUFtRjtBQUNoTztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEMiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1OCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZWFiZjBhZjBkMGNmZWE5MmIyZjYiLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgIWlzQXJyYXkob2JqKSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi91dGlscy5qcyIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19yb290LmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2lzQXJyYXkuanMiLCIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gdGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxuICAgIHZhciBleGlzdGluZyA9IGZ1bmN0aW9uYWxcbiAgICAgID8gb3B0aW9ucy5yZW5kZXJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICBpZiAoIWZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBleGlzdGluZyhoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgTW9kaWZpZWQgYnkgRXZhbiBZb3UgQHl5eDk5MDgwM1xuKi9cblxudmFyIGhhc0RvY3VtZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuXG5pZiAodHlwZW9mIERFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBERUJVRykge1xuICBpZiAoIWhhc0RvY3VtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2dWUtc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuICcgK1xuICAgIFwiVXNlIHsgdGFyZ2V0OiAnbm9kZScgfSBpbiB5b3VyIFdlYnBhY2sgY29uZmlnIHRvIGluZGljYXRlIGEgc2VydmVyLXJlbmRlcmluZyBlbnZpcm9ubWVudC5cIlxuICApIH1cbn1cblxudmFyIGxpc3RUb1N0eWxlcyA9IHJlcXVpcmUoJy4vbGlzdFRvU3R5bGVzJylcblxuLypcbnR5cGUgU3R5bGVPYmplY3QgPSB7XG4gIGlkOiBudW1iZXI7XG4gIHBhcnRzOiBBcnJheTxTdHlsZU9iamVjdFBhcnQ+XG59XG5cbnR5cGUgU3R5bGVPYmplY3RQYXJ0ID0ge1xuICBjc3M6IHN0cmluZztcbiAgbWVkaWE6IHN0cmluZztcbiAgc291cmNlTWFwOiA/c3RyaW5nXG59XG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7LypcbiAgW2lkOiBudW1iZXJdOiB7XG4gICAgaWQ6IG51bWJlcixcbiAgICByZWZzOiBudW1iZXIsXG4gICAgcGFydHM6IEFycmF5PChvYmo/OiBTdHlsZU9iamVjdFBhcnQpID0+IHZvaWQ+XG4gIH1cbiovfVxuXG52YXIgaGVhZCA9IGhhc0RvY3VtZW50ICYmIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pXG52YXIgc2luZ2xldG9uRWxlbWVudCA9IG51bGxcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMFxudmFyIGlzUHJvZHVjdGlvbiA9IGZhbHNlXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbi8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxudmFyIGlzT2xkSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvbXNpZSBbNi05XVxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uKSB7XG4gIGlzUHJvZHVjdGlvbiA9IF9pc1Byb2R1Y3Rpb25cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBsaXN0KVxuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICAgIGRvbVN0eWxlLnJlZnMtLVxuICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpXG4gICAgfVxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIG5ld0xpc3QpXG4gICAgICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcyA9IFtdXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV1cbiAgICAgIGlmIChkb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXSgpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzIC8qIEFycmF5PFN0eWxlT2JqZWN0PiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrK1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKVxuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMubGVuZ3RoID0gaXRlbS5wYXJ0cy5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW11cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7IGlkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHMgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKCkge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2NzcydcbiAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpXG4gIHJldHVybiBzdHlsZUVsZW1lbnRcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgdmFyIHVwZGF0ZSwgcmVtb3ZlXG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLXZ1ZS1zc3ItaWR+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9pbmRleC5qcyIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIi8qKlxuICogdnVleCB2Mi40LjFcbiAqIChjKSAyMDE3IEV2YW4gWW91XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xudmFyIGFwcGx5TWl4aW4gPSBmdW5jdGlvbiAoVnVlKSB7XG4gIHZhciB2ZXJzaW9uID0gTnVtYmVyKFZ1ZS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pO1xuXG4gIGlmICh2ZXJzaW9uID49IDIpIHtcbiAgICBWdWUubWl4aW4oeyBiZWZvcmVDcmVhdGU6IHZ1ZXhJbml0IH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG92ZXJyaWRlIGluaXQgYW5kIGluamVjdCB2dWV4IGluaXQgcHJvY2VkdXJlXG4gICAgLy8gZm9yIDEueCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICB2YXIgX2luaXQgPSBWdWUucHJvdG90eXBlLl9pbml0O1xuICAgIFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgICAgIG9wdGlvbnMuaW5pdCA9IG9wdGlvbnMuaW5pdFxuICAgICAgICA/IFt2dWV4SW5pdF0uY29uY2F0KG9wdGlvbnMuaW5pdClcbiAgICAgICAgOiB2dWV4SW5pdDtcbiAgICAgIF9pbml0LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWdWV4IGluaXQgaG9vaywgaW5qZWN0ZWQgaW50byBlYWNoIGluc3RhbmNlcyBpbml0IGhvb2tzIGxpc3QuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHZ1ZXhJbml0ICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgLy8gc3RvcmUgaW5qZWN0aW9uXG4gICAgaWYgKG9wdGlvbnMuc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gdHlwZW9mIG9wdGlvbnMuc3RvcmUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBvcHRpb25zLnN0b3JlKClcbiAgICAgICAgOiBvcHRpb25zLnN0b3JlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wYXJlbnQgJiYgb3B0aW9ucy5wYXJlbnQuJHN0b3JlKSB7XG4gICAgICB0aGlzLiRzdG9yZSA9IG9wdGlvbnMucGFyZW50LiRzdG9yZTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkZXZ0b29sSG9vayA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG5mdW5jdGlvbiBkZXZ0b29sUGx1Z2luIChzdG9yZSkge1xuICBpZiAoIWRldnRvb2xIb29rKSB7IHJldHVybiB9XG5cbiAgc3RvcmUuX2RldnRvb2xIb29rID0gZGV2dG9vbEhvb2s7XG5cbiAgZGV2dG9vbEhvb2suZW1pdCgndnVleDppbml0Jywgc3RvcmUpO1xuXG4gIGRldnRvb2xIb29rLm9uKCd2dWV4OnRyYXZlbC10by1zdGF0ZScsIGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuICAgIHN0b3JlLnJlcGxhY2VTdGF0ZSh0YXJnZXRTdGF0ZSk7XG4gIH0pO1xuXG4gIHN0b3JlLnN1YnNjcmliZShmdW5jdGlvbiAobXV0YXRpb24sIHN0YXRlKSB7XG4gICAgZGV2dG9vbEhvb2suZW1pdCgndnVleDptdXRhdGlvbicsIG11dGF0aW9uLCBzdGF0ZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZmlyc3QgaXRlbSB0aGF0IHBhc3MgdGhlIHRlc3RcbiAqIGJ5IHNlY29uZCBhcmd1bWVudCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEByZXR1cm4geyp9XG4gKi9cbi8qKlxuICogRGVlcCBjb3B5IHRoZSBnaXZlbiBvYmplY3QgY29uc2lkZXJpbmcgY2lyY3VsYXIgc3RydWN0dXJlLlxuICogVGhpcyBmdW5jdGlvbiBjYWNoZXMgYWxsIG5lc3RlZCBvYmplY3RzIGFuZCBpdHMgY29waWVzLlxuICogSWYgaXQgZGV0ZWN0cyBjaXJjdWxhciBzdHJ1Y3R1cmUsIHVzZSBjYWNoZWQgY29weSB0byBhdm9pZCBpbmZpbml0ZSBsb29wLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGNhY2hlXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cblxuLyoqXG4gKiBmb3JFYWNoIGZvciBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZm9yRWFjaFZhbHVlIChvYmosIGZuKSB7XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihvYmpba2V5XSwga2V5KTsgfSk7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICByZXR1cm4gdmFsICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbXNnKSB7XG4gIGlmICghY29uZGl0aW9uKSB7IHRocm93IG5ldyBFcnJvcigoXCJbdnVleF0gXCIgKyBtc2cpKSB9XG59XG5cbnZhciBNb2R1bGUgPSBmdW5jdGlvbiBNb2R1bGUgKHJhd01vZHVsZSwgcnVudGltZSkge1xuICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lO1xuICB0aGlzLl9jaGlsZHJlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRoaXMuX3Jhd01vZHVsZSA9IHJhd01vZHVsZTtcbiAgdmFyIHJhd1N0YXRlID0gcmF3TW9kdWxlLnN0YXRlO1xuICB0aGlzLnN0YXRlID0gKHR5cGVvZiByYXdTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IHJhd1N0YXRlKCkgOiByYXdTdGF0ZSkgfHwge307XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzJDEgPSB7IG5hbWVzcGFjZWQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEubmFtZXNwYWNlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIXRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKGtleSwgbW9kdWxlKSB7XG4gIHRoaXMuX2NoaWxkcmVuW2tleV0gPSBtb2R1bGU7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGtleSkge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5ba2V5XTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiBnZXRDaGlsZCAoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAocmF3TW9kdWxlKSB7XG4gIHRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkID0gcmF3TW9kdWxlLm5hbWVzcGFjZWQ7XG4gIGlmIChyYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zID0gcmF3TW9kdWxlLmFjdGlvbnM7XG4gIH1cbiAgaWYgKHJhd01vZHVsZS5tdXRhdGlvbnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zID0gcmF3TW9kdWxlLm11dGF0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycyA9IHJhd01vZHVsZS5nZXR0ZXJzO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIGZvckVhY2hDaGlsZCAoZm4pIHtcbiAgZm9yRWFjaFZhbHVlKHRoaXMuX2NoaWxkcmVuLCBmbik7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hHZXR0ZXIgPSBmdW5jdGlvbiBmb3JFYWNoR2V0dGVyIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoQWN0aW9uID0gZnVuY3Rpb24gZm9yRWFjaEFjdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zLCBmbik7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaE11dGF0aW9uID0gZnVuY3Rpb24gZm9yRWFjaE11dGF0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zLCBmbik7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNb2R1bGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG52YXIgTW9kdWxlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIE1vZHVsZUNvbGxlY3Rpb24gKHJhd1Jvb3RNb2R1bGUpIHtcbiAgLy8gcmVnaXN0ZXIgcm9vdCBtb2R1bGUgKFZ1ZXguU3RvcmUgb3B0aW9ucylcbiAgdGhpcy5yZWdpc3RlcihbXSwgcmF3Um9vdE1vZHVsZSwgZmFsc2UpO1xufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAobW9kdWxlLCBrZXkpIHtcbiAgICByZXR1cm4gbW9kdWxlLmdldENoaWxkKGtleSlcbiAgfSwgdGhpcy5yb290KVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24gZ2V0TmFtZXNwYWNlIChwYXRoKSB7XG4gIHZhciBtb2R1bGUgPSB0aGlzLnJvb3Q7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBrZXkpIHtcbiAgICBtb2R1bGUgPSBtb2R1bGUuZ2V0Q2hpbGQoa2V5KTtcbiAgICByZXR1cm4gbmFtZXNwYWNlICsgKG1vZHVsZS5uYW1lc3BhY2VkID8ga2V5ICsgJy8nIDogJycpXG4gIH0sICcnKVxufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlJDEgKHJhd1Jvb3RNb2R1bGUpIHtcbiAgdXBkYXRlKFtdLCB0aGlzLnJvb3QsIHJhd1Jvb3RNb2R1bGUpO1xufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlciAocGF0aCwgcmF3TW9kdWxlLCBydW50aW1lKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgaWYgKCBydW50aW1lID09PSB2b2lkIDAgKSBydW50aW1lID0gdHJ1ZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFJhd01vZHVsZShwYXRoLCByYXdNb2R1bGUpO1xuICB9XG5cbiAgdmFyIG5ld01vZHVsZSA9IG5ldyBNb2R1bGUocmF3TW9kdWxlLCBydW50aW1lKTtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5yb290ID0gbmV3TW9kdWxlO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgcGFyZW50LmFkZENoaWxkKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgbmV3TW9kdWxlKTtcbiAgfVxuXG4gIC8vIHJlZ2lzdGVyIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvckVhY2hWYWx1ZShyYXdNb2R1bGUubW9kdWxlcywgZnVuY3Rpb24gKHJhd0NoaWxkTW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3RlcihwYXRoLmNvbmNhdChrZXkpLCByYXdDaGlsZE1vZHVsZSwgcnVudGltZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyIChwYXRoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGlmICghcGFyZW50LmdldENoaWxkKGtleSkucnVudGltZSkgeyByZXR1cm4gfVxuXG4gIHBhcmVudC5yZW1vdmVDaGlsZChrZXkpO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlIChwYXRoLCB0YXJnZXRNb2R1bGUsIG5ld01vZHVsZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFJhd01vZHVsZShwYXRoLCBuZXdNb2R1bGUpO1xuICB9XG5cbiAgLy8gdXBkYXRlIHRhcmdldCBtb2R1bGVcbiAgdGFyZ2V0TW9kdWxlLnVwZGF0ZShuZXdNb2R1bGUpO1xuXG4gIC8vIHVwZGF0ZSBuZXN0ZWQgbW9kdWxlc1xuICBpZiAobmV3TW9kdWxlLm1vZHVsZXMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmV3TW9kdWxlLm1vZHVsZXMpIHtcbiAgICAgIGlmICghdGFyZ2V0TW9kdWxlLmdldENoaWxkKGtleSkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIlt2dWV4XSB0cnlpbmcgdG8gYWRkIGEgbmV3IG1vZHVsZSAnXCIgKyBrZXkgKyBcIicgb24gaG90IHJlbG9hZGluZywgXCIgK1xuICAgICAgICAgICAgJ21hbnVhbCByZWxvYWQgaXMgbmVlZGVkJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUoXG4gICAgICAgIHBhdGguY29uY2F0KGtleSksXG4gICAgICAgIHRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpLFxuICAgICAgICBuZXdNb2R1bGUubW9kdWxlc1trZXldXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSYXdNb2R1bGUgKHBhdGgsIHJhd01vZHVsZSkge1xuICBbJ2dldHRlcnMnLCAnYWN0aW9ucycsICdtdXRhdGlvbnMnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIXJhd01vZHVsZVtrZXldKSB7IHJldHVybiB9XG5cbiAgICBmb3JFYWNoVmFsdWUocmF3TW9kdWxlW2tleV0sIGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicsXG4gICAgICAgIG1ha2VBc3NlcnRpb25NZXNzYWdlKHBhdGgsIGtleSwgdHlwZSwgdmFsdWUpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFrZUFzc2VydGlvbk1lc3NhZ2UgKHBhdGgsIGtleSwgdHlwZSwgdmFsdWUpIHtcbiAgdmFyIGJ1ZiA9IGtleSArIFwiIHNob3VsZCBiZSBmdW5jdGlvbiBidXQgXFxcIlwiICsga2V5ICsgXCIuXCIgKyB0eXBlICsgXCJcXFwiXCI7XG4gIGlmIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICBidWYgKz0gXCIgaW4gbW9kdWxlIFxcXCJcIiArIChwYXRoLmpvaW4oJy4nKSkgKyBcIlxcXCJcIjtcbiAgfVxuICBidWYgKz0gXCIgaXMgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsdWUpKSArIFwiLlwiO1xuXG4gIHJldHVybiBidWZcbn1cblxudmFyIFZ1ZTsgLy8gYmluZCBvbiBpbnN0YWxsXG5cbnZhciBTdG9yZSA9IGZ1bmN0aW9uIFN0b3JlIChvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICAvLyBBdXRvIGluc3RhbGwgaWYgaXQgaXMgbm90IGRvbmUgeWV0IGFuZCBgd2luZG93YCBoYXMgYFZ1ZWAuXG4gIC8vIFRvIGFsbG93IHVzZXJzIHRvIGF2b2lkIGF1dG8taW5zdGFsbGF0aW9uIGluIHNvbWUgY2FzZXMsXG4gIC8vIHRoaXMgY29kZSBzaG91bGQgYmUgcGxhY2VkIGhlcmUuIFNlZSAjNzMxXG4gIGlmICghVnVlICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5WdWUpIHtcbiAgICBpbnN0YWxsKHdpbmRvdy5WdWUpO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQoVnVlLCBcIm11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLlwiKTtcbiAgICBhc3NlcnQodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnLCBcInZ1ZXggcmVxdWlyZXMgYSBQcm9taXNlIHBvbHlmaWxsIGluIHRoaXMgYnJvd3Nlci5cIik7XG4gICAgYXNzZXJ0KHRoaXMgaW5zdGFuY2VvZiBTdG9yZSwgXCJTdG9yZSBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3IuXCIpO1xuICB9XG5cbiAgdmFyIHBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7IGlmICggcGx1Z2lucyA9PT0gdm9pZCAwICkgcGx1Z2lucyA9IFtdO1xuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7IGlmICggc3RyaWN0ID09PSB2b2lkIDAgKSBzdHJpY3QgPSBmYWxzZTtcblxuICB2YXIgc3RhdGUgPSBvcHRpb25zLnN0YXRlOyBpZiAoIHN0YXRlID09PSB2b2lkIDAgKSBzdGF0ZSA9IHt9O1xuICBpZiAodHlwZW9mIHN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc3RhdGUgPSBzdGF0ZSgpO1xuICB9XG5cbiAgLy8gc3RvcmUgaW50ZXJuYWwgc3RhdGVcbiAgdGhpcy5fY29tbWl0dGluZyA9IGZhbHNlO1xuICB0aGlzLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fbXV0YXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9tb2R1bGVzID0gbmV3IE1vZHVsZUNvbGxlY3Rpb24ob3B0aW9ucyk7XG4gIHRoaXMuX21vZHVsZXNOYW1lc3BhY2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuICB0aGlzLl93YXRjaGVyVk0gPSBuZXcgVnVlKCk7XG5cbiAgLy8gYmluZCBjb21taXQgYW5kIGRpc3BhdGNoIHRvIHNlbGZcbiAgdmFyIHN0b3JlID0gdGhpcztcbiAgdmFyIHJlZiA9IHRoaXM7XG4gIHZhciBkaXNwYXRjaCA9IHJlZi5kaXNwYXRjaDtcbiAgdmFyIGNvbW1pdCA9IHJlZi5jb21taXQ7XG4gIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiBib3VuZERpc3BhdGNoICh0eXBlLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoLmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQpXG4gIH07XG4gIHRoaXMuY29tbWl0ID0gZnVuY3Rpb24gYm91bmRDb21taXQgKHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29tbWl0LmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpXG4gIH07XG5cbiAgLy8gc3RyaWN0IG1vZGVcbiAgdGhpcy5zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgLy8gaW5pdCByb290IG1vZHVsZS5cbiAgLy8gdGhpcyBhbHNvIHJlY3Vyc2l2ZWx5IHJlZ2lzdGVycyBhbGwgc3ViLW1vZHVsZXNcbiAgLy8gYW5kIGNvbGxlY3RzIGFsbCBtb2R1bGUgZ2V0dGVycyBpbnNpZGUgdGhpcy5fd3JhcHBlZEdldHRlcnNcbiAgaW5zdGFsbE1vZHVsZSh0aGlzLCBzdGF0ZSwgW10sIHRoaXMuX21vZHVsZXMucm9vdCk7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgc3RvcmUgdm0sIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgcmVhY3Rpdml0eVxuICAvLyAoYWxzbyByZWdpc3RlcnMgX3dyYXBwZWRHZXR0ZXJzIGFzIGNvbXB1dGVkIHByb3BlcnRpZXMpXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCBzdGF0ZSk7XG5cbiAgLy8gYXBwbHkgcGx1Z2luc1xuICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikgeyByZXR1cm4gcGx1Z2luKHRoaXMkMSk7IH0pO1xuXG4gIGlmIChWdWUuY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbFBsdWdpbih0aGlzKTtcbiAgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgc3RhdGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnN0YXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ZtLl9kYXRhLiQkc3RhdGVcbn07XG5cbnByb3RvdHlwZUFjY2Vzc29ycy5zdGF0ZS5zZXQgPSBmdW5jdGlvbiAodikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChmYWxzZSwgXCJVc2Ugc3RvcmUucmVwbGFjZVN0YXRlKCkgdG8gZXhwbGljaXQgcmVwbGFjZSBzdG9yZSBzdGF0ZS5cIik7XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiBjb21taXQgKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAvLyBjaGVjayBvYmplY3Qtc3R5bGUgY29tbWl0XG4gIHZhciByZWYgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcbiAgICB2YXIgb3B0aW9ucyA9IHJlZi5vcHRpb25zO1xuXG4gIHZhciBtdXRhdGlvbiA9IHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCB9O1xuICB2YXIgZW50cnkgPSB0aGlzLl9tdXRhdGlvbnNbdHlwZV07XG4gIGlmICghZW50cnkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgZW50cnkuZm9yRWFjaChmdW5jdGlvbiBjb21taXRJdGVyYXRvciAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcihwYXlsb2FkKTtcbiAgICB9KTtcbiAgfSk7XG4gIHRoaXMuX3N1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gc3ViKG11dGF0aW9uLCB0aGlzJDEuc3RhdGUpOyB9KTtcblxuICBpZiAoXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5zaWxlbnRcbiAgKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbdnVleF0gbXV0YXRpb24gdHlwZTogXCIgKyB0eXBlICsgXCIuIFNpbGVudCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gXCIgK1xuICAgICAgJ1VzZSB0aGUgZmlsdGVyIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIHZ1ZS1kZXZ0b29scydcbiAgICApO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAoX3R5cGUsIF9wYXlsb2FkKSB7XG4gIC8vIGNoZWNrIG9iamVjdC1zdHlsZSBkaXNwYXRjaFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcblxuICB2YXIgZW50cnkgPSB0aGlzLl9hY3Rpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIHVua25vd24gYWN0aW9uIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gZW50cnkubGVuZ3RoID4gMVxuICAgID8gUHJvbWlzZS5hbGwoZW50cnkubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKHBheWxvYWQpOyB9KSlcbiAgICA6IGVudHJ5WzBdKHBheWxvYWQpXG59O1xuXG5TdG9yZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlIChmbikge1xuICB2YXIgc3VicyA9IHRoaXMuX3N1YnNjcmliZXJzO1xuICBpZiAoc3Vicy5pbmRleE9mKGZuKSA8IDApIHtcbiAgICBzdWJzLnB1c2goZm4pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSBzdWJzLmluZGV4T2YoZm4pO1xuICAgIGlmIChpID4gLTEpIHtcbiAgICAgIHN1YnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufTtcblxuU3RvcmUucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gd2F0Y2ggKGdldHRlciwgY2IsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydCh0eXBlb2YgZ2V0dGVyID09PSAnZnVuY3Rpb24nLCBcInN0b3JlLndhdGNoIG9ubHkgYWNjZXB0cyBhIGZ1bmN0aW9uLlwiKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fd2F0Y2hlclZNLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBnZXR0ZXIodGhpcyQxLnN0YXRlLCB0aGlzJDEuZ2V0dGVycyk7IH0sIGNiLCBvcHRpb25zKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAoc3RhdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEuX3ZtLl9kYXRhLiQkc3RhdGUgPSBzdGF0ZTtcbiAgfSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiByZWdpc3Rlck1vZHVsZSAocGF0aCwgcmF3TW9kdWxlKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocGF0aCksIFwibW9kdWxlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBhbiBBcnJheS5cIik7XG4gICAgYXNzZXJ0KHBhdGgubGVuZ3RoID4gMCwgJ2Nhbm5vdCByZWdpc3RlciB0aGUgcm9vdCBtb2R1bGUgYnkgdXNpbmcgcmVnaXN0ZXJNb2R1bGUuJyk7XG4gIH1cblxuICB0aGlzLl9tb2R1bGVzLnJlZ2lzdGVyKHBhdGgsIHJhd01vZHVsZSk7XG4gIGluc3RhbGxNb2R1bGUodGhpcywgdGhpcy5zdGF0ZSwgcGF0aCwgdGhpcy5fbW9kdWxlcy5nZXQocGF0aCkpO1xuICAvLyByZXNldCBzdG9yZSB0byB1cGRhdGUgZ2V0dGVycy4uLlxuICByZXNldFN0b3JlVk0odGhpcywgdGhpcy5zdGF0ZSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUudW5yZWdpc3Rlck1vZHVsZSA9IGZ1bmN0aW9uIHVucmVnaXN0ZXJNb2R1bGUgKHBhdGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7IHBhdGggPSBbcGF0aF07IH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgdGhpcy5fbW9kdWxlcy51bnJlZ2lzdGVyKHBhdGgpO1xuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50U3RhdGUgPSBnZXROZXN0ZWRTdGF0ZSh0aGlzJDEuc3RhdGUsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBWdWUuZGVsZXRlKHBhcmVudFN0YXRlLCBwYXRoW3BhdGgubGVuZ3RoIC0gMV0pO1xuICB9KTtcbiAgcmVzZXRTdG9yZSh0aGlzKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5ob3RVcGRhdGUgPSBmdW5jdGlvbiBob3RVcGRhdGUgKG5ld09wdGlvbnMpIHtcbiAgdGhpcy5fbW9kdWxlcy51cGRhdGUobmV3T3B0aW9ucyk7XG4gIHJlc2V0U3RvcmUodGhpcywgdHJ1ZSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuX3dpdGhDb21taXQgPSBmdW5jdGlvbiBfd2l0aENvbW1pdCAoZm4pIHtcbiAgdmFyIGNvbW1pdHRpbmcgPSB0aGlzLl9jb21taXR0aW5nO1xuICB0aGlzLl9jb21taXR0aW5nID0gdHJ1ZTtcbiAgZm4oKTtcbiAgdGhpcy5fY29tbWl0dGluZyA9IGNvbW1pdHRpbmc7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggU3RvcmUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gcmVzZXRTdG9yZSAoc3RvcmUsIGhvdCkge1xuICBzdG9yZS5fYWN0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tdXRhdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdG9yZS5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzdG9yZS5fbW9kdWxlc05hbWVzcGFjZU1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBzdGF0ZSA9IHN0b3JlLnN0YXRlO1xuICAvLyBpbml0IGFsbCBtb2R1bGVzXG4gIGluc3RhbGxNb2R1bGUoc3RvcmUsIHN0YXRlLCBbXSwgc3RvcmUuX21vZHVsZXMucm9vdCwgdHJ1ZSk7XG4gIC8vIHJlc2V0IHZtXG4gIHJlc2V0U3RvcmVWTShzdG9yZSwgc3RhdGUsIGhvdCk7XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3RvcmVWTSAoc3RvcmUsIHN0YXRlLCBob3QpIHtcbiAgdmFyIG9sZFZtID0gc3RvcmUuX3ZtO1xuXG4gIC8vIGJpbmQgc3RvcmUgcHVibGljIGdldHRlcnNcbiAgc3RvcmUuZ2V0dGVycyA9IHt9O1xuICB2YXIgd3JhcHBlZEdldHRlcnMgPSBzdG9yZS5fd3JhcHBlZEdldHRlcnM7XG4gIHZhciBjb21wdXRlZCA9IHt9O1xuICBmb3JFYWNoVmFsdWUod3JhcHBlZEdldHRlcnMsIGZ1bmN0aW9uIChmbiwga2V5KSB7XG4gICAgLy8gdXNlIGNvbXB1dGVkIHRvIGxldmVyYWdlIGl0cyBsYXp5LWNhY2hpbmcgbWVjaGFuaXNtXG4gICAgY29tcHV0ZWRba2V5XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZuKHN0b3JlKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RvcmUuZ2V0dGVycywga2V5LCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLl92bVtrZXldOyB9LFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSAvLyBmb3IgbG9jYWwgZ2V0dGVyc1xuICAgIH0pO1xuICB9KTtcblxuICAvLyB1c2UgYSBWdWUgaW5zdGFuY2UgdG8gc3RvcmUgdGhlIHN0YXRlIHRyZWVcbiAgLy8gc3VwcHJlc3Mgd2FybmluZ3MganVzdCBpbiBjYXNlIHRoZSB1c2VyIGhhcyBhZGRlZFxuICAvLyBzb21lIGZ1bmt5IGdsb2JhbCBtaXhpbnNcbiAgdmFyIHNpbGVudCA9IFZ1ZS5jb25maWcuc2lsZW50O1xuICBWdWUuY29uZmlnLnNpbGVudCA9IHRydWU7XG4gIHN0b3JlLl92bSA9IG5ldyBWdWUoe1xuICAgIGRhdGE6IHtcbiAgICAgICQkc3RhdGU6IHN0YXRlXG4gICAgfSxcbiAgICBjb21wdXRlZDogY29tcHV0ZWRcbiAgfSk7XG4gIFZ1ZS5jb25maWcuc2lsZW50ID0gc2lsZW50O1xuXG4gIC8vIGVuYWJsZSBzdHJpY3QgbW9kZSBmb3IgbmV3IHZtXG4gIGlmIChzdG9yZS5zdHJpY3QpIHtcbiAgICBlbmFibGVTdHJpY3RNb2RlKHN0b3JlKTtcbiAgfVxuXG4gIGlmIChvbGRWbSkge1xuICAgIGlmIChob3QpIHtcbiAgICAgIC8vIGRpc3BhdGNoIGNoYW5nZXMgaW4gYWxsIHN1YnNjcmliZWQgd2F0Y2hlcnNcbiAgICAgIC8vIHRvIGZvcmNlIGdldHRlciByZS1ldmFsdWF0aW9uIGZvciBob3QgcmVsb2FkaW5nLlxuICAgICAgc3RvcmUuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBvbGRWbS5fZGF0YS4kJHN0YXRlID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBWdWUubmV4dFRpY2soZnVuY3Rpb24gKCkgeyByZXR1cm4gb2xkVm0uJGRlc3Ryb3koKTsgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFsbE1vZHVsZSAoc3RvcmUsIHJvb3RTdGF0ZSwgcGF0aCwgbW9kdWxlLCBob3QpIHtcbiAgdmFyIGlzUm9vdCA9ICFwYXRoLmxlbmd0aDtcbiAgdmFyIG5hbWVzcGFjZSA9IHN0b3JlLl9tb2R1bGVzLmdldE5hbWVzcGFjZShwYXRoKTtcblxuICAvLyByZWdpc3RlciBpbiBuYW1lc3BhY2UgbWFwXG4gIGlmIChtb2R1bGUubmFtZXNwYWNlZCkge1xuICAgIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV0gPSBtb2R1bGU7XG4gIH1cblxuICAvLyBzZXQgc3RhdGVcbiAgaWYgKCFpc1Jvb3QgJiYgIWhvdCkge1xuICAgIHZhciBwYXJlbnRTdGF0ZSA9IGdldE5lc3RlZFN0YXRlKHJvb3RTdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIHZhciBtb2R1bGVOYW1lID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHN0b3JlLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgIFZ1ZS5zZXQocGFyZW50U3RhdGUsIG1vZHVsZU5hbWUsIG1vZHVsZS5zdGF0ZSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgbG9jYWwgPSBtb2R1bGUuY29udGV4dCA9IG1ha2VMb2NhbENvbnRleHQoc3RvcmUsIG5hbWVzcGFjZSwgcGF0aCk7XG5cbiAgbW9kdWxlLmZvckVhY2hNdXRhdGlvbihmdW5jdGlvbiAobXV0YXRpb24sIGtleSkge1xuICAgIHZhciBuYW1lc3BhY2VkVHlwZSA9IG5hbWVzcGFjZSArIGtleTtcbiAgICByZWdpc3Rlck11dGF0aW9uKHN0b3JlLCBuYW1lc3BhY2VkVHlwZSwgbXV0YXRpb24sIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hBY3Rpb24oZnVuY3Rpb24gKGFjdGlvbiwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyQWN0aW9uKHN0b3JlLCBuYW1lc3BhY2VkVHlwZSwgYWN0aW9uLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoR2V0dGVyKGZ1bmN0aW9uIChnZXR0ZXIsIGtleSkge1xuICAgIHZhciBuYW1lc3BhY2VkVHlwZSA9IG5hbWVzcGFjZSArIGtleTtcbiAgICByZWdpc3RlckdldHRlcihzdG9yZSwgbmFtZXNwYWNlZFR5cGUsIGdldHRlciwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCwga2V5KSB7XG4gICAgaW5zdGFsbE1vZHVsZShzdG9yZSwgcm9vdFN0YXRlLCBwYXRoLmNvbmNhdChrZXkpLCBjaGlsZCwgaG90KTtcbiAgfSk7XG59XG5cbi8qKlxuICogbWFrZSBsb2NhbGl6ZWQgZGlzcGF0Y2gsIGNvbW1pdCwgZ2V0dGVycyBhbmQgc3RhdGVcbiAqIGlmIHRoZXJlIGlzIG5vIG5hbWVzcGFjZSwganVzdCB1c2Ugcm9vdCBvbmVzXG4gKi9cbmZ1bmN0aW9uIG1ha2VMb2NhbENvbnRleHQgKHN0b3JlLCBuYW1lc3BhY2UsIHBhdGgpIHtcbiAgdmFyIG5vTmFtZXNwYWNlID0gbmFtZXNwYWNlID09PSAnJztcblxuICB2YXIgbG9jYWwgPSB7XG4gICAgZGlzcGF0Y2g6IG5vTmFtZXNwYWNlID8gc3RvcmUuZGlzcGF0Y2ggOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0b3JlLl9hY3Rpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBhY3Rpb24gdHlwZTogXCIgKyAoYXJncy50eXBlKSArIFwiLCBnbG9iYWwgdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKHR5cGUsIHBheWxvYWQpXG4gICAgfSxcblxuICAgIGNvbW1pdDogbm9OYW1lc3BhY2UgPyBzdG9yZS5jb21taXQgOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIXN0b3JlLl9tdXRhdGlvbnNbdHlwZV0pIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGxvY2FsIG11dGF0aW9uIHR5cGU6IFwiICsgKGFyZ3MudHlwZSkgKyBcIiwgZ2xvYmFsIHR5cGU6IFwiICsgdHlwZSkpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0b3JlLmNvbW1pdCh0eXBlLCBwYXlsb2FkLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZ2V0dGVycyBhbmQgc3RhdGUgb2JqZWN0IG11c3QgYmUgZ290dGVuIGxhemlseVxuICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBjaGFuZ2VkIGJ5IHZtIHVwZGF0ZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsb2NhbCwge1xuICAgIGdldHRlcnM6IHtcbiAgICAgIGdldDogbm9OYW1lc3BhY2VcbiAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBzdG9yZS5nZXR0ZXJzOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZUxvY2FsR2V0dGVycyhzdG9yZSwgbmFtZXNwYWNlKTsgfVxuICAgIH0sXG4gICAgc3RhdGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0TmVzdGVkU3RhdGUoc3RvcmUuc3RhdGUsIHBhdGgpOyB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbG9jYWxcbn1cblxuZnVuY3Rpb24gbWFrZUxvY2FsR2V0dGVycyAoc3RvcmUsIG5hbWVzcGFjZSkge1xuICB2YXIgZ2V0dGVyc1Byb3h5ID0ge307XG5cbiAgdmFyIHNwbGl0UG9zID0gbmFtZXNwYWNlLmxlbmd0aDtcbiAgT2JqZWN0LmtleXMoc3RvcmUuZ2V0dGVycykuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIC8vIHNraXAgaWYgdGhlIHRhcmdldCBnZXR0ZXIgaXMgbm90IG1hdGNoIHRoaXMgbmFtZXNwYWNlXG4gICAgaWYgKHR5cGUuc2xpY2UoMCwgc3BsaXRQb3MpICE9PSBuYW1lc3BhY2UpIHsgcmV0dXJuIH1cblxuICAgIC8vIGV4dHJhY3QgbG9jYWwgZ2V0dGVyIHR5cGVcbiAgICB2YXIgbG9jYWxUeXBlID0gdHlwZS5zbGljZShzcGxpdFBvcyk7XG5cbiAgICAvLyBBZGQgYSBwb3J0IHRvIHRoZSBnZXR0ZXJzIHByb3h5LlxuICAgIC8vIERlZmluZSBhcyBnZXR0ZXIgcHJvcGVydHkgYmVjYXVzZVxuICAgIC8vIHdlIGRvIG5vdCB3YW50IHRvIGV2YWx1YXRlIHRoZSBnZXR0ZXJzIGluIHRoaXMgdGltZS5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0dGVyc1Byb3h5LCBsb2NhbFR5cGUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyc1t0eXBlXTsgfSxcbiAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGdldHRlcnNQcm94eVxufVxuXG5mdW5jdGlvbiByZWdpc3Rlck11dGF0aW9uIChzdG9yZSwgdHlwZSwgaGFuZGxlciwgbG9jYWwpIHtcbiAgdmFyIGVudHJ5ID0gc3RvcmUuX211dGF0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX211dGF0aW9uc1t0eXBlXSA9IFtdKTtcbiAgZW50cnkucHVzaChmdW5jdGlvbiB3cmFwcGVkTXV0YXRpb25IYW5kbGVyIChwYXlsb2FkKSB7XG4gICAgaGFuZGxlci5jYWxsKHN0b3JlLCBsb2NhbC5zdGF0ZSwgcGF5bG9hZCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckFjdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9hY3Rpb25zW3R5cGVdIHx8IChzdG9yZS5fYWN0aW9uc1t0eXBlXSA9IFtdKTtcbiAgZW50cnkucHVzaChmdW5jdGlvbiB3cmFwcGVkQWN0aW9uSGFuZGxlciAocGF5bG9hZCwgY2IpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5jYWxsKHN0b3JlLCB7XG4gICAgICBkaXNwYXRjaDogbG9jYWwuZGlzcGF0Y2gsXG4gICAgICBjb21taXQ6IGxvY2FsLmNvbW1pdCxcbiAgICAgIGdldHRlcnM6IGxvY2FsLmdldHRlcnMsXG4gICAgICBzdGF0ZTogbG9jYWwuc3RhdGUsXG4gICAgICByb290R2V0dGVyczogc3RvcmUuZ2V0dGVycyxcbiAgICAgIHJvb3RTdGF0ZTogc3RvcmUuc3RhdGVcbiAgICB9LCBwYXlsb2FkLCBjYik7XG4gICAgaWYgKCFpc1Byb21pc2UocmVzKSkge1xuICAgICAgcmVzID0gUHJvbWlzZS5yZXNvbHZlKHJlcyk7XG4gICAgfVxuICAgIGlmIChzdG9yZS5fZGV2dG9vbEhvb2spIHtcbiAgICAgIHJldHVybiByZXMuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBzdG9yZS5fZGV2dG9vbEhvb2suZW1pdCgndnVleDplcnJvcicsIGVycik7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyR2V0dGVyIChzdG9yZSwgdHlwZSwgcmF3R2V0dGVyLCBsb2NhbCkge1xuICBpZiAoc3RvcmUuX3dyYXBwZWRHZXR0ZXJzW3R5cGVdKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIGR1cGxpY2F0ZSBnZXR0ZXIga2V5OiBcIiArIHR5cGUpKTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgc3RvcmUuX3dyYXBwZWRHZXR0ZXJzW3R5cGVdID0gZnVuY3Rpb24gd3JhcHBlZEdldHRlciAoc3RvcmUpIHtcbiAgICByZXR1cm4gcmF3R2V0dGVyKFxuICAgICAgbG9jYWwuc3RhdGUsIC8vIGxvY2FsIHN0YXRlXG4gICAgICBsb2NhbC5nZXR0ZXJzLCAvLyBsb2NhbCBnZXR0ZXJzXG4gICAgICBzdG9yZS5zdGF0ZSwgLy8gcm9vdCBzdGF0ZVxuICAgICAgc3RvcmUuZ2V0dGVycyAvLyByb290IGdldHRlcnNcbiAgICApXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuYWJsZVN0cmljdE1vZGUgKHN0b3JlKSB7XG4gIHN0b3JlLl92bS4kd2F0Y2goZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YS4kJHN0YXRlIH0sIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0KHN0b3JlLl9jb21taXR0aW5nLCBcIkRvIG5vdCBtdXRhdGUgdnVleCBzdG9yZSBzdGF0ZSBvdXRzaWRlIG11dGF0aW9uIGhhbmRsZXJzLlwiKTtcbiAgICB9XG4gIH0sIHsgZGVlcDogdHJ1ZSwgc3luYzogdHJ1ZSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TmVzdGVkU3RhdGUgKHN0YXRlLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aFxuICAgID8gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlLCBrZXkpIHsgcmV0dXJuIHN0YXRlW2tleV07IH0sIHN0YXRlKVxuICAgIDogc3RhdGVcbn1cblxuZnVuY3Rpb24gdW5pZnlPYmplY3RTdHlsZSAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICBpZiAoaXNPYmplY3QodHlwZSkgJiYgdHlwZS50eXBlKSB7XG4gICAgb3B0aW9ucyA9IHBheWxvYWQ7XG4gICAgcGF5bG9hZCA9IHR5cGU7XG4gICAgdHlwZSA9IHR5cGUudHlwZTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJywgKFwiRXhwZWN0cyBzdHJpbmcgYXMgdGhlIHR5cGUsIGJ1dCBmb3VuZCBcIiArICh0eXBlb2YgdHlwZSkgKyBcIi5cIikpO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgcGF5bG9hZDogcGF5bG9hZCwgb3B0aW9uczogb3B0aW9ucyB9XG59XG5cbmZ1bmN0aW9uIGluc3RhbGwgKF9WdWUpIHtcbiAgaWYgKFZ1ZSAmJiBfVnVlID09PSBWdWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ1t2dWV4XSBhbHJlYWR5IGluc3RhbGxlZC4gVnVlLnVzZShWdWV4KSBzaG91bGQgYmUgY2FsbGVkIG9ubHkgb25jZS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuICBWdWUgPSBfVnVlO1xuICBhcHBseU1peGluKFZ1ZSk7XG59XG5cbnZhciBtYXBTdGF0ZSA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBzdGF0ZXMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoc3RhdGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkU3RhdGUgKCkge1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy4kc3RvcmUuc3RhdGU7XG4gICAgICB2YXIgZ2V0dGVycyA9IHRoaXMuJHN0b3JlLmdldHRlcnM7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcFN0YXRlJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IG1vZHVsZS5jb250ZXh0LnN0YXRlO1xuICAgICAgICBnZXR0ZXJzID0gbW9kdWxlLmNvbnRleHQuZ2V0dGVycztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdmFsLmNhbGwodGhpcywgc3RhdGUsIGdldHRlcnMpXG4gICAgICAgIDogc3RhdGVbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwTXV0YXRpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIG11dGF0aW9ucykge1xuICB2YXIgcmVzID0ge307XG4gIG5vcm1hbGl6ZU1hcChtdXRhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgcmVzW2tleV0gPSBmdW5jdGlvbiBtYXBwZWRNdXRhdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgdmFyIGNvbW1pdCA9IHRoaXMuJHN0b3JlLmNvbW1pdDtcbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgdmFyIG1vZHVsZSA9IGdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwTXV0YXRpb25zJywgbmFtZXNwYWNlKTtcbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjb21taXQgPSBtb2R1bGUuY29udGV4dC5jb21taXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5hcHBseSh0aGlzLCBbY29tbWl0XS5jb25jYXQoYXJncykpXG4gICAgICAgIDogY29tbWl0LmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwR2V0dGVycyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBnZXR0ZXJzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkR2V0dGVyICgpIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwR2V0dGVycycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhKHZhbCBpbiB0aGlzLiRzdG9yZS5nZXR0ZXJzKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSB1bmtub3duIGdldHRlcjogXCIgKyB2YWwpKTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1t2YWxdXG4gICAgfTtcbiAgICAvLyBtYXJrIHZ1ZXggZ2V0dGVyIGZvciBkZXZ0b29sc1xuICAgIHJlc1trZXldLnZ1ZXggPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbnZhciBtYXBBY3Rpb25zID0gbm9ybWFsaXplTmFtZXNwYWNlKGZ1bmN0aW9uIChuYW1lc3BhY2UsIGFjdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAoYWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZEFjdGlvbiAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgdmFyIGRpc3BhdGNoID0gdGhpcy4kc3RvcmUuZGlzcGF0Y2g7XG4gICAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcEFjdGlvbnMnLCBuYW1lc3BhY2UpO1xuICAgICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoID0gbW9kdWxlLmNvbnRleHQuZGlzcGF0Y2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5hcHBseSh0aGlzLCBbZGlzcGF0Y2hdLmNvbmNhdChhcmdzKSlcbiAgICAgICAgOiBkaXNwYXRjaC5hcHBseSh0aGlzLiRzdG9yZSwgW3ZhbF0uY29uY2F0KGFyZ3MpKVxuICAgIH07XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxudmFyIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSkgeyByZXR1cm4gKHtcbiAgbWFwU3RhdGU6IG1hcFN0YXRlLmJpbmQobnVsbCwgbmFtZXNwYWNlKSxcbiAgbWFwR2V0dGVyczogbWFwR2V0dGVycy5iaW5kKG51bGwsIG5hbWVzcGFjZSksXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLmJpbmQobnVsbCwgbmFtZXNwYWNlKSxcbiAgbWFwQWN0aW9uczogbWFwQWN0aW9ucy5iaW5kKG51bGwsIG5hbWVzcGFjZSlcbn0pOyB9O1xuXG5mdW5jdGlvbiBub3JtYWxpemVNYXAgKG1hcCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXApXG4gICAgPyBtYXAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IGtleSB9KTsgfSlcbiAgICA6IE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IG1hcFtrZXldIH0pOyB9KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lc3BhY2UgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZXNwYWNlLCBtYXApIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG1hcCA9IG5hbWVzcGFjZTtcbiAgICAgIG5hbWVzcGFjZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlLmNoYXJBdChuYW1lc3BhY2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgbmFtZXNwYWNlICs9ICcvJztcbiAgICB9XG4gICAgcmV0dXJuIGZuKG5hbWVzcGFjZSwgbWFwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZUJ5TmFtZXNwYWNlIChzdG9yZSwgaGVscGVyLCBuYW1lc3BhY2UpIHtcbiAgdmFyIG1vZHVsZSA9IHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFtb2R1bGUpIHtcbiAgICBjb25zb2xlLmVycm9yKChcIlt2dWV4XSBtb2R1bGUgbmFtZXNwYWNlIG5vdCBmb3VuZCBpbiBcIiArIGhlbHBlciArIFwiKCk6IFwiICsgbmFtZXNwYWNlKSk7XG4gIH1cbiAgcmV0dXJuIG1vZHVsZVxufVxuXG52YXIgaW5kZXhfZXNtID0ge1xuICBTdG9yZTogU3RvcmUsXG4gIGluc3RhbGw6IGluc3RhbGwsXG4gIHZlcnNpb246ICcyLjQuMScsXG4gIG1hcFN0YXRlOiBtYXBTdGF0ZSxcbiAgbWFwTXV0YXRpb25zOiBtYXBNdXRhdGlvbnMsXG4gIG1hcEdldHRlcnM6IG1hcEdldHRlcnMsXG4gIG1hcEFjdGlvbnM6IG1hcEFjdGlvbnMsXG4gIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzOiBjcmVhdGVOYW1lc3BhY2VkSGVscGVyc1xufTtcblxuZXhwb3J0IHsgU3RvcmUsIGluc3RhbGwsIG1hcFN0YXRlLCBtYXBNdXRhdGlvbnMsIG1hcEdldHRlcnMsIG1hcEFjdGlvbnMsIGNyZWF0ZU5hbWVzcGFjZWRIZWxwZXJzIH07XG5leHBvcnQgZGVmYXVsdCBpbmRleF9lc207XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3Z1ZXgvZGlzdC92dWV4LmVzbS5qcyIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fU3ltYm9sLmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL190b0tleS5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNPYmplY3QuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc1N5bWJvbC5qcyIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fTGlzdENhY2hlLmpzIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2lzSW5kZXguanMiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pZGVudGl0eS5qcyIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi40LjRcbiAqIChjKSAyMDE0LTIwMTcgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyogICovXG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3QsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LylcbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG51bGwpOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgdmFyIHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuXG4gICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgY29uZmlnLndhcm5IYW5kbGVyLmNhbGwobnVsbCwgbXNnLCB2bSwgdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICB9XG4gIH07XG5cbiAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICBpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IHR5cGVvZiB2bSA9PT0gJ3N0cmluZydcbiAgICAgID8gdm1cbiAgICAgIDogdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnNcbiAgICAgICAgPyB2bS5vcHRpb25zLm5hbWVcbiAgICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuICAgICAgICAgIDogdm0ubmFtZTtcblxuICAgIHZhciBmaWxlID0gdm0uX2lzVnVlICYmIHZtLiRvcHRpb25zLl9fZmlsZTtcbiAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgdmFyIG1hdGNoID0gZmlsZS5tYXRjaCgvKFteL1xcXFxdKylcXC52dWUkLyk7XG4gICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzID0gJyc7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICBpZiAobiA+IDEpIHsgc3RyICs9IHN0cjsgfVxuICAgICAgbiA+Pj0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9O1xuXG4gIHZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTXV0YXRpb25PYnNlcnZlciAqL1xuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcbnZhciBpc0Nocm9tZSA9IFVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuXG4vLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG52YXIgbmF0aXZlV2F0Y2ggPSAoe30pLndhdGNoO1xuXG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5pZiAoaW5Ccm93c2VyKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSB7fTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcblxuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IH07XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xuICAgICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIHZhciBjb3VudGVyID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsYmFjayB0byBzZXRUaW1lb3V0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KG5leHRUaWNrSGFuZGxlciwgMCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBxdWV1ZU5leHRUaWNrIChjYiwgY3R4KSB7XG4gICAgdmFyIF9yZXNvbHZlO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGltZXJGdW5jKCk7XG4gICAgfVxuICAgIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSkoKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG4gIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICBfU2V0ID0gU2V0O1xufSBlbHNlIHtcbiAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICBfU2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXQgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXRba2V5XSA9PT0gdHJ1ZVxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IHRydWU7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQkMSsrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgaWYgKERlcC50YXJnZXQpIHtcbiAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcbiAgfVxufTtcblxuRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiBub3RpZnkgKCkge1xuICAvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3Vic1tpXS51cGRhdGUoKTtcbiAgfVxufTtcblxuLy8gdGhlIGN1cnJlbnQgdGFyZ2V0IHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkLlxuLy8gdGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvbmx5IG9uZVxuLy8gd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQgYXQgYW55IHRpbWUuXG5EZXAudGFyZ2V0ID0gbnVsbDtcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBwdXNoVGFyZ2V0IChfdGFyZ2V0KSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cbiAgRGVwLnRhcmdldCA9IF90YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG4gIERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4uY2FsbCh0aGlzLCBwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICA6IHJlc1xufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXldO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBrZXlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdCAob3B0aW9ucykge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICB2YXIgbm9ybWFsaXplZCA9IG9wdGlvbnMuaW5qZWN0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IGluamVjdFtpXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQpO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICtcbiAgICAgICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykgK1xuICAgICAgJywgZ290ICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSArICcuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShmbikpIHtcbiAgICByZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZm4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgXCJyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0byBkZWNsYXJlIHJlYWN0aXZlIGRhdGEgXCIgK1xuICAgICAgXCJwcm9wZXJ0aWVzIGluIHRoZSBkYXRhIG9wdGlvbi5cIixcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhJyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG52YXIgbWFyaztcbnZhciBtZWFzdXJlO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcGVyZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2U7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgcGVyZiAmJlxuICAgIHBlcmYubWFyayAmJlxuICAgIHBlcmYubWVhc3VyZSAmJlxuICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICApIHtcbiAgICBtYXJrID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gcGVyZi5tYXJrKHRhZyk7IH07XG4gICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICBwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnByb3RvdHlwZUFjY2Vzc29ycy5jaGlsZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVk5vZGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xuICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSB0ZXh0O1xuICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gIHJldHVybiBub2RlXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxufVxuXG4vLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuLy8gdXNlZCBmb3Igc3RhdGljIG5vZGVzIGFuZCBzbG90IG5vZGVzIGJlY2F1c2UgdGhleSBtYXkgYmUgcmV1c2VkIGFjcm9zc1xuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XG4vLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUsIGRlZXApIHtcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgaWYgKGRlZXAgJiYgdm5vZGUuY2hpbGRyZW4pIHtcbiAgICBjbG9uZWQuY2hpbGRyZW4gPSBjbG9uZVZOb2Rlcyh2bm9kZS5jaGlsZHJlbik7XG4gIH1cbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzLCBkZWVwKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSwgZGVlcCk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIHBsYWluID0gIShwYXNzaXZlIHx8IG9uY2UkJDEgfHwgY2FwdHVyZSk7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBwbGFpbjogcGxhaW4sXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjbG9uZWRbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG4vLyAjNjU1MlxuZnVuY3Rpb24gcHJpb3JpdGl6ZVBsYWluRXZlbnRzIChhLCBiKSB7XG4gIHJldHVybiBhLnBsYWluID8gLTEgOiBiLnBsYWluID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICB2YXIgdG9BZGQgPSBbXTtcbiAgdmFyIGhhc01vZGlmaWVyID0gZmFsc2U7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKCFldmVudC5wbGFpbikgeyBoYXNNb2RpZmllciA9IHRydWU7IH1cbiAgICBpZiAoaXNVbmRlZihjdXIpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LmhhbmRsZXIgPSBjdXI7XG4gICAgICB0b0FkZC5wdXNoKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGlmICh0b0FkZC5sZW5ndGgpIHtcbiAgICBpZiAoaGFzTW9kaWZpZXIpIHsgdG9BZGQuc29ydChwcmlvcml0aXplUGxhaW5FdmVudHMpOyB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV2ZW50JDEgPSB0b0FkZFtpXTtcbiAgICAgIGFkZChldmVudCQxLm5hbWUsIGV2ZW50JDEuaGFuZGxlciwgZXZlbnQkMS5vbmNlLCBldmVudCQxLmNhcHR1cmUsIGV2ZW50JDEucGFzc2l2ZSk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBrZXlJbkxvd2VyQ2FzZSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuICAgICAgICAgIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpXG4gICAgICAgICkge1xuICAgICAgICAgIHRpcChcbiAgICAgICAgICAgIFwiUHJvcCBcXFwiXCIgKyBrZXlJbkxvd2VyQ2FzZSArIFwiXFxcIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICBcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBcIiArXG4gICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgXCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrUHJvcChyZXMsIHByb3BzLCBrZXksIGFsdEtleSwgdHJ1ZSkgfHxcbiAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuXG4vLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXG4vLyBub3JtYWxpemF0aW9uIGlzIG5lZWRlZCAtIGlmIGFueSBjaGlsZCBpcyBhbiBBcnJheSwgd2UgZmxhdHRlbiB0aGUgd2hvbGVcbi8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxuZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoaWxkcmVuXG59XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG4gIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgIDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIGlzRGVmKG5vZGUpICYmIGlzRGVmKG5vZGUudGV4dCkgJiYgaXNGYWxzZShub2RlLmlzQ29tbWVudClcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGksIGMsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAvLyAgbmVzdGVkXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpKTtcbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIChsYXN0KS50ZXh0ICs9IFN0cmluZyhjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKGNvbXAuX19lc01vZHVsZSAmJiBjb21wLmRlZmF1bHQpIHtcbiAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICB9XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmNQbGFjZWhvbGRlciAoXG4gIGZhY3RvcnksXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xuICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YTogZGF0YSwgY29udGV4dDogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuLCB0YWc6IHRhZyB9O1xuICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuICBmYWN0b3J5LFxuICBiYXNlQ3RvcixcbiAgY29udGV4dFxuKSB7XG4gIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG5cbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LmNvbnRleHRzKSkge1xuICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgIGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xuICAgIHZhciBzeW5jID0gdHJ1ZTtcblxuICAgIHZhciBmb3JjZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNvbnRleHRzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgLy8gKGFzeW5jIHJlc29sdmVzIGFyZSBzaGltbWVkIGFzIHN5bmNocm9ub3VzIGR1cmluZyBTU1IpXG4gICAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICAgICAgICAgICAgICAgID8gKFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIilcbiAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG4gIGlmIChvbmNlJCQxKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIHZhciBkZWZhdWx0U2xvdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZnVuY3Rpb25hbENvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGNoaWxkLmRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWZhdWx0U2xvdC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgLy8gaWdub3JlIHdoaXRlc3BhY2VcbiAgaWYgKCFkZWZhdWx0U2xvdC5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgc2xvdHMuZGVmYXVsdCA9IGRlZmF1bHRTbG90O1xuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50IHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gKHBhcmVudFZub2RlLmRhdGEgJiYgcGFyZW50Vm5vZGUuZGF0YS5hdHRycykgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMjsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3B0aW9uVHlwZSAodm0sIG5hbWUpIHtcbiAgdmFyIG9wdGlvbiA9IHZtLiRvcHRpb25zW25hbWVdO1xuICBpZiAoIWlzUGxhaW5PYmplY3Qob3B0aW9uKSkge1xuICAgIHdhcm4oXG4gICAgICAoXCJjb21wb25lbnQgb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgc2hvdWxkIGJlIGFuIG9iamVjdC5cIiksXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KSB8fCBjb25maWcuaXNSZXNlcnZlZEF0dHIoa2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoZWNrT3B0aW9uVHlwZSh2bSwgJ2NvbXB1dGVkJyk7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgdGFyZ2V0LFxuICBrZXksXG4gIHVzZXJEZWZcbikge1xuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDogdXNlckRlZjtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGVja09wdGlvblR5cGUodm0sICdtZXRob2RzJyk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcbiAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGVja09wdGlvblR5cGUodm0sICd3YXRjaCcpO1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGtleU9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGtleU9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluamVjdCwga2V5KS5lbnVtZXJhYmxlXG4gICAgICAgIH0pXG4gICAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzb3VyY2UpIHtcbiAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQgKFxuICBDdG9yLFxuICBwcm9wc0RhdGEsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIHByb3BzID0ge307XG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIF9jb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShjb250ZXh0KTtcbiAgdmFyIGggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChfY29udGV4dCwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG4gIHZhciB2bm9kZSA9IEN0b3Iub3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCBoLCB7XG4gICAgZGF0YTogZGF0YSxcbiAgICBwcm9wczogcHJvcHMsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHBhcmVudDogY29udGV4dCxcbiAgICBsaXN0ZW5lcnM6IGRhdGEub24gfHwgZW1wdHlPYmplY3QsXG4gICAgaW5qZWN0aW9uczogcmVzb2x2ZUluamVjdChDdG9yLm9wdGlvbnMuaW5qZWN0LCBjb250ZXh0KSxcbiAgICBzbG90czogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KTsgfVxuICB9KTtcbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICB2bm9kZS5mdW5jdGlvbmFsQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgdm5vZGUuZnVuY3Rpb25hbE9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChpc0RlZihvbltldmVudF0pKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlKSkge1xuICAgIGlmIChucykgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIHJldHVyblxuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiBpc1VuZGVmKGNoaWxkLm5zKSkge1xuICAgICAgICBhcHBseU5TKGNoaWxkLCBucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgfVxuICB9XG4gIGlmIChpc0RlZihyZXQpKSB7XG4gICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF07XG4gIC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZSBieSBkb2luZyBhIHNoYWxsb3cgY2xvbmUuXG4gIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSlcbiAgICAgID8gY2xvbmVWTm9kZXModHJlZSlcbiAgICAgIDogY2xvbmVWTm9kZSh0cmVlKVxuICB9XG4gIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XSA9XG4gICAgdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwodGhpcy5fcmVuZGVyUHJveHkpO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KG91cnMsIGV4aXN0aW5nKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGF0dHJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sICckbGlzdGVuZXJzJywgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBpZiB0aGUgcGFyZW50IGRpZG4ndCB1cGRhdGUsIHRoZSBzbG90IG5vZGVzIHdpbGwgYmUgdGhlIG9uZXMgZnJvbVxuICAgICAgLy8gbGFzdCByZW5kZXIuIFRoZXkgbmVlZCB0byBiZSBjbG9uZWQgdG8gZW5zdXJlIFwiZnJlc2huZXNzXCIgZm9yIHRoaXMgcmVuZGVyLlxuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2YXIgc2xvdCA9IHZtLiRzbG90c1trZXldO1xuICAgICAgICBpZiAoc2xvdC5fcmVuZGVyZWQpIHtcbiAgICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHNsb3QsIHRydWUgLyogZGVlcCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuICAgICAgdm0uX3N0YXRpY1RyZWVzID0gW107XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyIGZ1bmN0aW9uXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3JcbiAgICAgICAgICA/IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSlcbiAgICAgICAgICA6IHZtLl92bm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG5cbiAgLy8gaW50ZXJuYWwgcmVuZGVyIGhlbHBlcnMuXG4gIC8vIHRoZXNlIGFyZSBleHBvc2VkIG9uIHRoZSBpbnN0YW5jZSBwcm90b3R5cGUgdG8gcmVkdWNlIGdlbmVyYXRlZCByZW5kZXJcbiAgLy8gY29kZSBzaXplLlxuICBWdWUucHJvdG90eXBlLl9vID0gbWFya09uY2U7XG4gIFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcbiAgVnVlLnByb3RvdHlwZS5fcyA9IHRvU3RyaW5nO1xuICBWdWUucHJvdG90eXBlLl9sID0gcmVuZGVyTGlzdDtcbiAgVnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuICBWdWUucHJvdG90eXBlLl9pID0gbG9vc2VJbmRleE9mO1xuICBWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xuICBWdWUucHJvdG90eXBlLl9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgVnVlLnByb3RvdHlwZS5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIFZ1ZS5wcm90b3R5cGUuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICBWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICBWdWUucHJvdG90eXBlLl9nID0gYmluZE9iamVjdExpc3RlbmVycztcbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCsrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1pbml0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcbiAgICAgIGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAgICAgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIHRoZSBoeXBoZW4sICcgK1xuICAgICAgICAgICdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBjb25maWcuaXNSZXNlcnZlZFRhZyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgICAnaWQ6ICcgKyBpZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG52YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChjYWNoZSwgY3VycmVudCwgZmlsdGVyKSB7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIGlmIChjYWNoZWROb2RlICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG4gIGlmICh2bm9kZSkge1xuICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gIH1cbn1cblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXNcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuICAgIH1cbiAgfSxcblxuICB3YXRjaDoge1xuICAgIGluY2x1ZGU6IGZ1bmN0aW9uIGluY2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSxcbiAgICBleGNsdWRlOiBmdW5jdGlvbiBleGNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAoXG4gICAgICAgICh0aGlzLmluY2x1ZGUgJiYgIW1hdGNoZXModGhpcy5pbmNsdWRlLCBuYW1lKSkgfHxcbiAgICAgICAgKHRoaXMuZXhjbHVkZSAmJiBtYXRjaGVzKHRoaXMuZXhjbHVkZSwgbmFtZSkpXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKHRoaXMuY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufTtcblxudmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICBLZWVwQWxpdmU6IEtlZXBBbGl2ZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlJDMpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICBnZXQ6IGlzU2VydmVyUmVuZGVyaW5nXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuVnVlJDMudmVyc2lvbiA9ICcyLjQuNCc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIHN0cmluZ2lmaWVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG5cblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZSQkMS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZSQkMVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaW5QcmUgPSAwO1xuICBmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBpblByZSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhaW5QcmUgJiZcbiAgICAgICAgICAhdm5vZGUubnMgJiZcbiAgICAgICAgICAhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgaW5QcmUtLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgIGkodm5vZGUsIGZhbHNlIC8qIGh5ZHJhdGluZyAqLywgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZiQkMSkpIHtcbiAgICAgICAgaWYgKHJlZiQkMS5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmJCQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIGVsbVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICB2bm9kZS5lbG0gPSBlbG07XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhYmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFiYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgYmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUpKSB7XG4gICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICBpc0luaXRpYWxQYXRjaCA9IHRydWU7XG4gICAgICBjcmVhdGVFbG0odm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNSZWFsRWxlbWVudCkge1xuICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgLy8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cbiAgICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoaXNEZWYob3B0cykgJiYgb3B0cy5DdG9yLm9wdGlvbnMuaW5oZXJpdEF0dHJzID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuYXR0cnMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5hdHRycykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhdHRycyk7XG4gIH1cblxuICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgIGN1ciA9IGF0dHJzW2tleV07XG4gICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgIHNldEF0dHIoZWxtLCBrZXksIGN1cik7XG4gICAgfVxuICB9XG4gIC8vICM0MzkxOiBpbiBJRTksIHNldHRpbmcgdHlwZSBjYW4gcmVzZXQgdmFsdWUgZm9yIGlucHV0W3R5cGU9cmFkaW9dXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuXG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cblxuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxudmFyIHN0cjtcbnZhciBpbmRleCQxO1xuXG4vKiAgKi9cblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICB2YXIgZXZlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgLy8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXG4gICAgZXZlbnQgPSBpc0Nocm9tZSA/ICdjbGljaycgOiAnY2hhbmdlJztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlJCQxLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgaWYgKG9uY2UkJDEpIHtcbiAgICB2YXIgb2xkSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IG9sZEhhbmRsZXIoZXYpXG4gICAgICAgIDogb2xkSGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUkMihldmVudCwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG4gIGVsbSxcbiAgdm5vZGUsXG4gIGNoZWNrVmFsXG4pIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgdm5vZGUudGFnID09PSAnb3B0aW9uJyB8fFxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0lucHV0Q2hhbmdlZChlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNJbnB1dENoYW5nZWQgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy5udW1iZXIpIHtcbiAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gIH1cbiAgaWYgKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLnRyaW0pIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciBlbXB0eVN0eWxlO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuLyogICovXG5cbi8qKlxuICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICB2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuICAgIHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcbiAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICB9XG4gICAgY3VyID0gY3VyLnRyaW0oKTtcbiAgICBpZiAoY3VyKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgOiBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XG4gICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICByZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICB9XG4gIHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICBlbCxcbiAgZXhwZWN0ZWRUeXBlLFxuICBjYlxuKSB7XG4gIHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgdmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcbiAgdmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG4gIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcbiAgdmFyIGVuZGVkID0gMDtcbiAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgY2IoKTtcbiAgfTtcbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgIGVuZCgpO1xuICAgIH1cbiAgfSwgdGltZW91dCArIDEpO1xuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG59XG5cbnZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlLCB0b2dnbGVEaXNwbGF5KSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fbGVhdmVDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICB2YXIgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcztcbiAgdmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVyID0gZGF0YS5lbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gIHZhciBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhcjtcbiAgdmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICB2YXIgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQ7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAvLyB0cmFuc2l0aW9uLiBPbmUgZWRnZSBjYXNlIHRvIGNoZWNrIGlzIHdoZW4gdGhlIDx0cmFuc2l0aW9uPiBpcyBwbGFjZWRcbiAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcbiAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gIHZhciBjb250ZXh0ID0gYWN0aXZlSW5zdGFuY2U7XG4gIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcbiAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgIHRyYW5zaXRpb25Ob2RlID0gdHJhbnNpdGlvbk5vZGUucGFyZW50O1xuICAgIGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuICB9XG5cbiAgdmFyIGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuXG4gIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3NcbiAgICA/IGFwcGVhckNsYXNzXG4gICAgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA6IGVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuICAgID8gYXBwZWFyVG9DbGFzc1xuICAgIDogZW50ZXJUb0NsYXNzO1xuXG4gIHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICA6IGJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgIDogYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgIDogZW50ZXJDYW5jZWxsZWQ7XG5cbiAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5lbnRlclxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG4gICAgfVxuICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcbiAgYXR0cnMsXG4gIGtsYXNzLFxuICBldmVudHMsXG4gIGRvbVByb3BzLFxuICBzdHlsZSxcbiAgdHJhbnNpdGlvblxuXTtcblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIG1vZGVsJDEgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICB2YXIgY3VyT3B0aW9ucyA9IGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICAgIGlmIChjdXJPcHRpb25zLnNvbWUoZnVuY3Rpb24gKG8sIGkpIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHByZXZPcHRpb25zW2ldKTsgfSkpIHtcbiAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcbiAgICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgfSwgMCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZXZlcnkoZnVuY3Rpb24gKG8pIHsgcmV0dXJuICFsb29zZUVxdWFsKG8sIHZhbHVlKTsgfSlcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cbiAgaWYgKCFlLnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgdmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uJCQxID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgIGVsLFxuICAgIGJpbmRpbmcsXG4gICAgdm5vZGUsXG4gICAgb2xkVm5vZGUsXG4gICAgaXNEZXN0cm95XG4gICkge1xuICAgIGlmICghaXNEZXN0cm95KSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IG1vZGVsJDEsXG4gIHNob3c6IHNob3dcbn07XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cbnZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG4gIG5hbWU6IFN0cmluZyxcbiAgYXBwZWFyOiBCb29sZWFuLFxuICBjc3M6IEJvb2xlYW4sXG4gIG1vZGU6IFN0cmluZyxcbiAgdHlwZTogU3RyaW5nLFxuICBlbnRlckNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG4gIGxlYXZlVG9DbGFzczogU3RyaW5nLFxuICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyVG9DbGFzczogU3RyaW5nLFxuICBkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgcmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG4gICAgICBwcm9wczogcmF3Q2hpbGQuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGFcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gIHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWdcbn1cblxudmFyIFRyYW5zaXRpb24gPSB7XG4gIG5hbWU6ICd0cmFuc2l0aW9uJyxcbiAgcHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcbiAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQgJiYgKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICB0aGlzLl9sZWF2aW5nID0gdHJ1ZTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcyQxLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxheWVkTGVhdmU7XG4gICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgd2FybigoXCI8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZDogPFwiICsgbmFtZSArIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgYyQxLmRhdGEudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICBjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAga2VwdC5wdXNoKGMkMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgIHRoaXMucmVtb3ZlZCA9IHJlbW92ZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG4gICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuICAgIHRoaXMuX19wYXRjaF9fKFxuICAgICAgdGhpcy5fdm5vZGUsXG4gICAgICB0aGlzLmtlcHQsXG4gICAgICBmYWxzZSwgLy8gaHlkcmF0aW5nXG4gICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICApO1xuICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICB9LFxuXG4gIHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xuICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuICAgIC8vIGluIGVhY2ggaXRlcmF0aW9uIC0gd2hpY2ggaGVscHMgcHJldmVudCBsYXlvdXQgdGhyYXNoaW5nLlxuICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgIGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuICAgIGNoaWxkcmVuLmZvckVhY2goYXBwbHlUcmFuc2xhdGlvbik7XG5cbiAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGYgPSBib2R5Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgdmFyIHMgPSBlbC5zdHlsZTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghaGFzVHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmVcbiAgICAgIH1cbiAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXG4gICAgICAvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG4gICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgIC8vIGlzIGFwcGxpZWQuXG4gICAgICB2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgZWwuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykgeyByZW1vdmVDbGFzcyhjbG9uZSwgY2xzKTsgfSk7XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgIGNsb25lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUkMy5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlJDMuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHJ1bnRpbWUgZGlyZWN0aXZlcyAmIGNvbXBvbmVudHNcbmV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUkMy5wcm90b3R5cGUuX19wYXRjaF9fID0gaW5Ccm93c2VyID8gcGF0Y2ggOiBub29wO1xuXG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNDaHJvbWUpIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICBpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgKTtcbiAgfVxufSwgMCk7XG5cbi8qICAqL1xuXG5leHBvcnQgZGVmYXVsdCBWdWUkMztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdnVlL2Rpc3QvdnVlLnJ1bnRpbWUuZXNtLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fTWFwLmpzIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19NYXBDYWNoZS5qcyIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUdldC5qcyIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmUoJy4vX3N0cmluZ1RvUGF0aCcpLFxuICAgIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RQYXRoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2lzS2V5LmpzIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9lcS5qcyIsInZhciBiYXNlSXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL19iYXNlSXNBcmd1bWVudHMnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FyZ3VtZW50cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2lzQXJndW1lbnRzLmpzIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNMZW5ndGguanMiLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9rZXlzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcbnZhciBidG9hID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5idG9hICYmIHdpbmRvdy5idG9hLmJpbmQod2luZG93KSkgfHwgcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J0b2EnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgbG9hZEV2ZW50ID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG4gICAgdmFyIHhEb21haW4gPSBmYWxzZTtcblxuICAgIC8vIEZvciBJRSA4LzkgQ09SUyBzdXBwb3J0XG4gICAgLy8gT25seSBzdXBwb3J0cyBQT1NUIGFuZCBHRVQgY2FsbHMgYW5kIGRvZXNuJ3QgcmV0dXJucyB0aGUgcmVzcG9uc2UgaGVhZGVycy5cbiAgICAvLyBET04nVCBkbyB0aGlzIGZvciB0ZXN0aW5nIGIvYyBYTUxIdHRwUmVxdWVzdCBpcyBtb2NrZWQsIG5vdCBYRG9tYWluUmVxdWVzdC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuICAgICAgICAhaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSB7XG4gICAgICByZXF1ZXN0ID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgbG9hZEV2ZW50ID0gJ29ubG9hZCc7XG4gICAgICB4RG9tYWluID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKCkge307XG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7fTtcbiAgICB9XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkIHx8ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0W2xvYWRFdmVudF0gPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQgJiYgIXhEb21haW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIC8vIElFIHNlbmRzIDEyMjMgaW5zdGVhZCBvZiAyMDQgKGh0dHBzOi8vZ2l0aHViLmNvbS9temFicmlza2llL2F4aW9zL2lzc3Vlcy8yMDEpXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIHZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcblxuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19TdGFjay5qcyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYXJyYXlNYXAuanMiLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbERlZXAnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0J1ZmZlci5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xyXG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XHJcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcclxuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxyXG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcclxuXHR9XHJcblx0cmV0dXJuIG1vZHVsZTtcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNWZiNGZjNGFcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3JlZ2lzdGVyLnZ1ZVwiKVxufVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vcmVnaXN0ZXIudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi01ZmI0ZmM0YVxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9yZWdpc3Rlci52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCIvVXNlcnMvU2V0aC9Qcm9qZWN0cy9mYW50YXN5c3gvY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSByZWdpc3Rlci52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNWZiNGZjNGFcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi01ZmI0ZmM0YVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgUm91dGVyIGZyb20gJ3Z1ZS1yb3V0ZXInO1xuaW1wb3J0IGhvbWUgZnJvbSAnLi9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWUnO1xuaW1wb3J0IHJlZ2lzdGVyIGZyb20gJy4vY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlJztcbmltcG9ydCBteXRlYW0gZnJvbSAnLi9jbGllbnQvY29tcG9uZW50cy9teXRlYW0udnVlJztcbmltcG9ydCBydWxlcyBmcm9tICcuL2NsaWVudC9jb21wb25lbnRzL3J1bGVzLnZ1ZSc7XG5pbXBvcnQgc3RhdHRyYWNrZXIgZnJvbSAnLi9jbGllbnQvY29tcG9uZW50cy9zdGF0dHJhY2tlci52dWUnO1xuaW1wb3J0IHN1Z2dlc3Rpb25zIGZyb20gJy4vY2xpZW50L2NvbXBvbmVudHMvc3VnZ2VzdGlvbnMudnVlJztcblxuVnVlLnVzZShSb3V0ZXIpXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3V0ZXIgKCkge1xuICByZXR1cm4gbmV3IFJvdXRlcih7XG4gICAgbW9kZTogJ2hpc3RvcnknLFxuICAgIHJvdXRlczogW1xuICAgICAgeyBwYXRoOiBcIi9cIiwgY29tcG9uZW50OiBob21lIH0sXG4gICAgICB7IHBhdGg6IFwiL3JlZ2lzdGVyXCIsIGNvbXBvbmVudDogcmVnaXN0ZXIgfSxcbiAgICAgIHsgcGF0aDogXCIvbXl0ZWFtXCIsIGNvbXBvbmVudDogbXl0ZWFtIH0sXG4gICAgICB7IHBhdGg6IFwiL3J1bGVzXCIsIGNvbXBvbmVudDogcnVsZXMgfSxcbiAgICAgIHsgcGF0aDogXCIvbGl2ZVwiLCBjb21wb25lbnQ6IHN0YXR0cmFja2VyIH0sXG4gICAgICB7IHBhdGg6IFwiL3N1Z2dlc3Rpb25zXCIsIGNvbXBvbmVudDogc3VnZ2VzdGlvbnMgfSxcbiAgICAgIHsgcGF0aDogXCIvaG9tZVwiLCBjb21wb25lbnQ6IGhvbWUgfVxuICAgIF1cbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3JvdXRlci5qcyIsImltcG9ydCBWdWUgZnJvbSAndnVlJ1xuaW1wb3J0IFZ1ZXggZnJvbSAndnVleCdcblxuVnVlLnVzZShWdWV4KVxuXG5jb25zdCBzdGF0ZSA9IHtcbiAgdXNlcjoge1xuICAgIHVzZXJuYW1lOiAnJ1xuICB9LFxuICBpc0xvZ2dlZEluOiBmYWxzZSxcbiAgbW9kYWxDb250cm9sOiB7XG4gICAgc2hvd0xvZ2luTW9kYWw6IGZhbHNlLFxuICAgIHNob3dSZWdpc3Rlck1vZGFsOiBmYWxzZVxuICB9XG59XG5cbmNvbnN0IGdldHRlcnMgPSB7XG4gIGdldFVzZXJEYXRhOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0YXRlLnVzZXJcbiAgfSxcbiAgU2hvd0xvZ2luTW9kYWw6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RhdGUubW9kYWxDb250cm9sLnNob3dMb2dpbk1vZGFsXG4gIH0sXG4gIFNob3dSZWdpc3Rlck1vZGFsOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1vZGFsQ29udHJvbC5zaG93UmVnaXN0ZXJNb2RhbFxuICB9LFxuICBHZXRBdXRoU3RhdHVzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0YXRlLmlzTG9nZ2VkSW47XG4gIH1cbn1cblxuY29uc3QgbXV0YXRpb25zID0ge1xuICBjaGFuZ2VUZWFtIChzdGF0ZSwgcmlkZXJBcnJheSkge1xuICAgIHN0YXRlLnVzZXIucmlkZXJzID0gcmlkZXJBcnJheVxuICB9LFxuICBzZXRMb2dpbk1vZGFsIChzdGF0ZSwgeyBzaG93IH0pIHtcbiAgICBzdGF0ZS5tb2RhbENvbnRyb2wuc2hvd0xvZ2luTW9kYWwgPSBzaG93O1xuICB9LFxuICBzZXRSZWdpc3Rlck1vZGFsKHN0YXRlLCB7IHNob3cgfSkge1xuICAgIHN0YXRlLm1vZGFsQ29udHJvbC5zaG93UmVnaXN0ZXJNb2RhbCA9IHNob3dcbiAgfSxcbiAgc2V0VXNlckRhdGEoc3RhdGUsIHsgdXNlckRhdGEgfSkge1xuICAgIHN0YXRlLnVzZXIgPSB1c2VyRGF0YTtcbiAgfSxcbiAgc2V0TG9nZ2VkSW4oc3RhdGUsIHsgbG9nZ2VkSW4gfSkge1xuICAgIHN0YXRlLmlzTG9nZ2VkSW4gPSBsb2dnZWRJbjtcbiAgfSxcbiAgbG9nb3V0KHN0YXRlKSB7XG4gICAgc3RhdGUudXNlci5yaWRlcnMgPSBbXTtcbiAgICBzdGF0ZS51c2VyID0ge307XG4gICAgc3RhdGUuaXNMb2dnZWRJbiA9IGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBWdWV4LlN0b3JlKHtcbiAgc3RhdGUsXG4gIGdldHRlcnMsXG4gIG11dGF0aW9uc1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zdG9yZS9zdG9yZS5qcyIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi00ZmMwMDViMFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9pbmRleC52dWVcIilcbn1cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9pbmRleC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGZjMDA1YjBcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9pbmRleC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCIvVXNlcnMvU2V0aC9Qcm9qZWN0cy9mYW50YXN5c3gvaW5kZXgudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBpbmRleC52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNGZjMDA1YjBcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi00ZmMwMDViMFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5kZXgudnVlXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgQXBwIGZyb20gJy4vaW5kZXgudnVlJztcbmltcG9ydCB7IGNyZWF0ZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJztcbmltcG9ydCBzdG9yZSBmcm9tICcuL3N0b3JlL3N0b3JlJztcblxudmFyIHJvdXRlciA9IGNyZWF0ZVJvdXRlcigpO1xuY29uc3QgYXBwID0gbmV3IFZ1ZSh7XG4gIGVsOiBcIiNhcHBcIixcbiAgcm91dGVyLFxuICBzdG9yZSxcbiAgcmVuZGVyOiBoID0+IGgoQXBwKVxufSkuJG1vdW50KFwiI2FwcFwiKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UodXRpbHMubWVyZ2UoZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2F4aW9zLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gdXRpbHMubWVyZ2Uoe1xuICAgICAgdXJsOiBhcmd1bWVudHNbMF1cbiAgICB9LCBhcmd1bWVudHNbMV0pO1xuICB9XG5cbiAgY29uZmlnID0gdXRpbHMubWVyZ2UoZGVmYXVsdHMsIHRoaXMuZGVmYXVsdHMsIHsgbWV0aG9kOiAnZ2V0JyB9LCBjb25maWcpO1xuICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIFN1cHBvcnQgYmFzZVVSTCBjb25maWdcbiAgaWYgKGNvbmZpZy5iYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKGNvbmZpZy51cmwpKSB7XG4gICAgY29uZmlnLnVybCA9IGNvbWJpbmVVUkxzKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgfVxuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmxcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgcmV0dXJuIGVycm9yO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCIndXNlIHN0cmljdCc7XG5cbi8vIGJ0b2EgcG9seWZpbGwgZm9yIElFPDEwIGNvdXJ0ZXN5IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGNoYW1iZXJzL0Jhc2U2NC5qc1xuXG52YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG5mdW5jdGlvbiBFKCkge1xuICB0aGlzLm1lc3NhZ2UgPSAnU3RyaW5nIGNvbnRhaW5zIGFuIGludmFsaWQgY2hhcmFjdGVyJztcbn1cbkUucHJvdG90eXBlID0gbmV3IEVycm9yO1xuRS5wcm90b3R5cGUuY29kZSA9IDU7XG5FLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcic7XG5cbmZ1bmN0aW9uIGJ0b2EoaW5wdXQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhpbnB1dCk7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgZm9yIChcbiAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlclxuICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzO1xuICAgIC8vIGlmIHRoZSBuZXh0IHN0ciBpbmRleCBkb2VzIG5vdCBleGlzdDpcbiAgICAvLyAgIGNoYW5nZSB0aGUgbWFwcGluZyB0YWJsZSB0byBcIj1cIlxuICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICBzdHIuY2hhckF0KGlkeCB8IDApIHx8IChtYXAgPSAnPScsIGlkeCAlIDEpO1xuICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG4gICAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpXG4gICkge1xuICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaWR4ICs9IDMgLyA0KTtcbiAgICBpZiAoY2hhckNvZGUgPiAweEZGKSB7XG4gICAgICB0aHJvdyBuZXcgRSgpO1xuICAgIH1cbiAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ0b2E7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2J0b2EuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTQwL2dpLCAnQCcpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgfSxcblxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH0pKClcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgdmFyIG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICB9XG5cbiAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKClcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2lzLWJ1ZmZlci9pbmRleC5qcyIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19IYXNoLmpzIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19Qcm9taXNlLmpzIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19TZXQuanMiLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpLFxuICAgIHNldENhY2hlQWRkID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVBZGQnKSxcbiAgICBzZXRDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX3NldENhY2hlSGFzJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRDYWNoZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19TZXRDYWNoZS5qcyIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fVWludDhBcnJheS5qcyIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fV2Vha01hcC5qcyIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19hcHBseS5qcyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19hcnJheUZpbHRlci5qcyIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYXJyYXlTb21lLmpzIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlRWFjaC5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlRm9yLmpzIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlRm9yT3duLmpzIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIGVxdWFsQnlUYWcgPSByZXF1aXJlKCcuL19lcXVhbEJ5VGFnJyksXG4gICAgZXF1YWxPYmplY3RzID0gcmVxdWlyZSgnLi9fZXF1YWxPYmplY3RzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanMiLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUlzTWF0Y2guanMiLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlS2V5cy5qcyIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlTWFwLmpzIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlTWFwID0gcmVxdWlyZSgnLi9fYmFzZU1hcCcpLFxuICAgIGJhc2VTb3J0QnkgPSByZXF1aXJlKCcuL19iYXNlU29ydEJ5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgY29tcGFyZU11bHRpcGxlID0gcmVxdWlyZSgnLi9fY29tcGFyZU11bHRpcGxlJyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoID8gaXRlcmF0ZWVzIDogW2lkZW50aXR5XSwgYmFzZVVuYXJ5KGJhc2VJdGVyYXRlZSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcblxuICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VPcmRlckJ5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VPcmRlckJ5LmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsInZhciBiYXNlVW5zZXQgPSByZXF1aXJlKCcuL19iYXNlVW5zZXQnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIGluZGV4ZXMgb3IgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQdWxsQXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVB1bGxBdC5qcyIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlUmVzdC5qcyIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gIH1cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNsaWNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VTbGljZS5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICogdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNvcnRCeTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlU29ydEJ5LmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgbGFzdCA9IHJlcXVpcmUoJy4vbGFzdCcpLFxuICAgIHBhcmVudCA9IHJlcXVpcmUoJy4vX3BhcmVudCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcHJvcGVydHkgcGF0aCB0byB1bnNldC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbnNldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlVW5zZXQuanMiLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19jYWNoZUhhcy5qcyIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqXG4gKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVBc2NlbmRpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fY29tcGFyZUFzY2VuZGluZy5qcyIsInZhciBjb21wYXJlQXNjZW5kaW5nID0gcmVxdWlyZSgnLi9fY29tcGFyZUFzY2VuZGluZycpO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gKlxuICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgIH1cbiAgfVxuICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAvL1xuICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVNdWx0aXBsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19jb21wYXJlTXVsdGlwbGUuanMiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZ2V0VGFnLmpzIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19oYXNQYXRoLmpzIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faGFzaENsZWFyLmpzIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faGFzaFNldC5qcyIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2lzTWFza2VkLmpzIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19tYXBUb0FycmF5LmpzIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19ub2RlVXRpbC5qcyIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19vdmVyQXJnLmpzIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19vdmVyUmVzdC5qcyIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VTbGljZSA9IHJlcXVpcmUoJy4vX2Jhc2VTbGljZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3BhcmVudC5qcyIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3NldFRvQXJyYXkuanMiLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19zdGFja0dldC5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19zdGFja1NldC5qcyIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVMZWFkaW5nRG90ID0gL15cXC4vLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChyZUxlYWRpbmdEb3QudGVzdChzdHJpbmcpKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvY29uc3RhbnQuanMiLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRJbmRleDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2ZpbmRJbmRleC5qcyIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvZ2V0LmpzIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2hhc0luLmpzIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGFzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2xhc3QuanMiLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL21lbW9pemUuanMiLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9wcm9wZXJ0eS5qcyIsInZhciBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlUHVsbEF0ID0gcmVxdWlyZSgnLi9fYmFzZVB1bGxBdCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXG4gKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gKiB9KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gKiAvLyA9PiBbMSwgM11cbiAqXG4gKiBjb25zb2xlLmxvZyhldmVucyk7XG4gKiAvLyA9PiBbMiwgNF1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICB9XG4gIH1cbiAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVtb3ZlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvcmVtb3ZlLmpzIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlT3JkZXJCeSA9IHJlcXVpcmUoJy4vX2Jhc2VPcmRlckJ5JyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gKiBdO1xuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXSwgWydmcmVkJywgNDhdXVxuICovXG52YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtdO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgfVxuICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydEJ5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvc29ydEJ5LmpzIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9zdHViQXJyYXkuanMiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL3RvRmluaXRlLmpzIiwidmFyIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvSW50ZWdlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL3RvSW50ZWdlci5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvdG9OdW1iZXIuanMiLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL3RvU3RyaW5nLmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzIiwiPHRlbXBsYXRlPlxuICA8ZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJjb2x1bW5zIGxlYWRlcmJvYXJkXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLWhhbGYgaXMtb2Zmc2V0LW9uZS1xdWFydGVyXCI+XG4gICAgICAgIDx0YWJsZSBjbGFzcz1cImxlYWRlcmJvYXJkLXRhYmxlXCIgdi1pZj1cImRvbmVMb2FkaW5nXCI+XG4gICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgPHRyIGNsYXNzPVwidGl0bGVcIj5cbiAgICAgICAgICAgICAgPHRoIGNvbHNwYW49XCI0XCI+MjAxOCBGYW50YXN5IFNYOiBNYWluIExlYWd1ZSBTdGFuZGluZ3M8L3RoPlxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgPHRoPlBvc2l0aW9uPC90aD5cbiAgICAgICAgICAgICAgPHRoPlRvdGFsIFBvaW50czwvdGg+XG4gICAgICAgICAgICAgIDx0aD5Vc2VybmFtZTwvdGg+XG4gICAgICAgICAgICAgIDx0aD5Qb2ludHMgQmFjazwvdGg+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgPHRmb290PlxuICAgICAgICAgICAgPHRyPlxuICAgICAgICAgICAgICA8dGg+UG9zaXRpb248L3RoPlxuICAgICAgICAgICAgICA8dGg+VG90YWwgUG9pbnRzPC90aD5cbiAgICAgICAgICAgICAgPHRoPlVzZXJuYW1lPC90aD5cbiAgICAgICAgICAgICAgPHRoPlBvaW50cyBCYWNrPC90aD5cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgPC90Zm9vdD5cbiAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICA8dHIgdi1mb3I9XCIodXNlciwgaW5kZXgpIGluIHN0YW5kaW5nc1wiPlxuICAgICAgICAgICAgICA8dGQ+e3sgaW5kZXggKyAxIH19LjwvdGQ+XG4gICAgICAgICAgICAgIDx0ZD57e3VzZXIudG90YWxwb2ludHN9fTwvdGQ+XG4gICAgICAgICAgICAgIDx0ZD57e3VzZXIud2Vla2x5dGVhbXNbMF0udXNlcm5hbWV9fTwvdGQ+XG4gICAgICAgICAgICAgIDx0ZCB2LWJpbmQ6Y2xhc3M9XCJ7ICdwb2ludHNiYWNrJzogaW5kZXggPiAwIH1cIj57eyBwb2ludHNiZWhpbmQodXNlcikgfX08L3RkPlxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICA8L3RhYmxlPlxuICAgICAgICA8ZGl2IHYtaWY9XCIhZG9uZUxvYWRpbmdcIj5cbiAgICAgICAgICA8cD5cIlRoaXMgZGF0YSBkb2Vzbid0IGZldGNoIGl0c2VsZi4uIExvYWRpbmcgUmFjZSBUcmFja2VyLlwiPC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZUxvYWRpbmc6IGZhbHNlLFxuICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgbWFpbkxlYWd1ZVVzZXJzOiBbXSxcbiAgICAgICAgd2Vla2x5dGVhbXM6IFtdXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgc3RhbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbkxlYWd1ZVVzZXJzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICB2YXIgYVBvaW50cyA9IDA7XG4gICAgICAgICAgdmFyIGJQb2ludHMgPSAwO1xuICAgICAgICAgIGEud2Vla2x5dGVhbXMuZm9yRWFjaCh0ZWFtID0+IHsgYVBvaW50cyArPSB0ZWFtLnBsYWNlIH0pXG4gICAgICAgICAgYi53ZWVrbHl0ZWFtcy5mb3JFYWNoKHRlYW0gPT4geyBiUG9pbnRzICs9IHRlYW0ucGxhY2UgfSlcbiAgICAgICAgICByZXR1cm4gYVBvaW50cyAtIGJQb2ludHM7XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgbmV3c3RhbmRpbmdzOiBmdW5jdGlvbigpIHtcblxuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZCgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiZW52aXJvbm1lbnRcIiwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYpXG4gICAgICBheGlvcy5nZXQoJy9NYWluTGVhZ3VlU3RhbmRpbmdzJylcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICB0aGlzLm1haW5MZWFndWVVc2VycyA9IGRhdGEuZGF0YTtcbiAgICAgICAgdGhpcy5tYWluTGVhZ3VlVXNlcnMuZm9yRWFjaCgodXNlcikgPT4ge1xuICAgICAgICAgIHVzZXIudG90YWxwb2ludHMgPSAwXG4gICAgICAgICAgdXNlci53ZWVrbHl0ZWFtcy5mb3JFYWNoKHd0ID0+IHsgdXNlci50b3RhbHBvaW50cyArPSB3dC5wbGFjZSB9KVxuICAgICAgICAgIHVzZXIud2Vla2x5dGVhbXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuZG9uZUxvYWRpbmcgPSB0cnVlO1xuICAgICAgfSlcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHBvaW50c2JlaGluZDogZnVuY3Rpb24odXNlcikge1xuICAgICAgICB2YXIgb2JqSW5kZXggPSB0aGlzLnN0YW5kaW5ncy5pbmRleE9mKHVzZXIpO1xuICAgICAgICBpZiAob2JqSW5kZXggIT0gMCkge1xuICAgICAgICAgIHJldHVybiB1c2VyLnRvdGFscG9pbnRzIC0gdGhpcy5zdGFuZGluZ3NbMF0udG90YWxwb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICctJ1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBiZWZvcmVDcmVhdGUoKSB7XG4gICAgLy8gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgLy8gICAgICBheGlvcy5nZXQoJy9SYWNlUmVzdWx0cycpXG4gICAgLy8gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAvLyAgICAgICAgY29uc29sZS50aW1lKCk7XG4gICAgLy8gICAgICAgIHZhciByZXN1bHRzID0gZGF0YS5kYXRhLkI7XG4gICAgLy8gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgIC8vICAgICAgICB0aGlzLm1haW5MZWFndWVVc2Vycy5mb3JFYWNoKHVzZXIgPT4ge1xuICAgIC8vICAgICAgICAgIHVzZXIudG90YWxwb2ludHMgPSAwO1xuICAgIC8vICAgICAgICAgIHVzZXIucmlkZXJzLmZvckVhY2gocmlkZXIgPT4ge1xuICAgIC8vICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgLy8gICAgICAgICAgICAgIGlmIChyZXN1bHQuRi5zbGljZSgwLCAtMSkgPT0gcmlkZXIubmFtZSkge1xuICAgIC8vICAgICAgICAgICAgICAgIHJpZGVyLnBvaW50cyA9IHJlc3VsdC5BO1xuICAgIC8vICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICB9KVxuICAgIC8vICAgICAgICAgICAgdXNlci50b3RhbHBvaW50cyArPSByaWRlci5wb2ludHM7XG4gICAgLy8gICAgICAgICAgfSlcbiAgICAvLyAgICAgICAgfSlcbiAgICAvLyAgICAgICBjb25zb2xlLnRpbWVFbmQoKTtcbiAgICAvLyAgICAgICB0aGlzLmRvbmVMb2FkaW5nID0gdHJ1ZTtcbiAgICAvLyAgICAgICBjb25zb2xlLmxvZyh0aGlzLm1haW5MZWFndWVVc2VycylcbiAgICAvLyAgICAgfSlcbiAgICAvLyAgICB9LCAzMDAwKTtcbiAgICAvLyAgIGF4aW9zLmdldCgnL2dldE1haW5MZWFndWVJbmZvJylcbiAgICAvLyAgIC50aGVuKGRhdGEgPT4ge1xuICAgIC8vICAgICBjb25zb2xlLmxvZyhkYXRhLmRhdGEpO1xuICAgIC8vICAgICBkYXRhLmRhdGEuZm9yRWFjaCh1c2VyID0+IHtcbiAgICAvLyAgICAgICB0aGlzLm1haW5MZWFndWVVc2Vycy5wdXNoKHVzZXIpXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICB9KVxuICAgIC8vIH1cbiAgfVxuPC9zY3JpcHQ+XG48c3R5bGU+XG5ib2R5IHtcbiAgZm9udC1mYW1pbHk6IFwiT3BlbiBTYW5zIENvbmRlbnNlZFwiO1xuICBoZWlnaHQ6IDEwMCU7XG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xuICBiYWNrZ3JvdW5kOlxuICAgIGxpbmVhci1ncmFkaWVudCh0byBib3R0b20gcmlnaHQsIHJnYmEoMjUxLCAxMDksIDgsIC44KTAlLCByZ2JhKDIwNCwgNjYsIDAsIDEpMTAwJSksXG4gICAgdXJsKCdodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8zNzUyNy9zcG9ydHMtZ2FtZXMtZnVuLWhvbGlkYXktMzc1MjcuanBlZz93PTEyNjAmaD03NTAmYXV0bz1jb21wcmVzcyZjcz10aW55c3JnYicpO1xuICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOmNlbnRlcjtcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbn1cbi5sZWFkZXJib2FyZC10YWJsZSAudGl0bGUgPiB0aCB7XG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZjVmNWEyO1xuICBmb250LXNpemU6IDE2cHQ7XG4gIHBhZGRpbmc6IC41cmVtO1xufVxuLmxlYWRlcmJvYXJkLXRhYmxlIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuOCk7XG4gIGNvbG9yOiAjN2I3YjdiO1xuICBib3gtc2hhZG93OiAxcHggMXB4IDEwcHggIzIyMjtcbn1cbi5sZWFkZXJib2FyZC10YWJsZSB0aGVhZCB0aCwgdGZvb3QgdGgge1xuICBjb2xvcjogI2ZmZjtcbiAgZm9udC1zaXplOiAxMnB0O1xufVxuLmxlYWRlcmJvYXJkLXRhYmxlIHRoZWFkLCB0Zm9vdCB7XG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChyZ2JhKDI1NSwgMTA2LCAwLCAxKTAlLCByZ2JhKDE1NiwgNTIsIDAsIDEpMTAwJSk7XG59XG4ubGVhZGVyYm9hcmQtdGFibGUgdGQge1xuICBib3JkZXI6IG5vbmU7XG59XG4ubGVhZGVyYm9hcmQtdGFibGUgdHI6aG92ZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjMzLCAxMjAsIC4yKTtcbn1cbiAgLnBvaW50c2JhY2sge1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XG4gICAgY29sb3I6ICNmZjM4NjA7XG4gIH1cbiAgLmxlYWRlcmJvYXJkIHtcbiAgICBtYXJnaW4tdG9wOiA1MHB4O1xuICB9XG4gIHRhYmxlIHRkLCB0aCB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyICFpbXBvcnRhbnQ7XG4gIH1cbiAgLmxlYWRlcmJvYXJkLW1haW4ge1xuICAgIG1hcmdpbi10b3A6IDI1cHg7XG4gIH1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGVhZGVyYm9hcmQudnVlPzEwMjU4NzE4IiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibW9kYWxcIiB2LWJpbmQ6Y2xhc3M9XCJ7J2lzLWFjdGl2ZSc6IHNob3d9XCIgaWQ9XCJsb2dpbk1vZGFsXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtY2FyZFwiPlxuICAgICAgPGhlYWRlciBjbGFzcz1cIm1vZGFsLWNhcmQtaGVhZFwiPlxuICAgICAgICA8cCBjbGFzcz1cIm1vZGFsLWNhcmQtdGl0bGVcIj5Vc2VyIExvZ2luPC9wPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiZGVsZXRlXCIgQGNsaWNrPVwic2V0TG9naW5Nb2RhbCh7IHNob3c6ICFTaG93TG9naW5Nb2RhbCB9KVwiPjwvYnV0dG9uPlxuICAgICAgPC9oZWFkZXI+XG4gICAgICA8c2VjdGlvbiBjbGFzcz1cIm1vZGFsLWNhcmQtYm9keVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cInJlZy11c2VybmFtZVwiIGNsYXNzPVwibGFiZWxcIj5Vc2VybmFtZTogPC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiaW5wdXRcIiB2LW1vZGVsPVwidXNlcm5hbWVcIi8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJyZWctcGFzc3dvcmRcIiBjbGFzcz1cImxhYmVsXCI+UGFzc3dvcmQ6IDwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgY2xhc3M9XCJpbnB1dFwiIGlkPVwicmVnLXBhc3N3b3JkXCIgdi1tb2RlbD1cInBhc3N3b3JkXCIvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZy1yZWNhcHRjaGFcIiBkYXRhLXNpdGVrZXk9XCI2TGNTZkRJVUFBQUFBTzNqaEhuYS1EOHFUd1gtbmJGYnhBazJxNV83XCI+PC9kaXY+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgICA8Zm9vdGVyIGNsYXNzPVwibW9kYWwtY2FyZC1mb290XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gaXMtcHJpbWFyeVwiIHYtYmluZDpjbGFzcz1cInsgJ2lzLWxvYWRpbmcnOiBpc0xvYWRpbmcgfVwiIHYtb246Y2xpY2s9XCJzdWJtaXRcIiB0eXBlPVwiYnV0dG9uXCIgdmFsdWU9XCJMb2dpblwiIGlkPVwic3VibWl0LWxvZ2luXCI+TG9naW48L2J1dHRvbj5cbiAgICAgICAgICA8YSBjbGFzcz1cImJ1dHRvblwiIEBjbGljaz1cInNldExvZ2luTW9kYWwoeyBzaG93OiAhU2hvd0xvZ2luTW9kYWwgfSlcIj5DYW5jZWw8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9mb290ZXI+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPC9kaXY+XG4gIDwvdGVtcGxhdGU+XG4gIDxzY3JpcHQ+XG4gIGltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG4gIGltcG9ydCB7IG1hcE11dGF0aW9ucywgbWFwR2V0dGVycyB9IGZyb20gJ3Z1ZXgnO1xuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVzZXJuYW1lOiAnJyxcbiAgICAgICAgICBwYXNzd29yZDogJycsXG4gICAgICAgICAgaXNMb2FkaW5nOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWQ6IG1hcEdldHRlcnMoW1xuICAgICAgICAnU2hvd0xvZ2luTW9kYWwnXG4gICAgICBdKSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHNob3c6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICAuLi5tYXBNdXRhdGlvbnMoW1xuICAgICAgICAgICdzZXRMb2dpbk1vZGFsJyxcbiAgICAgICAgICAnc2V0VXNlckRhdGEnLFxuICAgICAgICAgICdzZXRMb2dnZWRJbidcbiAgICAgICAgXSksXG4gICAgICAgIHN1Ym1pdDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgYXhpb3MucG9zdCgnL2xvZ2luJywge1xuICAgICAgICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogdGhpcy5wYXNzd29yZCxcbiAgICAgICAgICAgIGNhcHRjaGE6IGdyZWNhcHRjaGEuZ2V0UmVzcG9uc2UoKVxuICAgICAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zZXRVc2VyRGF0YSh7IHVzZXJEYXRhOiBkYXRhLmRhdGEgfSlcbiAgICAgICAgICAgIHRoaXMuc2V0TG9nZ2VkSW4oeyBsb2dnZWRJbjogdHJ1ZSB9KVxuICAgICAgICAgICAgdGhpcy5zZXRMb2dpbk1vZGFsKHsgc2hvdzogZmFsc2UgfSlcbiAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiTG9naW4gZXJyb3I6IFwiLCBlcnIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsb2dpbi52dWU/NGM5ZTBiNWEiLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLWJsb2NrXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsaC00clwiPldlZWs6IDxzcGFuIGNsYXNzPVwiYm9sZGVzdC1oZWFkZXIgcmlnaHRcIj57e2N1cnJlbnR3ZWVrfX08L3NwYW4+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJsaC00clwiPkJhbGFuY2UgUmVtYWluaW5nOjxzcGFuIGNsYXNzPVwiYm9sZGVzdC1oZWFkZXIgcmlnaHRcIj4gJHt7ZG9sbGFyc319PC9zcGFuPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgPHRyYW5zaXRpb24gbmFtZT1cImZhZGVcIiBtb2RlPVwib3V0LWluXCI+XG4gICAgICAgIDxwIHYtaWY9XCJzaG93U2F2ZU1lc3NhZ2VcIiBjbGFzcz1cInN1Y2Nlc3NmdWwtc2F2ZVwiPllvdXIgdGVhbSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgc2F2ZWQhPC9wPlxuICAgICAgICA8cCB2LWlmPVwic2hvd0ZhaWxNZXNzYWdlXCIgY2xhc3M9XCJmYWlsdXJlLXNhdmVcIj5Pb3BzISBTb21ldGhpbmcgV2VudCBXcm9uZy4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci48L3A+XG4gICAgICA8L3RyYW5zaXRpb24+XG4gICAgICA8dGFibGUgY2xhc3M9XCJteXRlYW0tdGFibGVcIj5cbiAgICAgICAgPHRoZWFkPlxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgIDx0aD5BY3Rpb248L3RoPlxuICAgICAgICAgICAgPHRoIEBjbGljaz1cInNvcnRCeVByaWNlXCI+UHJpY2VcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCI+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1jYXJldC11cFwiIHYtaWY9XCJDb3N0U29ydEJ5QXNjXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtY2FyZXQtZG93blwiIHYtZWxzZSBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICA8dGg+UmFjZXIgTmFtZTwvdGg+XG4gICAgICAgICAgICA8dGg+UmFjZXIgTnVtYmVyPC90aD5cbiAgICAgICAgICAgIDx0aD5IaWdoZXN0IEZpbmlzaDwvdGg+XG4gICAgICAgICAgICA8dGg+TG93ZXN0IEZpbmlzaDwvdGg+XG4gICAgICAgICAgICA8dGg+QXZlcmFnZSBGaW5pc2g8L3RoPlxuICAgICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGhlYWQ+XG4gICAgICAgIDx0Zm9vdD5cbiAgICAgICAgICA8dHI+XG4gICAgICAgICAgICA8dGg+QWN0aW9uPC90aD5cbiAgICAgICAgICAgIDx0aD5QcmljZTwvdGg+XG4gICAgICAgICAgICA8dGg+UmFjZXIgTmFtZTwvdGg+XG4gICAgICAgICAgICA8dGg+UmFjZXIgTnVtYmVyPC90aD5cbiAgICAgICAgICAgIDx0aD5IaWdoZXN0IEZpbmlzaDwvdGg+XG4gICAgICAgICAgICA8dGg+TG93ZXN0IEZpbmlzaDwvdGg+XG4gICAgICAgICAgICA8dGg+QXZlcmFnZSBGaW5pc2g8L3RoPlxuICAgICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGZvb3Q+XG4gICAgICAgIDx0Ym9keT5cbiAgICAgICAgICA8dHIgdi1mb3I9XCIocmFjZXIsIGluZGV4KSBpbiBzZWxlY3RlZHJpZGVyc1wiPlxuICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICA8YSBocmVmPVwiIyFcIiB2LWlmPVwicmFjZXIubmFtZSAhPSAnT1BFTiBTTE9UJ1wiIEBjbGljaz1cInJlbW92ZVJhY2VyKHJhY2VyKVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBtaW51cy1pY29uXCI+XG4gICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLW1pbnVzXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZD4ke3tyYWNlci5jb3N0fX08L3RkPlxuICAgICAgICAgICAgPHRkPnt7cmFjZXIubmFtZX19PC90ZD5cbiAgICAgICAgICAgIDx0ZD57e3JhY2VyLnJpZGVyX251bWJlcn19PC90ZD5cbiAgICAgICAgICAgIDx0ZD57e3JhY2VyLmhpZ2hlc3RGaW5pc2h9fTwvdGQ+XG4gICAgICAgICAgICA8dGQ+e3tyYWNlci5sb3dlc3RGaW5pc2h9fTwvdGQ+XG4gICAgICAgICAgICA8dGQ+e3tyYWNlci5hdmVyYWdlRmluaXNofX08L3RkPlxuICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgPHRyIGNsYXNzPVwibGFzdFJvd1wiPlxuICAgICAgICAgICAgPHRkIGNvbHNwYW49XCI1XCI+PC90ZD5cbiAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVwiMVwiPlxuICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGlzLWRhbmdlclwiIEBjbGljaz1cIlJlbW92ZUFsbFwiIDpkaXNhYmxlZD1cIiFzaG93UmVtb3ZlQWxsXCI+UmVtb3ZlIEFsbDwvYnV0dG9uPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVwiMVwiPlxuICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGlzLXN1Y2Nlc3NcIiBAY2xpY2s9XCJTYXZlVGVhbVwiIDpkaXNhYmxlZD1cImhhc09wZW5TbG90c1wiIHYtYmluZDpjbGFzcz1cInsnaXMtbG9hZGluZyc6aXNMb2FkaW5nfVwiPlNhdmUgVGVhbTwvYnV0dG9uPlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICA8L3RyPlxuICAgICAgICAgIDx0ciB2LWZvcj1cInJpZGVyIGluIHBhZ2luYXRlZFJpZGVyc1wiPlxuICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICA8YSBocmVmPVwiIyFcIiB2LWlmPVwic2hvd1NlbGVjdCAmJiByaWRlci5jb3N0IDw9IGRvbGxhcnNcIiBAY2xpY2s9XCJhZGRSYWNlcihyaWRlcilcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24gcGx1cy1pY29uXCI+XG4gICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXBsdXNcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgPHRkPiR7e3JpZGVyLmNvc3R9fTwvdGQ+XG4gICAgICAgICAgICA8dGQ+e3tyaWRlci5uYW1lfX08L3RkPlxuICAgICAgICAgICAgPHRkPnt7cmlkZXIucmlkZXJfbnVtYmVyfX08L3RkPlxuICAgICAgICAgICAgPHRkPnt7cmlkZXIuaGlnaGVzdEZpbmlzaH19PC90ZD5cbiAgICAgICAgICAgIDx0ZD57e3JpZGVyLmxvd2VzdEZpbmlzaH19PC90ZD5cbiAgICAgICAgICAgIDx0ZD57e3JpZGVyLmF2ZXJhZ2VGaW5pc2h9fTwvdGQ+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgICA8ZGl2IGNsYXNzPVwiY3VzdG9tLXBhZ2luYXRpb25cIj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8YSBjbGFzcz1cInBhZ2luYXRpb24tcHJldmlvdXNcIiBAY2xpY2s9XCJwYWdlLS1cIiB2LWJpbmQ6Y2xhc3M9XCJ7ICdoaWRlLXBhZ2luYXRpb24tYnV0dG9uJyA6IGhpZGVQcmV2aW91cyB9XCI+UHJldmlvdXM8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxhIGNsYXNzPVwicGFnaW5hdGlvbi1udW1iZXJcIj57e3BhZ2V9fS97e3BhZ2luYXRpb25QYWdlc319PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8YSBjbGFzcz1cInBhZ2luYXRpb24tbmV4dFwiIEBjbGljaz1cInBhZ2UrK1wiIHYtYmluZDpjbGFzcz1cInsgJ2hpZGUtcGFnaW5hdGlvbi1idXR0b24nIDogaGlkZU5leHQgfVwiPk5leHQgcGFnZTwvYT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IG1hcEdldHRlcnMgfSBmcm9tICd2dWV4JztcbmltcG9ydCBfZmluZEluZGV4IGZyb20gJ2xvZGFzaC9maW5kSW5kZXgnO1xuaW1wb3J0IF9zb3J0QnkgZnJvbSAnbG9kYXNoL3NvcnRCeSc7XG5pbXBvcnQgX3JlbW92ZSBmcm9tICdsb2Rhc2gvcmVtb3ZlJztcbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50d2VlazogMCxcbiAgICAgICAgc2VsZWN0ZWRyaWRlcnM6IFtdLFxuICAgICAgICBhdmFpbGFibGVSaWRlcnM6IFtdLFxuICAgICAgICBDb3N0U29ydEJ5QXNjOiB0cnVlLFxuICAgICAgICBwYWdlOiAxLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICBzaG93U2F2ZU1lc3NhZ2U6IGZhbHNlLFxuICAgICAgICBzaG93RmFpbE1lc3NhZ2U6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgLi4ubWFwR2V0dGVycyhbXG4gICAgICAgICdnZXRVc2VyRGF0YSdcbiAgICAgIF0pLFxuICAgICAgZG9sbGFycygpIHtcbiAgICAgICAgdmFyIHRvdGFsID0gMTAwMDA7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRyaWRlcnMuZm9yRWFjaChyaWRlciA9PiB7XG4gICAgICAgICAgdG90YWwgLT0gcmlkZXIuY29zdDtcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgfSxcbiAgICAgIGhpZGVQcmV2aW91cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZSA8PSAxO1xuICAgICAgfSxcbiAgICAgIGhpZGVOZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlID49IHRoaXMucGFnaW5hdGlvblBhZ2VzO1xuICAgICAgfSxcbiAgICAgIHBhZ2luYXRlZFJpZGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMucGFnZSA9PSAxKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJlbnRpcmUgYXJyYXlcIiwgdGhpcy5hdmFpbGFibGVSaWRlcnMpXG4gICAgICAgICAgY29uc29sZS5sb2codGhpcy5hdmFpbGFibGVSaWRlcnMuc2xpY2UoMCwgMTApKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdmFpbGFibGVSaWRlcnMuc2xpY2UoMCwgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBiZWdpblNsaWNlID0gdGhpcy5wYWdlICogMTAgLSA5O1xuICAgICAgICAgIHZhciBlbmRTbGljZSA9IGJlZ2luU2xpY2UgKyAxMDtcbiAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmF2YWlsYWJsZVJpZGVycylcbiAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmF2YWlsYWJsZVJpZGVycy5zbGljZShiZWdpblNsaWNlLCBlbmRTbGljZSkpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlUmlkZXJzLnNsaWNlKGJlZ2luU2xpY2UsIGVuZFNsaWNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBhZ2luYXRpb25QYWdlcygpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmF2YWlsYWJsZVJpZGVycy5sZW5ndGggLyAxMCk7XG4gICAgICB9LFxuICAgICAgaGFzT3BlblNsb3RzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZHJpZGVycy5zb21lKHJpZGVyID0+IHsgcmV0dXJuIHJpZGVyLm5hbWUgPT0gXCJPUEVOIFNMT1RcIiB9KVxuICAgICAgfSxcbiAgICAgIHNob3dSZW1vdmVBbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkcmlkZXJzLnNvbWUocmlkZXIgPT4geyByZXR1cm4gcmlkZXIubmFtZSAhPSBcIk9QRU4gU0xPVFwiIH0pXG4gICAgICB9LFxuICAgICAgc2hvd1NlbGVjdCgpIHtcbiAgICAgICAgdmFyIG9wZW5TbG90cyA9IHRoaXMuc2VsZWN0ZWRyaWRlcnMuc29tZSgocmlkZXIpID0+IHtyZXR1cm4gcmlkZXIubmFtZSA9PSBcIk9QRU4gU0xPVFwifSk7XG4gICAgICAgIHZhciBsb3dlc3RDb3N0QXZhaWxhYmxlID0gX3NvcnRCeSh0aGlzLmF2YWlsYWJsZVJpZGVycywgbyA9PiB7IHJldHVybiBvLmNvc3QgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic2hvd1NlbGVjdFwiLCBsb3dlc3RDb3N0QXZhaWxhYmxlWzBdKVxuICAgICAgICBpZiAoKHRoaXMuZG9sbGFycyA+PSBsb3dlc3RDb3N0QXZhaWxhYmxlWzBdLmNvc3QpICYmIG9wZW5TbG90cykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHJlbW92ZVJhY2VyKHJhY2VyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwicmVtb3ZlZCByYWNlcnNcIiwgcmFjZXIpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRSYWNlckluZGV4ID0gX2ZpbmRJbmRleCh0aGlzLnNlbGVjdGVkcmlkZXJzLCBvID0+IHsgcmV0dXJuIG8ucmlkZXJpZCA9PT0gcmFjZXIucmlkZXJpZCB9KTtcbiAgICAgICAgdmFyIG9wZW5TcGFjZSA9IHtcbiAgICAgICAgICBpZDogdGhpcy5zZWxlY3RlZHJpZGVyc1tzZWxlY3RlZFJhY2VySW5kZXhdLmlkLFxuICAgICAgICAgIGF2YXRhcl91cmw6ICdodHRwOi8vd3d3LnNob3BhYXJkdmFyay5jb20vbWVkaWEvY2F0YWxvZy9wcm9kdWN0L1cvUy9XUy0xODY1NS5qcGcnLFxuICAgICAgICAgIGNvc3Q6IDAsXG4gICAgICAgICAgaGlnaGVzdEZpbmlzaDogJy0nLFxuICAgICAgICAgIGxvd2VzdEZpbmlzaDogJy0nLFxuICAgICAgICAgIG5hbWU6ICdPUEVOIFNMT1QnLFxuICAgICAgICAgIHJpZGVyX251bWJlcjogMCxcbiAgICAgICAgICByaWRlcmlkOiAwLFxuICAgICAgICAgIGxlYWd1ZWlkOiAxLFxuICAgICAgICAgIHNlYXNvbl93ZWVrc2lkOiB0aGlzLmN1cnJlbnR3ZWVrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdmFpbGFibGVSaWRlcnMucHVzaChyYWNlcilcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIHNlbGVjdGVkUmFjZXJJbmRleCwgb3BlblNwYWNlKVxuICAgICAgICBjb25zb2xlLmxvZyhcIk15IG5ldyB0ZWFtXCIsIHRoaXMuc2VsZWN0ZWRyaWRlcnMpXG4gICAgICB9LFxuICAgICAgYWRkUmFjZXIocmFjZXIpIHtcbiAgICAgICAgdmFyIG9wZW5TbG90SW5kZXggPSBfZmluZEluZGV4KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIG8gPT4geyByZXR1cm4gby5uYW1lID09IFwiT1BFTiBTTE9UXCIgfSk7XG4gICAgICAgIF9yZW1vdmUodGhpcy5wYWdpbmF0ZWRSaWRlcnMsIG8gPT4geyByZXR1cm4gby5yaWRlcmlkID09IHJhY2VyLnJpZGVyaWQgfSlcbiAgICAgICAgX3JlbW92ZSh0aGlzLmF2YWlsYWJsZVJpZGVycywgbyA9PiB7IHJldHVybiBvLnJpZGVyaWQgPT0gcmFjZXIucmlkZXJpZCB9KVxuICAgICAgICByYWNlci5pZCA9IHRoaXMuc2VsZWN0ZWRyaWRlcnNbb3BlblNsb3RJbmRleF0uaWQ7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnNlbGVjdGVkcmlkZXJzLCBvcGVuU2xvdEluZGV4LCByYWNlcik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUmFjZXJzIHRvIEFkZFwiLCB0aGlzLnNlbGVjdGVkcmlkZXJzKVxuICAgICAgfSxcbiAgICAgIHNvcnRCeVByaWNlKCkge1xuICAgICAgICBpZiAodGhpcy5Db3N0U29ydEJ5QXNjKSB7XG4gICAgICAgICAgdGhpcy5Db3N0U29ydEJ5QXNjID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5wYWdpbmF0ZWRSaWRlcnMgPSB0aGlzLnBhZ2luYXRlZFJpZGVycy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZiAoYS5jb3N0ID4gYi5jb3N0KSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEuY29zdCA8IGIuY29zdCkge1xuICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuQ29zdFNvcnRCeUFzYyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5wYWdpbmF0ZWRSaWRlcnMgPSB0aGlzLnBhZ2luYXRlZFJpZGVycy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZiAoYS5jb3N0ID4gYi5jb3N0KSB7XG4gICAgICAgICAgICAgIHJldHVybiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYS5jb3N0IDwgYi5jb3N0KSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgU2F2ZVRlYW0oKSB7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgYXhpb3MucG9zdChcIi9TYXZlVGVhbVwiLCB0aGlzLnNlbGVjdGVkcmlkZXJzKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuU2F2ZU1lc3NhZ2UoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLkZhaWxNZXNzYWdlKCk7XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgU2F2ZU1lc3NhZ2UoKSB7XG4gICAgICAgIHRoaXMuc2hvd1NhdmVNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuc2hvd1NhdmVNZXNzYWdlID0gZmFsc2UgfSwgNTAwMClcbiAgICAgIH0sXG4gICAgICBGYWlsTWVzc2FnZSgpIHtcbiAgICAgICAgdGhpcy5zaG93RmFpbE1lc3NhZ2UgPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5zaG93RmFpbE1lc3NhZ2UgPSBmYWxzZSB9LCA1MDAwKVxuICAgICAgfSxcbiAgICAgIFJlbW92ZUFsbCgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZHJpZGVycy5mb3JFYWNoKHJhY2VyID0+IHtcbiAgICAgICAgICBpZiAocmFjZXIubmFtZSAhPSBcIk9QRU4gU0xPVFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZVJhY2VyKHJhY2VyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICAgIGF4aW9zLmdldCgnL0N1cnJlbnRNeVRlYW1Nb2RlbCcpXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJkYXRhXCIsIGRhdGEuZGF0YSk7XG4gICAgICAgIHRoaXMuY3VycmVudHdlZWsgPSBkYXRhLmRhdGEuQ3VycmVudFdlZWs7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuY3VycmVudHdlZWspO1xuICAgICAgICB0aGlzLmF2YWlsYWJsZVJpZGVycyA9IF9zb3J0QnkoZGF0YS5kYXRhLkF2YWlsYWJsZVJpZGVycywgbyA9PiB7IHJldHVybiBvLmNvc3QgfSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRyaWRlcnMgPSBkYXRhLmRhdGEuQ3VycmVudFRlYW07XG4gICAgICB9KVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwibW91bnRlZFwiLCB0aGlzLmdldFVzZXJEYXRhKVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4uc3VjY2Vzc2Z1bC1zYXZlIHtcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xuICBjb2xvcjogIzAwZDFiMjtcbn1cbi5teXRlYW0tdGFibGUgdGFibGUgdGQge1xuICBib3JkZXI6IG5vbmU7XG59XG4ubXl0ZWFtLXRhYmxlIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuOCk7XG4gIGNvbG9yOiAjN2I3YjdiO1xuICBib3gtc2hhZG93OiAxcHggMXB4IDEwcHggIzIyMjtcbn1cbi5teXRlYW0tdGFibGUgdGhlYWQsIHRmb290IHtcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHJnYmEoMjU1LCAxMDYsIDAsIDEpMCUsIHJnYmEoMTU2LCA1MiwgMCwgMSkxMDAlKTtcbn1cbi5teXRlYW0tdGl0bGUge1xuICBjb2xvcjogIzg2ODY4NjtcbiAgZm9udC1zaXplOiAxNnB0O1xufVxuLm15dGVhbS10YWJsZSB0aGVhZCB0aCwgdGZvb3QgdGgge1xuICBjb2xvcjogI2ZmZjtcbiAgZm9udC1zaXplOiAxMnB0O1xufVxuLm15dGVhbS10YWJsZSB0cjpob3ZlciB7XG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyMzMsIDEyMCwgLjIpO1xufVxuLmZhaWx1cmUtc2F2ZSB7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgY29sb3I6ICNmZjJiNTY7XG59XG4uZmFkZS1lbnRlci1hY3RpdmUsIC5mYWRlLWxlYXZlLWFjdGl2ZSB7XG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMXM7XG59XG4uZmFkZS1lbnRlciwgLmZhZGUtbGVhdmUtdG8ge1xuICBvcGFjaXR5OiAwO1xufVxuLnBhZ2UtaGVhZGVyLWNvbnRhaW5lciB7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xufVxuYnV0dG9uIHtcbiAgbWFyZ2luLWJvdHRvbTogMC4yNXJlbTtcbn1cbi5wYWdlLWhlYWRlci1ibG9jayB7XG4gIHdpZHRoOiAxNSU7XG4gIG1pbi13aWR0aDogMjYwcHg7XG59XG4gIC5yaWRlcnMtY29udGFpbmVyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgfVxuICAucmlkZXItYmxvY2sge1xuICAgIG1pbi13aWR0aDogMTVyZW07XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2RlZGVkZTtcbiAgICBtYXJnaW46IDFyZW07XG4gICAgYm94LXNoYWRvdzogMXB4IDFweCAxcHggI2NlY2VjZTtcbiAgICBwYWRkaW5nOiAxcmVtO1xuICAgIG1heC13aWR0aDogMTVyZW07XG4gIH1cbiAgLnBhZ2UtdGl0bGUge1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICBmb250LXdlaWdodDogNzAwO1xuICB9XG4gIC5wYWdlLXRpdGxlIHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgfVxuICAucGFnZS1zdWJoZWFkZXIge1xuICAgIHRleHQtYWxpZ246Y2VudGVyO1xuICB9XG4gIC5jYXJkLWZvb3RlciB7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZWVlO1xuICB9XG4gIC5jYXJkLWNvbnRlbnQge1xuICAgIG1pbi1oZWlnaHQ6IDExcmVtO1xuICAgIG1heC1oZWlnaHQ6IDExcmVtO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcbiAgfVxuICAuY2FyZC1mb290ZXIgZGl2Om50aC1jaGlsZChldmVuKSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcbiAgfVxuICAuZm9vdGVyLXJvdyB7XG4gICAgZGlzcGxheTpmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgfVxuICBwLmNhcmQtaGVhZGVyLXRpdGxlIHtcbiAgICBkaXNwbGF5OmZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gIH1cbiAgcCBzcGFuLmljb24ge1xuICAgIGNvbG9yOiAjZmYzODYwO1xuICB9XG4gIHRoOmhvdmVyIHtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gIH1cbiAgLmhpZGUtcGFnaW5hdGlvbi1idXR0b24ge1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxuICAuY3VzdG9tLXBhZ2luYXRpb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICB9XG4gIC5sYXN0Um93IHtcbiAgICBib3JkZXItYm90dG9tOiAycHggc29saWQgcmdiKDIwOCwgODMsIDEpO1xuICB9XG4gIC5taW51cy1pY29uIHtcbiAgICBjb2xvcjogI2ZmMzg2MDtcbiAgfVxuICAucGx1cy1pY29uIHtcbiAgICBjb2xvcjogIzIzZDE2MDtcbiAgfVxuICAuYm9sZGVzdC1oZWFkZXIge1xuICAgIGNvbG9yOiAjZmZmYzdmO1xuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XG4gICAgZm9udC1zaXplOiB4eC1sYXJnZTtcbiAgfVxuICAucmlnaHQge1xuICAgIGZsb2F0OiByaWdodDtcbiAgfVxuICAubGgtNHIge1xuICAgIGhlaWdodDogNHJlbTtcbiAgICBsaW5lLWhlaWdodDogNHJlbTtcbiAgICBmb250LXNpemU6IDEuNzVyZW07XG4gICAgY29sb3I6d2hpdGU7XG4gIH1cbiAgLmxoLTRyOmZpcnN0LW9mLXR5cGUge1xuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZmZlOTc4O1xuICB9XG4gIC5saC00cjpsYXN0LW9mLXR5cGUge1xuICAgIG1hcmdpbi1ib3R0b206IDJyZW07XG4gIH1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbXl0ZWFtLnZ1ZT82NzQ1ZDM4MiIsIlxuICA8dGVtcGxhdGU+XG4gICAgPG5hdiBjbGFzcz1cIm5hdmJhclwiPlxuICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItYnJhbmRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1pdGVtXCI+XG4gICAgICAgICAgLy9BTFBIQSBURVNULy9cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItYnVyZ2VyIGJ1cmdlclwiIGRhdGEtdGFyZ2V0PVwibmF2TWVudVwiPlxuICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICAgICAgICA8c3Bhbj48L3NwYW4+XG4gICAgICAgICAgPHNwYW4+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1tZW51XCIgaWQ9XCJuYXZNZW51XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItc3RhcnRcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWl0ZW1cIj5cbiAgICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cIi9ob21lXCIgZXhhY3Q+SG9tZTwvcm91dGVyLWxpbms+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1pdGVtXCIgdi1pZj1cIkdldEF1dGhTdGF0dXNcIj5cbiAgICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cIi9teXRlYW1cIj5NeSBUZWFtPC9yb3V0ZXItbGluaz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWl0ZW1cIiB2LWlmPVwiR2V0QXV0aFN0YXR1c1wiPlxuICAgICAgICAgICAgPHJvdXRlci1saW5rIHRvPVwiL2xpdmVcIj5TdGF0IFRyYWNrZXI8L3JvdXRlci1saW5rPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbVwiPlxuICAgICAgICAgICAgPHJvdXRlci1saW5rIHRvPVwiL3J1bGVzXCI+SW5mbzwvcm91dGVyLWxpbms+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1pdGVtXCI+XG4gICAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XCIvc3VnZ2VzdGlvbnNcIj5TdWdnZXN0aW9uczwvcm91dGVyLWxpbms+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWVuZFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbVwiIHYtaWY9XCIhR2V0QXV0aFN0YXR1c1wiIEBjbGljaz1cInNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiAhU2hvd1JlZ2lzdGVyTW9kYWwgfSlcIj5cbiAgICAgICAgICAgIDxhIGhyZWY9XCIjIVwiPlJlZ2lzdGVyPC9hPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbVwiIHYtaWY9XCIhR2V0QXV0aFN0YXR1c1wiIEBjbGljaz1cInNldExvZ2luTW9kYWwoeyBzaG93OiAhU2hvd0xvZ2luTW9kYWwgfSlcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiPlxuICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXNpZ24taW5cIj48L2k+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8YSBocmVmPVwiIyFcIj5Mb2dpbjwvYT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWl0ZW1cIiB2LWlmPVwiR2V0QXV0aFN0YXR1c1wiPlxuICAgICAgICAgICAgPGEgaHJlZj1cIiMhXCI+V2VsY29tZSwge3sgZ2V0VXNlckRhdGEudXNlcm5hbWUgfX0hPC9hPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbVwiIHYtaWY9XCJHZXRBdXRoU3RhdHVzXCIgQGNsaWNrPVwic2V0TG9nZ2VkSW4oeyBpc0xvZ2dlZEluOiAhR2V0QXV0aFN0YXR1cyB9KVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCIgdi1pZj1cIkdldEF1dGhTdGF0dXNcIj5cbiAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1zaWduLW91dFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxhIGhyZWY9XCIjIVwiIEBjbGljaz1cImxvZ291dFwiPkxvZ291dDwvYT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxyZWdpc3RlciA6c2hvdz1cIlNob3dSZWdpc3Rlck1vZGFsXCI+PC9yZWdpc3Rlcj5cbiAgICAgIDxsb2dpbiB2LWJpbmQ6c2hvdz1cIlNob3dMb2dpbk1vZGFsXCI+PC9sb2dpbj5cbiAgICA8L25hdj5cbiAgPC90ZW1wbGF0ZT5cbiAgPHNjcmlwdD5cbiAgICBpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuICAgIGltcG9ydCB7IG1hcEdldHRlcnMsIG1hcE11dGF0aW9ucyB9IGZyb20gJ3Z1ZXgnO1xuICAgIGltcG9ydCByZWdpc3RlciBmcm9tICcuL3JlZ2lzdGVyLnZ1ZSc7XG4gICAgaW1wb3J0IGxvZ2luIGZyb20gJy4vbG9naW4udnVlJztcbiAgICBleHBvcnQgZGVmYXVsdCB7XG4gICAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4gIHtcbiAgICAgICAgICB1c2VybmFtZTogJycsXG4gICAgICAgICAgcGFzc3dvcmQ6ICcnLFxuICAgICAgICAgIHNob3dSZWdpc3Rlck1vZGFsOiBmYWxzZSxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkOiBtYXBHZXR0ZXJzKFtcbiAgICAgICAgJ1Nob3dMb2dpbk1vZGFsJyxcbiAgICAgICAgJ1Nob3dSZWdpc3Rlck1vZGFsJyxcbiAgICAgICAgJ2dldFVzZXJEYXRhJyxcbiAgICAgICAgJ0dldEF1dGhTdGF0dXMnXG4gICAgICBdKSxcbiAgICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIC8vIEdldCBhbGwgXCJuYXZiYXItYnVyZ2VyXCIgZWxlbWVudHNcbiAgICAgICAgdmFyICRuYXZiYXJCdXJnZXJzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm5hdmJhci1idXJnZXInKSwgMCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCRuYXZiYXJCdXJnZXJzKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSBuYXYgYnVyZ2Vyc1xuICAgICAgICBpZiAoJG5hdmJhckJ1cmdlcnMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgLy8gQWRkIGEgY2xpY2sgZXZlbnQgb24gZWFjaCBvZiB0aGVtXG4gICAgICAgICAgJG5hdmJhckJ1cmdlcnMuZm9yRWFjaChmdW5jdGlvbiAoJGVsKSB7XG4gICAgICAgICAgICAkZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG5cbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0YXJnZXQgZnJvbSB0aGUgXCJkYXRhLXRhcmdldFwiIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gJGVsLmRhdGFzZXQudGFyZ2V0O1xuICAgICAgICAgICAgICB2YXIgJHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCk7XG5cbiAgICAgICAgICAgICAgLy8gVG9nZ2xlIHRoZSBjbGFzcyBvbiBib3RoIHRoZSBcIm5hdmJhci1idXJnZXJcIiBhbmQgdGhlIFwibmF2YmFyLW1lbnVcIlxuICAgICAgICAgICAgICAkZWwuY2xhc3NMaXN0LnRvZ2dsZSgnaXMtYWN0aXZlJyk7XG4gICAgICAgICAgICAgICR0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgnaXMtYWN0aXZlJyk7XG5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgYXhpb3MuZ2V0KCcvbG9naW5yZWZyZXNoJykudGhlbihkYXRhID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhLmRhdGEpXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmRhdGEudXNlcm5hbWUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVXNlciBJcyBBdXRoZW50aWNhdGVkXCIpXG4gICAgICAgICAgICB0aGlzLnNldFVzZXJEYXRhKHsgdXNlckRhdGE6IGRhdGEuZGF0YSB9KVxuICAgICAgICAgICAgdGhpcy5zZXRMb2dnZWRJbih7IGxvZ2dlZEluOiB0cnVlIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwibG9naW4gcmVmcmVzaCBlcnJvclwiLCBlcnIpO1xuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgLi4ubWFwTXV0YXRpb25zKFtcbiAgICAgICAgICAnc2V0UmVnaXN0ZXJNb2RhbCcsXG4gICAgICAgICAgJ3NldExvZ2luTW9kYWwnLFxuICAgICAgICAgICdzZXRMb2dnZWRJbicsXG4gICAgICAgICAgJ3NldFVzZXJEYXRhJyxcbiAgICAgICAgICAnbG9nb3V0J1xuICAgICAgICBdKSxcbiAgICAgICAgbG9nb3V0KCkge1xuICAgICAgICAgIGF4aW9zLmdldCgnbG9nb3V0JykudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIHRoaXMuJHJvdXRlci5wdXNoKFwiL1wiKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAncmVnaXN0ZXInOiByZWdpc3RlcixcbiAgICAgICAgJ2xvZ2luJzogbG9naW5cbiAgICAgIH1cbiAgICB9XG4gIDwvc2NyaXB0PlxuICA8c3R5bGU+XG4gICAgLm5hdmJhci1tZW51IHtcbiAgICAgIHBhZGRpbmc6IDAgMTAwcHggMCA1MHB4O1xuICAgIH1cbiAgICAubmF2YmFyIHtcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgIH1cbiAgICBhIHtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTZwdDtcbiAgICB9XG4gICAgLnJvdXRlci1saW5rLWFjdGl2ZSB7XG4gICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2ZmZmM3ZjtcbiAgICB9XG4gIDwvc3R5bGU+XG59KVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIG5hdmJhci52dWU/NWY5OGYwNjAiLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtb2RhbFwiIHYtYmluZDpjbGFzcz1cInsnaXMtYWN0aXZlJzogU2hvd1JlZ2lzdGVyTW9kYWx9XCIgaWQ9XCJyZWdpc3Rlck1vZGFsXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtY2FyZFwiPlxuICAgICAgPGhlYWRlciBjbGFzcz1cIm1vZGFsLWNhcmQtaGVhZFwiPlxuICAgICAgICA8cCBjbGFzcz1cIm1vZGFsLWNhcmQtdGl0bGVcIj5OZXcgVXNlciBSZWdpc3RyYXRpb248L3A+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJkZWxldGVcIiBAY2xpY2s9XCJzZXRSZWdpc3Rlck1vZGFsKHsgc2hvdzogIVNob3dSZWdpc3Rlck1vZGFsfSlcIj48L2J1dHRvbj5cbiAgICAgIDwvaGVhZGVyPlxuICAgICAgPHNlY3Rpb24gY2xhc3M9XCJtb2RhbC1jYXJkLWJvZHlcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJsYWJlbFwiPlVzZXJuYW1lOiA8L2xhYmVsPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiaW5wdXRcIiB2LWJpbmQ6Y2xhc3M9XCJ7ICdpcy1kYW5nZXInOiBpbnZhbGlkVXNlcm5hbWUgfVwiIGlkPVwicmVnLXVzZXJuYW1lXCIgdi1tb2RlbD1cInVzZXJuYW1lXCIgcGxhY2Vob2xkZXI9XCJVc2VybmFtZVwiIHJlcXVpcmVkPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXVzZXJcIj48L2k+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImxhYmVsXCI+RW1haWw6IDwvbGFiZWw+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJlbWFpbFwiIGNsYXNzPVwiaW5wdXRcIiB2LWJpbmQ6Y2xhc3M9XCJ7ICdpcy1kYW5nZXInOiBpbnZhbGlkRW1haWwgfVwiICBpZD1cInJlZy1lbWFpbFwiIHYtbW9kZWw9XCJlbWFpbFwiIHBsYWNlaG9sZGVyPVwiRW1haWxcIiByZXF1aXJlZD5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24gaXMtc21hbGwgaXMtbGVmdFwiPlxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1lbnZlbG9wZVwiPjwvaT5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cbiAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwibGFiZWxcIj5QYXNzd29yZDogPC9sYWJlbD5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2wgaGFzLWljb25zLWxlZnRcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgY2xhc3M9XCJpbnB1dFwiIHYtYmluZDpjbGFzcz1cInsgJ2lzLWRhbmdlcic6IGJsYW5rUGFzc3dvcmQgfVwiIGlkPVwicmVnLXBhc3N3b3JkXCIgdi1tb2RlbD1cInBhc3N3b3JkXCIgcGxhY2Vob2xkZXI9XCJQYXNzd29yZFwiIHJlcXVpcmVkPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLWxvY2tcIj48L2k+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgICAgIFJFQ0FQVENIQSBQTEFDRUhPTERFUlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZXJyb3JNZXNzYWdlXCIgdi1mb3I9XCJlcnJvciBpbiBlcnJvck1lc3NhZ2VcIiB2LWlmPVwiZXJyb3JNZXNzYWdlICE9ICcnXCI+XG4gICAgICAgICAgICAgIHt7IGVycm9yIH19XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgICA8Zm9vdGVyIGNsYXNzPVwibW9kYWwtY2FyZC1mb290XCI+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gaXMtc3VjY2Vzc1wiIEBjbGljaz1cIlJlZ2lzdGVyXCIgdi1iaW5kOmNsYXNzPVwieyAnaXMtbG9hZGluZyc6IGlzTG9hZGluZyB9XCI+UmVnaXN0ZXI8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiIEBjbGljaz1cInNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiAhU2hvd1JlZ2lzdGVyTW9kYWwgfSlcIj5DYW5jZWw8L2J1dHRvbj5cbiAgICAgIDwvZm9vdGVyPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBtYXBHZXR0ZXJzLCBtYXBNdXRhdGlvbnMgfSBmcm9tICd2dWV4JztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcm5hbWU6ICcnLFxuICAgICAgICBlbWFpbDogJycsXG4gICAgICAgIHBhc3N3b3JkOiAnJyxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBbXSxcbiAgICAgICAgaW52YWxpZFVzZXJuYW1lOiBmYWxzZSxcbiAgICAgICAgaW52YWxpZEVtYWlsOiBmYWxzZSxcbiAgICAgICAgYmxhbmtQYXNzd29yZDogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiBtYXBHZXR0ZXJzKFtcbiAgICAgICdTaG93UmVnaXN0ZXJNb2RhbCcsXG4gICAgICAnZ2V0VXNlckRhdGEnXG4gICAgXSksXG4gICAgbWV0aG9kczoge1xuICAgICAgLi4ubWFwTXV0YXRpb25zKFtcbiAgICAgICAgJ3NldFJlZ2lzdGVyTW9kYWwnLFxuICAgICAgICAnc2V0VXNlckRhdGEnLFxuICAgICAgICAnc2V0TG9nZ2VkSW4nXG4gICAgICBdKSxcbiAgICAgIFJlZ2lzdGVyKCkge1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gW107XG4gICAgICAgIHRoaXMuaW52YWxpZEVtYWlsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxhbmtQYXNzd29yZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmludmFsaWRVc2VybmFtZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5SZWdpc3RyYXRpb25Jc1ZhbGlkKCkpIHtcblxuICAgICAgICAgIGF4aW9zLnBvc3QoJy9yZWdpc3RlcicsIHtcbiAgICAgICAgICAgIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lLFxuICAgICAgICAgICAgZW1haWw6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICBwYXNzd29yZDogdGhpcy5wYXNzd29yZFxuICAgICAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaXNGYWxzZSA9ICFkYXRhLmRhdGEuRXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpc0ZhbHNlXCIsIGlzRmFsc2UpXG4gICAgICAgICAgICBpZiAoIWRhdGEuZGF0YS5FcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRVc2VyRGF0YSh7IHVzZXJEYXRhOiBkYXRhLmRhdGEgfSlcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJnZXRVc2VyRGF0YVwiLCB0aGlzLmdldFVzZXJEYXRhKVxuICAgICAgICAgICAgICB0aGlzLnNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiBmYWxzZSB9KVxuICAgICAgICAgICAgICB0aGlzLnNldExvZ2dlZEluKHsgbG9nZ2VkSW46IHRydWUgfSlcbiAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy4kc3RvcmUuc3RhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UucHVzaChkYXRhLmRhdGEuRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtc2cuaW5kZXhPZihcIlVzZXJuYW1lXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZFVzZXJuYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1zZy5pbmRleE9mKFwiRW1haWxcIikgPi0xKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRFbWFpbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFJlZ2lzdHJhdGlvbklzVmFsaWQoKSB7XG4gICAgICAgIHZhciBlbWFpbFZhbGlkYXRpb24gPSB0aGlzLmVtYWlsLm1hdGNoKG5ldyBSZWdFeHAoL14oKFtePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC8pLCBcImlcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKGVtYWlsVmFsaWRhdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmVtYWlsID09IFwiXCIpIHtcbiAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZS5wdXNoKFwiVXNlcm5hbWUgY2Fubm90IGJlIGxlZnQgZW1wdHkuXCIpXG4gICAgICAgICAgdGhpcy5pbnZhbGlkVXNlcm5hbWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbWFpbFZhbGlkYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlLnB1c2goXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbC5cIilcbiAgICAgICAgICB0aGlzLmludmFsaWRFbWFpbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFzc3dvcmQgPT0gJycgfHwgdGhpcy5wYXNzd29yZC5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UucHVzaChcIlBhc3N3b3JkIGNhbm5vdCBiZSBsZWZ0IGVtcHR5IGFuZCBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycy5cIilcbiAgICAgICAgICB0aGlzLmJsYW5rUGFzc3dvcmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVycm9yTWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD5cbjxzdHlsZT5cbiAgLmVycm9yTWVzc2FnZSB7XG4gICAgY29sb3I6ICNmZjM4NjA7XG4gIH1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVnaXN0ZXIudnVlPzYwMGNmMzUyIiwiPHRlbXBsYXRlPlxuICA8ZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJmbGV4LWNlbnRlciBmbCBsaXZlLWhlYWRlclwiIHYtaWY9XCIhaXNMb2FkaW5nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibGl2ZS1oZWFkZXItYm94XCI+XG4gICAgICAgIDxkaXY+U2Vzc2lvbiBFdmVudDogPHNwYW4gY2xhc3M9XCJ0ZXh0LWhpZ2hsaWdodCBmbC1yaWdodFwiPnt7cmFjZURhdGEucmFjZURhdGEuU319PC9zcGFuPjwvZGl2PlxuICAgICAgICA8ZGl2PlNlYXNvbiBFdmVudDo8c3BhbiBjbGFzcz1cInRleHQtaGlnaGxpZ2h0IGZsLXJpZ2h0XCI+IHt7cmFjZURhdGEucmFjZURhdGEuRX19PC9zcGFuPjwvZGl2PlxuICAgICAgICA8ZGl2PlNlc3Npb24gU3RhdHVzOjxzcGFuIGNsYXNzPVwidGV4dC1oaWdobGlnaHQgZmwtcmlnaHRcIj4ge3tyYWNlRGF0YS5yYWNlRGV0YWlscy5CfX08L3NwYW4+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiY29sdW1ucyBsZWFkZXJib2FyZFwiPlxuICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy1oYWxmIGlzLW9mZnNldC1vbmUtcXVhcnRlclwiPlxuICAgICAgICA8dGFibGUgY2xhc3M9XCJ0YWJsZS1saXZlXCIgdi1pZj1cIiFpc0xvYWRpbmdcIj5cbiAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgIDx0aD5Qb3NpdGlvbjwvdGg+XG4gICAgICAgICAgICAgIDx0aD5Ub3RhbCBQb2ludHM8L3RoPlxuICAgICAgICAgICAgICA8dGg+VXNlcm5hbWU8L3RoPlxuICAgICAgICAgICAgICA8dGg+UG9pbnRzIEJhY2s8L3RoPlxuICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgIDx0Zm9vdD5cbiAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgPHRoPlBvc2l0aW9uPC90aD5cbiAgICAgICAgICAgICAgPHRoPlRvdGFsIFBvaW50czwvdGg+XG4gICAgICAgICAgICAgIDx0aD5Vc2VybmFtZTwvdGg+XG4gICAgICAgICAgICAgIDx0aD5Qb2ludHMgQmFjazwvdGg+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICAgIDwvdGZvb3Q+XG4gICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgPHRyIHYtZm9yPVwiKHVzZXIsIGluZGV4KSBpbiBzdGFuZGluZ3NcIiB2LWJpbmQ6Y2xhc3M9XCJbIHVzZXIudXNlcm5hbWUgPT0gZ2V0VXNlckRhdGEudXNlcm5hbWUgPyAnbXlSb3cnIDogJyddXCI+XG4gICAgICAgICAgICAgIDx0ZD57eyBpbmRleCArIDEgfX0uPC90ZD5cbiAgICAgICAgICAgICAgPHRkPnt7dXNlci50b3RhbH19PC90ZD5cbiAgICAgICAgICAgICAgPHRkPnt7dXNlci51c2VybmFtZX19PC90ZD5cbiAgICAgICAgICAgICAgPHRkIGNsYXNzPVwicG9pbnRzYmFja1wiPnt7IHBvaW50c2JlaGluZCh1c2VyKSB9fTwvdGQ+XG4gICAgICAgICAgICA8L3RyPlxuICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgIDwvdGFibGU+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyBtYXBHZXR0ZXJzIH0gZnJvbSAndnVleCc7XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVhZ3VlRGF0YTogW10sXG4gICAgICAgIHJhY2VEYXRhOiBbXSxcbiAgICAgICAgaXNMb2FkaW5nOiB0cnVlLFxuICAgICAgICB3czogbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIC4uLm1hcEdldHRlcnMoW1xuICAgICAgICAnZ2V0VXNlckRhdGEnXG4gICAgICBdKSxcbiAgICAgIHN0YW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlYWd1ZURhdGEuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgIHJldHVybiBhLnRvdGFsIC0gYi50b3RhbDtcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZWQoKSB7XG4gICAgICBjb25zb2xlLmxvZyhwcm9jZXNzLmVudi5OT0RFX0VOVilcbiAgICAgIHRoaXMud3MgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PSAncHJvZHVjdGlvbidcbiAgICAgICAgPyBuZXcgV2ViU29ja2V0KFwid3NzOi8vZmFudGFzeXN4Lmhlcm9rdWFwcC5jb20vdHJhY2tlclwiKVxuICAgICAgICA6IG5ldyBXZWJTb2NrZXQoXCJ3c3M6Ly9sb2NhbGhvc3Q6MzAwMC90cmFja2VyXCIpO1xuXG4gICAgICB2YXIgdiA9IHRoaXM7XG4gICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShlLmRhdGEpO1xuICAgICAgICB2LmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB2LmxlYWd1ZURhdGEgPSBkYXRhLkxlYWd1ZURhdGE7XG4gICAgICAgIHYucmFjZURhdGEgPSBkYXRhLlJhY2VEYXRhO1xuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxuICAgICAgfVxuICAgICAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvclwiLCBlKVxuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczogIHtcbiAgICAgIHBvaW50c2JlaGluZDogZnVuY3Rpb24odXNlcikge1xuICAgICAgICB2YXIgb2JqSW5kZXggPSB0aGlzLmxlYWd1ZURhdGEuaW5kZXhPZih1c2VyKTtcbiAgICAgICAgaWYgKG9iakluZGV4ICE9IDApIHtcbiAgICAgICAgICByZXR1cm4gdXNlci50b3RhbCAtIHRoaXMubGVhZ3VlRGF0YVswXS50b3RhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJy0nXG4gICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEZXN0cm95KCkge1xuICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4uZmxleC1jZW50ZXIge1xuICBkaXNwbGF5OmZsZXg7XG4gIGp1c3RpZnktY29udGVudDpjZW50ZXI7XG59XG4ubGl2ZS1oZWFkZXItYm94IHtcbiAgbWluLXdpZHRoOiAzNjBweDtcbn1cbi5saXZlLWhlYWRlciB7XG4gIGNvbG9yOiB3aGl0ZTtcbiAgZm9udC1zaXplOiAxMnB0O1xuICBtYXJnaW4tdG9wOiAzcmVtO1xuICBmb250LXdlaWdodDogNzAwO1xufVxuLnRleHQtaGlnaGxpZ2h0IHtcbiAgICBmb250LXNpemU6IDEycHQ7XG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgICBjb2xvcjogI2ZmZmM3Zjtcbn1cbi5mbC1yaWdodCB7XG4gIGZsb2F0OiByaWdodDtcbn1cbiAgLm15Um93IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjU1LCAyMzMsIDEyMCwgLjM1KSAhaW1wb3J0YW50O1xuICB9XG4gIC50YWJsZS1saXZlIHRhYmxlIHRkIHtcbiAgICBib3JkZXI6IG5vbmU7XG4gIH1cbiAgLnRhYmxlLWxpdmUge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjgpO1xuICAgIGNvbG9yOiAjN2I3YjdiO1xuICAgIGJveC1zaGFkb3c6IDFweCAxcHggMTBweCAjMjIyO1xuICB9XG4gIC50YWJsZS1saXZlIHRoZWFkLCB0Zm9vdCB7XG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHJnYmEoMjU1LCAxMDYsIDAsIDEpMCUsIHJnYmEoMTU2LCA1MiwgMCwgMSkxMDAlKTtcbiAgfVxuICAudGFibGUtbGl2ZSB0aGVhZCB0aCwgdGZvb3QgdGgge1xuICAgIGNvbG9yOiAjZmZmO1xuICAgIGZvbnQtc2l6ZTogMTJwdDtcbiAgfVxuICAudGFibGUtbGl2ZSB0cjpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDIzMywgMTIwLCAuMik7XG4gIH1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3RhdHRyYWNrZXIudnVlPzRmYjkzNTI0IiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIHN1Z2dlc3Rpb25zLWNvbnRhaW5lclwiPlxuICAgICAgPHNlY3Rpb24+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgICAgICA8bGFiZWw+QXJlIHlvdSBhIHJlZ2lzdGVyZWQgdXNlcj88L2xhYmVsPlxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwicmFkaW9cIj5cbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJSZWdpc3RlcmVkXCIgdmFsdWU9XCJ0cnVlXCIgdi1tb2RlbD1cIlJlZ2lzdGVyZWRcIj5cbiAgICAgICAgICAgICAgWWVzXG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwicmFkaW9cIj5cbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJSZWdpc3RlcmVkXCIgdmFsdWU9XCJmYWxzZVwiIHYtbW9kZWw9XCJSZWdpc3RlcmVkXCI+XG4gICAgICAgICAgICAgIE5vXG4gICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2xcIj5cbiAgICAgICAgICAgIDxsYWJlbD5JcyB0aGlzIGZlZWRiYWNrIG9yIGEgYnVnIHJlcG9ydD88L2xhYmVsPlxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwicmFkaW9cIj5cbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJmZWVkYmFja1wiIHYtbW9kZWw9XCJSZXBvcnRUeXBlXCIgdmFsdWU9XCJmZWVkYmFja1wiPlxuICAgICAgICAgICAgICBGZWVkYmFja1xuICAgICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInJhZGlvXCI+XG4gICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwiZmVlZGJhY2tcIiB2LW1vZGVsPVwiUmVwb3J0VHlwZVwiIHZhbHVlPVwiYnVnXCI+XG4gICAgICAgICAgICAgIEJ1ZyBSZXBvcnRcbiAgICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJsYWJlbFwiPlVzZXJuYW1lPC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImlucHV0XCIgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cIlVzZXJuYW1lXCIgdi1tb2RlbD1cIlVzZXJuYW1lXCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiIHYtaWY9XCJSZXBvcnRUeXBlID09ICdmZWVkYmFjaydcIj5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJsYWJlbFwiPlN1Z2dlc3QgRmVhdHVyZXM8L2xhYmVsPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VsZWN0XCI+XG4gICAgICAgICAgICAgIDxzZWxlY3Qgdi1tb2RlbD1cImZlYXR1cmVcIj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIGRpc2FibGVkIHZhbHVlPVwiXCI+U0VMRUNUIENBVEVHT1JZPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbj5Vc2VyIEludGVyZmFjZTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24+TmF2aWdhdGlvbiBDb250ZW50PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbj5NeSBUZWFtPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbj5TY29yaW5nPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbj5OZXcgRmVhdHVyZXM8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uPlN0YXQgVHJhY2tlcjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24+QWNjb3VudDwvb3B0aW9uPlxuICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCIgdi1pZj1cIlJlcG9ydFR5cGUgPT0gJ2ZlZWRiYWNrJ1wiPlxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImxhYmVsXCI+RmVlZGJhY2s8L2xhYmVsPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XG4gICAgICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJ0ZXh0YXJlYVwiIHYtbW9kZWw9XCJmZWVkYmFja1wiIHBsYWNlaG9sZGVyPVwiRGVzY3JpYmUgeW91ciBzdWdnZXN0aW9ucyBoZXJlLlwiPjwvdGV4dGFyZWE+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIiB2LWlmPVwiUmVwb3J0VHlwZSA9PSAnYnVnJ1wiPlxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImxhYmVsXCI+UmVwb3J0IEJ1ZzwvbGFiZWw+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2xcIj5cbiAgICAgICAgICAgIDx0ZXh0YXJlYSBjbGFzcz1cInRleHRhcmVhXCIgdi1tb2RlbD1cImJ1Z3JlcG9ydFwiIHBsYWNlaG9sZGVyPVwiRGVzY3JpYmUgdGhlIGFjdGlvbnMgeW91IHRvb2ssIHlvdXIgZGVzaXJlZCBvdXRjb21lIGFuZCB0aGUgYWN0dWFsIG91dGNvbWUgb2YgdGhvc2UgYWN0aW9ucy4gV2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVwbGljYXRlIHRoZSBidWcgYmFzZWQgb2ZmIHRoZSBzdGVwcyB5b3UgcHJvdmlkZSBoZXJlLlwiPjwvdGV4dGFyZWE+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cbiAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGlzLXByaW1hcnlcIiB2LW9uOmNsaWNrPVwic3VibWl0XCIgdHlwZT1cImJ1dHRvblwiPlN1Ym1pdDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvc2VjdGlvbj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgVXNlcm5hbWU6ICcnLFxuICAgICAgICBSZXBvcnRUeXBlOiAnJyxcbiAgICAgICAgUmVnaXN0ZXJlZDogZmFsc2UsXG4gICAgICAgIGZlYXR1cmU6ICcnLFxuICAgICAgICBidWdyZXBvcnQ6ICcnLFxuICAgICAgICBmZWVkYmFjazogJydcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHN1Ym1pdCgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgVXNlcm5hbWU6IHRoaXMuVXNlcm5hbWUsXG4gICAgICAgICAgUmVwb3J0VHlwZTogdGhpcy5SZXBvcnRUeXBlLFxuICAgICAgICAgIFJlZ2lzdGVyZWQ6IHRoaXMuUmVnaXN0ZXJlZCxcbiAgICAgICAgICBGZWF0dXJlOiB0aGlzLmZlYXR1cmUsXG4gICAgICAgICAgQnVnUmVwb3J0OiB0aGlzLmJ1Z3JlcG9ydCxcbiAgICAgICAgICBGZWVkYmFjazogdGhpcy5mZWVkYmFja1xuICAgICAgICB9XG4gICAgICAgIGF4aW9zLnBvc3QoJy9mZWVkYmFjaycsIGRhdGEpXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2cocmVzKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4gIC5zdWdnZXN0aW9ucy1jb250YWluZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgbWFyZ2luLXRvcDogM3JlbTtcbiAgfVxuPC9zdHlsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzdWdnZXN0aW9ucy52dWU/YTc4ZGIwNTYiLCI8dGVtcGxhdGU+XG4gIDxkaXYgaWQ9XCJhcHBcIj5cbiAgICA8bmF2aWdhdGlvbj48L25hdmlnYXRpb24+XG4gICAgPHJvdXRlci12aWV3Pjwvcm91dGVyLXZpZXc+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHN0eWxlPlxuPC9zdHlsZT5cblxuPHNjcmlwdD5cbmltcG9ydCBuYXZiYXIgZnJvbSAnLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXIudnVlJztcbmV4cG9ydCBkZWZhdWx0IHtcbiAgY29tcHV0ZWQ6IHtcbiAgICB1c2VybmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuc3RhdGUudXNlcm5hbWVcbiAgICB9LFxuICAgIGlzTG9nZ2VkSW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLnN0YXRlLmlzTG9nZ2VkSW5cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudHM6IHtcbiAgICAnbmF2aWdhdGlvbic6IG5hdmJhclxuICB9XG59XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBpbmRleC52dWU/ZGZjNDQ5ZWUiLCIvKipcbiAgKiB2dWUtcm91dGVyIHYyLjcuMFxuICAqIChjKSAyMDE3IEV2YW4gWW91XG4gICogQGxpY2Vuc2UgTUlUXG4gICovXG4vKiAgKi9cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybiAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25kaXRpb24pIHtcbiAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Vycm9yIChlcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpLmluZGV4T2YoJ0Vycm9yJykgPiAtMVxufVxuXG52YXIgVmlldyA9IHtcbiAgbmFtZTogJ3JvdXRlci12aWV3JyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGVmYXVsdCdcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChfLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG5cbiAgICBkYXRhLnJvdXRlclZpZXcgPSB0cnVlO1xuXG4gICAgLy8gZGlyZWN0bHkgdXNlIHBhcmVudCBjb250ZXh0J3MgY3JlYXRlRWxlbWVudCgpIGZ1bmN0aW9uXG4gICAgLy8gc28gdGhhdCBjb21wb25lbnRzIHJlbmRlcmVkIGJ5IHJvdXRlci12aWV3IGNhbiByZXNvbHZlIG5hbWVkIHNsb3RzXG4gICAgdmFyIGggPSBwYXJlbnQuJGNyZWF0ZUVsZW1lbnQ7XG4gICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICAgIHZhciByb3V0ZSA9IHBhcmVudC4kcm91dGU7XG4gICAgdmFyIGNhY2hlID0gcGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgfHwgKHBhcmVudC5fcm91dGVyVmlld0NhY2hlID0ge30pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGN1cnJlbnQgdmlldyBkZXB0aCwgYWxzbyBjaGVjayB0byBzZWUgaWYgdGhlIHRyZWVcbiAgICAvLyBoYXMgYmVlbiB0b2dnbGVkIGluYWN0aXZlIGJ1dCBrZXB0LWFsaXZlLlxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIGluYWN0aXZlID0gZmFsc2U7XG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuX3JvdXRlclJvb3QgIT09IHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC4kdm5vZGUgJiYgcGFyZW50LiR2bm9kZS5kYXRhLnJvdXRlclZpZXcpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQuX2luYWN0aXZlKSB7XG4gICAgICAgIGluYWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBkYXRhLnJvdXRlclZpZXdEZXB0aCA9IGRlcHRoO1xuXG4gICAgLy8gcmVuZGVyIHByZXZpb3VzIHZpZXcgaWYgdGhlIHRyZWUgaXMgaW5hY3RpdmUgYW5kIGtlcHQtYWxpdmVcbiAgICBpZiAoaW5hY3RpdmUpIHtcbiAgICAgIHJldHVybiBoKGNhY2hlW25hbWVdLCBkYXRhLCBjaGlsZHJlbilcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZCA9IHJvdXRlLm1hdGNoZWRbZGVwdGhdO1xuICAgIC8vIHJlbmRlciBlbXB0eSBub2RlIGlmIG5vIG1hdGNoZWQgcm91dGVcbiAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgIGNhY2hlW25hbWVdID0gbnVsbDtcbiAgICAgIHJldHVybiBoKClcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50ID0gY2FjaGVbbmFtZV0gPSBtYXRjaGVkLmNvbXBvbmVudHNbbmFtZV07XG5cbiAgICAvLyBhdHRhY2ggaW5zdGFuY2UgcmVnaXN0cmF0aW9uIGhvb2tcbiAgICAvLyB0aGlzIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBpbnN0YW5jZSdzIGluamVjdGVkIGxpZmVjeWNsZSBob29rc1xuICAgIGRhdGEucmVnaXN0ZXJSb3V0ZUluc3RhbmNlID0gZnVuY3Rpb24gKHZtLCB2YWwpIHtcbiAgICAgIC8vIHZhbCBjb3VsZCBiZSB1bmRlZmluZWQgZm9yIHVucmVnaXN0cmF0aW9uXG4gICAgICB2YXIgY3VycmVudCA9IG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICAodmFsICYmIGN1cnJlbnQgIT09IHZtKSB8fFxuICAgICAgICAoIXZhbCAmJiBjdXJyZW50ID09PSB2bSlcbiAgICAgICkge1xuICAgICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbHNvIHJlZ2lzZXRlciBpbnN0YW5jZSBpbiBwcmVwYXRjaCBob29rXG4gICAgLy8gaW4gY2FzZSB0aGUgc2FtZSBjb21wb25lbnQgaW5zdGFuY2UgaXMgcmV1c2VkIGFjcm9zcyBkaWZmZXJlbnQgcm91dGVzXG4gICAgOyhkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KSkucHJlcGF0Y2ggPSBmdW5jdGlvbiAoXywgdm5vZGUpIHtcbiAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgfTtcblxuICAgIC8vIHJlc29sdmUgcHJvcHNcbiAgICBkYXRhLnByb3BzID0gcmVzb2x2ZVByb3BzKHJvdXRlLCBtYXRjaGVkLnByb3BzICYmIG1hdGNoZWQucHJvcHNbbmFtZV0pO1xuXG4gICAgcmV0dXJuIGgoY29tcG9uZW50LCBkYXRhLCBjaGlsZHJlbilcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVByb3BzIChyb3V0ZSwgY29uZmlnKSB7XG4gIHN3aXRjaCAodHlwZW9mIGNvbmZpZykge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiBjb25maWcocm91dGUpXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY29uZmlnID8gcm91dGUucGFyYW1zIDogdW5kZWZpbmVkXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJwcm9wcyBpbiBcXFwiXCIgKyAocm91dGUucGF0aCkgKyBcIlxcXCIgaXMgYSBcIiArICh0eXBlb2YgY29uZmlnKSArIFwiLCBcIiArXG4gICAgICAgICAgXCJleHBlY3RpbmcgYW4gb2JqZWN0LCBmdW5jdGlvbiBvciBib29sZWFuLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBlbmNvZGVSZXNlcnZlUkUgPSAvWyEnKCkqXS9nO1xudmFyIGVuY29kZVJlc2VydmVSZXBsYWNlciA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpOyB9O1xudmFyIGNvbW1hUkUgPSAvJTJDL2c7XG5cbi8vIGZpeGVkIGVuY29kZVVSSUNvbXBvbmVudCB3aGljaCBpcyBtb3JlIGNvbmZvcm1hbnQgdG8gUkZDMzk4Njpcbi8vIC0gZXNjYXBlcyBbIScoKSpdXG4vLyAtIHByZXNlcnZlIGNvbW1hc1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIC5yZXBsYWNlKGVuY29kZVJlc2VydmVSRSwgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyKVxuICAucmVwbGFjZShjb21tYVJFLCAnLCcpOyB9O1xuXG52YXIgZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50O1xuXG5mdW5jdGlvbiByZXNvbHZlUXVlcnkgKFxuICBxdWVyeSxcbiAgZXh0cmFRdWVyeSxcbiAgX3BhcnNlUXVlcnlcbikge1xuICBpZiAoIGV4dHJhUXVlcnkgPT09IHZvaWQgMCApIGV4dHJhUXVlcnkgPSB7fTtcblxuICB2YXIgcGFyc2UgPSBfcGFyc2VRdWVyeSB8fCBwYXJzZVF1ZXJ5O1xuICB2YXIgcGFyc2VkUXVlcnk7XG4gIHRyeSB7XG4gICAgcGFyc2VkUXVlcnkgPSBwYXJzZShxdWVyeSB8fCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oZmFsc2UsIGUubWVzc2FnZSk7XG4gICAgcGFyc2VkUXVlcnkgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gZXh0cmFRdWVyeSkge1xuICAgIHZhciB2YWwgPSBleHRyYVF1ZXJ5W2tleV07XG4gICAgcGFyc2VkUXVlcnlba2V5XSA9IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbC5zbGljZSgpIDogdmFsO1xuICB9XG4gIHJldHVybiBwYXJzZWRRdWVyeVxufVxuXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5IChxdWVyeSkge1xuICB2YXIgcmVzID0ge307XG5cbiAgcXVlcnkgPSBxdWVyeS50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0cy5zaGlmdCgpKTtcbiAgICB2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMFxuICAgICAgPyBkZWNvZGUocGFydHMuam9pbignPScpKVxuICAgICAgOiBudWxsO1xuXG4gICAgaWYgKHJlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc1trZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXNba2V5XSkpIHtcbiAgICAgIHJlc1trZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2tleV0gPSBbcmVzW2tleV0sIHZhbF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5IChvYmopIHtcbiAgdmFyIHJlcyA9IG9iaiA/IE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoa2V5KVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG4gICAgICAgIGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsMiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwyKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsKVxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfSkuam9pbignJicpIDogbnVsbDtcbiAgcmV0dXJuIHJlcyA/IChcIj9cIiArIHJlcykgOiAnJ1xufVxuXG4vKiAgKi9cblxuXG52YXIgdHJhaWxpbmdTbGFzaFJFID0gL1xcLz8kLztcblxuZnVuY3Rpb24gY3JlYXRlUm91dGUgKFxuICByZWNvcmQsXG4gIGxvY2F0aW9uLFxuICByZWRpcmVjdGVkRnJvbSxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIHN0cmluZ2lmeVF1ZXJ5JCQxID0gcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnN0cmluZ2lmeVF1ZXJ5O1xuICB2YXIgcm91dGUgPSB7XG4gICAgbmFtZTogbG9jYXRpb24ubmFtZSB8fCAocmVjb3JkICYmIHJlY29yZC5uYW1lKSxcbiAgICBtZXRhOiAocmVjb3JkICYmIHJlY29yZC5tZXRhKSB8fCB7fSxcbiAgICBwYXRoOiBsb2NhdGlvbi5wYXRoIHx8ICcvJyxcbiAgICBoYXNoOiBsb2NhdGlvbi5oYXNoIHx8ICcnLFxuICAgIHF1ZXJ5OiBsb2NhdGlvbi5xdWVyeSB8fCB7fSxcbiAgICBwYXJhbXM6IGxvY2F0aW9uLnBhcmFtcyB8fCB7fSxcbiAgICBmdWxsUGF0aDogZ2V0RnVsbFBhdGgobG9jYXRpb24sIHN0cmluZ2lmeVF1ZXJ5JCQxKSxcbiAgICBtYXRjaGVkOiByZWNvcmQgPyBmb3JtYXRNYXRjaChyZWNvcmQpIDogW11cbiAgfTtcbiAgaWYgKHJlZGlyZWN0ZWRGcm9tKSB7XG4gICAgcm91dGUucmVkaXJlY3RlZEZyb20gPSBnZXRGdWxsUGF0aChyZWRpcmVjdGVkRnJvbSwgc3RyaW5naWZ5UXVlcnkkJDEpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHJvdXRlKVxufVxuXG4vLyB0aGUgc3RhcnRpbmcgcm91dGUgdGhhdCByZXByZXNlbnRzIHRoZSBpbml0aWFsIHN0YXRlXG52YXIgU1RBUlQgPSBjcmVhdGVSb3V0ZShudWxsLCB7XG4gIHBhdGg6ICcvJ1xufSk7XG5cbmZ1bmN0aW9uIGZvcm1hdE1hdGNoIChyZWNvcmQpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB3aGlsZSAocmVjb3JkKSB7XG4gICAgcmVzLnVuc2hpZnQocmVjb3JkKTtcbiAgICByZWNvcmQgPSByZWNvcmQucGFyZW50O1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0RnVsbFBhdGggKFxuICByZWYsXG4gIF9zdHJpbmdpZnlRdWVyeVxuKSB7XG4gIHZhciBwYXRoID0gcmVmLnBhdGg7XG4gIHZhciBxdWVyeSA9IHJlZi5xdWVyeTsgaWYgKCBxdWVyeSA9PT0gdm9pZCAwICkgcXVlcnkgPSB7fTtcbiAgdmFyIGhhc2ggPSByZWYuaGFzaDsgaWYgKCBoYXNoID09PSB2b2lkIDAgKSBoYXNoID0gJyc7XG5cbiAgdmFyIHN0cmluZ2lmeSA9IF9zdHJpbmdpZnlRdWVyeSB8fCBzdHJpbmdpZnlRdWVyeTtcbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyBzdHJpbmdpZnkocXVlcnkpICsgaGFzaFxufVxuXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZSAoYSwgYikge1xuICBpZiAoYiA9PT0gU1RBUlQpIHtcbiAgICByZXR1cm4gYSA9PT0gYlxuICB9IGVsc2UgaWYgKCFiKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoYS5wYXRoICYmIGIucGF0aCkge1xuICAgIHJldHVybiAoXG4gICAgICBhLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSA9PT0gYi5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpXG4gICAgKVxuICB9IGVsc2UgaWYgKGEubmFtZSAmJiBiLm5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5uYW1lID09PSBiLm5hbWUgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucGFyYW1zLCBiLnBhcmFtcylcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFcXVhbCAoYSwgYikge1xuICBpZiAoIGEgPT09IHZvaWQgMCApIGEgPSB7fTtcbiAgaWYgKCBiID09PSB2b2lkIDAgKSBiID0ge307XG5cbiAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBhVmFsID0gYVtrZXldO1xuICAgIHZhciBiVmFsID0gYltrZXldO1xuICAgIC8vIGNoZWNrIG5lc3RlZCBlcXVhbGl0eVxuICAgIGlmICh0eXBlb2YgYVZhbCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJWYWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RFcXVhbChhVmFsLCBiVmFsKVxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGFWYWwpID09PSBTdHJpbmcoYlZhbClcbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNJbmNsdWRlZFJvdXRlIChjdXJyZW50LCB0YXJnZXQpIHtcbiAgcmV0dXJuIChcbiAgICBjdXJyZW50LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJykuaW5kZXhPZihcbiAgICAgIHRhcmdldC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpXG4gICAgKSA9PT0gMCAmJlxuICAgICghdGFyZ2V0Lmhhc2ggfHwgY3VycmVudC5oYXNoID09PSB0YXJnZXQuaGFzaCkgJiZcbiAgICBxdWVyeUluY2x1ZGVzKGN1cnJlbnQucXVlcnksIHRhcmdldC5xdWVyeSlcbiAgKVxufVxuXG5mdW5jdGlvbiBxdWVyeUluY2x1ZGVzIChjdXJyZW50LCB0YXJnZXQpIHtcbiAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgIGlmICghKGtleSBpbiBjdXJyZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qICAqL1xuXG4vLyB3b3JrIGFyb3VuZCB3ZWlyZCBmbG93IGJ1Z1xudmFyIHRvVHlwZXMgPSBbU3RyaW5nLCBPYmplY3RdO1xudmFyIGV2ZW50VHlwZXMgPSBbU3RyaW5nLCBBcnJheV07XG5cbnZhciBMaW5rID0ge1xuICBuYW1lOiAncm91dGVyLWxpbmsnLFxuICBwcm9wczoge1xuICAgIHRvOiB7XG4gICAgICB0eXBlOiB0b1R5cGVzLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2EnXG4gICAgfSxcbiAgICBleGFjdDogQm9vbGVhbixcbiAgICBhcHBlbmQ6IEJvb2xlYW4sXG4gICAgcmVwbGFjZTogQm9vbGVhbixcbiAgICBhY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV4YWN0QWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogZXZlbnRUeXBlcyxcbiAgICAgIGRlZmF1bHQ6ICdjbGljaydcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy4kcm91dGVyO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy4kcm91dGU7XG4gICAgdmFyIHJlZiA9IHJvdXRlci5yZXNvbHZlKHRoaXMudG8sIGN1cnJlbnQsIHRoaXMuYXBwZW5kKTtcbiAgICB2YXIgbG9jYXRpb24gPSByZWYubG9jYXRpb247XG4gICAgdmFyIHJvdXRlID0gcmVmLnJvdXRlO1xuICAgIHZhciBocmVmID0gcmVmLmhyZWY7XG5cbiAgICB2YXIgY2xhc3NlcyA9IHt9O1xuICAgIHZhciBnbG9iYWxBY3RpdmVDbGFzcyA9IHJvdXRlci5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcztcbiAgICB2YXIgZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyA9IHJvdXRlci5vcHRpb25zLmxpbmtFeGFjdEFjdGl2ZUNsYXNzO1xuICAgIC8vIFN1cHBvcnQgZ2xvYmFsIGVtcHR5IGFjdGl2ZSBjbGFzc1xuICAgIHZhciBhY3RpdmVDbGFzc0ZhbGxiYWNrID0gZ2xvYmFsQWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyAncm91dGVyLWxpbmstYWN0aXZlJ1xuICAgICAgICAgICAgOiBnbG9iYWxBY3RpdmVDbGFzcztcbiAgICB2YXIgZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrID0gZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/ICdyb3V0ZXItbGluay1leGFjdC1hY3RpdmUnXG4gICAgICAgICAgICA6IGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3M7XG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gdGhpcy5hY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/IGFjdGl2ZUNsYXNzRmFsbGJhY2tcbiAgICAgICAgICAgIDogdGhpcy5hY3RpdmVDbGFzcztcbiAgICB2YXIgZXhhY3RBY3RpdmVDbGFzcyA9IHRoaXMuZXhhY3RBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/IGV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFja1xuICAgICAgICAgICAgOiB0aGlzLmV4YWN0QWN0aXZlQ2xhc3M7XG4gICAgdmFyIGNvbXBhcmVUYXJnZXQgPSBsb2NhdGlvbi5wYXRoXG4gICAgICA/IGNyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uLCBudWxsLCByb3V0ZXIpXG4gICAgICA6IHJvdXRlO1xuXG4gICAgY2xhc3Nlc1tleGFjdEFjdGl2ZUNsYXNzXSA9IGlzU2FtZVJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuICAgIGNsYXNzZXNbYWN0aXZlQ2xhc3NdID0gdGhpcy5leGFjdFxuICAgICAgPyBjbGFzc2VzW2V4YWN0QWN0aXZlQ2xhc3NdXG4gICAgICA6IGlzSW5jbHVkZWRSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KTtcblxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChndWFyZEV2ZW50KGUpKSB7XG4gICAgICAgIGlmICh0aGlzJDEucmVwbGFjZSkge1xuICAgICAgICAgIHJvdXRlci5yZXBsYWNlKGxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZXIucHVzaChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9uID0geyBjbGljazogZ3VhcmRFdmVudCB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZXZlbnQpKSB7XG4gICAgICB0aGlzLmV2ZW50LmZvckVhY2goZnVuY3Rpb24gKGUpIHsgb25bZV0gPSBoYW5kbGVyOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25bdGhpcy5ldmVudF0gPSBoYW5kbGVyO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgY2xhc3M6IGNsYXNzZXNcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMudGFnID09PSAnYScpIHtcbiAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIGRhdGEuYXR0cnMgPSB7IGhyZWY6IGhyZWYgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmluZCB0aGUgZmlyc3QgPGE+IGNoaWxkIGFuZCBhcHBseSBsaXN0ZW5lciBhbmQgaHJlZlxuICAgICAgdmFyIGEgPSBmaW5kQW5jaG9yKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgPGE+IGlzIGEgc3RhdGljIG5vZGVcbiAgICAgICAgYS5pc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXh0ZW5kID0gX1Z1ZS51dGlsLmV4dGVuZDtcbiAgICAgICAgdmFyIGFEYXRhID0gYS5kYXRhID0gZXh0ZW5kKHt9LCBhLmRhdGEpO1xuICAgICAgICBhRGF0YS5vbiA9IG9uO1xuICAgICAgICB2YXIgYUF0dHJzID0gYS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhLmRhdGEuYXR0cnMpO1xuICAgICAgICBhQXR0cnMuaHJlZiA9IGhyZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb2Vzbid0IGhhdmUgPGE+IGNoaWxkLCBhcHBseSBsaXN0ZW5lciB0byBzZWxmXG4gICAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaCh0aGlzLnRhZywgZGF0YSwgdGhpcy4kc2xvdHMuZGVmYXVsdClcbiAgfVxufTtcblxuZnVuY3Rpb24gZ3VhcmRFdmVudCAoZSkge1xuICAvLyBkb24ndCByZWRpcmVjdCB3aXRoIGNvbnRyb2wga2V5c1xuICBpZiAoZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcbiAgaWYgKGUuYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b24gIT09IDApIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3QgaWYgYHRhcmdldD1cIl9ibGFua1wiYFxuICBpZiAoZS5jdXJyZW50VGFyZ2V0ICYmIGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgaWYgKC9cXGJfYmxhbmtcXGIvaS50ZXN0KHRhcmdldCkpIHsgcmV0dXJuIH1cbiAgfVxuICAvLyB0aGlzIG1heSBiZSBhIFdlZXggZXZlbnQgd2hpY2ggZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kXG4gIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbmRBbmNob3IgKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIHZhciBjaGlsZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ2EnKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuICYmIChjaGlsZCA9IGZpbmRBbmNob3IoY2hpbGQuY2hpbGRyZW4pKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIF9WdWU7XG5cbmZ1bmN0aW9uIGluc3RhbGwgKFZ1ZSkge1xuICBpZiAoaW5zdGFsbC5pbnN0YWxsZWQpIHsgcmV0dXJuIH1cbiAgaW5zdGFsbC5pbnN0YWxsZWQgPSB0cnVlO1xuXG4gIF9WdWUgPSBWdWU7XG5cbiAgdmFyIGlzRGVmID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfTtcblxuICB2YXIgcmVnaXN0ZXJJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgY2FsbFZhbCkge1xuICAgIHZhciBpID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIGlmIChpc0RlZihpKSAmJiBpc0RlZihpID0gaS5kYXRhKSAmJiBpc0RlZihpID0gaS5yZWdpc3RlclJvdXRlSW5zdGFuY2UpKSB7XG4gICAgICBpKHZtLCBjYWxsVmFsKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLm1peGluKHtcbiAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSAoKSB7XG4gICAgICBpZiAoaXNEZWYodGhpcy4kb3B0aW9ucy5yb3V0ZXIpKSB7XG4gICAgICAgIHRoaXMuX3JvdXRlclJvb3QgPSB0aGlzO1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSB0aGlzLiRvcHRpb25zLnJvdXRlcjtcbiAgICAgICAgdGhpcy5fcm91dGVyLmluaXQodGhpcyk7XG4gICAgICAgIFZ1ZS51dGlsLmRlZmluZVJlYWN0aXZlKHRoaXMsICdfcm91dGUnLCB0aGlzLl9yb3V0ZXIuaGlzdG9yeS5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JvdXRlclJvb3QgPSAodGhpcy4kcGFyZW50ICYmIHRoaXMuJHBhcmVudC5fcm91dGVyUm9vdCkgfHwgdGhpcztcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgdGhpcyk7XG4gICAgfSxcbiAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGVyJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclJvb3QuX3JvdXRlciB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclJvb3QuX3JvdXRlIH1cbiAgfSk7XG5cbiAgVnVlLmNvbXBvbmVudCgncm91dGVyLXZpZXcnLCBWaWV3KTtcbiAgVnVlLmNvbXBvbmVudCgncm91dGVyLWxpbmsnLCBMaW5rKTtcblxuICB2YXIgc3RyYXRzID0gVnVlLmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG4gIC8vIHVzZSB0aGUgc2FtZSBob29rIG1lcmdpbmcgc3RyYXRlZ3kgZm9yIHJvdXRlIGhvb2tzXG4gIHN0cmF0cy5iZWZvcmVSb3V0ZUVudGVyID0gc3RyYXRzLmJlZm9yZVJvdXRlTGVhdmUgPSBzdHJhdHMuYmVmb3JlUm91dGVVcGRhdGUgPSBzdHJhdHMuY3JlYXRlZDtcbn1cblxuLyogICovXG5cbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRoIChcbiAgcmVsYXRpdmUsXG4gIGJhc2UsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBmaXJzdENoYXIgPSByZWxhdGl2ZS5jaGFyQXQoMCk7XG4gIGlmIChmaXJzdENoYXIgPT09ICcvJykge1xuICAgIHJldHVybiByZWxhdGl2ZVxuICB9XG5cbiAgaWYgKGZpcnN0Q2hhciA9PT0gJz8nIHx8IGZpcnN0Q2hhciA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIGJhc2UgKyByZWxhdGl2ZVxuICB9XG5cbiAgdmFyIHN0YWNrID0gYmFzZS5zcGxpdCgnLycpO1xuXG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzZWdtZW50IGlmOlxuICAvLyAtIG5vdCBhcHBlbmRpbmdcbiAgLy8gLSBhcHBlbmRpbmcgdG8gdHJhaWxpbmcgc2xhc2ggKGxhc3Qgc2VnbWVudCBpcyBlbXB0eSlcbiAgaWYgKCFhcHBlbmQgfHwgIXN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICAvLyByZXNvbHZlIHJlbGF0aXZlIHBhdGhcbiAgdmFyIHNlZ21lbnRzID0gcmVsYXRpdmUucmVwbGFjZSgvXlxcLy8sICcnKS5zcGxpdCgnLycpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSAnLicpIHtcbiAgICAgIHN0YWNrLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5zdXJlIGxlYWRpbmcgc2xhc2hcbiAgaWYgKHN0YWNrWzBdICE9PSAnJykge1xuICAgIHN0YWNrLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrLmpvaW4oJy8nKVxufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgdmFyIGhhc2ggPSAnJztcbiAgdmFyIHF1ZXJ5ID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICBoYXNoID0gcGF0aC5zbGljZShoYXNoSW5kZXgpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuICBpZiAocXVlcnlJbmRleCA+PSAwKSB7XG4gICAgcXVlcnkgPSBwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxKTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBxdWVyeUluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgaGFzaDogaGFzaFxuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuUGF0aCAocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC9cXC8vZywgJy8nKVxufVxuXG52YXIgaW5kZXgkMSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG52YXIgaW5kZXggPSBwYXRoVG9SZWdleHA7XG52YXIgcGFyc2VfMSA9IHBhcnNlO1xudmFyIGNvbXBpbGVfMSA9IGNvbXBpbGU7XG52YXIgdG9rZW5zVG9GdW5jdGlvbl8xID0gdG9rZW5zVG9GdW5jdGlvbjtcbnZhciB0b2tlbnNUb1JlZ0V4cF8xID0gdG9rZW5zVG9SZWdFeHA7XG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGtleSA9IDA7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBwYXRoID0gJyc7XG4gIHZhciBkZWZhdWx0RGVsaW1pdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlciB8fCAnLyc7XG4gIHZhciByZXM7XG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXTtcbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXTtcbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4O1xuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpO1xuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGg7XG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF07XG4gICAgdmFyIHByZWZpeCA9IHJlc1syXTtcbiAgICB2YXIgbmFtZSA9IHJlc1szXTtcbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XTtcbiAgICB2YXIgZ3JvdXAgPSByZXNbNV07XG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdO1xuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XTtcblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpO1xuICAgICAgcGF0aCA9ICcnO1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeDtcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonO1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXI7XG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwO1xuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleCk7XG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBleGlzdHMsIHB1c2ggaXQgb250byB0aGUgZW5kLlxuICBpZiAocGF0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpO1xuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJztcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlbjtcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdO1xuICAgICAgdmFyIHNlZ21lbnQ7XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4JDEodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSk7XG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXM7XG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBhc3RlcmlzazogZmFsc2UsXG4gICAgICAgIHBhdHRlcm46IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKTtcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaW5kZXgkMShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZTtcbiAgdmFyIHJvdXRlID0gJyc7XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpO1xuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSc7XG5cbiAgICAgIGtleXMucHVzaCh0b2tlbik7XG5cbiAgICAgIGlmICh0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/JztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpO1xuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlcjtcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/JztcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCc7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJztcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWluZGV4JDEoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGluZGV4JDEocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG5cbmluZGV4LnBhcnNlID0gcGFyc2VfMTtcbmluZGV4LmNvbXBpbGUgPSBjb21waWxlXzE7XG5pbmRleC50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvbl8xO1xuaW5kZXgudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cF8xO1xuXG4vKiAgKi9cblxudmFyIHJlZ2V4cENvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGZpbGxQYXJhbXMgKFxuICBwYXRoLFxuICBwYXJhbXMsXG4gIHJvdXRlTXNnXG4pIHtcbiAgdHJ5IHtcbiAgICB2YXIgZmlsbGVyID1cbiAgICAgIHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSB8fFxuICAgICAgKHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSA9IGluZGV4LmNvbXBpbGUocGF0aCkpO1xuICAgIHJldHVybiBmaWxsZXIocGFyYW1zIHx8IHt9LCB7IHByZXR0eTogdHJ1ZSB9KVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oZmFsc2UsIChcIm1pc3NpbmcgcGFyYW0gZm9yIFwiICsgcm91dGVNc2cgKyBcIjogXCIgKyAoZS5tZXNzYWdlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVNYXAgKFxuICByb3V0ZXMsXG4gIG9sZFBhdGhMaXN0LFxuICBvbGRQYXRoTWFwLFxuICBvbGROYW1lTWFwXG4pIHtcbiAgLy8gdGhlIHBhdGggbGlzdCBpcyB1c2VkIHRvIGNvbnRyb2wgcGF0aCBtYXRjaGluZyBwcmlvcml0eVxuICB2YXIgcGF0aExpc3QgPSBvbGRQYXRoTGlzdCB8fCBbXTtcbiAgdmFyIHBhdGhNYXAgPSBvbGRQYXRoTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBuYW1lTWFwID0gb2xkTmFtZU1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCByb3V0ZSk7XG4gIH0pO1xuXG4gIC8vIGVuc3VyZSB3aWxkY2FyZCByb3V0ZXMgYXJlIGFsd2F5cyBhdCB0aGUgZW5kXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aExpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHBhdGhMaXN0W2ldID09PSAnKicpIHtcbiAgICAgIHBhdGhMaXN0LnB1c2gocGF0aExpc3Quc3BsaWNlKGksIDEpWzBdKTtcbiAgICAgIGwtLTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhMaXN0OiBwYXRoTGlzdCxcbiAgICBwYXRoTWFwOiBwYXRoTWFwLFxuICAgIG5hbWVNYXA6IG5hbWVNYXBcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb3V0ZVJlY29yZCAoXG4gIHBhdGhMaXN0LFxuICBwYXRoTWFwLFxuICBuYW1lTWFwLFxuICByb3V0ZSxcbiAgcGFyZW50LFxuICBtYXRjaEFzXG4pIHtcbiAgdmFyIHBhdGggPSByb3V0ZS5wYXRoO1xuICB2YXIgbmFtZSA9IHJvdXRlLm5hbWU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHBhdGggIT0gbnVsbCwgXCJcXFwicGF0aFxcXCIgaXMgcmVxdWlyZWQgaW4gYSByb3V0ZSBjb25maWd1cmF0aW9uLlwiKTtcbiAgICBhc3NlcnQoXG4gICAgICB0eXBlb2Ygcm91dGUuY29tcG9uZW50ICE9PSAnc3RyaW5nJyxcbiAgICAgIFwicm91dGUgY29uZmlnIFxcXCJjb21wb25lbnRcXFwiIGZvciBwYXRoOiBcIiArIChTdHJpbmcocGF0aCB8fCBuYW1lKSkgKyBcIiBjYW5ub3QgYmUgYSBcIiArXG4gICAgICBcInN0cmluZyBpZC4gVXNlIGFuIGFjdHVhbCBjb21wb25lbnQgaW5zdGVhZC5cIlxuICAgICk7XG4gIH1cblxuICB2YXIgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgsIHBhcmVudCk7XG4gIHZhciBwYXRoVG9SZWdleHBPcHRpb25zID0gcm91dGUucGF0aFRvUmVnZXhwT3B0aW9ucyB8fCB7fTtcblxuICBpZiAodHlwZW9mIHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09ICdib29sZWFuJykge1xuICAgIHBhdGhUb1JlZ2V4cE9wdGlvbnMuc2Vuc2l0aXZlID0gcm91dGUuY2FzZVNlbnNpdGl2ZTtcbiAgfVxuXG4gIHZhciByZWNvcmQgPSB7XG4gICAgcGF0aDogbm9ybWFsaXplZFBhdGgsXG4gICAgcmVnZXg6IGNvbXBpbGVSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRQYXRoLCBwYXRoVG9SZWdleHBPcHRpb25zKSxcbiAgICBjb21wb25lbnRzOiByb3V0ZS5jb21wb25lbnRzIHx8IHsgZGVmYXVsdDogcm91dGUuY29tcG9uZW50IH0sXG4gICAgaW5zdGFuY2VzOiB7fSxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIG1hdGNoQXM6IG1hdGNoQXMsXG4gICAgcmVkaXJlY3Q6IHJvdXRlLnJlZGlyZWN0LFxuICAgIGJlZm9yZUVudGVyOiByb3V0ZS5iZWZvcmVFbnRlcixcbiAgICBtZXRhOiByb3V0ZS5tZXRhIHx8IHt9LFxuICAgIHByb3BzOiByb3V0ZS5wcm9wcyA9PSBudWxsXG4gICAgICA/IHt9XG4gICAgICA6IHJvdXRlLmNvbXBvbmVudHNcbiAgICAgICAgPyByb3V0ZS5wcm9wc1xuICAgICAgICA6IHsgZGVmYXVsdDogcm91dGUucHJvcHMgfVxuICB9O1xuXG4gIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgIC8vIFdhcm4gaWYgcm91dGUgaXMgbmFtZWQsIGRvZXMgbm90IHJlZGlyZWN0IGFuZCBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLlxuICAgIC8vIElmIHVzZXJzIG5hdmlnYXRlIHRvIHRoaXMgcm91dGUgYnkgbmFtZSwgdGhlIGRlZmF1bHQgY2hpbGQgd2lsbFxuICAgIC8vIG5vdCBiZSByZW5kZXJlZCAoR0ggSXNzdWUgIzYyOSlcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHJvdXRlLm5hbWUgJiYgIXJvdXRlLnJlZGlyZWN0ICYmIHJvdXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAvXlxcLz8kLy50ZXN0KGNoaWxkLnBhdGgpOyB9KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiTmFtZWQgUm91dGUgJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuIFwiICtcbiAgICAgICAgICBcIldoZW4gbmF2aWdhdGluZyB0byB0aGlzIG5hbWVkIHJvdXRlICg6dG89XFxcIntuYW1lOiAnXCIgKyAocm91dGUubmFtZSkgKyBcIidcXFwiKSwgXCIgK1xuICAgICAgICAgIFwidGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgd2lsbCBub3QgYmUgcmVuZGVyZWQuIFJlbW92ZSB0aGUgbmFtZSBmcm9tIFwiICtcbiAgICAgICAgICBcInRoaXMgcm91dGUgYW5kIHVzZSB0aGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSBmb3IgbmFtZWQgXCIgK1xuICAgICAgICAgIFwibGlua3MgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTWF0Y2hBcyA9IG1hdGNoQXNcbiAgICAgICAgPyBjbGVhblBhdGgoKG1hdGNoQXMgKyBcIi9cIiArIChjaGlsZC5wYXRoKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIGNoaWxkLCByZWNvcmQsIGNoaWxkTWF0Y2hBcyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocm91dGUuYWxpYXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBhbGlhc2VzID0gQXJyYXkuaXNBcnJheShyb3V0ZS5hbGlhcylcbiAgICAgID8gcm91dGUuYWxpYXNcbiAgICAgIDogW3JvdXRlLmFsaWFzXTtcblxuICAgIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgIHZhciBhbGlhc1JvdXRlID0ge1xuICAgICAgICBwYXRoOiBhbGlhcyxcbiAgICAgICAgY2hpbGRyZW46IHJvdXRlLmNoaWxkcmVuXG4gICAgICB9O1xuICAgICAgYWRkUm91dGVSZWNvcmQoXG4gICAgICAgIHBhdGhMaXN0LFxuICAgICAgICBwYXRoTWFwLFxuICAgICAgICBuYW1lTWFwLFxuICAgICAgICBhbGlhc1JvdXRlLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIHJlY29yZC5wYXRoIHx8ICcvJyAvLyBtYXRjaEFzXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFwYXRoTWFwW3JlY29yZC5wYXRoXSkge1xuICAgIHBhdGhMaXN0LnB1c2gocmVjb3JkLnBhdGgpO1xuICAgIHBhdGhNYXBbcmVjb3JkLnBhdGhdID0gcmVjb3JkO1xuICB9XG5cbiAgaWYgKG5hbWUpIHtcbiAgICBpZiAoIW5hbWVNYXBbbmFtZV0pIHtcbiAgICAgIG5hbWVNYXBbbmFtZV0gPSByZWNvcmQ7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFtYXRjaEFzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJEdXBsaWNhdGUgbmFtZWQgcm91dGVzIGRlZmluaXRpb246IFwiICtcbiAgICAgICAgXCJ7IG5hbWU6IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIHBhdGg6IFxcXCJcIiArIChyZWNvcmQucGF0aCkgKyBcIlxcXCIgfVwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21waWxlUm91dGVSZWdleCAocGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucykge1xuICB2YXIgcmVnZXggPSBpbmRleChwYXRoLCBbXSwgcGF0aFRvUmVnZXhwT3B0aW9ucyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGtleXMgPSB7fTtcbiAgICByZWdleC5rZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgd2Fybigha2V5c1trZXkubmFtZV0sIChcIkR1cGxpY2F0ZSBwYXJhbSBrZXlzIGluIHJvdXRlIHdpdGggcGF0aDogXFxcIlwiICsgcGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICBrZXlzW2tleS5uYW1lXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZ2V4XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGggKHBhdGgsIHBhcmVudCkge1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICBpZiAocGF0aFswXSA9PT0gJy8nKSB7IHJldHVybiBwYXRoIH1cbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7IHJldHVybiBwYXRoIH1cbiAgcmV0dXJuIGNsZWFuUGF0aCgoKHBhcmVudC5wYXRoKSArIFwiL1wiICsgcGF0aCkpXG59XG5cbi8qICAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICBhcHBlbmQsXG4gIHJvdXRlclxuKSB7XG4gIHZhciBuZXh0ID0gdHlwZW9mIHJhdyA9PT0gJ3N0cmluZycgPyB7IHBhdGg6IHJhdyB9IDogcmF3O1xuICAvLyBuYW1lZCB0YXJnZXRcbiAgaWYgKG5leHQubmFtZSB8fCBuZXh0Ll9ub3JtYWxpemVkKSB7XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIC8vIHJlbGF0aXZlIHBhcmFtc1xuICBpZiAoIW5leHQucGF0aCAmJiBuZXh0LnBhcmFtcyAmJiBjdXJyZW50KSB7XG4gICAgbmV4dCA9IGFzc2lnbih7fSwgbmV4dCk7XG4gICAgbmV4dC5fbm9ybWFsaXplZCA9IHRydWU7XG4gICAgdmFyIHBhcmFtcyA9IGFzc2lnbihhc3NpZ24oe30sIGN1cnJlbnQucGFyYW1zKSwgbmV4dC5wYXJhbXMpO1xuICAgIGlmIChjdXJyZW50Lm5hbWUpIHtcbiAgICAgIG5leHQubmFtZSA9IGN1cnJlbnQubmFtZTtcbiAgICAgIG5leHQucGFyYW1zID0gcGFyYW1zO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5tYXRjaGVkLmxlbmd0aCkge1xuICAgICAgdmFyIHJhd1BhdGggPSBjdXJyZW50Lm1hdGNoZWRbY3VycmVudC5tYXRjaGVkLmxlbmd0aCAtIDFdLnBhdGg7XG4gICAgICBuZXh0LnBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicGF0aCBcIiArIChjdXJyZW50LnBhdGgpKSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCBcInJlbGF0aXZlIHBhcmFtcyBuYXZpZ2F0aW9uIHJlcXVpcmVzIGEgY3VycmVudCByb3V0ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICB2YXIgcGFyc2VkUGF0aCA9IHBhcnNlUGF0aChuZXh0LnBhdGggfHwgJycpO1xuICB2YXIgYmFzZVBhdGggPSAoY3VycmVudCAmJiBjdXJyZW50LnBhdGgpIHx8ICcvJztcbiAgdmFyIHBhdGggPSBwYXJzZWRQYXRoLnBhdGhcbiAgICA/IHJlc29sdmVQYXRoKHBhcnNlZFBhdGgucGF0aCwgYmFzZVBhdGgsIGFwcGVuZCB8fCBuZXh0LmFwcGVuZClcbiAgICA6IGJhc2VQYXRoO1xuXG4gIHZhciBxdWVyeSA9IHJlc29sdmVRdWVyeShcbiAgICBwYXJzZWRQYXRoLnF1ZXJ5LFxuICAgIG5leHQucXVlcnksXG4gICAgcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnBhcnNlUXVlcnlcbiAgKTtcblxuICB2YXIgaGFzaCA9IG5leHQuaGFzaCB8fCBwYXJzZWRQYXRoLmhhc2g7XG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHtcbiAgICBoYXNoID0gXCIjXCIgKyBoYXNoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduIChhLCBiKSB7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgYVtrZXldID0gYltrZXldO1xuICB9XG4gIHJldHVybiBhXG59XG5cbi8qICAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIgKFxuICByb3V0ZXMsXG4gIHJvdXRlclxuKSB7XG4gIHZhciByZWYgPSBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMpO1xuICB2YXIgcGF0aExpc3QgPSByZWYucGF0aExpc3Q7XG4gIHZhciBwYXRoTWFwID0gcmVmLnBhdGhNYXA7XG4gIHZhciBuYW1lTWFwID0gcmVmLm5hbWVNYXA7XG5cbiAgZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcbiAgICBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMsIHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoIChcbiAgICByYXcsXG4gICAgY3VycmVudFJvdXRlLFxuICAgIHJlZGlyZWN0ZWRGcm9tXG4gICkge1xuICAgIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKHJhdywgY3VycmVudFJvdXRlLCBmYWxzZSwgcm91dGVyKTtcbiAgICB2YXIgbmFtZSA9IGxvY2F0aW9uLm5hbWU7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgdmFyIHJlY29yZCA9IG5hbWVNYXBbbmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKHJlY29yZCwgKFwiUm91dGUgd2l0aCBuYW1lICdcIiArIG5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3RcIikpO1xuICAgICAgfVxuICAgICAgaWYgKCFyZWNvcmQpIHsgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbikgfVxuICAgICAgdmFyIHBhcmFtTmFtZXMgPSByZWNvcmQucmVnZXgua2V5c1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFrZXkub3B0aW9uYWw7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5Lm5hbWU7IH0pO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uLnBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50Um91dGUgJiYgdHlwZW9mIGN1cnJlbnRSb3V0ZS5wYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50Um91dGUucGFyYW1zKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGxvY2F0aW9uLnBhcmFtcykgJiYgcGFyYW1OYW1lcy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgbG9jYXRpb24ucGFyYW1zW2tleV0gPSBjdXJyZW50Um91dGUucGFyYW1zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgbG9jYXRpb24ucGF0aCA9IGZpbGxQYXJhbXMocmVjb3JkLnBhdGgsIGxvY2F0aW9uLnBhcmFtcywgKFwibmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRoKSB7XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoTGlzdFtpXTtcbiAgICAgICAgdmFyIHJlY29yZCQxID0gcGF0aE1hcFtwYXRoXTtcbiAgICAgICAgaWYgKG1hdGNoUm91dGUocmVjb3JkJDEucmVnZXgsIGxvY2F0aW9uLnBhdGgsIGxvY2F0aW9uLnBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCQxLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm8gbWF0Y2hcbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkaXJlY3QgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvblxuICApIHtcbiAgICB2YXIgb3JpZ2luYWxSZWRpcmVjdCA9IHJlY29yZC5yZWRpcmVjdDtcbiAgICB2YXIgcmVkaXJlY3QgPSB0eXBlb2Ygb3JpZ2luYWxSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9yaWdpbmFsUmVkaXJlY3QoY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKSlcbiAgICAgICAgOiBvcmlnaW5hbFJlZGlyZWN0O1xuXG4gICAgaWYgKHR5cGVvZiByZWRpcmVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlZGlyZWN0ID0geyBwYXRoOiByZWRpcmVjdCB9O1xuICAgIH1cblxuICAgIGlmICghcmVkaXJlY3QgfHwgdHlwZW9mIHJlZGlyZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICAgIH1cblxuICAgIHZhciByZSA9IHJlZGlyZWN0O1xuICAgIHZhciBuYW1lID0gcmUubmFtZTtcbiAgICB2YXIgcGF0aCA9IHJlLnBhdGg7XG4gICAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnk7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBwYXJhbXMgPSBsb2NhdGlvbi5wYXJhbXM7XG4gICAgcXVlcnkgPSByZS5oYXNPd25Qcm9wZXJ0eSgncXVlcnknKSA/IHJlLnF1ZXJ5IDogcXVlcnk7XG4gICAgaGFzaCA9IHJlLmhhc093blByb3BlcnR5KCdoYXNoJykgPyByZS5oYXNoIDogaGFzaDtcbiAgICBwYXJhbXMgPSByZS5oYXNPd25Qcm9wZXJ0eSgncGFyYW1zJykgPyByZS5wYXJhbXMgOiBwYXJhbXM7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgLy8gcmVzb2x2ZWQgbmFtZWQgZGlyZWN0XG4gICAgICB2YXIgdGFyZ2V0UmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydCh0YXJnZXRSZWNvcmQsIChcInJlZGlyZWN0IGZhaWxlZDogbmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBub3QgZm91bmQuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICB9LCB1bmRlZmluZWQsIGxvY2F0aW9uKVxuICAgIH0gZWxzZSBpZiAocGF0aCkge1xuICAgICAgLy8gMS4gcmVzb2x2ZSByZWxhdGl2ZSByZWRpcmVjdFxuICAgICAgdmFyIHJhd1BhdGggPSByZXNvbHZlUmVjb3JkUGF0aChwYXRoLCByZWNvcmQpO1xuICAgICAgLy8gMi4gcmVzb2x2ZSBwYXJhbXNcbiAgICAgIHZhciByZXNvbHZlZFBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicmVkaXJlY3Qgcm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIHJhd1BhdGggKyBcIlxcXCJcIikpO1xuICAgICAgLy8gMy4gcmVtYXRjaCB3aXRoIGV4aXN0aW5nIHF1ZXJ5IGFuZCBoYXNoXG4gICAgICByZXR1cm4gbWF0Y2goe1xuICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgICAgcGF0aDogcmVzb2x2ZWRQYXRoLFxuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIGhhc2g6IGhhc2hcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oZmFsc2UsIChcImludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiBcIiArIChKU09OLnN0cmluZ2lmeShyZWRpcmVjdCkpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsaWFzIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgbWF0Y2hBc1xuICApIHtcbiAgICB2YXIgYWxpYXNlZFBhdGggPSBmaWxsUGFyYW1zKG1hdGNoQXMsIGxvY2F0aW9uLnBhcmFtcywgKFwiYWxpYXNlZCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgbWF0Y2hBcyArIFwiXFxcIlwiKSk7XG4gICAgdmFyIGFsaWFzZWRNYXRjaCA9IG1hdGNoKHtcbiAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgcGF0aDogYWxpYXNlZFBhdGhcbiAgICB9KTtcbiAgICBpZiAoYWxpYXNlZE1hdGNoKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IGFsaWFzZWRNYXRjaC5tYXRjaGVkO1xuICAgICAgdmFyIGFsaWFzZWRSZWNvcmQgPSBtYXRjaGVkW21hdGNoZWQubGVuZ3RoIC0gMV07XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSBhbGlhc2VkTWF0Y2gucGFyYW1zO1xuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShhbGlhc2VkUmVjb3JkLCBsb2NhdGlvbilcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVSb3V0ZSAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uLFxuICAgIHJlZGlyZWN0ZWRGcm9tXG4gICkge1xuICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLnJlZGlyZWN0KSB7XG4gICAgICByZXR1cm4gcmVkaXJlY3QocmVjb3JkLCByZWRpcmVjdGVkRnJvbSB8fCBsb2NhdGlvbilcbiAgICB9XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQubWF0Y2hBcykge1xuICAgICAgcmV0dXJuIGFsaWFzKHJlY29yZCwgbG9jYXRpb24sIHJlY29yZC5tYXRjaEFzKVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20sIHJvdXRlcilcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIGFkZFJvdXRlczogYWRkUm91dGVzXG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZSAoXG4gIHJlZ2V4LFxuICBwYXRoLFxuICBwYXJhbXNcbikge1xuICB2YXIgbSA9IHBhdGgubWF0Y2gocmVnZXgpO1xuXG4gIGlmICghbSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IG0ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIga2V5ID0gcmVnZXgua2V5c1tpIC0gMV07XG4gICAgdmFyIHZhbCA9IHR5cGVvZiBtW2ldID09PSAnc3RyaW5nJyA/IGRlY29kZVVSSUNvbXBvbmVudChtW2ldKSA6IG1baV07XG4gICAgaWYgKGtleSkge1xuICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUmVjb3JkUGF0aCAocGF0aCwgcmVjb3JkKSB7XG4gIHJldHVybiByZXNvbHZlUGF0aChwYXRoLCByZWNvcmQucGFyZW50ID8gcmVjb3JkLnBhcmVudC5wYXRoIDogJy8nLCB0cnVlKVxufVxuXG4vKiAgKi9cblxuXG52YXIgcG9zaXRpb25TdG9yZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIHNldHVwU2Nyb2xsICgpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICBpZiAoZS5zdGF0ZSAmJiBlLnN0YXRlLmtleSkge1xuICAgICAgc2V0U3RhdGVLZXkoZS5zdGF0ZS5rZXkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNjcm9sbCAoXG4gIHJvdXRlcixcbiAgdG8sXG4gIGZyb20sXG4gIGlzUG9wXG4pIHtcbiAgaWYgKCFyb3V0ZXIuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmVoYXZpb3IgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcbiAgaWYgKCFiZWhhdmlvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJlaGF2aW9yID09PSAnZnVuY3Rpb24nLCBcInNjcm9sbEJlaGF2aW9yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIC8vIHdhaXQgdW50aWwgcmUtcmVuZGVyIGZpbmlzaGVzIGJlZm9yZSBzY3JvbGxpbmdcbiAgcm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgdmFyIHNob3VsZFNjcm9sbCA9IGJlaGF2aW9yKHRvLCBmcm9tLCBpc1BvcCA/IHBvc2l0aW9uIDogbnVsbCk7XG4gICAgaWYgKCFzaG91bGRTY3JvbGwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgaXNPYmplY3QgPSB0eXBlb2Ygc2hvdWxkU2Nyb2xsID09PSAnb2JqZWN0JztcbiAgICBpZiAoaXNPYmplY3QgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5zZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2hvdWxkU2Nyb2xsLnNlbGVjdG9yKTtcbiAgICAgIGlmIChlbCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gc2hvdWxkU2Nyb2xsLm9mZnNldCAmJiB0eXBlb2Ygc2hvdWxkU2Nyb2xsLm9mZnNldCA9PT0gJ29iamVjdCcgPyBzaG91bGRTY3JvbGwub2Zmc2V0IDoge307XG4gICAgICAgIG9mZnNldCA9IG5vcm1hbGl6ZU9mZnNldChvZmZzZXQpO1xuICAgICAgICBwb3NpdGlvbiA9IGdldEVsZW1lbnRQb3NpdGlvbihlbCwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICAgICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QgJiYgaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHBvc2l0aW9uU3RvcmVba2V5XSA9IHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHJldHVybiBwb3NpdGlvblN0b3JlW2tleV1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50UG9zaXRpb24gKGVsLCBvZmZzZXQpIHtcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgZG9jUmVjdCA9IGRvY0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQgLSBvZmZzZXQueCxcbiAgICB5OiBlbFJlY3QudG9wIC0gZG9jUmVjdC50b3AgLSBvZmZzZXQueVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiBpc051bWJlcihvYmoueCkgfHwgaXNOdW1iZXIob2JqLnkpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9mZnNldCAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgeDogaXNOdW1iZXIob2JqLngpID8gb2JqLnggOiAwLFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogMFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcidcbn1cblxuLyogICovXG5cbnZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IGluQnJvd3NlciAmJiAoZnVuY3Rpb24gKCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoXG4gICAgKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmXG4gICAgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTFcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnlcbn0pKCk7XG5cbi8vIHVzZSBVc2VyIFRpbWluZyBhcGkgKGlmIHByZXNlbnQpIGZvciBtb3JlIGFjY3VyYXRlIGtleSBwcmVjaXNpb25cbnZhciBUaW1lID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93XG4gID8gd2luZG93LnBlcmZvcm1hbmNlXG4gIDogRGF0ZTtcblxudmFyIF9rZXkgPSBnZW5LZXkoKTtcblxuZnVuY3Rpb24gZ2VuS2V5ICgpIHtcbiAgcmV0dXJuIFRpbWUubm93KCkudG9GaXhlZCgzKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUtleSAoKSB7XG4gIHJldHVybiBfa2V5XG59XG5cbmZ1bmN0aW9uIHNldFN0YXRlS2V5IChrZXkpIHtcbiAgX2tleSA9IGtleTtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXRlICh1cmwsIHJlcGxhY2UpIHtcbiAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gIC8vIHRyeS4uLmNhdGNoIHRoZSBwdXNoU3RhdGUgY2FsbCB0byBnZXQgYXJvdW5kIFNhZmFyaVxuICAvLyBET00gRXhjZXB0aW9uIDE4IHdoZXJlIGl0IGxpbWl0cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzXG4gIHZhciBoaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfa2V5ID0gZ2VuS2V5KCk7XG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB3aW5kb3cubG9jYXRpb25bcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdhc3NpZ24nXSh1cmwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAodXJsKSB7XG4gIHB1c2hTdGF0ZSh1cmwsIHRydWUpO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcnVuUXVldWUgKHF1ZXVlLCBmbiwgY2IpIHtcbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gcXVldWUubGVuZ3RoKSB7XG4gICAgICBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocXVldWVbaW5kZXhdKSB7XG4gICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGVwKDApO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyAobWF0Y2hlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgdmFyIGhhc0FzeW5jID0gZmFsc2U7XG4gICAgdmFyIHBlbmRpbmcgPSAwO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG5cbiAgICBmbGF0TWFwQ29tcG9uZW50cyhtYXRjaGVkLCBmdW5jdGlvbiAoZGVmLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgICAvLyBpZiBpdCdzIGEgZnVuY3Rpb24gYW5kIGRvZXNuJ3QgaGF2ZSBjaWQgYXR0YWNoZWQsXG4gICAgICAvLyBhc3N1bWUgaXQncyBhbiBhc3luYyBjb21wb25lbnQgcmVzb2x2ZSBmdW5jdGlvbi5cbiAgICAgIC8vIHdlIGFyZSBub3QgdXNpbmcgVnVlJ3MgZGVmYXVsdCBhc3luYyByZXNvbHZpbmcgbWVjaGFuaXNtIGJlY2F1c2VcbiAgICAgIC8vIHdlIHdhbnQgdG8gaGFsdCB0aGUgbmF2aWdhdGlvbiB1bnRpbCB0aGUgaW5jb21pbmcgY29tcG9uZW50IGhhcyBiZWVuXG4gICAgICAvLyByZXNvbHZlZC5cbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGRlZi5jaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoYXNBc3luYyA9IHRydWU7XG4gICAgICAgIHBlbmRpbmcrKztcblxuICAgICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlc29sdmVkRGVmKSB7XG4gICAgICAgICAgaWYgKHJlc29sdmVkRGVmLl9fZXNNb2R1bGUgJiYgcmVzb2x2ZWREZWYuZGVmYXVsdCkge1xuICAgICAgICAgICAgcmVzb2x2ZWREZWYgPSByZXNvbHZlZERlZi5kZWZhdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzYXZlIHJlc29sdmVkIG9uIGFzeW5jIGZhY3RvcnkgaW4gY2FzZSBpdCdzIHVzZWQgZWxzZXdoZXJlXG4gICAgICAgICAgZGVmLnJlc29sdmVkID0gdHlwZW9mIHJlc29sdmVkRGVmID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHJlc29sdmVkRGVmXG4gICAgICAgICAgICA6IF9WdWUuZXh0ZW5kKHJlc29sdmVkRGVmKTtcbiAgICAgICAgICBtYXRjaC5jb21wb25lbnRzW2tleV0gPSByZXNvbHZlZERlZjtcbiAgICAgICAgICBwZW5kaW5nLS07XG4gICAgICAgICAgaWYgKHBlbmRpbmcgPD0gMCkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHZhciBtc2cgPSBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudCBcIiArIGtleSArIFwiOiBcIiArIHJlYXNvbjtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oZmFsc2UsIG1zZyk7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBpc0Vycm9yKHJlYXNvbilcbiAgICAgICAgICAgICAgPyByZWFzb25cbiAgICAgICAgICAgICAgOiBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIG5leHQoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBkZWYocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbmV3IHN5bnRheCBpbiBWdWUgMi4zXG4gICAgICAgICAgICB2YXIgY29tcCA9IHJlcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAoY29tcCAmJiB0eXBlb2YgY29tcC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNvbXAudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFoYXNBc3luYykgeyBuZXh0KCk7IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0TWFwQ29tcG9uZW50cyAoXG4gIG1hdGNoZWQsXG4gIGZuXG4pIHtcbiAgcmV0dXJuIGZsYXR0ZW4obWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4oXG4gICAgICBtLmNvbXBvbmVudHNba2V5XSxcbiAgICAgIG0uaW5zdGFuY2VzW2tleV0sXG4gICAgICBtLCBrZXlcbiAgICApOyB9KVxuICB9KSlcbn1cblxuZnVuY3Rpb24gZmxhdHRlbiAoYXJyKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpXG59XG5cbi8vIGluIFdlYnBhY2sgMiwgcmVxdWlyZS5lbnN1cmUgbm93IGFsc28gcmV0dXJucyBhIFByb21pc2Vcbi8vIHNvIHRoZSByZXNvbHZlL3JlamVjdCBmdW5jdGlvbnMgbWF5IGdldCBjYWxsZWQgYW4gZXh0cmEgdGltZVxuLy8gaWYgdGhlIHVzZXIgdXNlcyBhbiBhcnJvdyBmdW5jdGlvbiBzaG9ydGhhbmQgdGhhdCBoYXBwZW5zIHRvXG4vLyByZXR1cm4gdGhhdCBQcm9taXNlLlxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIGlmIChjYWxsZWQpIHsgcmV0dXJuIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgSGlzdG9yeSA9IGZ1bmN0aW9uIEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgdGhpcy5iYXNlID0gbm9ybWFsaXplQmFzZShiYXNlKTtcbiAgLy8gc3RhcnQgd2l0aCBhIHJvdXRlIG9iamVjdCB0aGF0IHN0YW5kcyBmb3IgXCJub3doZXJlXCJcbiAgdGhpcy5jdXJyZW50ID0gU1RBUlQ7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7XG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgdGhpcy5yZWFkeUNicyA9IFtdO1xuICB0aGlzLnJlYWR5RXJyb3JDYnMgPSBbXTtcbiAgdGhpcy5lcnJvckNicyA9IFtdO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuIChjYikge1xuICB0aGlzLmNiID0gY2I7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeSAoY2IsIGVycm9yQ2IpIHtcbiAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICBjYigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVhZHlDYnMucHVzaChjYik7XG4gICAgaWYgKGVycm9yQ2IpIHtcbiAgICAgIHRoaXMucmVhZHlFcnJvckNicy5wdXNoKGVycm9yQ2IpO1xuICAgIH1cbiAgfVxufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5lcnJvckNicy5wdXNoKGVycm9yQ2IpO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciByb3V0ZSA9IHRoaXMucm91dGVyLm1hdGNoKGxvY2F0aW9uLCB0aGlzLmN1cnJlbnQpO1xuICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIHRoaXMkMS5lbnN1cmVVUkwoKTtcblxuICAgIC8vIGZpcmUgcmVhZHkgY2JzIG9uY2VcbiAgICBpZiAoIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihyb3V0ZSk7IH0pO1xuICAgIH1cbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChvbkFib3J0KSB7XG4gICAgICBvbkFib3J0KGVycik7XG4gICAgfVxuICAgIGlmIChlcnIgJiYgIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5jb25maXJtVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uIChyb3V0ZSwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGlzRXJyb3IoZXJyKSkge1xuICAgICAgaWYgKHRoaXMkMS5lcnJvckNicy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcyQxLmVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihmYWxzZSwgJ3VuY2F1Z2h0IGVycm9yIGR1cmluZyByb3V0ZSBuYXZpZ2F0aW9uOicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIG9uQWJvcnQgJiYgb25BYm9ydChlcnIpO1xuICB9O1xuICBpZiAoXG4gICAgaXNTYW1lUm91dGUocm91dGUsIGN1cnJlbnQpICYmXG4gICAgLy8gaW4gdGhlIGNhc2UgdGhlIHJvdXRlIG1hcCBoYXMgYmVlbiBkeW5hbWljYWxseSBhcHBlbmRlZCB0b1xuICAgIHJvdXRlLm1hdGNoZWQubGVuZ3RoID09PSBjdXJyZW50Lm1hdGNoZWQubGVuZ3RoXG4gICkge1xuICAgIHRoaXMuZW5zdXJlVVJMKCk7XG4gICAgcmV0dXJuIGFib3J0KClcbiAgfVxuXG4gIHZhciByZWYgPSByZXNvbHZlUXVldWUodGhpcy5jdXJyZW50Lm1hdGNoZWQsIHJvdXRlLm1hdGNoZWQpO1xuICAgIHZhciB1cGRhdGVkID0gcmVmLnVwZGF0ZWQ7XG4gICAgdmFyIGRlYWN0aXZhdGVkID0gcmVmLmRlYWN0aXZhdGVkO1xuICAgIHZhciBhY3RpdmF0ZWQgPSByZWYuYWN0aXZhdGVkO1xuXG4gIHZhciBxdWV1ZSA9IFtdLmNvbmNhdChcbiAgICAvLyBpbi1jb21wb25lbnQgbGVhdmUgZ3VhcmRzXG4gICAgZXh0cmFjdExlYXZlR3VhcmRzKGRlYWN0aXZhdGVkKSxcbiAgICAvLyBnbG9iYWwgYmVmb3JlIGhvb2tzXG4gICAgdGhpcy5yb3V0ZXIuYmVmb3JlSG9va3MsXG4gICAgLy8gaW4tY29tcG9uZW50IHVwZGF0ZSBob29rc1xuICAgIGV4dHJhY3RVcGRhdGVIb29rcyh1cGRhdGVkKSxcbiAgICAvLyBpbi1jb25maWcgZW50ZXIgZ3VhcmRzXG4gICAgYWN0aXZhdGVkLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5iZWZvcmVFbnRlcjsgfSksXG4gICAgLy8gYXN5bmMgY29tcG9uZW50c1xuICAgIHJlc29sdmVBc3luY0NvbXBvbmVudHMoYWN0aXZhdGVkKVxuICApO1xuXG4gIHRoaXMucGVuZGluZyA9IHJvdXRlO1xuICB2YXIgaXRlcmF0b3IgPSBmdW5jdGlvbiAoaG9vaywgbmV4dCkge1xuICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgIHJldHVybiBhYm9ydCgpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBob29rKHJvdXRlLCBjdXJyZW50LCBmdW5jdGlvbiAodG8pIHtcbiAgICAgICAgaWYgKHRvID09PSBmYWxzZSB8fCBpc0Vycm9yKHRvKSkge1xuICAgICAgICAgIC8vIG5leHQoZmFsc2UpIC0+IGFib3J0IG5hdmlnYXRpb24sIGVuc3VyZSBjdXJyZW50IFVSTFxuICAgICAgICAgIHRoaXMkMS5lbnN1cmVVUkwodHJ1ZSk7XG4gICAgICAgICAgYWJvcnQodG8pO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiAoXG4gICAgICAgICAgICB0eXBlb2YgdG8ucGF0aCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0by5uYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICkpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5leHQoJy8nKSBvciBuZXh0KHsgcGF0aDogJy8nIH0pIC0+IHJlZGlyZWN0XG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiB0by5yZXBsYWNlKSB7XG4gICAgICAgICAgICB0aGlzJDEucmVwbGFjZSh0byk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMkMS5wdXNoKHRvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uZmlybSB0cmFuc2l0aW9uIGFuZCBwYXNzIG9uIHRoZSB2YWx1ZVxuICAgICAgICAgIG5leHQodG8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydChlKTtcbiAgICB9XG4gIH07XG5cbiAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc3RFbnRlckNicyA9IFtdO1xuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmN1cnJlbnQgPT09IHJvdXRlOyB9O1xuICAgIC8vIHdhaXQgdW50aWwgYXN5bmMgY29tcG9uZW50cyBhcmUgcmVzb2x2ZWQgYmVmb3JlXG4gICAgLy8gZXh0cmFjdGluZyBpbi1jb21wb25lbnQgZW50ZXIgZ3VhcmRzXG4gICAgdmFyIGVudGVyR3VhcmRzID0gZXh0cmFjdEVudGVyR3VhcmRzKGFjdGl2YXRlZCwgcG9zdEVudGVyQ2JzLCBpc1ZhbGlkKTtcbiAgICB2YXIgcXVldWUgPSBlbnRlckd1YXJkcy5jb25jYXQodGhpcyQxLnJvdXRlci5yZXNvbHZlSG9va3MpO1xuICAgIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gYWJvcnQoKVxuICAgICAgfVxuICAgICAgdGhpcyQxLnBlbmRpbmcgPSBudWxsO1xuICAgICAgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgICBpZiAodGhpcyQxLnJvdXRlci5hcHApIHtcbiAgICAgICAgdGhpcyQxLnJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwb3N0RW50ZXJDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnVwZGF0ZVJvdXRlID0gZnVuY3Rpb24gdXBkYXRlUm91dGUgKHJvdXRlKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50O1xuICB0aGlzLmN1cnJlbnQgPSByb3V0ZTtcbiAgdGhpcy5jYiAmJiB0aGlzLmNiKHJvdXRlKTtcbiAgdGhpcy5yb3V0ZXIuYWZ0ZXJIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9vayAmJiBob29rKHJvdXRlLCBwcmV2KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVCYXNlIChiYXNlKSB7XG4gIGlmICghYmFzZSkge1xuICAgIGlmIChpbkJyb3dzZXIpIHtcbiAgICAgIC8vIHJlc3BlY3QgPGJhc2U+IHRhZ1xuICAgICAgdmFyIGJhc2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICAgIGJhc2UgPSAoYmFzZUVsICYmIGJhc2VFbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgfHwgJy8nO1xuICAgICAgLy8gc3RyaXAgZnVsbCBVUkwgb3JpZ2luXG4gICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcL1teXFwvXSsvLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnLyc7XG4gICAgfVxuICB9XG4gIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIHRoZSBzdGFydGluZyBzbGFzaFxuICBpZiAoYmFzZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGJhc2UgPSAnLycgKyBiYXNlO1xuICB9XG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICByZXR1cm4gYmFzZS5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWV1ZSAoXG4gIGN1cnJlbnQsXG4gIG5leHRcbikge1xuICB2YXIgaTtcbiAgdmFyIG1heCA9IE1hdGgubWF4KGN1cnJlbnQubGVuZ3RoLCBuZXh0Lmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGlmIChjdXJyZW50W2ldICE9PSBuZXh0W2ldKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZWQ6IG5leHQuc2xpY2UoMCwgaSksXG4gICAgYWN0aXZhdGVkOiBuZXh0LnNsaWNlKGkpLFxuICAgIGRlYWN0aXZhdGVkOiBjdXJyZW50LnNsaWNlKGkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkcyAoXG4gIHJlY29yZHMsXG4gIG5hbWUsXG4gIGJpbmQsXG4gIHJldmVyc2Vcbikge1xuICB2YXIgZ3VhcmRzID0gZmxhdE1hcENvbXBvbmVudHMocmVjb3JkcywgZnVuY3Rpb24gKGRlZiwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpIHtcbiAgICB2YXIgZ3VhcmQgPSBleHRyYWN0R3VhcmQoZGVmLCBuYW1lKTtcbiAgICBpZiAoZ3VhcmQpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGd1YXJkKVxuICAgICAgICA/IGd1YXJkLm1hcChmdW5jdGlvbiAoZ3VhcmQpIHsgcmV0dXJuIGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KTsgfSlcbiAgICAgICAgOiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSlcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmxhdHRlbihyZXZlcnNlID8gZ3VhcmRzLnJldmVyc2UoKSA6IGd1YXJkcylcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkIChcbiAgZGVmLFxuICBrZXlcbikge1xuICBpZiAodHlwZW9mIGRlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGV4dGVuZCBub3cgc28gdGhhdCBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkLlxuICAgIGRlZiA9IF9WdWUuZXh0ZW5kKGRlZik7XG4gIH1cbiAgcmV0dXJuIGRlZi5vcHRpb25zW2tleV1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdExlYXZlR3VhcmRzIChkZWFjdGl2YXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhkZWFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlTGVhdmUnLCBiaW5kR3VhcmQsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RVcGRhdGVIb29rcyAodXBkYXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyh1cGRhdGVkLCAnYmVmb3JlUm91dGVVcGRhdGUnLCBiaW5kR3VhcmQpXG59XG5cbmZ1bmN0aW9uIGJpbmRHdWFyZCAoZ3VhcmQsIGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZFJvdXRlR3VhcmQgKCkge1xuICAgICAgcmV0dXJuIGd1YXJkLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFbnRlckd1YXJkcyAoXG4gIGFjdGl2YXRlZCxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVFbnRlcicsIGZ1bmN0aW9uIChndWFyZCwgXywgbWF0Y2gsIGtleSkge1xuICAgIHJldHVybiBiaW5kRW50ZXJHdWFyZChndWFyZCwgbWF0Y2gsIGtleSwgY2JzLCBpc1ZhbGlkKVxuICB9KVxufVxuXG5mdW5jdGlvbiBiaW5kRW50ZXJHdWFyZCAoXG4gIGd1YXJkLFxuICBtYXRjaCxcbiAga2V5LFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZnVuY3Rpb24gcm91dGVFbnRlckd1YXJkICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHJldHVybiBndWFyZCh0bywgZnJvbSwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICBuZXh0KGNiKTtcbiAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2JzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICM3NTBcbiAgICAgICAgICAvLyBpZiBhIHJvdXRlci12aWV3IGlzIHdyYXBwZWQgd2l0aCBhbiBvdXQtaW4gdHJhbnNpdGlvbixcbiAgICAgICAgICAvLyB0aGUgaW5zdGFuY2UgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBhdCB0aGlzIHRpbWUuXG4gICAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRvIHBvbGwgZm9yIHJlZ2lzdHJhdGlvbiB1bnRpbCBjdXJyZW50IHJvdXRlXG4gICAgICAgICAgLy8gaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgICAgICAgIHBvbGwoY2IsIG1hdGNoLmluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2xsIChcbiAgY2IsIC8vIHNvbWVob3cgZmxvdyBjYW5ub3QgaW5mZXIgdGhpcyBpcyBhIGZ1bmN0aW9uXG4gIGluc3RhbmNlcyxcbiAga2V5LFxuICBpc1ZhbGlkXG4pIHtcbiAgaWYgKGluc3RhbmNlc1trZXldKSB7XG4gICAgY2IoaW5zdGFuY2VzW2tleV0pO1xuICB9IGVsc2UgaWYgKGlzVmFsaWQoKSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcG9sbChjYiwgaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgIH0sIDE2KTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgSFRNTDVIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhUTUw1SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcblxuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcblxuICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgIHNldHVwU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcyQxLmN1cnJlbnQ7XG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGdldExvY2F0aW9uKHRoaXMkMS5iYXNlKSwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgICAgICBoYW5kbGVTY3JvbGwocm91dGVyLCByb3V0ZSwgY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSFRNTDVIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MNUhpc3Rvcnk7XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZVN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIGlmIChnZXRMb2NhdGlvbih0aGlzLmJhc2UpICE9PSB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gY2xlYW5QYXRoKHRoaXMuYmFzZSArIHRoaXMuY3VycmVudC5mdWxsUGF0aCk7XG4gICAgICBwdXNoID8gcHVzaFN0YXRlKGN1cnJlbnQpIDogcmVwbGFjZVN0YXRlKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldExvY2F0aW9uKHRoaXMuYmFzZSlcbiAgfTtcblxuICByZXR1cm4gSFRNTDVIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGdldExvY2F0aW9uIChiYXNlKSB7XG4gIHZhciBwYXRoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICBpZiAoYmFzZSAmJiBwYXRoLmluZGV4T2YoYmFzZSkgPT09IDApIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZShiYXNlLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2hcbn1cblxuLyogICovXG5cblxudmFyIEhhc2hIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhhc2hIaXN0b3J5IChyb3V0ZXIsIGJhc2UsIGZhbGxiYWNrKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgLy8gY2hlY2sgaGlzdG9yeSBmYWxsYmFjayBkZWVwbGlua2luZ1xuICAgIGlmIChmYWxsYmFjayAmJiBjaGVja0ZhbGxiYWNrKHRoaXMuYmFzZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbnN1cmVTbGFzaCgpO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSGFzaEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIYXNoSGlzdG9yeTtcblxuICAvLyB0aGlzIGlzIGRlbGF5ZWQgdW50aWwgdGhlIGFwcCBtb3VudHNcbiAgLy8gdG8gYXZvaWQgdGhlIGhhc2hjaGFuZ2UgbGlzdGVuZXIgYmVpbmcgZmlyZWQgdG9vIGVhcmx5XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zZXR1cExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFlbnN1cmVTbGFzaCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcyQxLnRyYW5zaXRpb25UbyhnZXRIYXNoKCksIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaEhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudC5mdWxsUGF0aDtcbiAgICBpZiAoZ2V0SGFzaCgpICE9PSBjdXJyZW50KSB7XG4gICAgICBwdXNoID8gcHVzaEhhc2goY3VycmVudCkgOiByZXBsYWNlSGFzaChjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEhhc2goKVxuICB9O1xuXG4gIHJldHVybiBIYXNoSGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBjaGVja0ZhbGxiYWNrIChiYXNlKSB7XG4gIHZhciBsb2NhdGlvbiA9IGdldExvY2F0aW9uKGJhc2UpO1xuICBpZiAoIS9eXFwvIy8udGVzdChsb2NhdGlvbikpIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShcbiAgICAgIGNsZWFuUGF0aChiYXNlICsgJy8jJyArIGxvY2F0aW9uKVxuICAgICk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVTbGFzaCAoKSB7XG4gIHZhciBwYXRoID0gZ2V0SGFzaCgpO1xuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmVwbGFjZUhhc2goJy8nICsgcGF0aCk7XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZXRIYXNoICgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zbGljZShpbmRleCArIDEpXG59XG5cbmZ1bmN0aW9uIHB1c2hIYXNoIChwYXRoKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhhc2ggKHBhdGgpIHtcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGkgPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgdmFyIGJhc2UgPSBpID49IDAgPyBocmVmLnNsaWNlKDAsIGkpIDogaHJlZjtcbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoKGJhc2UgKyBcIiNcIiArIHBhdGgpKTtcbn1cblxuLyogICovXG5cblxudmFyIEFic3RyYWN0SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBBYnN0cmFjdEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLmluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBBYnN0cmFjdEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFic3RyYWN0SGlzdG9yeTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCArIDEpLmNvbmNhdChyb3V0ZSk7XG4gICAgICB0aGlzJDEuaW5kZXgrKztcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXgpLmNvbmNhdChyb3V0ZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHRhcmdldEluZGV4ID0gdGhpcy5pbmRleCArIG47XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciByb3V0ZSA9IHRoaXMuc3RhY2tbdGFyZ2V0SW5kZXhdO1xuICAgIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5pbmRleCA9IHRhcmdldEluZGV4O1xuICAgICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGN1cnJlbnQgPyBjdXJyZW50LmZ1bGxQYXRoIDogJy8nXG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKCkge1xuICAgIC8vIG5vb3BcbiAgfTtcblxuICByZXR1cm4gQWJzdHJhY3RIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbi8qICAqL1xuXG52YXIgVnVlUm91dGVyID0gZnVuY3Rpb24gVnVlUm91dGVyIChvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIHRoaXMuYXBwID0gbnVsbDtcbiAgdGhpcy5hcHBzID0gW107XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuYmVmb3JlSG9va3MgPSBbXTtcbiAgdGhpcy5yZXNvbHZlSG9va3MgPSBbXTtcbiAgdGhpcy5hZnRlckhvb2tzID0gW107XG4gIHRoaXMubWF0Y2hlciA9IGNyZWF0ZU1hdGNoZXIob3B0aW9ucy5yb3V0ZXMgfHwgW10sIHRoaXMpO1xuXG4gIHZhciBtb2RlID0gb3B0aW9ucy5tb2RlIHx8ICdoYXNoJztcbiAgdGhpcy5mYWxsYmFjayA9IG1vZGUgPT09ICdoaXN0b3J5JyAmJiAhc3VwcG9ydHNQdXNoU3RhdGUgJiYgb3B0aW9ucy5mYWxsYmFjayAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgbW9kZSA9ICdoYXNoJztcbiAgfVxuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIG1vZGUgPSAnYWJzdHJhY3QnO1xuICB9XG4gIHRoaXMubW9kZSA9IG1vZGU7XG5cbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSAnaGlzdG9yeSc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSFRNTDVIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhhc2hIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSwgdGhpcy5mYWxsYmFjayk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Fic3RyYWN0JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBBYnN0cmFjdEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgKFwiaW52YWxpZCBtb2RlOiBcIiArIG1vZGUpKTtcbiAgICAgIH1cbiAgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY3VycmVudFJvdXRlOiB7fSB9O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2ggKFxuICByYXcsXG4gIGN1cnJlbnQsXG4gIHJlZGlyZWN0ZWRGcm9tXG4pIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2hlci5tYXRjaChyYXcsIGN1cnJlbnQsIHJlZGlyZWN0ZWRGcm9tKVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmN1cnJlbnRSb3V0ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LmN1cnJlbnRcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKGFwcCAvKiBWdWUgY29tcG9uZW50IGluc3RhbmNlICovKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnQoXG4gICAgaW5zdGFsbC5pbnN0YWxsZWQsXG4gICAgXCJub3QgaW5zdGFsbGVkLiBNYWtlIHN1cmUgdG8gY2FsbCBgVnVlLnVzZShWdWVSb3V0ZXIpYCBcIiArXG4gICAgXCJiZWZvcmUgY3JlYXRpbmcgcm9vdCBpbnN0YW5jZS5cIlxuICApO1xuXG4gIHRoaXMuYXBwcy5wdXNoKGFwcCk7XG5cbiAgLy8gbWFpbiBhcHAgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgaWYgKHRoaXMuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmFwcCA9IGFwcDtcblxuICB2YXIgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcblxuICBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhUTUw1SGlzdG9yeSkge1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9IGVsc2UgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIYXNoSGlzdG9yeSkge1xuICAgIHZhciBzZXR1cEhhc2hMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhpc3Rvcnkuc2V0dXBMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKFxuICAgICAgaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSxcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXJcbiAgICApO1xuICB9XG5cbiAgaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgdGhpcyQxLmFwcHMuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7XG4gICAgICBhcHAuX3JvdXRlID0gcm91dGU7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmJlZm9yZUhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlUmVzb2x2ZSA9IGZ1bmN0aW9uIGJlZm9yZVJlc29sdmUgKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5yZXNvbHZlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiBhZnRlckVhY2ggKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5hZnRlckhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiLCBlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uRXJyb3IoZXJyb3JDYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucHVzaChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgdGhpcy5oaXN0b3J5LmdvKG4pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gYmFjayAoKSB7XG4gIHRoaXMuZ28oLTEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gZm9yd2FyZCAoKSB7XG4gIHRoaXMuZ28oMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdldE1hdGNoZWRDb21wb25lbnRzID0gZnVuY3Rpb24gZ2V0TWF0Y2hlZENvbXBvbmVudHMgKHRvKSB7XG4gIHZhciByb3V0ZSA9IHRvXG4gICAgPyB0by5tYXRjaGVkXG4gICAgICA/IHRvXG4gICAgICA6IHRoaXMucmVzb2x2ZSh0bykucm91dGVcbiAgICA6IHRoaXMuY3VycmVudFJvdXRlO1xuICBpZiAoIXJvdXRlKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgcm91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG0uY29tcG9uZW50c1trZXldXG4gICAgfSlcbiAgfSkpXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChcbiAgdG8sXG4gIGN1cnJlbnQsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKFxuICAgIHRvLFxuICAgIGN1cnJlbnQgfHwgdGhpcy5oaXN0b3J5LmN1cnJlbnQsXG4gICAgYXBwZW5kLFxuICAgIHRoaXNcbiAgKTtcbiAgdmFyIHJvdXRlID0gdGhpcy5tYXRjaChsb2NhdGlvbiwgY3VycmVudCk7XG4gIHZhciBmdWxsUGF0aCA9IHJvdXRlLnJlZGlyZWN0ZWRGcm9tIHx8IHJvdXRlLmZ1bGxQYXRoO1xuICB2YXIgYmFzZSA9IHRoaXMuaGlzdG9yeS5iYXNlO1xuICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYoYmFzZSwgZnVsbFBhdGgsIHRoaXMubW9kZSk7XG4gIHJldHVybiB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHJvdXRlOiByb3V0ZSxcbiAgICBocmVmOiBocmVmLFxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgbm9ybWFsaXplZFRvOiBsb2NhdGlvbixcbiAgICByZXNvbHZlZDogcm91dGVcbiAgfVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZGRSb3V0ZXMgPSBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICB0aGlzLm1hdGNoZXIuYWRkUm91dGVzKHJvdXRlcyk7XG4gIGlmICh0aGlzLmhpc3RvcnkuY3VycmVudCAhPT0gU1RBUlQpIHtcbiAgICB0aGlzLmhpc3RvcnkudHJhbnNpdGlvblRvKHRoaXMuaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWdWVSb3V0ZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJIb29rIChsaXN0LCBmbikge1xuICBsaXN0LnB1c2goZm4pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gbGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7IGxpc3Quc3BsaWNlKGksIDEpOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSHJlZiAoYmFzZSwgZnVsbFBhdGgsIG1vZGUpIHtcbiAgdmFyIHBhdGggPSBtb2RlID09PSAnaGFzaCcgPyAnIycgKyBmdWxsUGF0aCA6IGZ1bGxQYXRoO1xuICByZXR1cm4gYmFzZSA/IGNsZWFuUGF0aChiYXNlICsgJy8nICsgcGF0aCkgOiBwYXRoXG59XG5cblZ1ZVJvdXRlci5pbnN0YWxsID0gaW5zdGFsbDtcblZ1ZVJvdXRlci52ZXJzaW9uID0gJzIuNy4wJztcblxuaWYgKGluQnJvd3NlciAmJiB3aW5kb3cuVnVlKSB7XG4gIHdpbmRvdy5WdWUudXNlKFZ1ZVJvdXRlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZVJvdXRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuZXNtLmpzIiwiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuYm9keSB7XFxuICBmb250LWZhbWlseTogXFxcIk9wZW4gU2FucyBDb25kZW5zZWRcXFwiO1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgbWluLWhlaWdodDogMTAwdmg7XFxuICBiYWNrZ3JvdW5kOlxcbiAgICBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tIHJpZ2h0LCByZ2JhKDI1MSwgMTA5LCA4LCAuOCkwJSwgcmdiYSgyMDQsIDY2LCAwLCAxKTEwMCUpLFxcbiAgICB1cmwoJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzM3NTI3L3Nwb3J0cy1nYW1lcy1mdW4taG9saWRheS0zNzUyNy5qcGVnP3c9MTI2MCZoPTc1MCZhdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJyk7XFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXI7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcbn1cXG4ubGVhZGVyYm9hcmQtdGFibGUgLnRpdGxlID4gdGgge1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNmNWY1YTI7XFxuICBmb250LXNpemU6IDE2cHQ7XFxuICBwYWRkaW5nOiAuNXJlbTtcXG59XFxuLmxlYWRlcmJvYXJkLXRhYmxlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjgpO1xcbiAgY29sb3I6ICM3YjdiN2I7XFxuICBib3gtc2hhZG93OiAxcHggMXB4IDEwcHggIzIyMjtcXG59XFxuLmxlYWRlcmJvYXJkLXRhYmxlIHRoZWFkIHRoLCB0Zm9vdCB0aCB7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGZvbnQtc2l6ZTogMTJwdDtcXG59XFxuLmxlYWRlcmJvYXJkLXRhYmxlIHRoZWFkLCB0Zm9vdCB7XFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQocmdiYSgyNTUsIDEwNiwgMCwgMSkwJSwgcmdiYSgxNTYsIDUyLCAwLCAxKTEwMCUpO1xcbn1cXG4ubGVhZGVyYm9hcmQtdGFibGUgdGQge1xcbiAgYm9yZGVyOiBub25lO1xcbn1cXG4ubGVhZGVyYm9hcmQtdGFibGUgdHI6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDIzMywgMTIwLCAuMik7XFxufVxcbi5wb2ludHNiYWNrIHtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gICAgY29sb3I6ICNmZjM4NjA7XFxufVxcbi5sZWFkZXJib2FyZCB7XFxuICAgIG1hcmdpbi10b3A6IDUwcHg7XFxufVxcbnRhYmxlIHRkLCB0aCB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlciAhaW1wb3J0YW50O1xcbn1cXG4ubGVhZGVyYm9hcmQtbWFpbiB7XFxuICAgIG1hcmdpbi10b3A6IDI1cHg7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMvU2V0aC9Qcm9qZWN0cy9mYW50YXN5c3gvY2xpZW50L2NvbXBvbmVudHMvbGVhZGVyYm9hcmQudnVlPzEwMjU4NzE4XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUEySEE7RUFDQSxtQ0FBQTtFQUNBLGFBQUE7RUFDQSxrQkFBQTtFQUNBOzs2SEFFQTtFQUNBLHVCQUFBO0VBQ0EsMkJBQUE7RUFDQSw2QkFBQTtDQUNBO0FBQ0E7RUFDQSxpQ0FBQTtFQUNBLGdCQUFBO0VBQ0EsZUFBQTtDQUNBO0FBQ0E7RUFDQSwwQ0FBQTtFQUNBLGVBQUE7RUFDQSw4QkFBQTtDQUNBO0FBQ0E7RUFDQSxZQUFBO0VBQ0EsZ0JBQUE7Q0FDQTtBQUNBO0VBQ0EsNkVBQUE7Q0FDQTtBQUNBO0VBQ0EsYUFBQTtDQUNBO0FBQ0E7RUFDQSwwQ0FBQTtDQUNBO0FBQ0E7SUFDQSxvQkFBQTtJQUNBLGVBQUE7Q0FDQTtBQUNBO0lBQ0EsaUJBQUE7Q0FDQTtBQUNBO0lBQ0EsOEJBQUE7Q0FDQTtBQUNBO0lBQ0EsaUJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwibGVhZGVyYm9hcmQudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXG4gIDxkaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbHVtbnMgbGVhZGVyYm9hcmRcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbHVtbiBpcy1oYWxmIGlzLW9mZnNldC1vbmUtcXVhcnRlclxcXCI+XFxuICAgICAgICA8dGFibGUgY2xhc3M9XFxcImxlYWRlcmJvYXJkLXRhYmxlXFxcIiB2LWlmPVxcXCJkb25lTG9hZGluZ1xcXCI+XFxuICAgICAgICAgIDx0aGVhZD5cXG4gICAgICAgICAgICA8dHIgY2xhc3M9XFxcInRpdGxlXFxcIj5cXG4gICAgICAgICAgICAgIDx0aCBjb2xzcGFuPVxcXCI0XFxcIj4yMDE4IEZhbnRhc3kgU1g6IE1haW4gTGVhZ3VlIFN0YW5kaW5nczwvdGg+XFxuICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgICA8dHI+XFxuICAgICAgICAgICAgICA8dGg+UG9zaXRpb248L3RoPlxcbiAgICAgICAgICAgICAgPHRoPlRvdGFsIFBvaW50czwvdGg+XFxuICAgICAgICAgICAgICA8dGg+VXNlcm5hbWU8L3RoPlxcbiAgICAgICAgICAgICAgPHRoPlBvaW50cyBCYWNrPC90aD5cXG4gICAgICAgICAgICA8L3RyPlxcbiAgICAgICAgICA8L3RoZWFkPlxcbiAgICAgICAgICA8dGZvb3Q+XFxuICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgPHRoPlBvc2l0aW9uPC90aD5cXG4gICAgICAgICAgICAgIDx0aD5Ub3RhbCBQb2ludHM8L3RoPlxcbiAgICAgICAgICAgICAgPHRoPlVzZXJuYW1lPC90aD5cXG4gICAgICAgICAgICAgIDx0aD5Qb2ludHMgQmFjazwvdGg+XFxuICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgPC90Zm9vdD5cXG4gICAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICAgIDx0ciB2LWZvcj1cXFwiKHVzZXIsIGluZGV4KSBpbiBzdGFuZGluZ3NcXFwiPlxcbiAgICAgICAgICAgICAgPHRkPnt7IGluZGV4ICsgMSB9fS48L3RkPlxcbiAgICAgICAgICAgICAgPHRkPnt7dXNlci50b3RhbHBvaW50c319PC90ZD5cXG4gICAgICAgICAgICAgIDx0ZD57e3VzZXIud2Vla2x5dGVhbXNbMF0udXNlcm5hbWV9fTwvdGQ+XFxuICAgICAgICAgICAgICA8dGQgdi1iaW5kOmNsYXNzPVxcXCJ7ICdwb2ludHNiYWNrJzogaW5kZXggPiAwIH1cXFwiPnt7IHBvaW50c2JlaGluZCh1c2VyKSB9fTwvdGQ+XFxuICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgIDwvdGFibGU+XFxuICAgICAgICA8ZGl2IHYtaWY9XFxcIiFkb25lTG9hZGluZ1xcXCI+XFxuICAgICAgICAgIDxwPlxcXCJUaGlzIGRhdGEgZG9lc24ndCBmZXRjaCBpdHNlbGYuLiBMb2FkaW5nIFJhY2UgVHJhY2tlci5cXFwiPC9wPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbjwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xcbiAgZXhwb3J0IGRlZmF1bHQge1xcbiAgICBkYXRhKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBkb25lTG9hZGluZzogZmFsc2UsXFxuICAgICAgICByZXN1bHRzOiBbXSxcXG4gICAgICAgIG1haW5MZWFndWVVc2VyczogW10sXFxuICAgICAgICB3ZWVrbHl0ZWFtczogW11cXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgc3RhbmRpbmdzOiBmdW5jdGlvbigpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLm1haW5MZWFndWVVc2Vycy5zb3J0KChhLCBiKSA9PiB7XFxuICAgICAgICAgIHZhciBhUG9pbnRzID0gMDtcXG4gICAgICAgICAgdmFyIGJQb2ludHMgPSAwO1xcbiAgICAgICAgICBhLndlZWtseXRlYW1zLmZvckVhY2godGVhbSA9PiB7IGFQb2ludHMgKz0gdGVhbS5wbGFjZSB9KVxcbiAgICAgICAgICBiLndlZWtseXRlYW1zLmZvckVhY2godGVhbSA9PiB7IGJQb2ludHMgKz0gdGVhbS5wbGFjZSB9KVxcbiAgICAgICAgICByZXR1cm4gYVBvaW50cyAtIGJQb2ludHM7XFxuICAgICAgICB9KVxcbiAgICAgIH0sXFxuICAgICAgbmV3c3RhbmRpbmdzOiBmdW5jdGlvbigpIHtcXG5cXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGNyZWF0ZWQoKSB7XFxuICAgICAgY29uc29sZS5sb2coXFxcImVudmlyb25tZW50XFxcIiwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYpXFxuICAgICAgYXhpb3MuZ2V0KCcvTWFpbkxlYWd1ZVN0YW5kaW5ncycpXFxuICAgICAgLnRoZW4oZGF0YSA9PiB7XFxuICAgICAgICB0aGlzLm1haW5MZWFndWVVc2VycyA9IGRhdGEuZGF0YTtcXG4gICAgICAgIHRoaXMubWFpbkxlYWd1ZVVzZXJzLmZvckVhY2goKHVzZXIpID0+IHtcXG4gICAgICAgICAgdXNlci50b3RhbHBvaW50cyA9IDBcXG4gICAgICAgICAgdXNlci53ZWVrbHl0ZWFtcy5mb3JFYWNoKHd0ID0+IHsgdXNlci50b3RhbHBvaW50cyArPSB3dC5wbGFjZSB9KVxcbiAgICAgICAgICB1c2VyLndlZWtseXRlYW1zLnNvcnQoKGEsIGIpID0+IHtcXG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XFxuICAgICAgICAgIH0pXFxuICAgICAgICB9KVxcbiAgICAgICAgdGhpcy5kb25lTG9hZGluZyA9IHRydWU7XFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgIHBvaW50c2JlaGluZDogZnVuY3Rpb24odXNlcikge1xcbiAgICAgICAgdmFyIG9iakluZGV4ID0gdGhpcy5zdGFuZGluZ3MuaW5kZXhPZih1c2VyKTtcXG4gICAgICAgIGlmIChvYmpJbmRleCAhPSAwKSB7XFxuICAgICAgICAgIHJldHVybiB1c2VyLnRvdGFscG9pbnRzIC0gdGhpcy5zdGFuZGluZ3NbMF0udG90YWxwb2ludHM7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gJy0nXFxuICAgICAgfVxcbiAgICB9XFxuICAgIC8vIGJlZm9yZUNyZWF0ZSgpIHtcXG4gICAgLy8gICAgc2V0VGltZW91dCgoKSA9PiB7XFxuICAgIC8vICAgICAgYXhpb3MuZ2V0KCcvUmFjZVJlc3VsdHMnKVxcbiAgICAvLyAgICAgIC50aGVuKGRhdGEgPT4ge1xcbiAgICAvLyAgICAgICAgY29uc29sZS50aW1lKCk7XFxuICAgIC8vICAgICAgICB2YXIgcmVzdWx0cyA9IGRhdGEuZGF0YS5CO1xcbiAgICAvLyAgICAgICAgY29uc29sZS5sb2cocmVzdWx0cyk7XFxuICAgIC8vICAgICAgICB0aGlzLm1haW5MZWFndWVVc2Vycy5mb3JFYWNoKHVzZXIgPT4ge1xcbiAgICAvLyAgICAgICAgICB1c2VyLnRvdGFscG9pbnRzID0gMDtcXG4gICAgLy8gICAgICAgICAgdXNlci5yaWRlcnMuZm9yRWFjaChyaWRlciA9PiB7XFxuICAgIC8vICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XFxuICAgIC8vICAgICAgICAgICAgICBpZiAocmVzdWx0LkYuc2xpY2UoMCwgLTEpID09IHJpZGVyLm5hbWUpIHtcXG4gICAgLy8gICAgICAgICAgICAgICAgcmlkZXIucG9pbnRzID0gcmVzdWx0LkE7XFxuICAgIC8vICAgICAgICAgICAgICB9XFxuICAgIC8vICAgICAgICAgICAgfSlcXG4gICAgLy8gICAgICAgICAgICB1c2VyLnRvdGFscG9pbnRzICs9IHJpZGVyLnBvaW50cztcXG4gICAgLy8gICAgICAgICAgfSlcXG4gICAgLy8gICAgICAgIH0pXFxuICAgIC8vICAgICAgIGNvbnNvbGUudGltZUVuZCgpO1xcbiAgICAvLyAgICAgICB0aGlzLmRvbmVMb2FkaW5nID0gdHJ1ZTtcXG4gICAgLy8gICAgICAgY29uc29sZS5sb2codGhpcy5tYWluTGVhZ3VlVXNlcnMpXFxuICAgIC8vICAgICB9KVxcbiAgICAvLyAgICB9LCAzMDAwKTtcXG4gICAgLy8gICBheGlvcy5nZXQoJy9nZXRNYWluTGVhZ3VlSW5mbycpXFxuICAgIC8vICAgLnRoZW4oZGF0YSA9PiB7XFxuICAgIC8vICAgICBjb25zb2xlLmxvZyhkYXRhLmRhdGEpO1xcbiAgICAvLyAgICAgZGF0YS5kYXRhLmZvckVhY2godXNlciA9PiB7XFxuICAgIC8vICAgICAgIHRoaXMubWFpbkxlYWd1ZVVzZXJzLnB1c2godXNlcilcXG4gICAgLy8gICAgIH0pXFxuICAgIC8vICAgfSlcXG4gICAgLy8gfVxcbiAgfVxcbjwvc2NyaXB0PlxcbjxzdHlsZT5cXG5ib2R5IHtcXG4gIGZvbnQtZmFtaWx5OiBcXFwiT3BlbiBTYW5zIENvbmRlbnNlZFxcXCI7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBtaW4taGVpZ2h0OiAxMDB2aDtcXG4gIGJhY2tncm91bmQ6XFxuICAgIGxpbmVhci1ncmFkaWVudCh0byBib3R0b20gcmlnaHQsIHJnYmEoMjUxLCAxMDksIDgsIC44KTAlLCByZ2JhKDIwNCwgNjYsIDAsIDEpMTAwJSksXFxuICAgIHVybCgnaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMzc1Mjcvc3BvcnRzLWdhbWVzLWZ1bi1ob2xpZGF5LTM3NTI3LmpwZWc/dz0xMjYwJmg9NzUwJmF1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2InKTtcXG4gIGJhY2tncm91bmQtc2l6ZTogY292ZXI7XFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOmNlbnRlcjtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxufVxcbi5sZWFkZXJib2FyZC10YWJsZSAudGl0bGUgPiB0aCB7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2Y1ZjVhMjtcXG4gIGZvbnQtc2l6ZTogMTZwdDtcXG4gIHBhZGRpbmc6IC41cmVtO1xcbn1cXG4ubGVhZGVyYm9hcmQtdGFibGUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuOCk7XFxuICBjb2xvcjogIzdiN2I3YjtcXG4gIGJveC1zaGFkb3c6IDFweCAxcHggMTBweCAjMjIyO1xcbn1cXG4ubGVhZGVyYm9hcmQtdGFibGUgdGhlYWQgdGgsIHRmb290IHRoIHtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgZm9udC1zaXplOiAxMnB0O1xcbn1cXG4ubGVhZGVyYm9hcmQtdGFibGUgdGhlYWQsIHRmb290IHtcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChyZ2JhKDI1NSwgMTA2LCAwLCAxKTAlLCByZ2JhKDE1NiwgNTIsIDAsIDEpMTAwJSk7XFxufVxcbi5sZWFkZXJib2FyZC10YWJsZSB0ZCB7XFxuICBib3JkZXI6IG5vbmU7XFxufVxcbi5sZWFkZXJib2FyZC10YWJsZSB0cjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjMzLCAxMjAsIC4yKTtcXG59XFxuICAucG9pbnRzYmFjayB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxuICAgIGNvbG9yOiAjZmYzODYwO1xcbiAgfVxcbiAgLmxlYWRlcmJvYXJkIHtcXG4gICAgbWFyZ2luLXRvcDogNTBweDtcXG4gIH1cXG4gIHRhYmxlIHRkLCB0aCB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlciAhaW1wb3J0YW50O1xcbiAgfVxcbiAgLmxlYWRlcmJvYXJkLW1haW4ge1xcbiAgICBtYXJnaW4tdG9wOiAyNXB4O1xcbiAgfVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtMmU0YTcwYTZcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbGVhZGVyYm9hcmQudnVlXG4vLyBtb2R1bGUgaWQgPSAxOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5zdWdnZXN0aW9ucy1jb250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgbWFyZ2luLXRvcDogM3JlbTtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9Vc2Vycy9TZXRoL1Byb2plY3RzL2ZhbnRhc3lzeC9jbGllbnQvY29tcG9uZW50cy9zdWdnZXN0aW9ucy52dWU/YTc4ZGIwNTZcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXNHQTtFQUNBLGNBQUE7RUFDQSx3QkFBQTtFQUNBLGlCQUFBO0NBQ0FcIixcImZpbGVcIjpcInN1Z2dlc3Rpb25zLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXIgc3VnZ2VzdGlvbnMtY29udGFpbmVyXFxcIj5cXG4gICAgICA8c2VjdGlvbj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbFxcXCI+XFxuICAgICAgICAgICAgPGxhYmVsPkFyZSB5b3UgYSByZWdpc3RlcmVkIHVzZXI/PC9sYWJlbD5cXG4gICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInJhZGlvXFxcIj5cXG4gICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwiUmVnaXN0ZXJlZFxcXCIgdmFsdWU9XFxcInRydWVcXFwiIHYtbW9kZWw9XFxcIlJlZ2lzdGVyZWRcXFwiPlxcbiAgICAgICAgICAgICAgWWVzXFxuICAgICAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInJhZGlvXFxcIj5cXG4gICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwiUmVnaXN0ZXJlZFxcXCIgdmFsdWU9XFxcImZhbHNlXFxcIiB2LW1vZGVsPVxcXCJSZWdpc3RlcmVkXFxcIj5cXG4gICAgICAgICAgICAgIE5vXFxuICAgICAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbFxcXCI+XFxuICAgICAgICAgICAgPGxhYmVsPklzIHRoaXMgZmVlZGJhY2sgb3IgYSBidWcgcmVwb3J0PzwvbGFiZWw+XFxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJyYWRpb1xcXCI+XFxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcImZlZWRiYWNrXFxcIiB2LW1vZGVsPVxcXCJSZXBvcnRUeXBlXFxcIiB2YWx1ZT1cXFwiZmVlZGJhY2tcXFwiPlxcbiAgICAgICAgICAgICAgRmVlZGJhY2tcXG4gICAgICAgICAgICA8L2xhYmVsPlxcbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwicmFkaW9cXFwiPlxcbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJmZWVkYmFja1xcXCIgdi1tb2RlbD1cXFwiUmVwb3J0VHlwZVxcXCIgdmFsdWU9XFxcImJ1Z1xcXCI+XFxuICAgICAgICAgICAgICBCdWcgUmVwb3J0XFxuICAgICAgICAgICAgPC9sYWJlbD5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJsYWJlbFxcXCI+VXNlcm5hbWU8L2xhYmVsPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xcXFwiPlxcbiAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJpbnB1dFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIlVzZXJuYW1lXFxcIiB2LW1vZGVsPVxcXCJVc2VybmFtZVxcXCI+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIiB2LWlmPVxcXCJSZXBvcnRUeXBlID09ICdmZWVkYmFjaydcXFwiPlxcbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcImxhYmVsXFxcIj5TdWdnZXN0IEZlYXR1cmVzPC9sYWJlbD5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbFxcXCI+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwic2VsZWN0XFxcIj5cXG4gICAgICAgICAgICAgIDxzZWxlY3Qgdi1tb2RlbD1cXFwiZmVhdHVyZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxvcHRpb24gZGlzYWJsZWQgdmFsdWU9XFxcIlxcXCI+U0VMRUNUIENBVEVHT1JZPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgIDxvcHRpb24+VXNlciBJbnRlcmZhY2U8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgPG9wdGlvbj5OYXZpZ2F0aW9uIENvbnRlbnQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgICAgPG9wdGlvbj5NeSBUZWFtPC9vcHRpb24+XFxuICAgICAgICAgICAgICAgIDxvcHRpb24+U2NvcmluZzwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICA8b3B0aW9uPk5ldyBGZWF0dXJlczwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICA8b3B0aW9uPlN0YXQgVHJhY2tlcjwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICA8b3B0aW9uPkFjY291bnQ8L29wdGlvbj5cXG4gICAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiIHYtaWY9XFxcIlJlcG9ydFR5cGUgPT0gJ2ZlZWRiYWNrJ1xcXCI+XFxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwibGFiZWxcXFwiPkZlZWRiYWNrPC9sYWJlbD5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbFxcXCI+XFxuICAgICAgICAgICAgPHRleHRhcmVhIGNsYXNzPVxcXCJ0ZXh0YXJlYVxcXCIgdi1tb2RlbD1cXFwiZmVlZGJhY2tcXFwiIHBsYWNlaG9sZGVyPVxcXCJEZXNjcmliZSB5b3VyIHN1Z2dlc3Rpb25zIGhlcmUuXFxcIj48L3RleHRhcmVhPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiIHYtaWY9XFxcIlJlcG9ydFR5cGUgPT0gJ2J1ZydcXFwiPlxcbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcImxhYmVsXFxcIj5SZXBvcnQgQnVnPC9sYWJlbD5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbFxcXCI+XFxuICAgICAgICAgICAgPHRleHRhcmVhIGNsYXNzPVxcXCJ0ZXh0YXJlYVxcXCIgdi1tb2RlbD1cXFwiYnVncmVwb3J0XFxcIiBwbGFjZWhvbGRlcj1cXFwiRGVzY3JpYmUgdGhlIGFjdGlvbnMgeW91IHRvb2ssIHlvdXIgZGVzaXJlZCBvdXRjb21lIGFuZCB0aGUgYWN0dWFsIG91dGNvbWUgb2YgdGhvc2UgYWN0aW9ucy4gV2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVwbGljYXRlIHRoZSBidWcgYmFzZWQgb2ZmIHRoZSBzdGVwcyB5b3UgcHJvdmlkZSBoZXJlLlxcXCI+PC90ZXh0YXJlYT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGlzLXByaW1hcnlcXFwiIHYtb246Y2xpY2s9XFxcInN1Ym1pdFxcXCIgdHlwZT1cXFwiYnV0dG9uXFxcIj5TdWJtaXQ8L2J1dHRvbj5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvc2VjdGlvbj5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuPHNjcmlwdD5cXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xcbiAgZXhwb3J0IGRlZmF1bHQge1xcbiAgICBkYXRhKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBVc2VybmFtZTogJycsXFxuICAgICAgICBSZXBvcnRUeXBlOiAnJyxcXG4gICAgICAgIFJlZ2lzdGVyZWQ6IGZhbHNlLFxcbiAgICAgICAgZmVhdHVyZTogJycsXFxuICAgICAgICBidWdyZXBvcnQ6ICcnLFxcbiAgICAgICAgZmVlZGJhY2s6ICcnXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgc3VibWl0KCkge1xcbiAgICAgICAgdmFyIGRhdGEgPSB7XFxuICAgICAgICAgIFVzZXJuYW1lOiB0aGlzLlVzZXJuYW1lLFxcbiAgICAgICAgICBSZXBvcnRUeXBlOiB0aGlzLlJlcG9ydFR5cGUsXFxuICAgICAgICAgIFJlZ2lzdGVyZWQ6IHRoaXMuUmVnaXN0ZXJlZCxcXG4gICAgICAgICAgRmVhdHVyZTogdGhpcy5mZWF0dXJlLFxcbiAgICAgICAgICBCdWdSZXBvcnQ6IHRoaXMuYnVncmVwb3J0LFxcbiAgICAgICAgICBGZWVkYmFjazogdGhpcy5mZWVkYmFja1xcbiAgICAgICAgfVxcbiAgICAgICAgYXhpb3MucG9zdCgnL2ZlZWRiYWNrJywgZGF0YSlcXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XFxuICAgICAgICAgIGNvbnNvbGUubG9nKHJlcylcXG4gICAgICAgIH0pXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbiAgLnN1Z2dlc3Rpb25zLWNvbnRhaW5lciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBtYXJnaW4tdG9wOiAzcmVtO1xcbiAgfVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtM2ZiNzc3MThcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvc3VnZ2VzdGlvbnMudnVlXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5zdWNjZXNzZnVsLXNhdmUge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgY29sb3I6ICMwMGQxYjI7XFxufVxcbi5teXRlYW0tdGFibGUgdGFibGUgdGQge1xcbiAgYm9yZGVyOiBub25lO1xcbn1cXG4ubXl0ZWFtLXRhYmxlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjgpO1xcbiAgY29sb3I6ICM3YjdiN2I7XFxuICBib3gtc2hhZG93OiAxcHggMXB4IDEwcHggIzIyMjtcXG59XFxuLm15dGVhbS10YWJsZSB0aGVhZCwgdGZvb3Qge1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHJnYmEoMjU1LCAxMDYsIDAsIDEpMCUsIHJnYmEoMTU2LCA1MiwgMCwgMSkxMDAlKTtcXG59XFxuLm15dGVhbS10aXRsZSB7XFxuICBjb2xvcjogIzg2ODY4NjtcXG4gIGZvbnQtc2l6ZTogMTZwdDtcXG59XFxuLm15dGVhbS10YWJsZSB0aGVhZCB0aCwgdGZvb3QgdGgge1xcbiAgY29sb3I6ICNmZmY7XFxuICBmb250LXNpemU6IDEycHQ7XFxufVxcbi5teXRlYW0tdGFibGUgdHI6aG92ZXIge1xcbiAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDIzMywgMTIwLCAuMik7XFxufVxcbi5mYWlsdXJlLXNhdmUge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgY29sb3I6ICNmZjJiNTY7XFxufVxcbi5mYWRlLWVudGVyLWFjdGl2ZSwgLmZhZGUtbGVhdmUtYWN0aXZlIHtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMXM7XFxufVxcbi5mYWRlLWVudGVyLCAuZmFkZS1sZWF2ZS10byB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG4ucGFnZS1oZWFkZXItY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuYnV0dG9uIHtcXG4gIG1hcmdpbi1ib3R0b206IDAuMjVyZW07XFxufVxcbi5wYWdlLWhlYWRlci1ibG9jayB7XFxuICB3aWR0aDogMTUlO1xcbiAgbWluLXdpZHRoOiAyNjBweDtcXG59XFxuLnJpZGVycy1jb250YWluZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LXdyYXA6IHdyYXA7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG4ucmlkZXItYmxvY2sge1xcbiAgICBtaW4td2lkdGg6IDE1cmVtO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZGVkZWRlO1xcbiAgICBtYXJnaW46IDFyZW07XFxuICAgIGJveC1zaGFkb3c6IDFweCAxcHggMXB4ICNjZWNlY2U7XFxuICAgIHBhZGRpbmc6IDFyZW07XFxuICAgIG1heC13aWR0aDogMTVyZW07XFxufVxcbi5wYWdlLXRpdGxlIHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXG59XFxuLnBhZ2UtdGl0bGUge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgICBmb250LXdlaWdodDogNzAwO1xcbn1cXG4ucGFnZS1zdWJoZWFkZXIge1xcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcXG59XFxuLmNhcmQtZm9vdGVyIHtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2VlZTtcXG59XFxuLmNhcmQtY29udGVudCB7XFxuICAgIG1pbi1oZWlnaHQ6IDExcmVtO1xcbiAgICBtYXgtaGVpZ2h0OiAxMXJlbTtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG59XFxuLmNhcmQtZm9vdGVyIGRpdjpudGgtY2hpbGQoZXZlbikge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbn1cXG4uZm9vdGVyLXJvdyB7XFxuICAgIGRpc3BsYXk6ZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbn1cXG5wLmNhcmQtaGVhZGVyLXRpdGxlIHtcXG4gICAgZGlzcGxheTpmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcXG59XFxucCBzcGFuLmljb24ge1xcbiAgICBjb2xvcjogI2ZmMzg2MDtcXG59XFxudGg6aG92ZXIge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5oaWRlLXBhZ2luYXRpb24tYnV0dG9uIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbn1cXG4uY3VzdG9tLXBhZ2luYXRpb24ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcbi5sYXN0Um93IHtcXG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHJnYigyMDgsIDgzLCAxKTtcXG59XFxuLm1pbnVzLWljb24ge1xcbiAgICBjb2xvcjogI2ZmMzg2MDtcXG59XFxuLnBsdXMtaWNvbiB7XFxuICAgIGNvbG9yOiAjMjNkMTYwO1xcbn1cXG4uYm9sZGVzdC1oZWFkZXIge1xcbiAgICBjb2xvcjogI2ZmZmM3ZjtcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gICAgZm9udC1zaXplOiB4eC1sYXJnZTtcXG59XFxuLnJpZ2h0IHtcXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG4ubGgtNHIge1xcbiAgICBoZWlnaHQ6IDRyZW07XFxuICAgIGxpbmUtaGVpZ2h0OiA0cmVtO1xcbiAgICBmb250LXNpemU6IDEuNzVyZW07XFxuICAgIGNvbG9yOndoaXRlO1xcbn1cXG4ubGgtNHI6Zmlyc3Qtb2YtdHlwZSB7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZmZlOTc4O1xcbn1cXG4ubGgtNHI6bGFzdC1vZi10eXBlIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMnJlbTtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9Vc2Vycy9TZXRoL1Byb2plY3RzL2ZhbnRhc3lzeC9jbGllbnQvY29tcG9uZW50cy9teXRlYW0udnVlPzY3NDVkMzgyXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUF5UUE7RUFDQSxtQkFBQTtFQUNBLGVBQUE7Q0FDQTtBQUNBO0VBQ0EsYUFBQTtDQUNBO0FBQ0E7RUFDQSwwQ0FBQTtFQUNBLGVBQUE7RUFDQSw4QkFBQTtDQUNBO0FBQ0E7RUFDQSw2RUFBQTtDQUNBO0FBQ0E7RUFDQSxlQUFBO0VBQ0EsZ0JBQUE7Q0FDQTtBQUNBO0VBQ0EsWUFBQTtFQUNBLGdCQUFBO0NBQ0E7QUFDQTtFQUNBLG9DQUFBO0NBQ0E7QUFDQTtFQUNBLG1CQUFBO0VBQ0EsZUFBQTtDQUNBO0FBQ0E7RUFDQSx1QkFBQTtDQUNBO0FBQ0E7RUFDQSxXQUFBO0NBQ0E7QUFDQTtFQUNBLGNBQUE7RUFDQSx3QkFBQTtDQUNBO0FBQ0E7RUFDQSx1QkFBQTtDQUNBO0FBQ0E7RUFDQSxXQUFBO0VBQ0EsaUJBQUE7Q0FDQTtBQUNBO0lBQ0EsY0FBQTtJQUNBLGdCQUFBO0lBQ0Esd0JBQUE7Q0FDQTtBQUNBO0lBQ0EsaUJBQUE7SUFDQSwwQkFBQTtJQUNBLGFBQUE7SUFDQSxnQ0FBQTtJQUNBLGNBQUE7SUFDQSxpQkFBQTtDQUNBO0FBQ0E7SUFDQSxtQkFBQTtJQUNBLDJCQUFBO0lBQ0EsaUJBQUE7Q0FDQTtBQUNBO0lBQ0EsbUJBQUE7SUFDQSwyQkFBQTtJQUNBLGlCQUFBO0NBQ0E7QUFDQTtJQUNBLGtCQUFBO0NBQ0E7QUFDQTtJQUNBLHVCQUFBO0lBQ0EsdUJBQUE7Q0FDQTtBQUNBO0lBQ0Esa0JBQUE7SUFDQSxrQkFBQTtJQUNBLGlCQUFBO0lBQ0Esb0JBQUE7Q0FDQTtBQUNBO0lBQ0EsdUJBQUE7Q0FDQTtBQUNBO0lBQ0EsYUFBQTtJQUNBLCtCQUFBO0NBQ0E7QUFDQTtJQUNBLGFBQUE7SUFDQSw4QkFBQTtDQUNBO0FBQ0E7SUFDQSxlQUFBO0NBQ0E7QUFDQTtJQUNBLGdCQUFBO0NBQ0E7QUFDQTtJQUNBLG1CQUFBO0NBQ0E7QUFDQTtJQUNBLGNBQUE7SUFDQSwrQkFBQTtDQUNBO0FBQ0E7SUFDQSx5Q0FBQTtDQUNBO0FBQ0E7SUFDQSxlQUFBO0NBQ0E7QUFDQTtJQUNBLGVBQUE7Q0FDQTtBQUNBO0lBQ0EsZUFBQTtJQUNBLGlCQUFBO0lBQ0Esb0JBQUE7Q0FDQTtBQUNBO0lBQ0EsYUFBQTtDQUNBO0FBQ0E7SUFDQSxhQUFBO0lBQ0Esa0JBQUE7SUFDQSxtQkFBQTtJQUNBLFlBQUE7Q0FDQTtBQUNBO0lBQ0EsaUNBQUE7Q0FDQTtBQUNBO0lBQ0Esb0JBQUE7Q0FDQVwiLFwiZmlsZVwiOlwibXl0ZWFtLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8ZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJwYWdlLWhlYWRlci1jb250YWluZXJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInBhZ2UtaGVhZGVyLWJsb2NrXFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImxoLTRyXFxcIj5XZWVrOiA8c3BhbiBjbGFzcz1cXFwiYm9sZGVzdC1oZWFkZXIgcmlnaHRcXFwiPnt7Y3VycmVudHdlZWt9fTwvc3Bhbj48L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImxoLTRyXFxcIj5CYWxhbmNlIFJlbWFpbmluZzo8c3BhbiBjbGFzcz1cXFwiYm9sZGVzdC1oZWFkZXIgcmlnaHRcXFwiPiAke3tkb2xsYXJzfX08L3NwYW4+PC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgICAgIDx0cmFuc2l0aW9uIG5hbWU9XFxcImZhZGVcXFwiIG1vZGU9XFxcIm91dC1pblxcXCI+XFxuICAgICAgICA8cCB2LWlmPVxcXCJzaG93U2F2ZU1lc3NhZ2VcXFwiIGNsYXNzPVxcXCJzdWNjZXNzZnVsLXNhdmVcXFwiPllvdXIgdGVhbSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgc2F2ZWQhPC9wPlxcbiAgICAgICAgPHAgdi1pZj1cXFwic2hvd0ZhaWxNZXNzYWdlXFxcIiBjbGFzcz1cXFwiZmFpbHVyZS1zYXZlXFxcIj5Pb3BzISBTb21ldGhpbmcgV2VudCBXcm9uZy4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci48L3A+XFxuICAgICAgPC90cmFuc2l0aW9uPlxcbiAgICAgIDx0YWJsZSBjbGFzcz1cXFwibXl0ZWFtLXRhYmxlXFxcIj5cXG4gICAgICAgIDx0aGVhZD5cXG4gICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgIDx0aD5BY3Rpb248L3RoPlxcbiAgICAgICAgICAgIDx0aCBAY2xpY2s9XFxcInNvcnRCeVByaWNlXFxcIj5QcmljZVxcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb25cXFwiPlxcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtY2FyZXQtdXBcXFwiIHYtaWY9XFxcIkNvc3RTb3J0QnlBc2NcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1jYXJldC1kb3duXFxcIiB2LWVsc2UgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvaT5cXG4gICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICA8L3RoPlxcbiAgICAgICAgICAgIDx0aD5SYWNlciBOYW1lPC90aD5cXG4gICAgICAgICAgICA8dGg+UmFjZXIgTnVtYmVyPC90aD5cXG4gICAgICAgICAgICA8dGg+SGlnaGVzdCBGaW5pc2g8L3RoPlxcbiAgICAgICAgICAgIDx0aD5Mb3dlc3QgRmluaXNoPC90aD5cXG4gICAgICAgICAgICA8dGg+QXZlcmFnZSBGaW5pc2g8L3RoPlxcbiAgICAgICAgICA8L3RyPlxcbiAgICAgICAgPC90aGVhZD5cXG4gICAgICAgIDx0Zm9vdD5cXG4gICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgIDx0aD5BY3Rpb248L3RoPlxcbiAgICAgICAgICAgIDx0aD5QcmljZTwvdGg+XFxuICAgICAgICAgICAgPHRoPlJhY2VyIE5hbWU8L3RoPlxcbiAgICAgICAgICAgIDx0aD5SYWNlciBOdW1iZXI8L3RoPlxcbiAgICAgICAgICAgIDx0aD5IaWdoZXN0IEZpbmlzaDwvdGg+XFxuICAgICAgICAgICAgPHRoPkxvd2VzdCBGaW5pc2g8L3RoPlxcbiAgICAgICAgICAgIDx0aD5BdmVyYWdlIEZpbmlzaDwvdGg+XFxuICAgICAgICAgIDwvdHI+XFxuICAgICAgICA8L3Rmb290PlxcbiAgICAgICAgPHRib2R5PlxcbiAgICAgICAgICA8dHIgdi1mb3I9XFxcIihyYWNlciwgaW5kZXgpIGluIHNlbGVjdGVkcmlkZXJzXFxcIj5cXG4gICAgICAgICAgICA8dGQ+XFxuICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjIVxcXCIgdi1pZj1cXFwicmFjZXIubmFtZSAhPSAnT1BFTiBTTE9UJ1xcXCIgQGNsaWNrPVxcXCJyZW1vdmVSYWNlcihyYWNlcilcXFwiPlxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbiBtaW51cy1pY29uXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtbWludXNcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgIDwvYT5cXG4gICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgIDx0ZD4ke3tyYWNlci5jb3N0fX08L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e3JhY2VyLm5hbWV9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7cmFjZXIucmlkZXJfbnVtYmVyfX08L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e3JhY2VyLmhpZ2hlc3RGaW5pc2h9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7cmFjZXIubG93ZXN0RmluaXNofX08L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e3JhY2VyLmF2ZXJhZ2VGaW5pc2h9fTwvdGQ+XFxuICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgIDx0ciBjbGFzcz1cXFwibGFzdFJvd1xcXCI+XFxuICAgICAgICAgICAgPHRkIGNvbHNwYW49XFxcIjVcXFwiPjwvdGQ+XFxuICAgICAgICAgICAgPHRkIGNvbHNwYW49XFxcIjFcXFwiPlxcbiAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uIGlzLWRhbmdlclxcXCIgQGNsaWNrPVxcXCJSZW1vdmVBbGxcXFwiIDpkaXNhYmxlZD1cXFwiIXNob3dSZW1vdmVBbGxcXFwiPlJlbW92ZSBBbGw8L2J1dHRvbj5cXG4gICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCIxXFxcIj5cXG4gICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBpcy1zdWNjZXNzXFxcIiBAY2xpY2s9XFxcIlNhdmVUZWFtXFxcIiA6ZGlzYWJsZWQ9XFxcImhhc09wZW5TbG90c1xcXCIgdi1iaW5kOmNsYXNzPVxcXCJ7J2lzLWxvYWRpbmcnOmlzTG9hZGluZ31cXFwiPlNhdmUgVGVhbTwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgIDx0ciB2LWZvcj1cXFwicmlkZXIgaW4gcGFnaW5hdGVkUmlkZXJzXFxcIj5cXG4gICAgICAgICAgICA8dGQ+XFxuICAgICAgICAgICAgICA8YSBocmVmPVxcXCIjIVxcXCIgdi1pZj1cXFwic2hvd1NlbGVjdCAmJiByaWRlci5jb3N0IDw9IGRvbGxhcnNcXFwiIEBjbGljaz1cXFwiYWRkUmFjZXIocmlkZXIpXFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24gcGx1cy1pY29uXFxcIj5cXG4gICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtcGx1c1xcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgPC9hPlxcbiAgICAgICAgICAgIDwvdGQ+XFxuICAgICAgICAgICAgPHRkPiR7e3JpZGVyLmNvc3R9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7cmlkZXIubmFtZX19PC90ZD5cXG4gICAgICAgICAgICA8dGQ+e3tyaWRlci5yaWRlcl9udW1iZXJ9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7cmlkZXIuaGlnaGVzdEZpbmlzaH19PC90ZD5cXG4gICAgICAgICAgICA8dGQ+e3tyaWRlci5sb3dlc3RGaW5pc2h9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7cmlkZXIuYXZlcmFnZUZpbmlzaH19PC90ZD5cXG4gICAgICAgICAgPC90cj5cXG4gICAgICAgIDwvdGJvZHk+XFxuICAgICAgPC90YWJsZT5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjdXN0b20tcGFnaW5hdGlvblxcXCI+XFxuICAgICAgICA8ZGl2PlxcbiAgICAgICAgICA8YSBjbGFzcz1cXFwicGFnaW5hdGlvbi1wcmV2aW91c1xcXCIgQGNsaWNrPVxcXCJwYWdlLS1cXFwiIHYtYmluZDpjbGFzcz1cXFwieyAnaGlkZS1wYWdpbmF0aW9uLWJ1dHRvbicgOiBoaWRlUHJldmlvdXMgfVxcXCI+UHJldmlvdXM8L2E+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXY+XFxuICAgICAgICAgIDxhIGNsYXNzPVxcXCJwYWdpbmF0aW9uLW51bWJlclxcXCI+e3twYWdlfX0ve3twYWdpbmF0aW9uUGFnZXN9fTwvYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdj5cXG4gICAgICAgICAgPGEgY2xhc3M9XFxcInBhZ2luYXRpb24tbmV4dFxcXCIgQGNsaWNrPVxcXCJwYWdlKytcXFwiIHYtYmluZDpjbGFzcz1cXFwieyAnaGlkZS1wYWdpbmF0aW9uLWJ1dHRvbicgOiBoaWRlTmV4dCB9XFxcIj5OZXh0IHBhZ2U8L2E+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L3RlbXBsYXRlPlxcblxcbjxzY3JpcHQ+XFxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcXG5pbXBvcnQgeyBtYXBHZXR0ZXJzIH0gZnJvbSAndnVleCc7XFxuaW1wb3J0IF9maW5kSW5kZXggZnJvbSAnbG9kYXNoL2ZpbmRJbmRleCc7XFxuaW1wb3J0IF9zb3J0QnkgZnJvbSAnbG9kYXNoL3NvcnRCeSc7XFxuaW1wb3J0IF9yZW1vdmUgZnJvbSAnbG9kYXNoL3JlbW92ZSc7XFxuICBleHBvcnQgZGVmYXVsdCB7XFxuICAgIGRhdGEoKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGN1cnJlbnR3ZWVrOiAwLFxcbiAgICAgICAgc2VsZWN0ZWRyaWRlcnM6IFtdLFxcbiAgICAgICAgYXZhaWxhYmxlUmlkZXJzOiBbXSxcXG4gICAgICAgIENvc3RTb3J0QnlBc2M6IHRydWUsXFxuICAgICAgICBwYWdlOiAxLFxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcXG4gICAgICAgIHNob3dTYXZlTWVzc2FnZTogZmFsc2UsXFxuICAgICAgICBzaG93RmFpbE1lc3NhZ2U6IGZhbHNlXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wdXRlZDoge1xcbiAgICAgIC4uLm1hcEdldHRlcnMoW1xcbiAgICAgICAgJ2dldFVzZXJEYXRhJ1xcbiAgICAgIF0pLFxcbiAgICAgIGRvbGxhcnMoKSB7XFxuICAgICAgICB2YXIgdG90YWwgPSAxMDAwMDtcXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRyaWRlcnMuZm9yRWFjaChyaWRlciA9PiB7XFxuICAgICAgICAgIHRvdGFsIC09IHJpZGVyLmNvc3Q7XFxuICAgICAgICB9KVxcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xcbiAgICAgIH0sXFxuICAgICAgaGlkZVByZXZpb3VzKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZSA8PSAxO1xcbiAgICAgIH0sXFxuICAgICAgaGlkZU5leHQoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5wYWdlID49IHRoaXMucGFnaW5hdGlvblBhZ2VzO1xcbiAgICAgIH0sXFxuICAgICAgcGFnaW5hdGVkUmlkZXJzKCkge1xcbiAgICAgICAgaWYgKHRoaXMucGFnZSA9PSAxKSB7XFxuICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJlbnRpcmUgYXJyYXlcXFwiLCB0aGlzLmF2YWlsYWJsZVJpZGVycylcXG4gICAgICAgICAgY29uc29sZS5sb2codGhpcy5hdmFpbGFibGVSaWRlcnMuc2xpY2UoMCwgMTApKTtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlUmlkZXJzLnNsaWNlKDAsIDEwKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHZhciBiZWdpblNsaWNlID0gdGhpcy5wYWdlICogMTAgLSA5O1xcbiAgICAgICAgICB2YXIgZW5kU2xpY2UgPSBiZWdpblNsaWNlICsgMTA7XFxuICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYXZhaWxhYmxlUmlkZXJzKVxcbiAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmF2YWlsYWJsZVJpZGVycy5zbGljZShiZWdpblNsaWNlLCBlbmRTbGljZSkpXFxuICAgICAgICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZVJpZGVycy5zbGljZShiZWdpblNsaWNlLCBlbmRTbGljZSk7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBwYWdpbmF0aW9uUGFnZXMoKSB7XFxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYXZhaWxhYmxlUmlkZXJzLmxlbmd0aCAvIDEwKTtcXG4gICAgICB9LFxcbiAgICAgIGhhc09wZW5TbG90cygpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkcmlkZXJzLnNvbWUocmlkZXIgPT4geyByZXR1cm4gcmlkZXIubmFtZSA9PSBcXFwiT1BFTiBTTE9UXFxcIiB9KVxcbiAgICAgIH0sXFxuICAgICAgc2hvd1JlbW92ZUFsbCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkcmlkZXJzLnNvbWUocmlkZXIgPT4geyByZXR1cm4gcmlkZXIubmFtZSAhPSBcXFwiT1BFTiBTTE9UXFxcIiB9KVxcbiAgICAgIH0sXFxuICAgICAgc2hvd1NlbGVjdCgpIHtcXG4gICAgICAgIHZhciBvcGVuU2xvdHMgPSB0aGlzLnNlbGVjdGVkcmlkZXJzLnNvbWUoKHJpZGVyKSA9PiB7cmV0dXJuIHJpZGVyLm5hbWUgPT0gXFxcIk9QRU4gU0xPVFxcXCJ9KTtcXG4gICAgICAgIHZhciBsb3dlc3RDb3N0QXZhaWxhYmxlID0gX3NvcnRCeSh0aGlzLmF2YWlsYWJsZVJpZGVycywgbyA9PiB7IHJldHVybiBvLmNvc3QgfSk7XFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwic2hvd1NlbGVjdFxcXCIsIGxvd2VzdENvc3RBdmFpbGFibGVbMF0pXFxuICAgICAgICBpZiAoKHRoaXMuZG9sbGFycyA+PSBsb3dlc3RDb3N0QXZhaWxhYmxlWzBdLmNvc3QpICYmIG9wZW5TbG90cykge1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIG1ldGhvZHM6IHtcXG4gICAgICByZW1vdmVSYWNlcihyYWNlcikge1xcbiAgICAgICAgY29uc29sZS5sb2coXFxcInJlbW92ZWQgcmFjZXJzXFxcIiwgcmFjZXIpO1xcbiAgICAgICAgdmFyIHNlbGVjdGVkUmFjZXJJbmRleCA9IF9maW5kSW5kZXgodGhpcy5zZWxlY3RlZHJpZGVycywgbyA9PiB7IHJldHVybiBvLnJpZGVyaWQgPT09IHJhY2VyLnJpZGVyaWQgfSk7XFxuICAgICAgICB2YXIgb3BlblNwYWNlID0ge1xcbiAgICAgICAgICBpZDogdGhpcy5zZWxlY3RlZHJpZGVyc1tzZWxlY3RlZFJhY2VySW5kZXhdLmlkLFxcbiAgICAgICAgICBhdmF0YXJfdXJsOiAnaHR0cDovL3d3dy5zaG9wYWFyZHZhcmsuY29tL21lZGlhL2NhdGFsb2cvcHJvZHVjdC9XL1MvV1MtMTg2NTUuanBnJyxcXG4gICAgICAgICAgY29zdDogMCxcXG4gICAgICAgICAgaGlnaGVzdEZpbmlzaDogJy0nLFxcbiAgICAgICAgICBsb3dlc3RGaW5pc2g6ICctJyxcXG4gICAgICAgICAgbmFtZTogJ09QRU4gU0xPVCcsXFxuICAgICAgICAgIHJpZGVyX251bWJlcjogMCxcXG4gICAgICAgICAgcmlkZXJpZDogMCxcXG4gICAgICAgICAgbGVhZ3VlaWQ6IDEsXFxuICAgICAgICAgIHNlYXNvbl93ZWVrc2lkOiB0aGlzLmN1cnJlbnR3ZWVrXFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLmF2YWlsYWJsZVJpZGVycy5wdXNoKHJhY2VyKVxcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIHNlbGVjdGVkUmFjZXJJbmRleCwgb3BlblNwYWNlKVxcbiAgICAgICAgY29uc29sZS5sb2coXFxcIk15IG5ldyB0ZWFtXFxcIiwgdGhpcy5zZWxlY3RlZHJpZGVycylcXG4gICAgICB9LFxcbiAgICAgIGFkZFJhY2VyKHJhY2VyKSB7XFxuICAgICAgICB2YXIgb3BlblNsb3RJbmRleCA9IF9maW5kSW5kZXgodGhpcy5zZWxlY3RlZHJpZGVycywgbyA9PiB7IHJldHVybiBvLm5hbWUgPT0gXFxcIk9QRU4gU0xPVFxcXCIgfSk7XFxuICAgICAgICBfcmVtb3ZlKHRoaXMucGFnaW5hdGVkUmlkZXJzLCBvID0+IHsgcmV0dXJuIG8ucmlkZXJpZCA9PSByYWNlci5yaWRlcmlkIH0pXFxuICAgICAgICBfcmVtb3ZlKHRoaXMuYXZhaWxhYmxlUmlkZXJzLCBvID0+IHsgcmV0dXJuIG8ucmlkZXJpZCA9PSByYWNlci5yaWRlcmlkIH0pXFxuICAgICAgICByYWNlci5pZCA9IHRoaXMuc2VsZWN0ZWRyaWRlcnNbb3BlblNsb3RJbmRleF0uaWQ7XFxuICAgICAgICB0aGlzLiRzZXQodGhpcy5zZWxlY3RlZHJpZGVycywgb3BlblNsb3RJbmRleCwgcmFjZXIpO1xcbiAgICAgICAgY29uc29sZS5sb2coXFxcIlJhY2VycyB0byBBZGRcXFwiLCB0aGlzLnNlbGVjdGVkcmlkZXJzKVxcbiAgICAgIH0sXFxuICAgICAgc29ydEJ5UHJpY2UoKSB7XFxuICAgICAgICBpZiAodGhpcy5Db3N0U29ydEJ5QXNjKSB7XFxuICAgICAgICAgIHRoaXMuQ29zdFNvcnRCeUFzYyA9IGZhbHNlO1xcbiAgICAgICAgICB0aGlzLnBhZ2luYXRlZFJpZGVycyA9IHRoaXMucGFnaW5hdGVkUmlkZXJzLnNvcnQoKGEsIGIpID0+IHtcXG4gICAgICAgICAgICBpZiAoYS5jb3N0ID4gYi5jb3N0KSB7XFxuICAgICAgICAgICAgICByZXR1cm4gLTFcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKGEuY29zdCA8IGIuY29zdCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIDFcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIDBcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuQ29zdFNvcnRCeUFzYyA9IHRydWU7XFxuICAgICAgICAgIHRoaXMucGFnaW5hdGVkUmlkZXJzID0gdGhpcy5wYWdpbmF0ZWRSaWRlcnMuc29ydCgoYSwgYikgPT4ge1xcbiAgICAgICAgICAgIGlmIChhLmNvc3QgPiBiLmNvc3QpIHtcXG4gICAgICAgICAgICAgIHJldHVybiAxXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChhLmNvc3QgPCBiLmNvc3QpIHtcXG4gICAgICAgICAgICAgIHJldHVybiAtMVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gMFxcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgU2F2ZVRlYW0oKSB7XFxuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XFxuICAgICAgICBheGlvcy5wb3N0KFxcXCIvU2F2ZVRlYW1cXFwiLCB0aGlzLnNlbGVjdGVkcmlkZXJzKVxcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XFxuICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XFxuICAgICAgICAgIHRoaXMuU2F2ZU1lc3NhZ2UoKTtcXG4gICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XFxuICAgICAgICB9KVxcbiAgICAgICAgLmNhdGNoKGVycm9yID0+IHtcXG4gICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xcbiAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xcbiAgICAgICAgICB0aGlzLkZhaWxNZXNzYWdlKCk7XFxuICAgICAgICB9KVxcbiAgICAgIH0sXFxuICAgICAgU2F2ZU1lc3NhZ2UoKSB7XFxuICAgICAgICB0aGlzLnNob3dTYXZlTWVzc2FnZSA9IHRydWU7XFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5zaG93U2F2ZU1lc3NhZ2UgPSBmYWxzZSB9LCA1MDAwKVxcbiAgICAgIH0sXFxuICAgICAgRmFpbE1lc3NhZ2UoKSB7XFxuICAgICAgICB0aGlzLnNob3dGYWlsTWVzc2FnZSA9IHRydWU7XFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5zaG93RmFpbE1lc3NhZ2UgPSBmYWxzZSB9LCA1MDAwKVxcbiAgICAgIH0sXFxuICAgICAgUmVtb3ZlQWxsKCkge1xcbiAgICAgICAgdGhpcy5zZWxlY3RlZHJpZGVycy5mb3JFYWNoKHJhY2VyID0+IHtcXG4gICAgICAgICAgaWYgKHJhY2VyLm5hbWUgIT0gXFxcIk9QRU4gU0xPVFxcXCIpIHtcXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVJhY2VyKHJhY2VyKVxcbiAgICAgICAgICB9XFxuICAgICAgICB9KVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgYmVmb3JlQ3JlYXRlKCkge1xcbiAgICAgIGF4aW9zLmdldCgnL0N1cnJlbnRNeVRlYW1Nb2RlbCcpXFxuICAgICAgLnRoZW4oZGF0YSA9PiB7XFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwiZGF0YVxcXCIsIGRhdGEuZGF0YSk7XFxuICAgICAgICB0aGlzLmN1cnJlbnR3ZWVrID0gZGF0YS5kYXRhLkN1cnJlbnRXZWVrO1xcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5jdXJyZW50d2Vlayk7XFxuICAgICAgICB0aGlzLmF2YWlsYWJsZVJpZGVycyA9IF9zb3J0QnkoZGF0YS5kYXRhLkF2YWlsYWJsZVJpZGVycywgbyA9PiB7IHJldHVybiBvLmNvc3QgfSk7XFxuICAgICAgICB0aGlzLnNlbGVjdGVkcmlkZXJzID0gZGF0YS5kYXRhLkN1cnJlbnRUZWFtO1xcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIG1vdW50ZWQoKSB7XFxuICAgICAgY29uc29sZS5sb2coXFxcIm1vdW50ZWRcXFwiLCB0aGlzLmdldFVzZXJEYXRhKVxcbiAgICB9XFxuICB9XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbi5zdWNjZXNzZnVsLXNhdmUge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgY29sb3I6ICMwMGQxYjI7XFxufVxcbi5teXRlYW0tdGFibGUgdGFibGUgdGQge1xcbiAgYm9yZGVyOiBub25lO1xcbn1cXG4ubXl0ZWFtLXRhYmxlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjgpO1xcbiAgY29sb3I6ICM3YjdiN2I7XFxuICBib3gtc2hhZG93OiAxcHggMXB4IDEwcHggIzIyMjtcXG59XFxuLm15dGVhbS10YWJsZSB0aGVhZCwgdGZvb3Qge1xcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHJnYmEoMjU1LCAxMDYsIDAsIDEpMCUsIHJnYmEoMTU2LCA1MiwgMCwgMSkxMDAlKTtcXG59XFxuLm15dGVhbS10aXRsZSB7XFxuICBjb2xvcjogIzg2ODY4NjtcXG4gIGZvbnQtc2l6ZTogMTZwdDtcXG59XFxuLm15dGVhbS10YWJsZSB0aGVhZCB0aCwgdGZvb3QgdGgge1xcbiAgY29sb3I6ICNmZmY7XFxuICBmb250LXNpemU6IDEycHQ7XFxufVxcbi5teXRlYW0tdGFibGUgdHI6aG92ZXIge1xcbiAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDIzMywgMTIwLCAuMik7XFxufVxcbi5mYWlsdXJlLXNhdmUge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgY29sb3I6ICNmZjJiNTY7XFxufVxcbi5mYWRlLWVudGVyLWFjdGl2ZSwgLmZhZGUtbGVhdmUtYWN0aXZlIHtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMXM7XFxufVxcbi5mYWRlLWVudGVyLCAuZmFkZS1sZWF2ZS10byB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG4ucGFnZS1oZWFkZXItY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuYnV0dG9uIHtcXG4gIG1hcmdpbi1ib3R0b206IDAuMjVyZW07XFxufVxcbi5wYWdlLWhlYWRlci1ibG9jayB7XFxuICB3aWR0aDogMTUlO1xcbiAgbWluLXdpZHRoOiAyNjBweDtcXG59XFxuICAucmlkZXJzLWNvbnRhaW5lciB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtd3JhcDogd3JhcDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICB9XFxuICAucmlkZXItYmxvY2sge1xcbiAgICBtaW4td2lkdGg6IDE1cmVtO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZGVkZWRlO1xcbiAgICBtYXJnaW46IDFyZW07XFxuICAgIGJveC1zaGFkb3c6IDFweCAxcHggMXB4ICNjZWNlY2U7XFxuICAgIHBhZGRpbmc6IDFyZW07XFxuICAgIG1heC13aWR0aDogMTVyZW07XFxuICB9XFxuICAucGFnZS10aXRsZSB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICB9XFxuICAucGFnZS10aXRsZSB7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICB9XFxuICAucGFnZS1zdWJoZWFkZXIge1xcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcXG4gIH1cXG4gIC5jYXJkLWZvb3RlciB7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICB9XFxuICAuY2FyZC1jb250ZW50IHtcXG4gICAgbWluLWhlaWdodDogMTFyZW07XFxuICAgIG1heC1oZWlnaHQ6IDExcmVtO1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgfVxcbiAgLmNhcmQtZm9vdGVyIGRpdjpudGgtY2hpbGQoZXZlbikge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbiAgfVxcbiAgLmZvb3Rlci1yb3cge1xcbiAgICBkaXNwbGF5OmZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIH1cXG4gIHAuY2FyZC1oZWFkZXItdGl0bGUge1xcbiAgICBkaXNwbGF5OmZsZXg7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcbiAgfVxcbiAgcCBzcGFuLmljb24ge1xcbiAgICBjb2xvcjogI2ZmMzg2MDtcXG4gIH1cXG4gIHRoOmhvdmVyIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbiAgLmhpZGUtcGFnaW5hdGlvbi1idXR0b24ge1xcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICB9XFxuICAuY3VzdG9tLXBhZ2luYXRpb24ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICB9XFxuICAubGFzdFJvdyB7XFxuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCByZ2IoMjA4LCA4MywgMSk7XFxuICB9XFxuICAubWludXMtaWNvbiB7XFxuICAgIGNvbG9yOiAjZmYzODYwO1xcbiAgfVxcbiAgLnBsdXMtaWNvbiB7XFxuICAgIGNvbG9yOiAjMjNkMTYwO1xcbiAgfVxcbiAgLmJvbGRlc3QtaGVhZGVyIHtcXG4gICAgY29sb3I6ICNmZmZjN2Y7XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICAgIGZvbnQtc2l6ZTogeHgtbGFyZ2U7XFxuICB9XFxuICAucmlnaHQge1xcbiAgICBmbG9hdDogcmlnaHQ7XFxuICB9XFxuICAubGgtNHIge1xcbiAgICBoZWlnaHQ6IDRyZW07XFxuICAgIGxpbmUtaGVpZ2h0OiA0cmVtO1xcbiAgICBmb250LXNpemU6IDEuNzVyZW07XFxuICAgIGNvbG9yOndoaXRlO1xcbiAgfVxcbiAgLmxoLTRyOmZpcnN0LW9mLXR5cGUge1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2ZmZTk3ODtcXG4gIH1cXG4gIC5saC00cjpsYXN0LW9mLXR5cGUge1xcbiAgICBtYXJnaW4tYm90dG9tOiAycmVtO1xcbiAgfVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNDkzNjFjNzBcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbXl0ZWFtLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiXCIsXCJmaWxlXCI6XCJpbmRleC52dWVcIixcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTRmYzAwNWIwXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2luZGV4LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uZXJyb3JNZXNzYWdlIHtcXG4gIGNvbG9yOiAjZmYzODYwO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL1VzZXJzL1NldGgvUHJvamVjdHMvZmFudGFzeXN4L2NsaWVudC9jb21wb25lbnRzL3JlZ2lzdGVyLnZ1ZT82MDBjZjM1MlwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBOElBO0VBQ0EsZUFBQTtDQUNBXCIsXCJmaWxlXCI6XCJyZWdpc3Rlci52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPGRpdiBjbGFzcz1cXFwibW9kYWxcXFwiIHYtYmluZDpjbGFzcz1cXFwieydpcy1hY3RpdmUnOiBTaG93UmVnaXN0ZXJNb2RhbH1cXFwiIGlkPVxcXCJyZWdpc3Rlck1vZGFsXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtYmFja2dyb3VuZFxcXCI+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWNhcmRcXFwiPlxcbiAgICAgIDxoZWFkZXIgY2xhc3M9XFxcIm1vZGFsLWNhcmQtaGVhZFxcXCI+XFxuICAgICAgICA8cCBjbGFzcz1cXFwibW9kYWwtY2FyZC10aXRsZVxcXCI+TmV3IFVzZXIgUmVnaXN0cmF0aW9uPC9wPlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiZGVsZXRlXFxcIiBAY2xpY2s9XFxcInNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiAhU2hvd1JlZ2lzdGVyTW9kYWx9KVxcXCI+PC9idXR0b24+XFxuICAgICAgPC9oZWFkZXI+XFxuICAgICAgPHNlY3Rpb24gY2xhc3M9XFxcIm1vZGFsLWNhcmQtYm9keVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcImxhYmVsXFxcIj5Vc2VybmFtZTogPC9sYWJlbD5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wgaGFzLWljb25zLWxlZnRcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImlucHV0XFxcIiB2LWJpbmQ6Y2xhc3M9XFxcInsgJ2lzLWRhbmdlcic6IGludmFsaWRVc2VybmFtZSB9XFxcIiBpZD1cXFwicmVnLXVzZXJuYW1lXFxcIiB2LW1vZGVsPVxcXCJ1c2VybmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIlVzZXJuYW1lXFxcIiByZXF1aXJlZD5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24gaXMtc21hbGwgaXMtbGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXVzZXJcXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJsYWJlbFxcXCI+RW1haWw6IDwvbGFiZWw+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImVtYWlsXFxcIiBjbGFzcz1cXFwiaW5wdXRcXFwiIHYtYmluZDpjbGFzcz1cXFwieyAnaXMtZGFuZ2VyJzogaW52YWxpZEVtYWlsIH1cXFwiICBpZD1cXFwicmVnLWVtYWlsXFxcIiB2LW1vZGVsPVxcXCJlbWFpbFxcXCIgcGxhY2Vob2xkZXI9XFxcIkVtYWlsXFxcIiByZXF1aXJlZD5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24gaXMtc21hbGwgaXMtbGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWVudmVsb3BlXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwibGFiZWxcXFwiPlBhc3N3b3JkOiA8L2xhYmVsPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJwYXNzd29yZFxcXCIgY2xhc3M9XFxcImlucHV0XFxcIiB2LWJpbmQ6Y2xhc3M9XFxcInsgJ2lzLWRhbmdlcic6IGJsYW5rUGFzc3dvcmQgfVxcXCIgaWQ9XFxcInJlZy1wYXNzd29yZFxcXCIgdi1tb2RlbD1cXFwicGFzc3dvcmRcXFwiIHBsYWNlaG9sZGVyPVxcXCJQYXNzd29yZFxcXCIgcmVxdWlyZWQ+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1sb2NrXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgIFJFQ0FQVENIQSBQTEFDRUhPTERFUlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImVycm9yTWVzc2FnZVxcXCIgdi1mb3I9XFxcImVycm9yIGluIGVycm9yTWVzc2FnZVxcXCIgdi1pZj1cXFwiZXJyb3JNZXNzYWdlICE9ICcnXFxcIj5cXG4gICAgICAgICAgICAgIHt7IGVycm9yIH19XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L3NlY3Rpb24+XFxuICAgICAgPGZvb3RlciBjbGFzcz1cXFwibW9kYWwtY2FyZC1mb290XFxcIj5cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBpcy1zdWNjZXNzXFxcIiBAY2xpY2s9XFxcIlJlZ2lzdGVyXFxcIiB2LWJpbmQ6Y2xhc3M9XFxcInsgJ2lzLWxvYWRpbmcnOiBpc0xvYWRpbmcgfVxcXCI+UmVnaXN0ZXI8L2J1dHRvbj5cXG4gICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvblxcXCIgQGNsaWNrPVxcXCJzZXRSZWdpc3Rlck1vZGFsKHsgc2hvdzogIVNob3dSZWdpc3Rlck1vZGFsIH0pXFxcIj5DYW5jZWw8L2J1dHRvbj5cXG4gICAgICA8L2Zvb3Rlcj5cXG4gICAgPC9kaXY+XFxuICA8L2Rpdj5cXG48L3RlbXBsYXRlPlxcblxcbjxzY3JpcHQ+XFxuaW1wb3J0IHsgbWFwR2V0dGVycywgbWFwTXV0YXRpb25zIH0gZnJvbSAndnVleCc7XFxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcXG4gIGV4cG9ydCBkZWZhdWx0IHtcXG4gICAgZGF0YSgpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdXNlcm5hbWU6ICcnLFxcbiAgICAgICAgZW1haWw6ICcnLFxcbiAgICAgICAgcGFzc3dvcmQ6ICcnLFxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBbXSxcXG4gICAgICAgIGludmFsaWRVc2VybmFtZTogZmFsc2UsXFxuICAgICAgICBpbnZhbGlkRW1haWw6IGZhbHNlLFxcbiAgICAgICAgYmxhbmtQYXNzd29yZDogZmFsc2UsXFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wdXRlZDogbWFwR2V0dGVycyhbXFxuICAgICAgJ1Nob3dSZWdpc3Rlck1vZGFsJyxcXG4gICAgICAnZ2V0VXNlckRhdGEnXFxuICAgIF0pLFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgLi4ubWFwTXV0YXRpb25zKFtcXG4gICAgICAgICdzZXRSZWdpc3Rlck1vZGFsJyxcXG4gICAgICAgICdzZXRVc2VyRGF0YScsXFxuICAgICAgICAnc2V0TG9nZ2VkSW4nXFxuICAgICAgXSksXFxuICAgICAgUmVnaXN0ZXIoKSB7XFxuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XFxuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZSA9IFtdO1xcbiAgICAgICAgdGhpcy5pbnZhbGlkRW1haWwgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMuYmxhbmtQYXNzd29yZCA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy5pbnZhbGlkVXNlcm5hbWUgPSBmYWxzZTtcXG4gICAgICAgIGlmICh0aGlzLlJlZ2lzdHJhdGlvbklzVmFsaWQoKSkge1xcblxcbiAgICAgICAgICBheGlvcy5wb3N0KCcvcmVnaXN0ZXInLCB7XFxuICAgICAgICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXFxuICAgICAgICAgICAgZW1haWw6IHRoaXMuZW1haWwsXFxuICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMucGFzc3dvcmRcXG4gICAgICAgICAgfSkudGhlbihkYXRhID0+IHtcXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xcbiAgICAgICAgICAgIHZhciBpc0ZhbHNlID0gIWRhdGEuZGF0YS5FcnJvck1lc3NhZ2U7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coXFxcImlzRmFsc2VcXFwiLCBpc0ZhbHNlKVxcbiAgICAgICAgICAgIGlmICghZGF0YS5kYXRhLkVycm9yTWVzc2FnZSkge1xcbiAgICAgICAgICAgICAgdGhpcy5zZXRVc2VyRGF0YSh7IHVzZXJEYXRhOiBkYXRhLmRhdGEgfSlcXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJnZXRVc2VyRGF0YVxcXCIsIHRoaXMuZ2V0VXNlckRhdGEpXFxuICAgICAgICAgICAgICB0aGlzLnNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiBmYWxzZSB9KVxcbiAgICAgICAgICAgICAgdGhpcy5zZXRMb2dnZWRJbih7IGxvZ2dlZEluOiB0cnVlIH0pXFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLiRzdG9yZS5zdGF0ZSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlLnB1c2goZGF0YS5kYXRhLkVycm9yTWVzc2FnZSk7XFxuICAgICAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZS5mb3JFYWNoKG1zZyA9PiB7XFxuICAgICAgICAgICAgICAgIGlmIChtc2cuaW5kZXhPZihcXFwiVXNlcm5hbWVcXFwiKSA+IC0xKSB7XFxuICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkVXNlcm5hbWUgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmIChtc2cuaW5kZXhPZihcXFwiRW1haWxcXFwiKSA+LTEpIHtcXG4gICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRFbWFpbCA9IHRydWU7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0pXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KVxcblxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgUmVnaXN0cmF0aW9uSXNWYWxpZCgpIHtcXG4gICAgICAgIHZhciBlbWFpbFZhbGlkYXRpb24gPSB0aGlzLmVtYWlsLm1hdGNoKG5ldyBSZWdFeHAoL14oKFtePD4oKVxcXFxbXFxcXF1cXFxcXFxcXC4sOzpcXFxcc0BcXFwiXSsoXFxcXC5bXjw+KClcXFxcW1xcXFxdXFxcXFxcXFwuLDs6XFxcXHNAXFxcIl0rKSopfChcXFwiLitcXFwiKSlAKChcXFxcW1swLTldezEsM31cXFxcLlswLTldezEsM31cXFxcLlswLTldezEsM31cXFxcLlswLTldezEsM31dKXwoKFthLXpBLVpcXFxcLTAtOV0rXFxcXC4pK1thLXpBLVpdezIsfSkpJC8pLCBcXFwiaVxcXCIpO1xcbiAgICAgICAgY29uc29sZS5sb2coZW1haWxWYWxpZGF0aW9uKTtcXG4gICAgICAgIGlmICh0aGlzLmVtYWlsID09IFxcXCJcXFwiKSB7XFxuICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlLnB1c2goXFxcIlVzZXJuYW1lIGNhbm5vdCBiZSBsZWZ0IGVtcHR5LlxcXCIpXFxuICAgICAgICAgIHRoaXMuaW52YWxpZFVzZXJuYW1lID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChlbWFpbFZhbGlkYXRpb24gPT0gbnVsbCkge1xcbiAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZS5wdXNoKFxcXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbC5cXFwiKVxcbiAgICAgICAgICB0aGlzLmludmFsaWRFbWFpbCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGhpcy5wYXNzd29yZCA9PSAnJyB8fCB0aGlzLnBhc3N3b3JkLmxlbmd0aCA8IDYpIHtcXG4gICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UucHVzaChcXFwiUGFzc3dvcmQgY2Fubm90IGJlIGxlZnQgZW1wdHkgYW5kIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzLlxcXCIpXFxuICAgICAgICAgIHRoaXMuYmxhbmtQYXNzd29yZCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGhpcy5lcnJvck1lc3NhZ2UubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG48L3NjcmlwdD5cXG48c3R5bGU+XFxuICAuZXJyb3JNZXNzYWdlIHtcXG4gICAgY29sb3I6ICNmZjM4NjA7XFxuICB9XFxuPC9zdHlsZT5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi01ZmI0ZmM0YVwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWVcbi8vIG1vZHVsZSBpZCA9IDIwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuaDEge1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG4vKiBBY29yZGVvbiBzdHlsZXMgKi9cXG4udGFiIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIG1hcmdpbi1ib3R0b206IDFweDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgY29sb3I6ICNmZmY7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbn1cXG5pbnB1dCB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBvcGFjaXR5OiAwO1xcbiAgei1pbmRleDogLTE7XFxufVxcbmxhYmVsIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcGFkZGluZzogMCAwIDAgMWVtO1xcbiAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBsaW5lLWhlaWdodDogMztcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGNvbG9yOiAjZmZmYzdmO1xcbn1cXG4udGFiLWNvbnRlbnQge1xcbiAgbWF4LWhlaWdodDogMDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogbWF4LWhlaWdodCAuMzVzO1xcbiAgLW8tdHJhbnNpdGlvbjogbWF4LWhlaWdodCAuMzVzO1xcbiAgdHJhbnNpdGlvbjogbWF4LWhlaWdodCAuMzVzO1xcbiAgY29sb3I6ICNmZmY7XFxufVxcbi50YWItY29udGVudCBwIHtcXG4gIG1hcmdpbjogMWVtO1xcbn1cXG4vKiA6Y2hlY2tlZCAqL1xcbmlucHV0OmNoZWNrZWQgfiAudGFiLWNvbnRlbnQge1xcbiAgbWF4LWhlaWdodDogMTBlbTtcXG59XFxuLyogSWNvbiAqL1xcbmxhYmVsOjphZnRlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogMDtcXG4gIHRvcDogMDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgd2lkdGg6IDNlbTtcXG4gIGhlaWdodDogM2VtO1xcbiAgbGluZS1oZWlnaHQ6IDM7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAuMzVzO1xcbiAgLW8tdHJhbnNpdGlvbjogYWxsIC4zNXM7XFxuICB0cmFuc2l0aW9uOiBhbGwgLjM1cztcXG59XFxuaW5wdXRbdHlwZT1jaGVja2JveF0gKyBsYWJlbDo6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIitcXFwiO1xcbn1cXG5pbnB1dFt0eXBlPXJhZGlvXSArIGxhYmVsOjphZnRlciB7XFxuICBjb250ZW50OiBcXFwiXFxcXDI1QkNcXFwiO1xcbn1cXG5pbnB1dFt0eXBlPWNoZWNrYm94XTpjaGVja2VkICsgbGFiZWw6OmFmdGVyIHtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDMxNWRlZyk7XFxufVxcbmlucHV0W3R5cGU9cmFkaW9dOmNoZWNrZWQgKyBsYWJlbDo6YWZ0ZXIge1xcbiAgdHJhbnNmb3JtOiByb3RhdGVYKDE4MGRlZyk7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMvU2V0aC9Qcm9qZWN0cy9mYW50YXN5c3gvY2xpZW50L2NvbXBvbmVudHMvcnVsZXMudnVlPzY3MTJhODA1XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFtQ0E7RUFDQSxtQkFBQTtDQUNBO0FBQ0EscUJBQUE7QUFDQTtFQUNBLG1CQUFBO0VBQ0EsbUJBQUE7RUFDQSxZQUFBO0VBQ0EsWUFBQTtFQUNBLGlCQUFBO0NBQ0E7QUFDQTtFQUNBLG1CQUFBO0VBQ0EsV0FBQTtFQUNBLFlBQUE7Q0FDQTtBQUNBO0VBQ0EsbUJBQUE7RUFDQSxlQUFBO0VBQ0EsbUJBQUE7RUFDQSxxQ0FBQTtFQUNBLGtCQUFBO0VBQ0EsZUFBQTtFQUNBLGdCQUFBO0VBQ0EsZUFBQTtDQUNBO0FBQ0E7RUFDQSxjQUFBO0VBQ0EsaUJBQUE7RUFDQSx3QkFBQTtFQUNBLG9DQUFBO0VBQ0EsK0JBQUE7RUFDQSw0QkFBQTtFQUNBLFlBQUE7Q0FDQTtBQUNBO0VBQ0EsWUFBQTtDQUNBO0FBQ0EsY0FBQTtBQUNBO0VBQ0EsaUJBQUE7Q0FDQTtBQUNBLFVBQUE7QUFDQTtFQUNBLG1CQUFBO0VBQ0EsU0FBQTtFQUNBLE9BQUE7RUFDQSxlQUFBO0VBQ0EsV0FBQTtFQUNBLFlBQUE7RUFDQSxlQUFBO0VBQ0EsbUJBQUE7RUFDQSw2QkFBQTtFQUNBLHdCQUFBO0VBQ0EscUJBQUE7Q0FDQTtBQUNBO0VBQ0EsYUFBQTtDQUNBO0FBQ0E7RUFDQSxpQkFBQTtDQUNBO0FBQ0E7RUFDQSwwQkFBQTtDQUNBO0FBQ0E7RUFDQSwyQkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJydWxlcy52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiXFxcIj5cXG4gICAgICA8cD5SdWxlczwvcD5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJ0YWJcXFwiPlxcbiAgICAgICAgPGlucHV0IGlkPVxcXCJ0YWItb25lXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmFtZT1cXFwidGFic1xcXCI+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0YWItb25lXFxcIj5Ib3cgZG9lcyBzY29yaW5nIHdvcms/PC9sYWJlbD5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50XFxcIj5cXG4gICAgICAgICAgPHA+UmlnaHQgbm93LCBzY29yaW5nIGlzIHNldCBieSByYWNlciBmaW5pc2guIElmIGEgc2VsZWN0ZWQgcmFjZXIgZm9yIHRoYXQgd2VlayBmaW5pc2hlcyBpbiBmaXJzdCwgdGhhdCByYWNlciBpcyBhd2FyZGVkIDEgcG9pbnQuIElmIGEgcmFjZXIgZmluaXNoZXMgaW4gZm91cnRoLCB0aGF0IHJhY2VyIGlzIGF3YXJkZWQgNCBwb2ludHMuIFRoZSBsb3dlciB0aGUgcG9pbnQgdG90YWwgdGhlIGJldHRlciBzY29yZS48L3A+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJ0YWJcXFwiPlxcbiAgICAgICAgPGlucHV0IGlkPVxcXCJ0YWItdHdvXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmFtZT1cXFwidGFic1xcXCI+XFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0YWItdHdvXFxcIj5Ib3cgZG9lcyB0ZWFtIHNlbGVjdGlvbiB3b3JrPzwvbGFiZWw+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudFxcXCI+XFxuICAgICAgICAgIDxwPkFzIG9mIG5vdywgZWFjaCB1c2VyIGlzIFJFUVVJUkVEIHRvIHNlbGVjdCA0IHJhY2VycyBmb3IgZWFjaCB3ZWVrLiBUaGUgZGVhZGxpbmUgZm9yIG1ha2luZyByYWNlciBzZWxlY3Rpb24gaXMgM2FtIE1vdW50YWluIFRpbWUgb24gdGhlIGRheSBvZiB0aGUgc2NoZWR1bGVkIHJhY2UuIEFmdGVyIHRoYXQgdGltZVxcbiAgICAgICAgICAgIHVzZXJzIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gc2VsZWN0IHJhY2VycyBmb3IgdGhhdCB3ZWVrJ3MgcmFjZTsgdGhlIHRlYW0gc2VsZWN0aW9uIGZvciB0aGUgbmV4dCB3ZWVrIHdpbGwgYmUgYXZhaWxhYmxlIGZvciBzZWxlY3Rpb248L3A+XFxuICAgICAgICAgIDxwPlVzZXJzIG1heSBvbmx5IFNBVkUgYSByb3N0ZXIgaWYgQUxMIDQgcm9zdGVyIHNsb3RzIGhhdmUgYSByYWNlciBjaG9zZW4uIFRoZSBTQVZFIGJ1dHRvbiBpcyBkaXNhYmxlZCBpZiBhbiBPUEVOIFNMT1Qgc3RpbGwgZXhpc3RzIGZvciBhIHdlZWtseSBsaW5ldXAuPC9wPlxcbiAgICAgICAgICA8cD5FYWNoIHVzZXIgYmVnaW5zIGVhY2ggd2VlayB3aXRoICQ4IGNyZWRpdHMgdG8gc3BlbmQgb24gZmlsbGluZyBvdXQgdGhlaXIgd2Vla2x5IGxpbmV1cCwgYW5kIHRoYXQgY3JlZGl0IGlzIHVzZWQgdG8gc2VsZWN0IHJhY2VycyBmb3IgdGhlaXIgd2VlaydzIGxpbmV1cCBmcm9tIHRoZSBhdmFpbGFibGUgcmFjZXJzIHBvb2wuXFxuICAgICAgICAgICAgVGhlIHNlbGVjdGVkIHJhY2VyJ3MgY29zdCwgb25jZSBzZWxlY3RlZCwgd2lsbCBiZSBkZWR1Y3RlZCBmcm9tIHRoZSBjdXJyZW50IHdlZWsncyBhdmFpbGFibGUgY3JlZGl0cy4gWW91IGFyZSBOT1QgUkVRVUlSRUQgdG8gc3BlbmQgYWxsICQ4IGNyZWRpdHMgZWFjaCB3ZWVrLjwvcD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcInRhYlxcXCI+XFxuICAgICAgICA8aW5wdXQgaWQ9XFxcInRhYi10aHJlZVxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5hbWU9XFxcInRhYnNcXFwiPlxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidGFiLXRocmVlXFxcIj5MaXZlIFN0YXQgVHJhY2tlciAmIEN1c3RvbSBMZWFndWVzPC9sYWJlbD5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50XFxcIj5cXG4gICAgICAgICAgPHA+UmlnaHQgbm93IHRoZSBhcHBsaWNhdGlvbiBpcyBjb25maWd1cmVkIHdoZXJlIGV2ZXJ5IHJlZ2lzdGVyZWQgdXNlciBjb21wZXRlcyBhZ2FpbnN0IGVhY2ggb3RoZXIgaW4gYW4gb3BlbiBNYWluIExlYWd1ZS4gVGhlIGxpdmUgc3RhdCB0cmFja2VyICh0byBzZWUgdGhlIHN0YW5kaW5ncyB1cGRhdGUgd2l0aCBsaXZlIHBvc2l0aW9uIGNoYW5nZXMpIGlzIG5vdCBhdmFpbGFibGUgZm9yIHRoZSBBTFBIQSB0ZXN0LlxcbiAgICAgICAgICBUaGlzIGZlYXR1cmUgd2lsbCBiZSB0ZXN0YWJsZSBkdXJpbmcgdGhlIEJFVEEgdmVyc2lvbiBvZiB0aGUgYXBwbGljYXRpb24uPC9wPlxcbiAgICAgICAgICA8cD5DdXJyZW50bHksIHRoZSBhcHBsaWNhdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGN1c3RvbSAvIHByaXZhdGUgbGVhZ3VlcywgaG93ZXZlciwgdGhpcyBmZWF0dXJlIHdpbGwgYmUgYXZhaWxhYmxlIGZvciB0ZXN0aW5nIGluIHRoZSBCRVRBIHZlcnNpb24gb2YgdGhlIGFwcGxpY2F0aW9uLjwvcD5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuPHN0eWxlPlxcbmgxIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuLyogQWNvcmRlb24gc3R5bGVzICovXFxuLnRhYiB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBtYXJnaW4tYm90dG9tOiAxcHg7XFxuICB3aWR0aDogMTAwJTtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuaW5wdXQge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgb3BhY2l0eTogMDtcXG4gIHotaW5kZXg6IC0xO1xcbn1cXG5sYWJlbCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHBhZGRpbmc6IDAgMCAwIDFlbTtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgbGluZS1oZWlnaHQ6IDM7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBjb2xvcjogI2ZmZmM3ZjtcXG59XFxuLnRhYi1jb250ZW50IHtcXG4gIG1heC1oZWlnaHQ6IDA7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICAtd2Via2l0LXRyYW5zaXRpb246IG1heC1oZWlnaHQgLjM1cztcXG4gIC1vLXRyYW5zaXRpb246IG1heC1oZWlnaHQgLjM1cztcXG4gIHRyYW5zaXRpb246IG1heC1oZWlnaHQgLjM1cztcXG4gIGNvbG9yOiAjZmZmO1xcbn1cXG4udGFiLWNvbnRlbnQgcCB7XFxuICBtYXJnaW46IDFlbTtcXG59XFxuLyogOmNoZWNrZWQgKi9cXG5pbnB1dDpjaGVja2VkIH4gLnRhYi1jb250ZW50IHtcXG4gIG1heC1oZWlnaHQ6IDEwZW07XFxufVxcbi8qIEljb24gKi9cXG5sYWJlbDo6YWZ0ZXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcmlnaHQ6IDA7XFxuICB0b3A6IDA7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAzZW07XFxuICBoZWlnaHQ6IDNlbTtcXG4gIGxpbmUtaGVpZ2h0OiAzO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjM1cztcXG4gIC1vLXRyYW5zaXRpb246IGFsbCAuMzVzO1xcbiAgdHJhbnNpdGlvbjogYWxsIC4zNXM7XFxufVxcbmlucHV0W3R5cGU9Y2hlY2tib3hdICsgbGFiZWw6OmFmdGVyIHtcXG4gIGNvbnRlbnQ6IFxcXCIrXFxcIjtcXG59XFxuaW5wdXRbdHlwZT1yYWRpb10gKyBsYWJlbDo6YWZ0ZXIge1xcbiAgY29udGVudDogXFxcIlxcXFwyNUJDXFxcIjtcXG59XFxuaW5wdXRbdHlwZT1jaGVja2JveF06Y2hlY2tlZCArIGxhYmVsOjphZnRlciB7XFxuICB0cmFuc2Zvcm06IHJvdGF0ZSgzMTVkZWcpO1xcbn1cXG5pbnB1dFt0eXBlPXJhZGlvXTpjaGVja2VkICsgbGFiZWw6OmFmdGVyIHtcXG4gIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpO1xcbn1cXG48L3N0eWxlPlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTliM2IzNDQwXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL3J1bGVzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uZmxleC1jZW50ZXIge1xcbiAgZGlzcGxheTpmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OmNlbnRlcjtcXG59XFxuLmxpdmUtaGVhZGVyLWJveCB7XFxuICBtaW4td2lkdGg6IDM2MHB4O1xcbn1cXG4ubGl2ZS1oZWFkZXIge1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZm9udC1zaXplOiAxMnB0O1xcbiAgbWFyZ2luLXRvcDogM3JlbTtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcbi50ZXh0LWhpZ2hsaWdodCB7XFxuICAgIGZvbnQtc2l6ZTogMTJwdDtcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gICAgY29sb3I6ICNmZmZjN2Y7XFxufVxcbi5mbC1yaWdodCB7XFxuICBmbG9hdDogcmlnaHQ7XFxufVxcbi5teVJvdyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsIDIzMywgMTIwLCAuMzUpICFpbXBvcnRhbnQ7XFxufVxcbi50YWJsZS1saXZlIHRhYmxlIHRkIHtcXG4gICAgYm9yZGVyOiBub25lO1xcbn1cXG4udGFibGUtbGl2ZSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjgpO1xcbiAgICBjb2xvcjogIzdiN2I3YjtcXG4gICAgYm94LXNoYWRvdzogMXB4IDFweCAxMHB4ICMyMjI7XFxufVxcbi50YWJsZS1saXZlIHRoZWFkLCB0Zm9vdCB7XFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChyZ2JhKDI1NSwgMTA2LCAwLCAxKTAlLCByZ2JhKDE1NiwgNTIsIDAsIDEpMTAwJSk7XFxufVxcbi50YWJsZS1saXZlIHRoZWFkIHRoLCB0Zm9vdCB0aCB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBmb250LXNpemU6IDEycHQ7XFxufVxcbi50YWJsZS1saXZlIHRyOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDIzMywgMTIwLCAuMik7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMvU2V0aC9Qcm9qZWN0cy9mYW50YXN5c3gvY2xpZW50L2NvbXBvbmVudHMvc3RhdHRyYWNrZXIudnVlPzRmYjkzNTI0XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUFnR0E7RUFDQSxhQUFBO0VBQ0EsdUJBQUE7Q0FDQTtBQUNBO0VBQ0EsaUJBQUE7Q0FDQTtBQUNBO0VBQ0EsYUFBQTtFQUNBLGdCQUFBO0VBQ0EsaUJBQUE7RUFDQSxpQkFBQTtDQUNBO0FBQ0E7SUFDQSxnQkFBQTtJQUNBLGlCQUFBO0lBQ0EsZUFBQTtDQUNBO0FBQ0E7RUFDQSxhQUFBO0NBQ0E7QUFDQTtJQUNBLHFEQUFBO0NBQ0E7QUFDQTtJQUNBLGFBQUE7Q0FDQTtBQUNBO0lBQ0EsMENBQUE7SUFDQSxlQUFBO0lBQ0EsOEJBQUE7Q0FDQTtBQUNBO0lBQ0EsNkVBQUE7Q0FDQTtBQUNBO0lBQ0EsWUFBQTtJQUNBLGdCQUFBO0NBQ0E7QUFDQTtJQUNBLG9DQUFBO0NBQ0FcIixcImZpbGVcIjpcInN0YXR0cmFja2VyLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8ZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmbGV4LWNlbnRlciBmbCBsaXZlLWhlYWRlclxcXCIgdi1pZj1cXFwiIWlzTG9hZGluZ1xcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibGl2ZS1oZWFkZXItYm94XFxcIj5cXG4gICAgICAgIDxkaXY+U2Vzc2lvbiBFdmVudDogPHNwYW4gY2xhc3M9XFxcInRleHQtaGlnaGxpZ2h0IGZsLXJpZ2h0XFxcIj57e3JhY2VEYXRhLnJhY2VEYXRhLlN9fTwvc3Bhbj48L2Rpdj5cXG4gICAgICAgIDxkaXY+U2Vhc29uIEV2ZW50OjxzcGFuIGNsYXNzPVxcXCJ0ZXh0LWhpZ2hsaWdodCBmbC1yaWdodFxcXCI+IHt7cmFjZURhdGEucmFjZURhdGEuRX19PC9zcGFuPjwvZGl2PlxcbiAgICAgICAgPGRpdj5TZXNzaW9uIFN0YXR1czo8c3BhbiBjbGFzcz1cXFwidGV4dC1oaWdobGlnaHQgZmwtcmlnaHRcXFwiPiB7e3JhY2VEYXRhLnJhY2VEZXRhaWxzLkJ9fTwvc3Bhbj48L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcImNvbHVtbnMgbGVhZGVyYm9hcmRcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbHVtbiBpcy1oYWxmIGlzLW9mZnNldC1vbmUtcXVhcnRlclxcXCI+XFxuICAgICAgICA8dGFibGUgY2xhc3M9XFxcInRhYmxlLWxpdmVcXFwiIHYtaWY9XFxcIiFpc0xvYWRpbmdcXFwiPlxcbiAgICAgICAgICA8dGhlYWQ+XFxuICAgICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgICAgPHRoPlBvc2l0aW9uPC90aD5cXG4gICAgICAgICAgICAgIDx0aD5Ub3RhbCBQb2ludHM8L3RoPlxcbiAgICAgICAgICAgICAgPHRoPlVzZXJuYW1lPC90aD5cXG4gICAgICAgICAgICAgIDx0aD5Qb2ludHMgQmFjazwvdGg+XFxuICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgPC90aGVhZD5cXG4gICAgICAgICAgPHRmb290PlxcbiAgICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICAgIDx0aD5Qb3NpdGlvbjwvdGg+XFxuICAgICAgICAgICAgICA8dGg+VG90YWwgUG9pbnRzPC90aD5cXG4gICAgICAgICAgICAgIDx0aD5Vc2VybmFtZTwvdGg+XFxuICAgICAgICAgICAgICA8dGg+UG9pbnRzIEJhY2s8L3RoPlxcbiAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgIDwvdGZvb3Q+XFxuICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICA8dHIgdi1mb3I9XFxcIih1c2VyLCBpbmRleCkgaW4gc3RhbmRpbmdzXFxcIiB2LWJpbmQ6Y2xhc3M9XFxcIlsgdXNlci51c2VybmFtZSA9PSBnZXRVc2VyRGF0YS51c2VybmFtZSA/ICdteVJvdycgOiAnJ11cXFwiPlxcbiAgICAgICAgICAgICAgPHRkPnt7IGluZGV4ICsgMSB9fS48L3RkPlxcbiAgICAgICAgICAgICAgPHRkPnt7dXNlci50b3RhbH19PC90ZD5cXG4gICAgICAgICAgICAgIDx0ZD57e3VzZXIudXNlcm5hbWV9fTwvdGQ+XFxuICAgICAgICAgICAgICA8dGQgY2xhc3M9XFxcInBvaW50c2JhY2tcXFwiPnt7IHBvaW50c2JlaGluZCh1c2VyKSB9fTwvdGQ+XFxuICAgICAgICAgICAgPC90cj5cXG4gICAgICAgICAgPC90Ym9keT5cXG4gICAgICAgIDwvdGFibGU+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XFxuaW1wb3J0IHsgbWFwR2V0dGVycyB9IGZyb20gJ3Z1ZXgnO1xcbiAgZXhwb3J0IGRlZmF1bHQge1xcbiAgICBkYXRhKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBsZWFndWVEYXRhOiBbXSxcXG4gICAgICAgIHJhY2VEYXRhOiBbXSxcXG4gICAgICAgIGlzTG9hZGluZzogdHJ1ZSxcXG4gICAgICAgIHdzOiBudWxsXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBjb21wdXRlZDoge1xcbiAgICAgIC4uLm1hcEdldHRlcnMoW1xcbiAgICAgICAgJ2dldFVzZXJEYXRhJ1xcbiAgICAgIF0pLFxcbiAgICAgIHN0YW5kaW5nczogZnVuY3Rpb24oKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy5sZWFndWVEYXRhLnNvcnQoKGEsIGIpID0+IHtcXG4gICAgICAgICAgcmV0dXJuIGEudG90YWwgLSBiLnRvdGFsO1xcbiAgICAgICAgfSlcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGNyZWF0ZWQoKSB7XFxuICAgICAgY29uc29sZS5sb2cocHJvY2Vzcy5lbnYuTk9ERV9FTlYpXFxuICAgICAgdGhpcy53cyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09ICdwcm9kdWN0aW9uJ1xcbiAgICAgICAgPyBuZXcgV2ViU29ja2V0KFxcXCJ3c3M6Ly9mYW50YXN5c3guaGVyb2t1YXBwLmNvbS90cmFja2VyXFxcIilcXG4gICAgICAgIDogbmV3IFdlYlNvY2tldChcXFwid3NzOi8vbG9jYWxob3N0OjMwMDAvdHJhY2tlclxcXCIpO1xcblxcbiAgICAgIHZhciB2ID0gdGhpcztcXG4gICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoZS5kYXRhKTtcXG4gICAgICAgIHYuaXNMb2FkaW5nID0gZmFsc2U7XFxuICAgICAgICB2LmxlYWd1ZURhdGEgPSBkYXRhLkxlYWd1ZURhdGE7XFxuICAgICAgICB2LnJhY2VEYXRhID0gZGF0YS5SYWNlRGF0YTtcXG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXFxuICAgICAgfVxcbiAgICAgIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwiRXJyb3JcXFwiLCBlKVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgbWV0aG9kczogIHtcXG4gICAgICBwb2ludHNiZWhpbmQ6IGZ1bmN0aW9uKHVzZXIpIHtcXG4gICAgICAgIHZhciBvYmpJbmRleCA9IHRoaXMubGVhZ3VlRGF0YS5pbmRleE9mKHVzZXIpO1xcbiAgICAgICAgaWYgKG9iakluZGV4ICE9IDApIHtcXG4gICAgICAgICAgcmV0dXJuIHVzZXIudG90YWwgLSB0aGlzLmxlYWd1ZURhdGFbMF0udG90YWw7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gJy0nXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBiZWZvcmVEZXN0cm95KCkge1xcbiAgICAgIHRoaXMud3MuY2xvc2UoKTtcXG4gICAgfVxcbiAgfVxcbjwvc2NyaXB0PlxcbjxzdHlsZT5cXG4uZmxleC1jZW50ZXIge1xcbiAgZGlzcGxheTpmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OmNlbnRlcjtcXG59XFxuLmxpdmUtaGVhZGVyLWJveCB7XFxuICBtaW4td2lkdGg6IDM2MHB4O1xcbn1cXG4ubGl2ZS1oZWFkZXIge1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZm9udC1zaXplOiAxMnB0O1xcbiAgbWFyZ2luLXRvcDogM3JlbTtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcbi50ZXh0LWhpZ2hsaWdodCB7XFxuICAgIGZvbnQtc2l6ZTogMTJwdDtcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gICAgY29sb3I6ICNmZmZjN2Y7XFxufVxcbi5mbC1yaWdodCB7XFxuICBmbG9hdDogcmlnaHQ7XFxufVxcbiAgLm15Um93IHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjpyZ2JhKDI1NSwgMjMzLCAxMjAsIC4zNSkgIWltcG9ydGFudDtcXG4gIH1cXG4gIC50YWJsZS1saXZlIHRhYmxlIHRkIHtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgfVxcbiAgLnRhYmxlLWxpdmUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC44KTtcXG4gICAgY29sb3I6ICM3YjdiN2I7XFxuICAgIGJveC1zaGFkb3c6IDFweCAxcHggMTBweCAjMjIyO1xcbiAgfVxcbiAgLnRhYmxlLWxpdmUgdGhlYWQsIHRmb290IHtcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHJnYmEoMjU1LCAxMDYsIDAsIDEpMCUsIHJnYmEoMTU2LCA1MiwgMCwgMSkxMDAlKTtcXG4gIH1cXG4gIC50YWJsZS1saXZlIHRoZWFkIHRoLCB0Zm9vdCB0aCB7XFxuICAgIGNvbG9yOiAjZmZmO1xcbiAgICBmb250LXNpemU6IDEycHQ7XFxuICB9XFxuICAudGFibGUtbGl2ZSB0cjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyMzMsIDEyMCwgLjIpO1xcbiAgfVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtYzZlN2VmZTZcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvc3RhdHRyYWNrZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5uYXZiYXItbWVudSB7XFxuICBwYWRkaW5nOiAwIDEwMHB4IDAgNTBweDtcXG59XFxuLm5hdmJhciB7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG59XFxuYSB7XFxuICBjb2xvcjogd2hpdGU7XFxuICBmb250LXNpemU6IDE2cHQ7XFxufVxcbi5yb3V0ZXItbGluay1hY3RpdmUge1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNmZmZjN2Y7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMvU2V0aC9Qcm9qZWN0cy9mYW50YXN5c3gvY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZT81Zjk4ZjA2MFwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBbUlBO0VBQ0Esd0JBQUE7Q0FDQTtBQUNBO0VBQ0Esd0JBQUE7Q0FDQTtBQUNBO0VBQ0EsYUFBQTtFQUNBLGdCQUFBO0NBQ0E7QUFDQTtFQUNBLGlDQUFBO0NBQ0FcIixcImZpbGVcIjpcIm5hdmJhci52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiXFxuICA8dGVtcGxhdGU+XFxuICAgIDxuYXYgY2xhc3M9XFxcIm5hdmJhclxcXCI+XFxuICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1icmFuZFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaXRlbVxcXCI+XFxuICAgICAgICAgIC8vQUxQSEEgVEVTVC8vXFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1idXJnZXIgYnVyZ2VyXFxcIiBkYXRhLXRhcmdldD1cXFwibmF2TWVudVxcXCI+XFxuICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cXG4gICAgICAgICAgPHNwYW4+PC9zcGFuPlxcbiAgICAgICAgICA8c3Bhbj48L3NwYW4+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItbWVudVxcXCIgaWQ9XFxcIm5hdk1lbnVcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLXN0YXJ0XFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWl0ZW1cXFwiPlxcbiAgICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cXFwiL2hvbWVcXFwiIGV4YWN0PkhvbWU8L3JvdXRlci1saW5rPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWl0ZW1cXFwiIHYtaWY9XFxcIkdldEF1dGhTdGF0dXNcXFwiPlxcbiAgICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cXFwiL215dGVhbVxcXCI+TXkgVGVhbTwvcm91dGVyLWxpbms+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaXRlbVxcXCIgdi1pZj1cXFwiR2V0QXV0aFN0YXR1c1xcXCI+XFxuICAgICAgICAgICAgPHJvdXRlci1saW5rIHRvPVxcXCIvbGl2ZVxcXCI+U3RhdCBUcmFja2VyPC9yb3V0ZXItbGluaz5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1pdGVtXFxcIj5cXG4gICAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XFxcIi9ydWxlc1xcXCI+SW5mbzwvcm91dGVyLWxpbms+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaXRlbVxcXCI+XFxuICAgICAgICAgICAgPHJvdXRlci1saW5rIHRvPVxcXCIvc3VnZ2VzdGlvbnNcXFwiPlN1Z2dlc3Rpb25zPC9yb3V0ZXItbGluaz5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1lbmRcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaXRlbVxcXCIgdi1pZj1cXFwiIUdldEF1dGhTdGF0dXNcXFwiIEBjbGljaz1cXFwic2V0UmVnaXN0ZXJNb2RhbCh7IHNob3c6ICFTaG93UmVnaXN0ZXJNb2RhbCB9KVxcXCI+XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiIyFcXFwiPlJlZ2lzdGVyPC9hPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWl0ZW1cXFwiIHYtaWY9XFxcIiFHZXRBdXRoU3RhdHVzXFxcIiBAY2xpY2s9XFxcInNldExvZ2luTW9kYWwoeyBzaG93OiAhU2hvd0xvZ2luTW9kYWwgfSlcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj5cXG4gICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1zaWduLWluXFxcIj48L2k+XFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcIiMhXFxcIj5Mb2dpbjwvYT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1pdGVtXFxcIiB2LWlmPVxcXCJHZXRBdXRoU3RhdHVzXFxcIj5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjIVxcXCI+V2VsY29tZSwge3sgZ2V0VXNlckRhdGEudXNlcm5hbWUgfX0hPC9hPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWl0ZW1cXFwiIHYtaWY9XFxcIkdldEF1dGhTdGF0dXNcXFwiIEBjbGljaz1cXFwic2V0TG9nZ2VkSW4oeyBpc0xvZ2dlZEluOiAhR2V0QXV0aFN0YXR1cyB9KVxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb25cXFwiIHYtaWY9XFxcIkdldEF1dGhTdGF0dXNcXFwiPlxcbiAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXNpZ24tb3V0XFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9pPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjIVxcXCIgQGNsaWNrPVxcXCJsb2dvdXRcXFwiPkxvZ291dDwvYT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8cmVnaXN0ZXIgOnNob3c9XFxcIlNob3dSZWdpc3Rlck1vZGFsXFxcIj48L3JlZ2lzdGVyPlxcbiAgICAgIDxsb2dpbiB2LWJpbmQ6c2hvdz1cXFwiU2hvd0xvZ2luTW9kYWxcXFwiPjwvbG9naW4+XFxuICAgIDwvbmF2PlxcbiAgPC90ZW1wbGF0ZT5cXG4gIDxzY3JpcHQ+XFxuICAgIGltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XFxuICAgIGltcG9ydCB7IG1hcEdldHRlcnMsIG1hcE11dGF0aW9ucyB9IGZyb20gJ3Z1ZXgnO1xcbiAgICBpbXBvcnQgcmVnaXN0ZXIgZnJvbSAnLi9yZWdpc3Rlci52dWUnO1xcbiAgICBpbXBvcnQgbG9naW4gZnJvbSAnLi9sb2dpbi52dWUnO1xcbiAgICBleHBvcnQgZGVmYXVsdCB7XFxuICAgICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiAge1xcbiAgICAgICAgICB1c2VybmFtZTogJycsXFxuICAgICAgICAgIHBhc3N3b3JkOiAnJyxcXG4gICAgICAgICAgc2hvd1JlZ2lzdGVyTW9kYWw6IGZhbHNlLFxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgY29tcHV0ZWQ6IG1hcEdldHRlcnMoW1xcbiAgICAgICAgJ1Nob3dMb2dpbk1vZGFsJyxcXG4gICAgICAgICdTaG93UmVnaXN0ZXJNb2RhbCcsXFxuICAgICAgICAnZ2V0VXNlckRhdGEnLFxcbiAgICAgICAgJ0dldEF1dGhTdGF0dXMnXFxuICAgICAgXSksXFxuICAgICAgbW91bnRlZCgpIHtcXG4gICAgICAgIC8vIEdldCBhbGwgXFxcIm5hdmJhci1idXJnZXJcXFwiIGVsZW1lbnRzXFxuICAgICAgICB2YXIgJG5hdmJhckJ1cmdlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubmF2YmFyLWJ1cmdlcicpLCAwKTtcXG4gICAgICAgIGNvbnNvbGUubG9nKCRuYXZiYXJCdXJnZXJzKTtcXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbmF2IGJ1cmdlcnNcXG4gICAgICAgIGlmICgkbmF2YmFyQnVyZ2Vycy5sZW5ndGggPiAwKSB7XFxuXFxuICAgICAgICAgIC8vIEFkZCBhIGNsaWNrIGV2ZW50IG9uIGVhY2ggb2YgdGhlbVxcbiAgICAgICAgICAkbmF2YmFyQnVyZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICgkZWwpIHtcXG4gICAgICAgICAgICAkZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XFxuXFxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRhcmdldCBmcm9tIHRoZSBcXFwiZGF0YS10YXJnZXRcXFwiIGF0dHJpYnV0ZVxcbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9ICRlbC5kYXRhc2V0LnRhcmdldDtcXG4gICAgICAgICAgICAgIHZhciAkdGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KTtcXG5cXG4gICAgICAgICAgICAgIC8vIFRvZ2dsZSB0aGUgY2xhc3Mgb24gYm90aCB0aGUgXFxcIm5hdmJhci1idXJnZXJcXFwiIGFuZCB0aGUgXFxcIm5hdmJhci1tZW51XFxcIlxcbiAgICAgICAgICAgICAgJGVsLmNsYXNzTGlzdC50b2dnbGUoJ2lzLWFjdGl2ZScpO1xcbiAgICAgICAgICAgICAgJHRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKCdpcy1hY3RpdmUnKTtcXG5cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBjcmVhdGVkKCkge1xcbiAgICAgICAgYXhpb3MuZ2V0KCcvbG9naW5yZWZyZXNoJykudGhlbihkYXRhID0+IHtcXG4gICAgICAgICAgY29uc29sZS5sb2coZGF0YS5kYXRhKVxcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEuZGF0YS51c2VybmFtZSAhPSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJVc2VyIElzIEF1dGhlbnRpY2F0ZWRcXFwiKVxcbiAgICAgICAgICAgIHRoaXMuc2V0VXNlckRhdGEoeyB1c2VyRGF0YTogZGF0YS5kYXRhIH0pXFxuICAgICAgICAgICAgdGhpcy5zZXRMb2dnZWRJbih7IGxvZ2dlZEluOiB0cnVlIH0pXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XFxuICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJsb2dpbiByZWZyZXNoIGVycm9yXFxcIiwgZXJyKTtcXG4gICAgICAgIH0pXFxuICAgICAgfSxcXG4gICAgICBtZXRob2RzOiB7XFxuICAgICAgICAuLi5tYXBNdXRhdGlvbnMoW1xcbiAgICAgICAgICAnc2V0UmVnaXN0ZXJNb2RhbCcsXFxuICAgICAgICAgICdzZXRMb2dpbk1vZGFsJyxcXG4gICAgICAgICAgJ3NldExvZ2dlZEluJyxcXG4gICAgICAgICAgJ3NldFVzZXJEYXRhJyxcXG4gICAgICAgICAgJ2xvZ291dCdcXG4gICAgICAgIF0pLFxcbiAgICAgICAgbG9nb3V0KCkge1xcbiAgICAgICAgICBheGlvcy5nZXQoJ2xvZ291dCcpLnRoZW4oZGF0YSA9PiB7XFxuICAgICAgICAgICAgdGhpcy4kcm91dGVyLnB1c2goXFxcIi9cXFwiKTtcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIGNvbXBvbmVudHM6IHtcXG4gICAgICAgICdyZWdpc3Rlcic6IHJlZ2lzdGVyLFxcbiAgICAgICAgJ2xvZ2luJzogbG9naW5cXG4gICAgICB9XFxuICAgIH1cXG4gIDwvc2NyaXB0PlxcbiAgPHN0eWxlPlxcbiAgICAubmF2YmFyLW1lbnUge1xcbiAgICAgIHBhZGRpbmc6IDAgMTAwcHggMCA1MHB4O1xcbiAgICB9XFxuICAgIC5uYXZiYXIge1xcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgICB9XFxuICAgIGEge1xcbiAgICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgICBmb250LXNpemU6IDE2cHQ7XFxuICAgIH1cXG4gICAgLnJvdXRlci1saW5rLWFjdGl2ZSB7XFxuICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNmZmZjN2Y7XFxuICAgIH1cXG4gIDwvc3R5bGU+XFxufSlcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi1lZjI5N2ExMlwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0yZTRhNzBhNlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vbGVhZGVyYm9hcmQudnVlXCIpXG59XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9sZWFkZXJib2FyZC52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTJlNGE3MGE2XFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2xlYWRlcmJvYXJkLnZ1ZVwiKSxcbiAgLyogc3R5bGVzICovXG4gIGluamVjdFN0eWxlLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9Vc2Vycy9TZXRoL1Byb2plY3RzL2ZhbnRhc3lzeC9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIGxlYWRlcmJvYXJkLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yZTRhNzBhNlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTJlNGE3MGE2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWVcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vbG9naW4udnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03MGUyZjk1Y1xcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9sb2dpbi52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBudWxsLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9Vc2Vycy9TZXRoL1Byb2plY3RzL2ZhbnRhc3lzeC9jbGllbnQvY29tcG9uZW50cy9sb2dpbi52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIGxvZ2luLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi03MGUyZjk1Y1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTcwZTJmOTVjXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jbGllbnQvY29tcG9uZW50cy9sb2dpbi52dWVcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTQ5MzYxYzcwXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9teXRlYW0udnVlXCIpXG59XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9teXRlYW0udnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi00OTM2MWM3MFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9teXRlYW0udnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgaW5qZWN0U3R5bGUsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiL1VzZXJzL1NldGgvUHJvamVjdHMvZmFudGFzeXN4L2NsaWVudC9jb21wb25lbnRzL215dGVhbS52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIG15dGVhbS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNDkzNjFjNzBcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi00OTM2MWM3MFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2xpZW50L2NvbXBvbmVudHMvbXl0ZWFtLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZWYyOTdhMTJcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL25hdmJhci52dWVcIilcbn1cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL25hdmJhci52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWVmMjk3YTEyXFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL25hdmJhci52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCIvVXNlcnMvU2V0aC9Qcm9qZWN0cy9mYW50YXN5c3gvY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gbmF2YmFyLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1lZjI5N2ExMlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWVmMjk3YTEyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi05YjNiMzQ0MFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vcnVsZXMudnVlXCIpXG59XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICBudWxsLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi05YjNiMzQ0MFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9ydWxlcy52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCIvVXNlcnMvU2V0aC9Qcm9qZWN0cy9mYW50YXN5c3gvY2xpZW50L2NvbXBvbmVudHMvcnVsZXMudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBydWxlcy52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtOWIzYjM0NDBcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi05YjNiMzQ0MFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2xpZW50L2NvbXBvbmVudHMvcnVsZXMudnVlXG4vLyBtb2R1bGUgaWQgPSAyMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1jNmU3ZWZlNlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3RhdHRyYWNrZXIudnVlXCIpXG59XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9zdGF0dHJhY2tlci52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWM2ZTdlZmU2XFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3N0YXR0cmFja2VyLnZ1ZVwiKSxcbiAgLyogc3R5bGVzICovXG4gIGluamVjdFN0eWxlLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9Vc2Vycy9TZXRoL1Byb2plY3RzL2ZhbnRhc3lzeC9jbGllbnQvY29tcG9uZW50cy9zdGF0dHJhY2tlci52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIHN0YXR0cmFja2VyLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi1jNmU3ZWZlNlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LWM2ZTdlZmU2XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jbGllbnQvY29tcG9uZW50cy9zdGF0dHJhY2tlci52dWVcbi8vIG1vZHVsZSBpZCA9IDIwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTNmYjc3NzE4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zdWdnZXN0aW9ucy52dWVcIilcbn1cbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3N1Z2dlc3Rpb25zLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2ZiNzc3MThcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vc3VnZ2VzdGlvbnMudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgaW5qZWN0U3R5bGUsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiL1VzZXJzL1NldGgvUHJvamVjdHMvZmFudGFzeXN4L2NsaWVudC9jb21wb25lbnRzL3N1Z2dlc3Rpb25zLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gc3VnZ2VzdGlvbnMudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTNmYjc3NzE4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtM2ZiNzc3MThcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9jb21wb25lbnRzL3N1Z2dlc3Rpb25zLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2JywgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29sdW1ucyBsZWFkZXJib2FyZFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbHVtbiBpcy1oYWxmIGlzLW9mZnNldC1vbmUtcXVhcnRlclwiXG4gIH0sIFsoX3ZtLmRvbmVMb2FkaW5nKSA/IF9jKCd0YWJsZScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsZWFkZXJib2FyZC10YWJsZVwiXG4gIH0sIFtfdm0uX20oMCksIF92bS5fdihcIiBcIiksIF92bS5fbSgxKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3Rib2R5JywgX3ZtLl9sKChfdm0uc3RhbmRpbmdzKSwgZnVuY3Rpb24odXNlciwgaW5kZXgpIHtcbiAgICByZXR1cm4gX2MoJ3RyJywgW19jKCd0ZCcsIFtfdm0uX3YoX3ZtLl9zKGluZGV4ICsgMSkgKyBcIi5cIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywgW192bS5fdihfdm0uX3ModXNlci50b3RhbHBvaW50cykpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIFtfdm0uX3YoX3ZtLl9zKHVzZXIud2Vla2x5dGVhbXNbMF0udXNlcm5hbWUpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCB7XG4gICAgICBjbGFzczoge1xuICAgICAgICAncG9pbnRzYmFjayc6IGluZGV4ID4gMFxuICAgICAgfVxuICAgIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5wb2ludHNiZWhpbmQodXNlcikpKV0pXSlcbiAgfSkpXSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgKCFfdm0uZG9uZUxvYWRpbmcpID8gX2MoJ2RpdicsIFtfYygncCcsIFtfdm0uX3YoXCJcXFwiVGhpcyBkYXRhIGRvZXNuJ3QgZmV0Y2ggaXRzZWxmLi4gTG9hZGluZyBSYWNlIFRyYWNrZXIuXFxcIlwiKV0pXSkgOiBfdm0uX2UoKV0pXSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCd0aGVhZCcsIFtfYygndHInLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwidGl0bGVcIlxuICB9LCBbX2MoJ3RoJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImNvbHNwYW5cIjogXCI0XCJcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCIyMDE4IEZhbnRhc3kgU1g6IE1haW4gTGVhZ3VlIFN0YW5kaW5nc1wiKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCd0cicsIFtfYygndGgnLCBbX3ZtLl92KFwiUG9zaXRpb25cIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlRvdGFsIFBvaW50c1wiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCBbX3ZtLl92KFwiVXNlcm5hbWVcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlBvaW50cyBCYWNrXCIpXSldKV0pXG59LGZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3Rmb290JywgW19jKCd0cicsIFtfYygndGgnLCBbX3ZtLl92KFwiUG9zaXRpb25cIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlRvdGFsIFBvaW50c1wiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCBbX3ZtLl92KFwiVXNlcm5hbWVcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlBvaW50cyBCYWNrXCIpXSldKV0pXG59XX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtMmU0YTcwYTZcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi0yZTRhNzBhNlwiLFwiaGFzU2NvcGVkXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWVcbi8vIG1vZHVsZSBpZCA9IDIxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb250YWluZXIgc3VnZ2VzdGlvbnMtY29udGFpbmVyXCJcbiAgfSwgW19jKCdzZWN0aW9uJywgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmllbGRcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb250cm9sXCJcbiAgfSwgW19jKCdsYWJlbCcsIFtfdm0uX3YoXCJBcmUgeW91IGEgcmVnaXN0ZXJlZCB1c2VyP1wiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnbGFiZWwnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwicmFkaW9cIlxuICB9LCBbX2MoJ2lucHV0Jywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgIHZhbHVlOiAoX3ZtLlJlZ2lzdGVyZWQpLFxuICAgICAgZXhwcmVzc2lvbjogXCJSZWdpc3RlcmVkXCJcbiAgICB9XSxcbiAgICBhdHRyczoge1xuICAgICAgXCJ0eXBlXCI6IFwicmFkaW9cIixcbiAgICAgIFwibmFtZVwiOiBcIlJlZ2lzdGVyZWRcIixcbiAgICAgIFwidmFsdWVcIjogXCJ0cnVlXCJcbiAgICB9LFxuICAgIGRvbVByb3BzOiB7XG4gICAgICBcImNoZWNrZWRcIjogX3ZtLl9xKF92bS5SZWdpc3RlcmVkLCBcInRydWVcIilcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcIl9fY1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgX3ZtLlJlZ2lzdGVyZWQgPSBcInRydWVcIlxuICAgICAgfVxuICAgIH1cbiAgfSksIF92bS5fdihcIlxcbiAgICAgICAgICAgIFllc1xcbiAgICAgICAgICBcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2xhYmVsJywge1xuICAgIHN0YXRpY0NsYXNzOiBcInJhZGlvXCJcbiAgfSwgW19jKCdpbnB1dCcsIHtcbiAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICB2YWx1ZTogKF92bS5SZWdpc3RlcmVkKSxcbiAgICAgIGV4cHJlc3Npb246IFwiUmVnaXN0ZXJlZFwiXG4gICAgfV0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcInJhZGlvXCIsXG4gICAgICBcIm5hbWVcIjogXCJSZWdpc3RlcmVkXCIsXG4gICAgICBcInZhbHVlXCI6IFwiZmFsc2VcIlxuICAgIH0sXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwiY2hlY2tlZFwiOiBfdm0uX3EoX3ZtLlJlZ2lzdGVyZWQsIFwiZmFsc2VcIilcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcIl9fY1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgX3ZtLlJlZ2lzdGVyZWQgPSBcImZhbHNlXCJcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBfdm0uX3YoXCJcXG4gICAgICAgICAgICBOb1xcbiAgICAgICAgICBcIildKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmllbGRcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb250cm9sXCJcbiAgfSwgW19jKCdsYWJlbCcsIFtfdm0uX3YoXCJJcyB0aGlzIGZlZWRiYWNrIG9yIGEgYnVnIHJlcG9ydD9cIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2xhYmVsJywge1xuICAgIHN0YXRpY0NsYXNzOiBcInJhZGlvXCJcbiAgfSwgW19jKCdpbnB1dCcsIHtcbiAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICB2YWx1ZTogKF92bS5SZXBvcnRUeXBlKSxcbiAgICAgIGV4cHJlc3Npb246IFwiUmVwb3J0VHlwZVwiXG4gICAgfV0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcInJhZGlvXCIsXG4gICAgICBcIm5hbWVcIjogXCJmZWVkYmFja1wiLFxuICAgICAgXCJ2YWx1ZVwiOiBcImZlZWRiYWNrXCJcbiAgICB9LFxuICAgIGRvbVByb3BzOiB7XG4gICAgICBcImNoZWNrZWRcIjogX3ZtLl9xKF92bS5SZXBvcnRUeXBlLCBcImZlZWRiYWNrXCIpXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJfX2NcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5SZXBvcnRUeXBlID0gXCJmZWVkYmFja1wiXG4gICAgICB9XG4gICAgfVxuICB9KSwgX3ZtLl92KFwiXFxuICAgICAgICAgICAgRmVlZGJhY2tcXG4gICAgICAgICAgXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdsYWJlbCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJyYWRpb1wiXG4gIH0sIFtfYygnaW5wdXQnLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgdmFsdWU6IChfdm0uUmVwb3J0VHlwZSksXG4gICAgICBleHByZXNzaW9uOiBcIlJlcG9ydFR5cGVcIlxuICAgIH1dLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInR5cGVcIjogXCJyYWRpb1wiLFxuICAgICAgXCJuYW1lXCI6IFwiZmVlZGJhY2tcIixcbiAgICAgIFwidmFsdWVcIjogXCJidWdcIlxuICAgIH0sXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwiY2hlY2tlZFwiOiBfdm0uX3EoX3ZtLlJlcG9ydFR5cGUsIFwiYnVnXCIpXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJfX2NcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5SZXBvcnRUeXBlID0gXCJidWdcIlxuICAgICAgfVxuICAgIH1cbiAgfSksIF92bS5fdihcIlxcbiAgICAgICAgICAgIEJ1ZyBSZXBvcnRcXG4gICAgICAgICAgXCIpXSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZpZWxkXCJcbiAgfSwgW19jKCdsYWJlbCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsYWJlbFwiXG4gIH0sIFtfdm0uX3YoXCJVc2VybmFtZVwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbnRyb2xcIlxuICB9LCBbX2MoJ2lucHV0Jywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgIHZhbHVlOiAoX3ZtLlVzZXJuYW1lKSxcbiAgICAgIGV4cHJlc3Npb246IFwiVXNlcm5hbWVcIlxuICAgIH1dLFxuICAgIHN0YXRpY0NsYXNzOiBcImlucHV0XCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcInRleHRcIixcbiAgICAgIFwicGxhY2Vob2xkZXJcIjogXCJVc2VybmFtZVwiXG4gICAgfSxcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJ2YWx1ZVwiOiAoX3ZtLlVzZXJuYW1lKVxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiaW5wdXRcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm47IH1cbiAgICAgICAgX3ZtLlVzZXJuYW1lID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfSldKV0pLCBfdm0uX3YoXCIgXCIpLCAoX3ZtLlJlcG9ydFR5cGUgPT0gJ2ZlZWRiYWNrJykgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZpZWxkXCJcbiAgfSwgW19jKCdsYWJlbCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsYWJlbFwiXG4gIH0sIFtfdm0uX3YoXCJTdWdnZXN0IEZlYXR1cmVzXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29udHJvbFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInNlbGVjdFwiXG4gIH0sIFtfYygnc2VsZWN0Jywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgIHZhbHVlOiAoX3ZtLmZlYXR1cmUpLFxuICAgICAgZXhwcmVzc2lvbjogXCJmZWF0dXJlXCJcbiAgICB9XSxcbiAgICBvbjoge1xuICAgICAgXCJjaGFuZ2VcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIHZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucywgZnVuY3Rpb24obykge1xuICAgICAgICAgIHJldHVybiBvLnNlbGVjdGVkXG4gICAgICAgIH0pLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IFwiX3ZhbHVlXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdmFsXG4gICAgICAgIH0pO1xuICAgICAgICBfdm0uZmVhdHVyZSA9ICRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXVxuICAgICAgfVxuICAgIH1cbiAgfSwgW19jKCdvcHRpb24nLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiZGlzYWJsZWRcIjogXCJcIixcbiAgICAgIFwidmFsdWVcIjogXCJcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIlNFTEVDVCBDQVRFR09SWVwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnb3B0aW9uJywgW192bS5fdihcIlVzZXIgSW50ZXJmYWNlXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdvcHRpb24nLCBbX3ZtLl92KFwiTmF2aWdhdGlvbiBDb250ZW50XCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdvcHRpb24nLCBbX3ZtLl92KFwiTXkgVGVhbVwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnb3B0aW9uJywgW192bS5fdihcIlNjb3JpbmdcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ29wdGlvbicsIFtfdm0uX3YoXCJOZXcgRmVhdHVyZXNcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ29wdGlvbicsIFtfdm0uX3YoXCJTdGF0IFRyYWNrZXJcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ29wdGlvbicsIFtfdm0uX3YoXCJBY2NvdW50XCIpXSldKV0pXSldKSA6IF92bS5fZSgpLCBfdm0uX3YoXCIgXCIpLCAoX3ZtLlJlcG9ydFR5cGUgPT0gJ2ZlZWRiYWNrJykgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZpZWxkXCJcbiAgfSwgW19jKCdsYWJlbCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsYWJlbFwiXG4gIH0sIFtfdm0uX3YoXCJGZWVkYmFja1wiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbnRyb2xcIlxuICB9LCBbX2MoJ3RleHRhcmVhJywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgIHZhbHVlOiAoX3ZtLmZlZWRiYWNrKSxcbiAgICAgIGV4cHJlc3Npb246IFwiZmVlZGJhY2tcIlxuICAgIH1dLFxuICAgIHN0YXRpY0NsYXNzOiBcInRleHRhcmVhXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwicGxhY2Vob2xkZXJcIjogXCJEZXNjcmliZSB5b3VyIHN1Z2dlc3Rpb25zIGhlcmUuXCJcbiAgICB9LFxuICAgIGRvbVByb3BzOiB7XG4gICAgICBcInZhbHVlXCI6IChfdm0uZmVlZGJhY2spXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJpbnB1dFwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybjsgfVxuICAgICAgICBfdm0uZmVlZGJhY2sgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9KV0pXSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgKF92bS5SZXBvcnRUeXBlID09ICdidWcnKSA/IF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmllbGRcIlxuICB9LCBbX2MoJ2xhYmVsJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImxhYmVsXCJcbiAgfSwgW192bS5fdihcIlJlcG9ydCBCdWdcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb250cm9sXCJcbiAgfSwgW19jKCd0ZXh0YXJlYScsIHtcbiAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICB2YWx1ZTogKF92bS5idWdyZXBvcnQpLFxuICAgICAgZXhwcmVzc2lvbjogXCJidWdyZXBvcnRcIlxuICAgIH1dLFxuICAgIHN0YXRpY0NsYXNzOiBcInRleHRhcmVhXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwicGxhY2Vob2xkZXJcIjogXCJEZXNjcmliZSB0aGUgYWN0aW9ucyB5b3UgdG9vaywgeW91ciBkZXNpcmVkIG91dGNvbWUgYW5kIHRoZSBhY3R1YWwgb3V0Y29tZSBvZiB0aG9zZSBhY3Rpb25zLiBXZSBzaG91bGQgYmUgYWJsZSB0byByZXBsaWNhdGUgdGhlIGJ1ZyBiYXNlZCBvZmYgdGhlIHN0ZXBzIHlvdSBwcm92aWRlIGhlcmUuXCJcbiAgICB9LFxuICAgIGRvbVByb3BzOiB7XG4gICAgICBcInZhbHVlXCI6IChfdm0uYnVncmVwb3J0KVxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiaW5wdXRcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm47IH1cbiAgICAgICAgX3ZtLmJ1Z3JlcG9ydCA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH0pXSldKSA6IF92bS5fZSgpLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZpZWxkXCJcbiAgfSwgW19jKCdidXR0b24nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYnV0dG9uIGlzLXByaW1hcnlcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJ0eXBlXCI6IFwiYnV0dG9uXCJcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5zdWJtaXRcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJTdWJtaXRcIildKV0pXSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi0zZmI3NzcxOFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTNmYjc3NzE4XCIsXCJoYXNTY29wZWRcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL3N1Z2dlc3Rpb25zLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2JywgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwicGFnZS1oZWFkZXItY29udGFpbmVyXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwicGFnZS1oZWFkZXItYmxvY2tcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsaC00clwiXG4gIH0sIFtfdm0uX3YoXCJXZWVrOiBcIiksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImJvbGRlc3QtaGVhZGVyIHJpZ2h0XCJcbiAgfSwgW192bS5fdihfdm0uX3MoX3ZtLmN1cnJlbnR3ZWVrKSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImxoLTRyXCJcbiAgfSwgW192bS5fdihcIkJhbGFuY2UgUmVtYWluaW5nOlwiKSwgX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYm9sZGVzdC1oZWFkZXIgcmlnaHRcIlxuICB9LCBbX3ZtLl92KFwiICRcIiArIF92bS5fcyhfdm0uZG9sbGFycykpXSldKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29udGFpbmVyXCJcbiAgfSwgW19jKCd0cmFuc2l0aW9uJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcIm5hbWVcIjogXCJmYWRlXCIsXG4gICAgICBcIm1vZGVcIjogXCJvdXQtaW5cIlxuICAgIH1cbiAgfSwgWyhfdm0uc2hvd1NhdmVNZXNzYWdlKSA/IF9jKCdwJywge1xuICAgIHN0YXRpY0NsYXNzOiBcInN1Y2Nlc3NmdWwtc2F2ZVwiXG4gIH0sIFtfdm0uX3YoXCJZb3VyIHRlYW0gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHNhdmVkIVwiKV0pIDogX3ZtLl9lKCksIF92bS5fdihcIiBcIiksIChfdm0uc2hvd0ZhaWxNZXNzYWdlKSA/IF9jKCdwJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZhaWx1cmUtc2F2ZVwiXG4gIH0sIFtfdm0uX3YoXCJPb3BzISBTb21ldGhpbmcgV2VudCBXcm9uZy4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cIildKSA6IF92bS5fZSgpXSksIF92bS5fdihcIiBcIiksIF9jKCd0YWJsZScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJteXRlYW0tdGFibGVcIlxuICB9LCBbX2MoJ3RoZWFkJywgW19jKCd0cicsIFtfYygndGgnLCBbX3ZtLl92KFwiQWN0aW9uXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIHtcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0uc29ydEJ5UHJpY2VcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJQcmljZVxcbiAgICAgICAgICAgIFwiKSwgX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaWNvblwiXG4gIH0sIFsoX3ZtLkNvc3RTb3J0QnlBc2MpID8gX2MoJ2knLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmEgZmEtY2FyZXQtdXBcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICAgIH1cbiAgfSkgOiBfYygnaScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmYSBmYS1jYXJldC1kb3duXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcbiAgICB9XG4gIH0pXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlJhY2VyIE5hbWVcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlJhY2VyIE51bWJlclwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCBbX3ZtLl92KFwiSGlnaGVzdCBGaW5pc2hcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIkxvd2VzdCBGaW5pc2hcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIkF2ZXJhZ2UgRmluaXNoXCIpXSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfdm0uX20oMCksIF92bS5fdihcIiBcIiksIF9jKCd0Ym9keScsIFtfdm0uX2woKF92bS5zZWxlY3RlZHJpZGVycyksIGZ1bmN0aW9uKHJhY2VyLCBpbmRleCkge1xuICAgIHJldHVybiBfYygndHInLCBbX2MoJ3RkJywgWyhyYWNlci5uYW1lICE9ICdPUEVOIFNMT1QnKSA/IF9jKCdhJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJocmVmXCI6IFwiIyFcIlxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLnJlbW92ZVJhY2VyKHJhY2VyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW192bS5fbSgxLCB0cnVlKV0pIDogX3ZtLl9lKCldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywgW192bS5fdihcIiRcIiArIF92bS5fcyhyYWNlci5jb3N0KSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywgW192bS5fdihfdm0uX3MocmFjZXIubmFtZSkpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIFtfdm0uX3YoX3ZtLl9zKHJhY2VyLnJpZGVyX251bWJlcikpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIFtfdm0uX3YoX3ZtLl9zKHJhY2VyLmhpZ2hlc3RGaW5pc2gpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCBbX3ZtLl92KF92bS5fcyhyYWNlci5sb3dlc3RGaW5pc2gpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCBbX3ZtLl92KF92bS5fcyhyYWNlci5hdmVyYWdlRmluaXNoKSldKV0pXG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygndHInLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibGFzdFJvd1wiXG4gIH0sIFtfYygndGQnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiY29sc3BhblwiOiBcIjVcIlxuICAgIH1cbiAgfSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJjb2xzcGFuXCI6IFwiMVwiXG4gICAgfVxuICB9LCBbX2MoJ2J1dHRvbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJidXR0b24gaXMtZGFuZ2VyXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiZGlzYWJsZWRcIjogIV92bS5zaG93UmVtb3ZlQWxsXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0uUmVtb3ZlQWxsXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiUmVtb3ZlIEFsbFwiKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJjb2xzcGFuXCI6IFwiMVwiXG4gICAgfVxuICB9LCBbX2MoJ2J1dHRvbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJidXR0b24gaXMtc3VjY2Vzc1wiLFxuICAgIGNsYXNzOiB7XG4gICAgICAnaXMtbG9hZGluZyc6IF92bS5pc0xvYWRpbmdcbiAgICB9LFxuICAgIGF0dHJzOiB7XG4gICAgICBcImRpc2FibGVkXCI6IF92bS5oYXNPcGVuU2xvdHNcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5TYXZlVGVhbVxuICAgIH1cbiAgfSwgW192bS5fdihcIlNhdmUgVGVhbVwiKV0pXSldKSwgX3ZtLl92KFwiIFwiKSwgX3ZtLl9sKChfdm0ucGFnaW5hdGVkUmlkZXJzKSwgZnVuY3Rpb24ocmlkZXIpIHtcbiAgICByZXR1cm4gX2MoJ3RyJywgW19jKCd0ZCcsIFsoX3ZtLnNob3dTZWxlY3QgJiYgcmlkZXIuY29zdCA8PSBfdm0uZG9sbGFycykgPyBfYygnYScsIHtcbiAgICAgIGF0dHJzOiB7XG4gICAgICAgIFwiaHJlZlwiOiBcIiMhXCJcbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgIF92bS5hZGRSYWNlcihyaWRlcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtfdm0uX20oMiwgdHJ1ZSldKSA6IF92bS5fZSgpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIFtfdm0uX3YoXCIkXCIgKyBfdm0uX3MocmlkZXIuY29zdCkpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIFtfdm0uX3YoX3ZtLl9zKHJpZGVyLm5hbWUpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCBbX3ZtLl92KF92bS5fcyhyaWRlci5yaWRlcl9udW1iZXIpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCBbX3ZtLl92KF92bS5fcyhyaWRlci5oaWdoZXN0RmluaXNoKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywgW192bS5fdihfdm0uX3MocmlkZXIubG93ZXN0RmluaXNoKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywgW192bS5fdihfdm0uX3MocmlkZXIuYXZlcmFnZUZpbmlzaCkpXSldKVxuICB9KV0sIDIpXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY3VzdG9tLXBhZ2luYXRpb25cIlxuICB9LCBbX2MoJ2RpdicsIFtfYygnYScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJwYWdpbmF0aW9uLXByZXZpb3VzXCIsXG4gICAgY2xhc3M6IHtcbiAgICAgICdoaWRlLXBhZ2luYXRpb24tYnV0dG9uJzogX3ZtLmhpZGVQcmV2aW91c1xuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5wYWdlLS1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJQcmV2aW91c1wiKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCBbX2MoJ2EnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwicGFnaW5hdGlvbi1udW1iZXJcIlxuICB9LCBbX3ZtLl92KF92bS5fcyhfdm0ucGFnZSkgKyBcIi9cIiArIF92bS5fcyhfdm0ucGFnaW5hdGlvblBhZ2VzKSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2JywgW19jKCdhJywge1xuICAgIHN0YXRpY0NsYXNzOiBcInBhZ2luYXRpb24tbmV4dFwiLFxuICAgIGNsYXNzOiB7XG4gICAgICAnaGlkZS1wYWdpbmF0aW9uLWJ1dHRvbic6IF92bS5oaWRlTmV4dFxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5wYWdlKytcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJOZXh0IHBhZ2VcIildKV0pXSldLCAxKV0pXG59LHN0YXRpY1JlbmRlckZuczogW2Z1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3Rmb290JywgW19jKCd0cicsIFtfYygndGgnLCBbX3ZtLl92KFwiQWN0aW9uXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJQcmljZVwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCBbX3ZtLl92KFwiUmFjZXIgTmFtZVwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCBbX3ZtLl92KFwiUmFjZXIgTnVtYmVyXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJIaWdoZXN0IEZpbmlzaFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCBbX3ZtLl92KFwiTG93ZXN0IEZpbmlzaFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCBbX3ZtLl92KFwiQXZlcmFnZSBGaW5pc2hcIildKV0pXSlcbn0sZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJpY29uIG1pbnVzLWljb25cIlxuICB9LCBbX2MoJ2knLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmEgZmEtbWludXNcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICAgIH1cbiAgfSldKVxufSxmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImljb24gcGx1cy1pY29uXCJcbiAgfSwgW19jKCdpJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZhIGZhLXBsdXNcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICAgIH1cbiAgfSldKVxufV19XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTQ5MzYxYzcwXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNDkzNjFjNzBcIixcImhhc1Njb3BlZFwiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbXl0ZWFtLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwiYXBwXCJcbiAgICB9XG4gIH0sIFtfYygnbmF2aWdhdGlvbicpLCBfdm0uX3YoXCIgXCIpLCBfYygncm91dGVyLXZpZXcnKV0sIDEpXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTRmYzAwNWIwXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNGZjMDA1YjBcIixcImhhc1Njb3BlZFwiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vaW5kZXgudnVlXG4vLyBtb2R1bGUgaWQgPSAyMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWxcIixcbiAgICBjbGFzczoge1xuICAgICAgJ2lzLWFjdGl2ZSc6IF92bS5TaG93UmVnaXN0ZXJNb2RhbFxuICAgIH0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJyZWdpc3Rlck1vZGFsXCJcbiAgICB9XG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsLWJhY2tncm91bmRcIlxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkXCJcbiAgfSwgW19jKCdoZWFkZXInLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWwtY2FyZC1oZWFkXCJcbiAgfSwgW19jKCdwJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsLWNhcmQtdGl0bGVcIlxuICB9LCBbX3ZtLl92KFwiTmV3IFVzZXIgUmVnaXN0cmF0aW9uXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdidXR0b24nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZGVsZXRlXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5zZXRSZWdpc3Rlck1vZGFsKHtcbiAgICAgICAgICBzaG93OiAhX3ZtLlNob3dSZWdpc3Rlck1vZGFsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9KV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnc2VjdGlvbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkLWJvZHlcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb250ZW50XCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmllbGRcIlxuICB9LCBbX2MoJ2xhYmVsJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImxhYmVsXCJcbiAgfSwgW192bS5fdihcIlVzZXJuYW1lOiBcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCJcbiAgfSwgW19jKCdpbnB1dCcsIHtcbiAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICB2YWx1ZTogKF92bS51c2VybmFtZSksXG4gICAgICBleHByZXNzaW9uOiBcInVzZXJuYW1lXCJcbiAgICB9XSxcbiAgICBzdGF0aWNDbGFzczogXCJpbnB1dFwiLFxuICAgIGNsYXNzOiB7XG4gICAgICAnaXMtZGFuZ2VyJzogX3ZtLmludmFsaWRVc2VybmFtZVxuICAgIH0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcInRleHRcIixcbiAgICAgIFwiaWRcIjogXCJyZWctdXNlcm5hbWVcIixcbiAgICAgIFwicGxhY2Vob2xkZXJcIjogXCJVc2VybmFtZVwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBcIlwiXG4gICAgfSxcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJ2YWx1ZVwiOiAoX3ZtLnVzZXJuYW1lKVxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiaW5wdXRcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm47IH1cbiAgICAgICAgX3ZtLnVzZXJuYW1lID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfSksIF92bS5fdihcIiBcIiksIF92bS5fbSgwKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmllbGRcIlxuICB9LCBbX2MoJ2xhYmVsJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImxhYmVsXCJcbiAgfSwgW192bS5fdihcIkVtYWlsOiBcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCJcbiAgfSwgW19jKCdpbnB1dCcsIHtcbiAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICB2YWx1ZTogKF92bS5lbWFpbCksXG4gICAgICBleHByZXNzaW9uOiBcImVtYWlsXCJcbiAgICB9XSxcbiAgICBzdGF0aWNDbGFzczogXCJpbnB1dFwiLFxuICAgIGNsYXNzOiB7XG4gICAgICAnaXMtZGFuZ2VyJzogX3ZtLmludmFsaWRFbWFpbFxuICAgIH0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcImVtYWlsXCIsXG4gICAgICBcImlkXCI6IFwicmVnLWVtYWlsXCIsXG4gICAgICBcInBsYWNlaG9sZGVyXCI6IFwiRW1haWxcIixcbiAgICAgIFwicmVxdWlyZWRcIjogXCJcIlxuICAgIH0sXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwidmFsdWVcIjogKF92bS5lbWFpbClcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImlucHV0XCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuOyB9XG4gICAgICAgIF92bS5lbWFpbCA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfdm0uX20oMSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZpZWxkXCJcbiAgfSwgW19jKCdsYWJlbCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsYWJlbFwiXG4gIH0sIFtfdm0uX3YoXCJQYXNzd29yZDogXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiXG4gIH0sIFtfYygnaW5wdXQnLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgdmFsdWU6IChfdm0ucGFzc3dvcmQpLFxuICAgICAgZXhwcmVzc2lvbjogXCJwYXNzd29yZFwiXG4gICAgfV0sXG4gICAgc3RhdGljQ2xhc3M6IFwiaW5wdXRcIixcbiAgICBjbGFzczoge1xuICAgICAgJ2lzLWRhbmdlcic6IF92bS5ibGFua1Bhc3N3b3JkXG4gICAgfSxcbiAgICBhdHRyczoge1xuICAgICAgXCJ0eXBlXCI6IFwicGFzc3dvcmRcIixcbiAgICAgIFwiaWRcIjogXCJyZWctcGFzc3dvcmRcIixcbiAgICAgIFwicGxhY2Vob2xkZXJcIjogXCJQYXNzd29yZFwiLFxuICAgICAgXCJyZXF1aXJlZFwiOiBcIlwiXG4gICAgfSxcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJ2YWx1ZVwiOiAoX3ZtLnBhc3N3b3JkKVxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiaW5wdXRcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm47IH1cbiAgICAgICAgX3ZtLnBhc3N3b3JkID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfSksIF92bS5fdihcIiBcIiksIF92bS5fbSgyKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmllbGRcIlxuICB9LCBbX3ZtLl92KFwiXFxuICAgICAgICAgICAgUkVDQVBUQ0hBIFBMQUNFSE9MREVSXFxuICAgICAgICAgIFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfdm0uX2woKF92bS5lcnJvck1lc3NhZ2UpLCBmdW5jdGlvbihlcnJvcikge1xuICAgIHJldHVybiAoX3ZtLmVycm9yTWVzc2FnZSAhPSAnJykgPyBfYygnZGl2Jywge1xuICAgICAgc3RhdGljQ2xhc3M6IFwiZXJyb3JNZXNzYWdlXCJcbiAgICB9LCBbX3ZtLl92KFwiXFxuICAgICAgICAgICAgXCIgKyBfdm0uX3MoZXJyb3IpICsgXCJcXG4gICAgICAgICAgXCIpXSkgOiBfdm0uX2UoKVxuICB9KV0sIDIpXSksIF92bS5fdihcIiBcIiksIF9jKCdmb290ZXInLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWwtY2FyZC1mb290XCJcbiAgfSwgW19jKCdidXR0b24nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYnV0dG9uIGlzLXN1Y2Nlc3NcIixcbiAgICBjbGFzczoge1xuICAgICAgJ2lzLWxvYWRpbmcnOiBfdm0uaXNMb2FkaW5nXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0uUmVnaXN0ZXJcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJSZWdpc3RlclwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnYnV0dG9uJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImJ1dHRvblwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBfdm0uc2V0UmVnaXN0ZXJNb2RhbCh7XG4gICAgICAgICAgc2hvdzogIV92bS5TaG93UmVnaXN0ZXJNb2RhbFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW192bS5fdihcIkNhbmNlbFwiKV0pXSldKV0pXG59LHN0YXRpY1JlbmRlckZuczogW2Z1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCJcbiAgfSwgW19jKCdpJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZhIGZhLXVzZXJcIlxuICB9KV0pXG59LGZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCJcbiAgfSwgW19jKCdpJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZhIGZhLWVudmVsb3BlXCJcbiAgfSldKVxufSxmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImljb24gaXMtc21hbGwgaXMtbGVmdFwiXG4gIH0sIFtfYygnaScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmYSBmYS1sb2NrXCJcbiAgfSldKVxufV19XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTVmYjRmYzRhXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNWZiNGZjNGFcIixcImhhc1Njb3BlZFwiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWxcIixcbiAgICBjbGFzczoge1xuICAgICAgJ2lzLWFjdGl2ZSc6IF92bS5zaG93XG4gICAgfSxcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBcImxvZ2luTW9kYWxcIlxuICAgIH1cbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWwtYmFja2dyb3VuZFwiXG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsLWNhcmRcIlxuICB9LCBbX2MoJ2hlYWRlcicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkLWhlYWRcIlxuICB9LCBbX2MoJ3AnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWwtY2FyZC10aXRsZVwiXG4gIH0sIFtfdm0uX3YoXCJVc2VyIExvZ2luXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdidXR0b24nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZGVsZXRlXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5zZXRMb2dpbk1vZGFsKHtcbiAgICAgICAgICBzaG93OiAhX3ZtLlNob3dMb2dpbk1vZGFsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9KV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnc2VjdGlvbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkLWJvZHlcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb250ZW50XCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmllbGRcIlxuICB9LCBbX2MoJ2xhYmVsJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImxhYmVsXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiZm9yXCI6IFwicmVnLXVzZXJuYW1lXCJcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJVc2VybmFtZTogXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29udHJvbFwiXG4gIH0sIFtfYygnaW5wdXQnLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgdmFsdWU6IChfdm0udXNlcm5hbWUpLFxuICAgICAgZXhwcmVzc2lvbjogXCJ1c2VybmFtZVwiXG4gICAgfV0sXG4gICAgc3RhdGljQ2xhc3M6IFwiaW5wdXRcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJ0eXBlXCI6IFwidGV4dFwiXG4gICAgfSxcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJ2YWx1ZVwiOiAoX3ZtLnVzZXJuYW1lKVxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiaW5wdXRcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm47IH1cbiAgICAgICAgX3ZtLnVzZXJuYW1lID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZpZWxkXCJcbiAgfSwgW19jKCdsYWJlbCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsYWJlbFwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcImZvclwiOiBcInJlZy1wYXNzd29yZFwiXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiUGFzc3dvcmQ6IFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbnRyb2xcIlxuICB9LCBbX2MoJ2lucHV0Jywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgIHZhbHVlOiAoX3ZtLnBhc3N3b3JkKSxcbiAgICAgIGV4cHJlc3Npb246IFwicGFzc3dvcmRcIlxuICAgIH1dLFxuICAgIHN0YXRpY0NsYXNzOiBcImlucHV0XCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcInBhc3N3b3JkXCIsXG4gICAgICBcImlkXCI6IFwicmVnLXBhc3N3b3JkXCJcbiAgICB9LFxuICAgIGRvbVByb3BzOiB7XG4gICAgICBcInZhbHVlXCI6IChfdm0ucGFzc3dvcmQpXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJpbnB1dFwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybjsgfVxuICAgICAgICBfdm0ucGFzc3dvcmQgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9KV0pXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJnLXJlY2FwdGNoYVwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcImRhdGEtc2l0ZWtleVwiOiBcIjZMY1NmRElVQUFBQUFPM2poSG5hLUQ4cVR3WC1uYkZieEFrMnE1XzdcIlxuICAgIH1cbiAgfSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2Zvb3RlcicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkLWZvb3RcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmaWVsZFwiXG4gIH0sIFtfYygnYnV0dG9uJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImJ1dHRvbiBpcy1wcmltYXJ5XCIsXG4gICAgY2xhc3M6IHtcbiAgICAgICdpcy1sb2FkaW5nJzogX3ZtLmlzTG9hZGluZ1xuICAgIH0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcImJ1dHRvblwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIkxvZ2luXCIsXG4gICAgICBcImlkXCI6IFwic3VibWl0LWxvZ2luXCJcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5zdWJtaXRcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJMb2dpblwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnYScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJidXR0b25cIixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgX3ZtLnNldExvZ2luTW9kYWwoe1xuICAgICAgICAgIHNob3c6ICFfdm0uU2hvd0xvZ2luTW9kYWxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJDYW5jZWxcIildKV0pXSldKV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTcwZTJmOTVjXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNzBlMmY5NWNcIixcImhhc1Njb3BlZFwiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbG9naW4udnVlXG4vLyBtb2R1bGUgaWQgPSAyMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF92bS5fbSgwKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29udGFpbmVyXCJcbiAgfSwgW19jKCdkaXYnLCB7fSwgW19jKCdwJywgW192bS5fdihcIlJ1bGVzXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwidGFiXCJcbiAgfSwgW19jKCdpbnB1dCcsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJpZFwiOiBcInRhYi1vbmVcIixcbiAgICAgIFwidHlwZVwiOiBcImNoZWNrYm94XCIsXG4gICAgICBcIm5hbWVcIjogXCJ0YWJzXCJcbiAgICB9XG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygnbGFiZWwnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiZm9yXCI6IFwidGFiLW9uZVwiXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiSG93IGRvZXMgc2NvcmluZyB3b3JrP1wiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInRhYi1jb250ZW50XCJcbiAgfSwgW19jKCdwJywgW192bS5fdihcIlJpZ2h0IG5vdywgc2NvcmluZyBpcyBzZXQgYnkgcmFjZXIgZmluaXNoLiBJZiBhIHNlbGVjdGVkIHJhY2VyIGZvciB0aGF0IHdlZWsgZmluaXNoZXMgaW4gZmlyc3QsIHRoYXQgcmFjZXIgaXMgYXdhcmRlZCAxIHBvaW50LiBJZiBhIHJhY2VyIGZpbmlzaGVzIGluIGZvdXJ0aCwgdGhhdCByYWNlciBpcyBhd2FyZGVkIDQgcG9pbnRzLiBUaGUgbG93ZXIgdGhlIHBvaW50IHRvdGFsIHRoZSBiZXR0ZXIgc2NvcmUuXCIpXSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInRhYlwiXG4gIH0sIFtfYygnaW5wdXQnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJ0YWItdHdvXCIsXG4gICAgICBcInR5cGVcIjogXCJjaGVja2JveFwiLFxuICAgICAgXCJuYW1lXCI6IFwidGFic1wiXG4gICAgfVxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2xhYmVsJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcImZvclwiOiBcInRhYi10d29cIlxuICAgIH1cbiAgfSwgW192bS5fdihcIkhvdyBkb2VzIHRlYW0gc2VsZWN0aW9uIHdvcms/XCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwidGFiLWNvbnRlbnRcIlxuICB9LCBbX2MoJ3AnLCBbX3ZtLl92KFwiQXMgb2Ygbm93LCBlYWNoIHVzZXIgaXMgUkVRVUlSRUQgdG8gc2VsZWN0IDQgcmFjZXJzIGZvciBlYWNoIHdlZWsuIFRoZSBkZWFkbGluZSBmb3IgbWFraW5nIHJhY2VyIHNlbGVjdGlvbiBpcyAzYW0gTW91bnRhaW4gVGltZSBvbiB0aGUgZGF5IG9mIHRoZSBzY2hlZHVsZWQgcmFjZS4gQWZ0ZXIgdGhhdCB0aW1lXFxuICAgICAgICAgIHVzZXJzIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gc2VsZWN0IHJhY2VycyBmb3IgdGhhdCB3ZWVrJ3MgcmFjZTsgdGhlIHRlYW0gc2VsZWN0aW9uIGZvciB0aGUgbmV4dCB3ZWVrIHdpbGwgYmUgYXZhaWxhYmxlIGZvciBzZWxlY3Rpb25cIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3AnLCBbX3ZtLl92KFwiVXNlcnMgbWF5IG9ubHkgU0FWRSBhIHJvc3RlciBpZiBBTEwgNCByb3N0ZXIgc2xvdHMgaGF2ZSBhIHJhY2VyIGNob3Nlbi4gVGhlIFNBVkUgYnV0dG9uIGlzIGRpc2FibGVkIGlmIGFuIE9QRU4gU0xPVCBzdGlsbCBleGlzdHMgZm9yIGEgd2Vla2x5IGxpbmV1cC5cIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3AnLCBbX3ZtLl92KFwiRWFjaCB1c2VyIGJlZ2lucyBlYWNoIHdlZWsgd2l0aCAkOCBjcmVkaXRzIHRvIHNwZW5kIG9uIGZpbGxpbmcgb3V0IHRoZWlyIHdlZWtseSBsaW5ldXAsIGFuZCB0aGF0IGNyZWRpdCBpcyB1c2VkIHRvIHNlbGVjdCByYWNlcnMgZm9yIHRoZWlyIHdlZWsncyBsaW5ldXAgZnJvbSB0aGUgYXZhaWxhYmxlIHJhY2VycyBwb29sLlxcbiAgICAgICAgICBUaGUgc2VsZWN0ZWQgcmFjZXIncyBjb3N0LCBvbmNlIHNlbGVjdGVkLCB3aWxsIGJlIGRlZHVjdGVkIGZyb20gdGhlIGN1cnJlbnQgd2VlaydzIGF2YWlsYWJsZSBjcmVkaXRzLiBZb3UgYXJlIE5PVCBSRVFVSVJFRCB0byBzcGVuZCBhbGwgJDggY3JlZGl0cyBlYWNoIHdlZWsuXCIpXSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcInRhYlwiXG4gIH0sIFtfYygnaW5wdXQnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJ0YWItdGhyZWVcIixcbiAgICAgIFwidHlwZVwiOiBcImNoZWNrYm94XCIsXG4gICAgICBcIm5hbWVcIjogXCJ0YWJzXCJcbiAgICB9XG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfYygnbGFiZWwnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiZm9yXCI6IFwidGFiLXRocmVlXCJcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJMaXZlIFN0YXQgVHJhY2tlciAmIEN1c3RvbSBMZWFndWVzXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwidGFiLWNvbnRlbnRcIlxuICB9LCBbX2MoJ3AnLCBbX3ZtLl92KFwiUmlnaHQgbm93IHRoZSBhcHBsaWNhdGlvbiBpcyBjb25maWd1cmVkIHdoZXJlIGV2ZXJ5IHJlZ2lzdGVyZWQgdXNlciBjb21wZXRlcyBhZ2FpbnN0IGVhY2ggb3RoZXIgaW4gYW4gb3BlbiBNYWluIExlYWd1ZS4gVGhlIGxpdmUgc3RhdCB0cmFja2VyICh0byBzZWUgdGhlIHN0YW5kaW5ncyB1cGRhdGUgd2l0aCBsaXZlIHBvc2l0aW9uIGNoYW5nZXMpIGlzIG5vdCBhdmFpbGFibGUgZm9yIHRoZSBBTFBIQSB0ZXN0LlxcbiAgICAgICAgVGhpcyBmZWF0dXJlIHdpbGwgYmUgdGVzdGFibGUgZHVyaW5nIHRoZSBCRVRBIHZlcnNpb24gb2YgdGhlIGFwcGxpY2F0aW9uLlwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygncCcsIFtfdm0uX3YoXCJDdXJyZW50bHksIHRoZSBhcHBsaWNhdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGN1c3RvbSAvIHByaXZhdGUgbGVhZ3VlcywgaG93ZXZlciwgdGhpcyBmZWF0dXJlIHdpbGwgYmUgYXZhaWxhYmxlIGZvciB0ZXN0aW5nIGluIHRoZSBCRVRBIHZlcnNpb24gb2YgdGhlIGFwcGxpY2F0aW9uLlwiKV0pXSldKV0pXSlcbn1dfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi05YjNiMzQ0MFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTliM2IzNDQwXCIsXCJoYXNTY29wZWRcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL3J1bGVzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2JywgWyghX3ZtLmlzTG9hZGluZykgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZsZXgtY2VudGVyIGZsIGxpdmUtaGVhZGVyXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibGl2ZS1oZWFkZXItYm94XCJcbiAgfSwgW19jKCdkaXYnLCBbX3ZtLl92KFwiU2Vzc2lvbiBFdmVudDogXCIpLCBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJ0ZXh0LWhpZ2hsaWdodCBmbC1yaWdodFwiXG4gIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5yYWNlRGF0YS5yYWNlRGF0YS5TKSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2JywgW192bS5fdihcIlNlYXNvbiBFdmVudDpcIiksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcInRleHQtaGlnaGxpZ2h0IGZsLXJpZ2h0XCJcbiAgfSwgW192bS5fdihcIiBcIiArIF92bS5fcyhfdm0ucmFjZURhdGEucmFjZURhdGEuRSkpXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIFtfdm0uX3YoXCJTZXNzaW9uIFN0YXR1czpcIiksIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcInRleHQtaGlnaGxpZ2h0IGZsLXJpZ2h0XCJcbiAgfSwgW192bS5fdihcIiBcIiArIF92bS5fcyhfdm0ucmFjZURhdGEucmFjZURldGFpbHMuQikpXSldKV0pXSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb2x1bW5zIGxlYWRlcmJvYXJkXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29sdW1uIGlzLWhhbGYgaXMtb2Zmc2V0LW9uZS1xdWFydGVyXCJcbiAgfSwgWyghX3ZtLmlzTG9hZGluZykgPyBfYygndGFibGUnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwidGFibGUtbGl2ZVwiXG4gIH0sIFtfdm0uX20oMCksIF92bS5fdihcIiBcIiksIF92bS5fbSgxKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3Rib2R5JywgX3ZtLl9sKChfdm0uc3RhbmRpbmdzKSwgZnVuY3Rpb24odXNlciwgaW5kZXgpIHtcbiAgICByZXR1cm4gX2MoJ3RyJywge1xuICAgICAgY2xhc3M6IFt1c2VyLnVzZXJuYW1lID09IF92bS5nZXRVc2VyRGF0YS51c2VybmFtZSA/ICdteVJvdycgOiAnJ11cbiAgICB9LCBbX2MoJ3RkJywgW192bS5fdihfdm0uX3MoaW5kZXggKyAxKSArIFwiLlwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCBbX3ZtLl92KF92bS5fcyh1c2VyLnRvdGFsKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywgW192bS5fdihfdm0uX3ModXNlci51c2VybmFtZSkpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcInBvaW50c2JhY2tcIlxuICAgIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5wb2ludHNiZWhpbmQodXNlcikpKV0pXSlcbiAgfSkpXSkgOiBfdm0uX2UoKV0pXSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCd0aGVhZCcsIFtfYygndHInLCBbX2MoJ3RoJywgW192bS5fdihcIlBvc2l0aW9uXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJUb3RhbCBQb2ludHNcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlVzZXJuYW1lXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJQb2ludHMgQmFja1wiKV0pXSldKVxufSxmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCd0Zm9vdCcsIFtfYygndHInLCBbX2MoJ3RoJywgW192bS5fdihcIlBvc2l0aW9uXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJUb3RhbCBQb2ludHNcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlVzZXJuYW1lXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJQb2ludHMgQmFja1wiKV0pXSldKVxufV19XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LWM2ZTdlZmU2XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtYzZlN2VmZTZcIixcImhhc1Njb3BlZFwiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvc3RhdHRyYWNrZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCduYXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibmF2YmFyXCJcbiAgfSwgW192bS5fbSgwKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItbWVudVwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwibmF2TWVudVwiXG4gICAgfVxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItc3RhcnRcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItaXRlbVwiXG4gIH0sIFtfYygncm91dGVyLWxpbmsnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwidG9cIjogXCIvaG9tZVwiLFxuICAgICAgXCJleGFjdFwiOiBcIlwiXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiSG9tZVwiKV0pXSwgMSksIF92bS5fdihcIiBcIiksIChfdm0uR2V0QXV0aFN0YXR1cykgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm5hdmJhci1pdGVtXCJcbiAgfSwgW19jKCdyb3V0ZXItbGluaycsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJ0b1wiOiBcIi9teXRlYW1cIlxuICAgIH1cbiAgfSwgW192bS5fdihcIk15IFRlYW1cIildKV0sIDEpIDogX3ZtLl9lKCksIF92bS5fdihcIiBcIiksIChfdm0uR2V0QXV0aFN0YXR1cykgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm5hdmJhci1pdGVtXCJcbiAgfSwgW19jKCdyb3V0ZXItbGluaycsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJ0b1wiOiBcIi9saXZlXCJcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJTdGF0IFRyYWNrZXJcIildKV0sIDEpIDogX3ZtLl9lKCksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibmF2YmFyLWl0ZW1cIlxuICB9LCBbX2MoJ3JvdXRlci1saW5rJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcInRvXCI6IFwiL3J1bGVzXCJcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJJbmZvXCIpXSldLCAxKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItaXRlbVwiXG4gIH0sIFtfYygncm91dGVyLWxpbmsnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwidG9cIjogXCIvc3VnZ2VzdGlvbnNcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIlN1Z2dlc3Rpb25zXCIpXSldLCAxKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm5hdmJhci1lbmRcIlxuICB9LCBbKCFfdm0uR2V0QXV0aFN0YXR1cykgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm5hdmJhci1pdGVtXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5zZXRSZWdpc3Rlck1vZGFsKHtcbiAgICAgICAgICBzaG93OiAhX3ZtLlNob3dSZWdpc3Rlck1vZGFsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9LCBbX2MoJ2EnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaHJlZlwiOiBcIiMhXCJcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJSZWdpc3RlclwiKV0pXSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgKCFfdm0uR2V0QXV0aFN0YXR1cykgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm5hdmJhci1pdGVtXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5zZXRMb2dpbk1vZGFsKHtcbiAgICAgICAgICBzaG93OiAhX3ZtLlNob3dMb2dpbk1vZGFsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9LCBbX3ZtLl9tKDEpLCBfdm0uX3YoXCIgXCIpLCBfYygnYScsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJocmVmXCI6IFwiIyFcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIkxvZ2luXCIpXSldKSA6IF92bS5fZSgpLCBfdm0uX3YoXCIgXCIpLCAoX3ZtLkdldEF1dGhTdGF0dXMpID8gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItaXRlbVwiXG4gIH0sIFtfYygnYScsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJocmVmXCI6IFwiIyFcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIldlbGNvbWUsIFwiICsgX3ZtLl9zKF92bS5nZXRVc2VyRGF0YS51c2VybmFtZSkgKyBcIiFcIildKV0pIDogX3ZtLl9lKCksIF92bS5fdihcIiBcIiksIChfdm0uR2V0QXV0aFN0YXR1cykgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm5hdmJhci1pdGVtXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5zZXRMb2dnZWRJbih7XG4gICAgICAgICAgaXNMb2dnZWRJbjogIV92bS5HZXRBdXRoU3RhdHVzXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9LCBbKF92bS5HZXRBdXRoU3RhdHVzKSA/IF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImljb25cIlxuICB9LCBbX2MoJ2knLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmEgZmEtc2lnbi1vdXRcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICAgIH1cbiAgfSldKSA6IF92bS5fZSgpLCBfdm0uX3YoXCIgXCIpLCBfYygnYScsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJocmVmXCI6IFwiIyFcIlxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLmxvZ291dFxuICAgIH1cbiAgfSwgW192bS5fdihcIkxvZ291dFwiKV0pXSkgOiBfdm0uX2UoKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdyZWdpc3RlcicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJzaG93XCI6IF92bS5TaG93UmVnaXN0ZXJNb2RhbFxuICAgIH1cbiAgfSksIF92bS5fdihcIiBcIiksIF9jKCdsb2dpbicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJzaG93XCI6IF92bS5TaG93TG9naW5Nb2RhbFxuICAgIH1cbiAgfSldLCAxKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibmF2YmFyLWJyYW5kXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibmF2YmFyLWl0ZW1cIlxuICB9LCBbX3ZtLl92KFwiXFxuICAgICAgLy9BTFBIQSBURVNULy9cXG4gICAgXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibmF2YmFyLWJ1cmdlciBidXJnZXJcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJkYXRhLXRhcmdldFwiOiBcIm5hdk1lbnVcIlxuICAgIH1cbiAgfSwgW19jKCdzcGFuJyksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJyksIF92bS5fdihcIiBcIiksIF9jKCdzcGFuJyldKV0pXG59LGZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaWNvblwiXG4gIH0sIFtfYygnaScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmYSBmYS1zaWduLWluXCJcbiAgfSldKVxufV19XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LWVmMjk3YTEyXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZWYyOTdhMTJcIixcImhhc1Njb3BlZFwiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0yZTRhNzBhNlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbGVhZGVyYm9hcmQudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCIyNDEzOTIyZVwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0yZTRhNzBhNlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbGVhZGVyYm9hcmQudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTJlNGE3MGE2XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9sZWFkZXJib2FyZC52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtMmU0YTcwYTZcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbGVhZGVyYm9hcmQudnVlXG4vLyBtb2R1bGUgaWQgPSAyMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTNmYjc3NzE4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zdWdnZXN0aW9ucy52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjUwY2NkZjRhXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTNmYjc3NzE4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zdWdnZXN0aW9ucy52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2ZiNzc3MThcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3N1Z2dlc3Rpb25zLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0zZmI3NzcxOFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9zdWdnZXN0aW9ucy52dWVcbi8vIG1vZHVsZSBpZCA9IDIyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNDkzNjFjNzBcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL215dGVhbS52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjc0OGZiOTI1XCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTQ5MzYxYzcwXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9teXRlYW0udnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTQ5MzYxYzcwXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9teXRlYW0udnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTQ5MzYxYzcwXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL215dGVhbS52dWVcbi8vIG1vZHVsZSBpZCA9IDIyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTRmYzAwNWIwXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2luZGV4LnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI2ZTNjZWYxNFwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGZjMDA1YjBcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vaW5kZXgudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi00ZmMwMDViMFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9pbmRleC52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNGZjMDA1YjBcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vaW5kZXgudnVlXG4vLyBtb2R1bGUgaWQgPSAyMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTVmYjRmYzRhXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9yZWdpc3Rlci52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjBiMzg2OGM1XCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTVmYjRmYzRhXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9yZWdpc3Rlci52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNWZiNGZjNGFcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3JlZ2lzdGVyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi01ZmI0ZmM0YVwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWVcbi8vIG1vZHVsZSBpZCA9IDIyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtOWIzYjM0NDBcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3J1bGVzLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiZjMyMWEwNjZcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtOWIzYjM0NDBcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3J1bGVzLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi05YjNiMzQ0MFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vcnVsZXMudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTliM2IzNDQwXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL3J1bGVzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1jNmU3ZWZlNlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3RhdHRyYWNrZXIudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI1M2JiODFiZVwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1jNmU3ZWZlNlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vc3RhdHRyYWNrZXIudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWM2ZTdlZmU2XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zdGF0dHJhY2tlci52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtYzZlN2VmZTZcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvc3RhdHRyYWNrZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWVmMjk3YTEyXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9uYXZiYXIudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCIxMDBkYzQ3ZVwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1lZjI5N2ExMlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbmF2YmFyLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1lZjI5N2ExMlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbmF2YmFyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi1lZjI5N2ExMlwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==