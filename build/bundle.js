/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 72);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(202)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var bind = __webpack_require__(39);
var isBuffer = __webpack_require__(90);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && !isArray(obj)) {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge() /* obj1, obj2, obj3, ... */{
  var result = {};
  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(73);

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * vuex v2.3.0
 * (c) 2017 Evan You
 * @license MIT
 */
var applyMixin = function applyMixin(Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;
    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if (options === void 0) options = {};

      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit() {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
};

var devtoolHook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin(store) {
  if (!devtoolHook) {
    return;
  }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */

/**
 * forEach for object
 */
function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function (key) {
    return fn(obj[key], key);
  });
}

function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

function isPromise(val) {
  return val && typeof val.then === 'function';
}

function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}

var Module = function Module(rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = { namespaced: {} };

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced;
};

Module.prototype.addChild = function addChild(key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};

Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties(Module.prototype, prototypeAccessors$1);

var ModuleCollection = function ModuleCollection(rawRootModule) {
  var this$1 = this;

  // register root module (Vuex.Store options)
  this.root = new Module(rawRootModule, false);

  // register all nested modules
  if (rawRootModule.modules) {
    forEachValue(rawRootModule.modules, function (rawModule, key) {
      this$1.register([key], rawModule, false);
    });
  }
};

ModuleCollection.prototype.get = function get(path) {
  return path.reduce(function (module, key) {
    return module.getChild(key);
  }, this.root);
};

ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '');
  }, '');
};

ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update(this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1 = this;
  if (runtime === void 0) runtime = true;

  var parent = this.get(path.slice(0, -1));
  var newModule = new Module(rawModule, runtime);
  parent.addChild(path[path.length - 1], newModule);

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (!parent.getChild(key).runtime) {
    return;
  }

  parent.removeChild(key);
};

function update(targetModule, newModule) {
  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        console.warn("[vuex] trying to add a new module '" + key + "' on hot reloading, " + 'manual reload is needed');
        return;
      }
      update(targetModule.getChild(key), newModule.modules[key]);
    }
  }
}

var Vue; // bind on install

var Store = function Store(options) {
  var this$1 = this;
  if (options === void 0) options = {};

  assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
  assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");

  var state = options.state;if (state === void 0) state = {};
  var plugins = options.plugins;if (plugins === void 0) plugins = [];
  var strict = options.strict;if (strict === void 0) strict = false;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch(type, payload) {
    return dispatch.call(store, type, payload);
  };
  this.commit = function boundCommit(type, payload, options) {
    return commit.call(store, type, payload, options);
  };

  // strict mode
  this.strict = strict;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.concat(devtoolPlugin).forEach(function (plugin) {
    return plugin(this$1);
  });
};

var prototypeAccessors = { state: {} };

prototypeAccessors.state.get = function () {
  return this._vm._data.$$state;
};

prototypeAccessors.state.set = function (v) {
  assert(false, "Use store.replaceState() to explicit replace store state.");
};

Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
  var type = ref.type;
  var payload = ref.payload;
  var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    console.error("[vuex] unknown mutation type: " + type);
    return;
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });
  this._subscribers.forEach(function (sub) {
    return sub(mutation, this$1.state);
  });

  if (options && options.silent) {
    console.warn("[vuex] mutation type: " + type + ". Silent option has been removed. " + 'Use the filter functionality in the vue-devtools');
  }
};

Store.prototype.dispatch = function dispatch(_type, _payload) {
  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
  var type = ref.type;
  var payload = ref.payload;

  var entry = this._actions[type];
  if (!entry) {
    console.error("[vuex] unknown action type: " + type);
    return;
  }
  return entry.length > 1 ? Promise.all(entry.map(function (handler) {
    return handler(payload);
  })) : entry[0](payload);
};

Store.prototype.subscribe = function subscribe(fn) {
  var subs = this._subscribers;
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  };
};

Store.prototype.watch = function watch(getter, cb, options) {
  var this$1 = this;

  assert(typeof getter === 'function', "store.watch only accepts a function.");
  return this._watcherVM.$watch(function () {
    return getter(this$1.state, this$1.getters);
  }, cb, options);
};

Store.prototype.replaceState = function replaceState(state) {
  var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule(path, rawModule) {
  if (typeof path === 'string') {
    path = [path];
  }
  assert(Array.isArray(path), "module path must be a string or an Array.");
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path));
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1 = this;

  if (typeof path === 'string') {
    path = [path];
  }
  assert(Array.isArray(path), "module path must be a string or an Array.");
  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties(Store.prototype, prototypeAccessors);

function resetStore(store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM(store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = function () {
      return fn(store);
    };
    Object.defineProperty(store.getters, key, {
      get: function get() {
        return store._vm[key];
      },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () {
      return oldVm.$destroy();
    });
  }
}

function installModule(store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var namespacedType = namespace + key;
    registerAction(store, namespacedType, action, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext(store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (!store._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }

      return store.dispatch(type, payload);
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (!store._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function () {
        return store.getters;
      } : function () {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function get() {
        return getNestedState(store.state, path);
      }
    }
  });

  return local;
}

function makeLocalGetters(store, namespace) {
  var gettersProxy = {};

  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) {
      return;
    }

    // extract local getter type
    var localType = type.slice(splitPos);

    // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.
    Object.defineProperty(gettersProxy, localType, {
      get: function get() {
        return store.getters[type];
      },
      enumerable: true
    });
  });

  return gettersProxy;
}

function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler(local.state, payload);
  });
}

function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler(payload, cb) {
    var res = handler({
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err;
      });
    } else {
      return res;
    }
  });
}

function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    console.error("[vuex] duplicate getter key: " + type);
    return;
  }
  store._wrappedGetters[type] = function wrappedGetter(store) {
    return rawGetter(local.state, // local state
    local.getters, // local getters
    store.state, // root state
    store.getters // root getters
    );
  };
}

function enableStrictMode(store) {
  store._vm.$watch(function () {
    return this._data.$$state;
  }, function () {
    assert(store._committing, "Do not mutate vuex store state outside mutation handlers.");
  }, { deep: true, sync: true });
}

function getNestedState(state, path) {
  return path.length ? path.reduce(function (state, key) {
    return state[key];
  }, state) : state;
}

function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  assert(typeof type === 'string', "Expects string as the type, but found " + (typeof type === 'undefined' ? 'undefined' : _typeof(type)) + ".");

  return { type: type, payload: payload, options: options };
}

function install(_Vue) {
  if (Vue) {
    console.error('[vuex] already installed. Vue.use(Vuex) should be called only once.');
    return;
  }
  Vue = _Vue;
  applyMixin(Vue);
}

// auto install in dist mode
if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
}

var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return;
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function' ? val.call(this, state, getters) : state[val];
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res;
});

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedMutation() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }if (namespace && !getModuleByNamespace(this.$store, 'mapMutations', namespace)) {
        return;
      }
      return this.$store.commit.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return;
      }
      if (!(val in this.$store.getters)) {
        console.error("[vuex] unknown getter: " + val);
        return;
      }
      return this.$store.getters[val];
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res;
});

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedAction() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }if (namespace && !getModuleByNamespace(this.$store, 'mapActions', namespace)) {
        return;
      }
      return this.$store.dispatch.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});

function normalizeMap(map) {
  return Array.isArray(map) ? map.map(function (key) {
    return { key: key, val: key };
  }) : Object.keys(map).map(function (key) {
    return { key: key, val: map[key] };
  });
}

function normalizeNamespace(fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map);
  };
}

function getModuleByNamespace(store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (!module) {
    console.error("[vuex] module namespace not found in " + helper + "(): " + namespace);
  }
  return module;
}

var index_esm = {
  Store: Store,
  install: install,
  version: '2.3.0',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions
};

exports.Store = Store;
exports.mapState = mapState;
exports.mapMutations = mapMutations;
exports.mapGetters = mapGetters;
exports.mapActions = mapActions;
exports.default = index_esm;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(46);

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsNative = __webpack_require__(112),
    getValue = __webpack_require__(143);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(6);

/** Built-in value references. */
var _Symbol = root.Symbol;

module.exports = _Symbol;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(9),
    getRawTag = __webpack_require__(140),
    objectToString = __webpack_require__(169);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(14);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var baseGetTag = __webpack_require__(10),
    isObjectLike = __webpack_require__(13);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var listCacheClear = __webpack_require__(155),
    listCacheDelete = __webpack_require__(156),
    listCacheGet = __webpack_require__(157),
    listCacheHas = __webpack_require__(158),
    listCacheSet = __webpack_require__(159);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var eq = __webpack_require__(30);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isKeyable = __webpack_require__(152);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(8);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(51),
    isLength = __webpack_require__(32);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Vue.js v2.5.13
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

var emptyObject = Object.freeze({});

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}

/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' ||
  // $flow-disable-line
  (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol' || typeof value === 'boolean';
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

/**
 * Get the raw type string of a value e.g. [object Object]
 */
var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});

/**
 * Simple bind, faster than native
 */
function bind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn;
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop(a, b, c) {}

/**
 * Always return false.
 */
var no = function no(a, b, c) {
  return false;
};

/**
 * Return same value
 */
var identity = function identity(_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  if (a === b) {
    return true;
  }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = ['component', 'directive', 'filter'];

var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "production" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "production" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};

/*  */

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = {}.watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function isServerRendering() {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check
var formatComponentName = noop;

if (false) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function classify(str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function warn(msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function tip(msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function formatComponentName(vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function repeat(str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) {
        res += str;
      }
      if (n > 1) {
        str += str;
      }
      n >>= 1;
    }
    return res;
  };

  generateComponentTrace = function generateComponentTrace(vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}

/*  */

var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function createEmptyVNode(text) {
  if (text === void 0) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode, deep) {
  var componentOptions = vnode.componentOptions;
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.isCloned = true;
  if (deep) {
    if (vnode.children) {
      cloned.children = cloneVNodes(vnode.children, true);
    }
    if (componentOptions && componentOptions.children) {
      componentOptions.children = cloneVNodes(componentOptions.children, true);
    }
  }
  return cloned;
}

function cloneVNodes(vnodes, deep) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i], deep);
  }
  return res;
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;
    while (len--) {
      args[len] = arguments[len];
    }var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive(obj, key, val, customSetter, shallow) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if (false) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    "production" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    "production" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (false) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "production" !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

      return parentVal;
    }
    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    "production" !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }
  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (false) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "production" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) {
    extend(ret, childVal);
  }
  return ret;
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function defaultStrat(parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName(name) {
  if (!/^[a-zA-Z][\w-]*$/.test(name)) {
    warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options, vm) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (false) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  } else if (false) {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options, vm) {
  var inject = options.inject;
  if (!inject) {
    return;
  }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
    }
  } else if (false) {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (false) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (false) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (false) {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (false) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn("Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ') + ", got " + toRawType(value) + ".", vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isType(type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type);
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true;
    }
  }
  /* istanbul ignore next */
  return false;
}

/*  */

function handleError(err, vm, info) {
  if (vm) {
    var cur = vm;
    while (cur = cur.$parent) {
      var hooks = cur.$options.errorCaptured;
      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;
            if (capture) {
              return;
            }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }
  globalHandleError(err, vm, info);
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError(err, vm, info) {
  if (false) {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}

/*  */
/* globals MessageChannel */

var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using both micro and macro tasks.
// In < 2.4 we used micro tasks everywhere, but there are some scenarios where
// micro tasks have too high a priority and fires in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using macro tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use micro task by default, but expose a way to force macro task when
// needed (e.g. in event handlers attached by v-on).
var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false;

// Determine (macro) Task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function macroTimerFunc() {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) ||
// PhantomJS
MessageChannel.toString() === '[object MessageChannelConstructor]')) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = function macroTimerFunc() {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function macroTimerFunc() {
    setTimeout(flushCallbacks, 0);
  };
}

// Determine MicroTask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  microTimerFunc = function microTimerFunc() {
    p.then(flushCallbacks);
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) {
      setTimeout(noop);
    }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a Task instead of a MicroTask.
 */
function withMacroTask(fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res;
  });
}

function nextTick(cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (false) {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function warnNonPresent(target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse(val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || Object.isFrozen(val)) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

var mark;
var measure;

if (false) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function mark(tag) {
      return perf.mark(tag);
    };
    measure = function measure(name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, def, cur, old, event;
  for (name in on) {
    def = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    /* istanbul ignore if */
    if (isUndef(cur)) {
      "production" !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (false) {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i);
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }
  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node;
}

function resolveAsyncComponent(factory, baseCtor, context) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function forceRender() {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "production" !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject( false ? "timeout (" + res.timeout + "ms)" : null);
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}

/*  */

function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}

/*  */

function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}

/*  */

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (!fn) {
      vm._events[event] = null;
      return vm;
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break;
        }
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (false) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, "event handler for \"" + event + "\"");
        }
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = data.slot;
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}

function resolveScopedSlots(fns, // see flow/vnode
res) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res;
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (false) {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (false) {
    updateComponent = function updateComponent() {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function updateComponent() {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (false) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data && parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (false) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (false) {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (false) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  false ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "production" !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function loop(key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (false) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) {
    loop(key);
  }observerState.shouldConvert = true;
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "production" !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (false) {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }
    if (props && hasOwn(props, key)) {
      "production" !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData(data, vm) {
  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (false) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (false) {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  if (false) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (false) {
      if (methods[key] == null) {
        warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }
      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, keyOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (false) {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (false) {
        defineReactive(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {
        defineReactive(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
      /* istanbul ignore next */
      return Object.getOwnPropertyDescriptor(inject, key).enumerable;
    }) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break;
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if (false) {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }
    return result;
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    ret._isVList = true;
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      if (false) {
        warn('slot v-bind without argument expects an Object', this);
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes) {
      if (false) {
        warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      }
      slotNodes._rendered = true;
    }
    nodes = slotNodes || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes);
  } else {
    return nodes;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes(eventKeyCode, key, builtInAlias, eventKeyName) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (keyCodes) {
    if (Array.isArray(keyCodes)) {
      return keyCodes.indexOf(eventKeyCode) === -1;
    } else {
      return keyCodes !== eventKeyCode;
    }
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
      "production" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function loop(key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) {
        loop(key);
      }
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
  );
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "production" !== 'production' && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data;
}

/*  */

function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}

/*  */

function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var options = Ctor.options;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    return resolveSlots(children, parent);
  };

  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm = Object.create(parent);
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }
    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    vnode.fnContext = contextVm;
    vnode.fnOptions = options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }

  return vnode;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// Register the component hook to weex native render engine.
// The hook will be triggered by native, not javascript.


// Updates the state of the component to weex native render engine.

/*  */

// https://github.com/Hanks10100/weex-native-directive/tree/master/component

// listening on native callback

/*  */

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (false) {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var options = {
    _isComponent: true,
    parent: parent,
    _parentVnode: vnode,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options);
}

function mergeHooks(data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1(one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  };
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    "production" !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // warn against non-primitive key
  if (false) {
    {
      warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) {
      applyNS(vnode, ns);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {
        applyNS(child, ns, force);
      }
    }
  }
}

/*  */

function initRender(vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (false) {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // if the parent didn't update, the slot nodes will be the ones from
      // last render. They need to be cloned to ensure "freshness" for this render.
      for (var key in vm.$slots) {
        var slot = vm.$slots[key];
        // _rendered is a flag added by renderSlot, but may not be present
        // if the slot is passed from manually written render functions
        if (slot._rendered || slot[0] && slot[0].elm) {
          vm.$slots[key] = cloneVNodes(slot, true /* deep */);
        }
      }
    }

    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (false) {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (false) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };
}

/*  */

var uid = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (false) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (false) {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (false) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue$3(options) {
  if (false) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (false) {
      validateComponentName(name);
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (false) {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },

  watch: {
    include: function include(val) {
      pruneCache(this, function (name) {
        return matches(val, name);
      });
    },
    exclude: function exclude(val) {
      pruneCache(this, function (name) {
        return !matches(val, name);
      });
    }
  },

  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
      // not included
      include && (!name || !matches(include, name)) ||
      // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || slot && slot[0];
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (false) {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
});

Vue$3.version = '2.5.13';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function mustUseProp(tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function isXlink(name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function getXlinkProp(name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function isFalsyAttrValue(val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }
  if (isObject(value)) {
    return stringifyObject(value);
  }
  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */
  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }
      res += stringified;
    }
  }
  return res;
}

function stringifyObject(value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }
      res += key;
    }
  }
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isReservedTag = function isReservedTag(tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      "production" !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setAttribute(node, key, val) {
  node.setAttribute(key, val);
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove() {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove.listeners = listeners;
    return remove;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (false) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (false) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      if (false) {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setAttribute(vnode.elm, i, '');
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    if (false) {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys(children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn("Duplicate keys detected: '" + key + "'. This may cause an update error.", vnode.context);
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return;
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    }
    // assert node match
    if (false) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (false) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (false) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false;
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (false) {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);

        // create new node
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function callInsert() {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.
      /* istanbul ignore if */
      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {
        var blocker = function blocker(e) {
          e.stopImmediatePropagation();
          el.removeEventListener('input', blocker);
        };
        el.addEventListener('input', blocker);
        // $flow-disable-line
        el.__ieph = true; /* IE placeholder patched */
      }
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

/*  */

// add a raw attr (use this in preTransforms)


// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.

/*  */

/**
 * Cross-platform code generation for component v-model
 */

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler(handler, event, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler() {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
}

function add$1(event, handler, once$$1, capture, passive) {
  handler = withMacroTask(handler);
  if (once$$1) {
    handler = createOnceHandler(handler, event, capture);
  }
  target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
}

function isNotInFocusAndDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}
  return notInFocus && elm.value !== checkVal;
}

function isDirtyWithModifiers(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.lazy) {
      // inputs with lazy should only be updated when not in focus
      return false;
    }
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal);
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim();
    }
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function setProp(el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition(def) {
  if (!def) {
    return;
  }
  /* istanbul ignore else */
  if ((typeof def === 'undefined' ? 'undefined' : _typeof(def)) === 'object') {
    var res = {};
    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }
    extend(res, def);
    return res;
  } else if (typeof def === 'string') {
    return autoCssTransition(def);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function end() {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function onEnd(e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return;
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if (false) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if (false) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    "production" !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag || isAsyncPlaceholder(c);
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if (false) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if (false) {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&
    // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }
        var delayedLeave;
        var performLeave = function performLeave() {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (false) {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
Vue$3.nextTick(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if (false) {
      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
  }
  if (false) {
    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
  }
}, 0);

/*  */

exports.default = Vue$3;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34), __webpack_require__(200).setImmediate))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(3);
var normalizeHeaderName = __webpack_require__(87);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(35);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(35);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {/* Ignore */}
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(8),
    root = __webpack_require__(6);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var mapCacheClear = __webpack_require__(160),
    mapCacheDelete = __webpack_require__(161),
    mapCacheGet = __webpack_require__(162),
    mapCacheHas = __webpack_require__(163),
    mapCacheSet = __webpack_require__(164);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var castPath = __webpack_require__(28),
    toKey = __webpack_require__(11);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var baseMatches = __webpack_require__(116),
    baseMatchesProperty = __webpack_require__(117),
    identity = __webpack_require__(20),
    isArray = __webpack_require__(7),
    property = __webpack_require__(190);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArray = __webpack_require__(7),
    isKey = __webpack_require__(29),
    stringToPath = __webpack_require__(183),
    toString = __webpack_require__(198);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isArray = __webpack_require__(7),
    isSymbol = __webpack_require__(14);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsArguments = __webpack_require__(109),
    isObjectLike = __webpack_require__(13);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
    return arguments;
}()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayLikeKeys = __webpack_require__(100),
    baseKeys = __webpack_require__(114),
    isArrayLike = __webpack_require__(21);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(3);
var settle = __webpack_require__(79);
var buildURL = __webpack_require__(82);
var parseHeaders = __webpack_require__(88);
var isURLSameOrigin = __webpack_require__(86);
var createError = __webpack_require__(38);
var btoa = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || __webpack_require__(81);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if ("production" !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || request.readyState !== 4 && !xDomain) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(84);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(78);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ListCache = __webpack_require__(15),
    stackClear = __webpack_require__(178),
    stackDelete = __webpack_require__(179),
    stackGet = __webpack_require__(180),
    stackHas = __webpack_require__(181),
    stackSet = __webpack_require__(182);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsEqualDeep = __webpack_require__(110),
    isObjectLike = __webpack_require__(13);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SetCache = __webpack_require__(95),
    arraySome = __webpack_require__(101),
    cacheHas = __webpack_require__(129);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(12);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

module.exports = matchesStrictComparable;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var root = __webpack_require__(6),
    stubFalse = __webpack_require__(194);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67)(module)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(10),
    isObject = __webpack_require__(12);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsTypedArray = __webpack_require__(113),
    baseUnary = __webpack_require__(44),
    nodeUtil = __webpack_require__(168);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _vuex = __webpack_require__(5);

var _axios = __webpack_require__(4);

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {};
  },

  computed: (0, _vuex.mapGetters)(['getUserData']),
  methods: _extends({}, (0, _vuex.mapMutations)([]))
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _vuex = __webpack_require__(5);

var _axios = __webpack_require__(4);

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {};
  },

  computed: (0, _vuex.mapGetters)(['getUserData']),
  methods: _extends({}, (0, _vuex.mapMutations)([]))
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _vuex = __webpack_require__(5);

var _axios = __webpack_require__(4);

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {};
  },

  computed: (0, _vuex.mapGetters)(['getUserData']),
  methods: _extends({}, (0, _vuex.mapMutations)([]))
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(4);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      doneLoading: false,
      results: [],
      mainLeagueUsers: [],
      weeklyteams: []
    };
  },

  computed: _extends({
    standings: function standings() {
      return this.mainLeagueUsers.sort(function (a, b) {
        var aPoints = 0;
        var bPoints = 0;
        a.weeklyteams.forEach(function (team) {
          aPoints += team.place;
        });
        b.weeklyteams.forEach(function (team) {
          bPoints += team.place;
        });
        return aPoints - bPoints;
      });
    },
    newstandings: function newstandings() {}
  }, (0, _vuex.mapGetters)(['getUserData'])),
  created: function created() {
    var _this = this;

    console.log("environment", "production");
    _axios2.default.get('/MainLeagueStandings').then(function (data) {
      _this.mainLeagueUsers = data.data;
      _this.mainLeagueUsers.forEach(function (user) {
        user.totalpoints = 0;
        user.weeklyteams.forEach(function (wt) {
          user.totalpoints += wt.place;
        });
        user.weeklyteams.sort(function (a, b) {
          return a - b;
        });
      });
      _this.doneLoading = true;
    });
  },

  methods: {
    pointsbehind: function pointsbehind(user) {
      var objIndex = this.standings.indexOf(user);
      if (objIndex != 0) {
        return user.totalpoints - this.standings[0].totalpoints;
      }
      return '-';
    },
    IsMe: function IsMe(user) {
      if (user.weeklyteams[0].username == this.getUserData.username) {
        console.log("username", this.getUserData.username);
        return true;
      }
      return false;
    }
  }
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(4);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      username: '',
      password: '',
      isLoading: false,
      errorMessage: ''
    };
  },

  computed: (0, _vuex.mapGetters)(['ShowLoginModal']),
  props: {
    show: {
      type: Boolean,
      required: true
    }
  },
  methods: _extends({}, (0, _vuex.mapMutations)(['setLoginModal', 'setUserData', 'setLoggedIn']), {
    submit: function submit(e) {
      var _this = this;

      e.preventDefault();
      this.isLoading = true;
      _axios2.default.post('/login', {
        username: this.username,
        password: this.password,
        captcha: grecaptcha.getResponse()
      }).then(function (data) {
        _this.isLoading = false;
        grecaptcha.reset();
        _this.username = '';
        _this.password = '';
        _this.setUserData({ userData: data.data });
        _this.setLoggedIn({ loggedIn: true });
        _this.setLoginModal({ show: false });
      }).catch(function (err) {
        _this.isLoading = false;
        grecaptcha.reset();
        _this.username = '';
        _this.password = '';
        _this.errorMessage = err.response.data.error;
      });
    }
  })
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
  data: function data() {
    return {};
  }
};

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(4);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(5);

var _findIndex2 = __webpack_require__(185);

var _findIndex3 = _interopRequireDefault(_findIndex2);

var _sortBy2 = __webpack_require__(192);

var _sortBy3 = _interopRequireDefault(_sortBy2);

var _remove2 = __webpack_require__(191);

var _remove3 = _interopRequireDefault(_remove2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      currentweek: 0,
      selectedriders: [],
      availableRiders: [],
      CostSortByAsc: true,
      page: 1,
      isLoading: false,
      showSaveMessage: false,
      showFailMessage: false
    };
  },

  computed: _extends({}, (0, _vuex.mapGetters)(['getUserData']), {
    dollars: function dollars() {
      var total = 10000;
      this.selectedriders.forEach(function (rider) {
        total -= rider.cost;
      });
      return total;
    },
    hidePrevious: function hidePrevious() {
      return this.page <= 1;
    },
    hideNext: function hideNext() {
      return this.page >= this.paginationPages;
    },
    paginatedRiders: function paginatedRiders() {
      if (this.page == 1) {
        console.log("entire array", this.availableRiders);
        console.log(this.availableRiders.slice(0, 10));
        return this.availableRiders.slice(0, 10);
      } else {
        var beginSlice = this.page * 10 - 9;
        var endSlice = beginSlice + 10;
        console.log(this.availableRiders);
        console.log(this.availableRiders.slice(beginSlice, endSlice));
        return this.availableRiders.slice(beginSlice, endSlice);
      }
    },
    paginationPages: function paginationPages() {
      return Math.ceil(this.availableRiders.length / 10);
    },
    hasOpenSlots: function hasOpenSlots() {
      return this.selectedriders.some(function (rider) {
        return rider.name == "OPEN SLOT";
      });
    },
    showRemoveAll: function showRemoveAll() {
      return this.selectedriders.some(function (rider) {
        return rider.name != "OPEN SLOT";
      });
    },
    showSelect: function showSelect() {
      var openSlots = this.selectedriders.some(function (rider) {
        return rider.name == "OPEN SLOT";
      });
      var lowestCostAvailable = (0, _sortBy3.default)(this.availableRiders, function (o) {
        return o.cost;
      });
      console.log("showSelect", lowestCostAvailable[0]);
      if (this.dollars >= lowestCostAvailable[0].cost && openSlots) {
        return true;
      }
      return false;
    }
  }),
  methods: {
    removeRacer: function removeRacer(racer) {
      console.log("removed racers", racer);
      var selectedRacerIndex = (0, _findIndex3.default)(this.selectedriders, function (o) {
        return o.riderid === racer.riderid;
      });
      var openSpace = {
        id: this.selectedriders[selectedRacerIndex].id,
        avatar_url: 'http://www.shopaardvark.com/media/catalog/product/W/S/WS-18655.jpg',
        cost: 0,
        highestFinish: '-',
        lowestFinish: '-',
        name: 'OPEN SLOT',
        rider_number: 0,
        riderid: 0,
        leagueid: 1,
        season_weeksid: this.currentweek
      };
      this.availableRiders.push(racer);
      this.$set(this.selectedriders, selectedRacerIndex, openSpace);
      this.sortByPrice();
      console.log("My new team", this.selectedriders);
    },
    addRacer: function addRacer(racer) {
      var openSlotIndex = (0, _findIndex3.default)(this.selectedriders, function (o) {
        return o.name == "OPEN SLOT";
      });
      (0, _remove3.default)(this.paginatedRiders, function (o) {
        return o.riderid == racer.riderid;
      });
      (0, _remove3.default)(this.availableRiders, function (o) {
        return o.riderid == racer.riderid;
      });
      racer.id = this.selectedriders[openSlotIndex].id;
      this.$set(this.selectedriders, openSlotIndex, racer);
      console.log("Racers to Add", this.selectedriders);
    },
    sortByPrice: function sortByPrice() {
      if (this.CostSortByAsc) {
        this.CostSortByAsc = false;
        this.availableRiders = this.availableRiders.sort(function (a, b) {
          if (a.cost > b.cost) {
            return -1;
          }
          if (a.cost < b.cost) {
            return 1;
          }
          return 0;
        });
      } else {
        this.CostSortByAsc = true;
        this.availableRiders = this.availableRiders.sort(function (a, b) {
          if (a.cost > b.cost) {
            return 1;
          }
          if (a.cost < b.cost) {
            return -1;
          }
          return 0;
        });
      }
    },
    SaveTeam: function SaveTeam() {
      var _this = this;

      this.isLoading = true;
      _axios2.default.post("/SaveTeam", this.selectedriders).then(function (data) {
        _this.isLoading = false;
        _this.SaveMessage();
        console.log(data);
      }).catch(function (error) {
        console.log(error);
        _this.isLoading = false;
        _this.FailMessage();
      });
    },
    SaveMessage: function SaveMessage() {
      var _this2 = this;

      this.showSaveMessage = true;
      setTimeout(function () {
        _this2.showSaveMessage = false;
      }, 5000);
    },
    FailMessage: function FailMessage() {
      var _this3 = this;

      this.showFailMessage = true;
      setTimeout(function () {
        _this3.showFailMessage = false;
      }, 5000);
    },
    RemoveAll: function RemoveAll() {
      var _this4 = this;

      this.selectedriders.forEach(function (racer) {
        if (racer.name != "OPEN SLOT") {
          _this4.removeRacer(racer);
        }
      });
    }
  },
  beforeCreate: function beforeCreate() {
    var _this5 = this;

    _axios2.default.get('/CurrentMyTeamModel').then(function (data) {
      console.log("data", data.data);
      _this5.currentweek = data.data.CurrentWeek;
      console.log(_this5.currentweek);
      _this5.availableRiders = (0, _sortBy3.default)(data.data.AvailableRiders, function (o) {
        return o.cost;
      });
      _this5.selectedriders = data.data.CurrentTeam;
    });
  },
  mounted: function mounted() {
    console.log("mounted", this.getUserData);
  }
};

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(4);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(5);

var _register = __webpack_require__(68);

var _register2 = _interopRequireDefault(_register);

var _login = __webpack_require__(220);

var _login2 = _interopRequireDefault(_login);

var _navbarDropdown = __webpack_require__(224);

var _navbarDropdown2 = _interopRequireDefault(_navbarDropdown);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      username: '',
      password: '',
      showRegisterModal: false
    };
  },

  computed: (0, _vuex.mapGetters)(['ShowLoginModal', 'ShowRegisterModal', 'getUserData', 'GetAuthStatus']),
  mounted: function mounted() {
    // Get all "navbar-burger" elements
    var $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
    // Check if there are any nav burgers
    if ($navbarBurgers.length > 0) {

      // Add a click event on each of them
      $navbarBurgers.forEach(function ($el) {
        $el.addEventListener('click', function () {

          // Get the target from the "data-target" attribute
          var target = $el.dataset.target;
          var $target = document.getElementById(target);

          // Toggle the class on both the "navbar-burger" and the "navbar-menu"
          $el.classList.toggle('is-active');
          $target.classList.toggle('is-active');
        });
      });
    }
  },
  created: function created() {
    var _this = this;

    console.log("src", this.logosrc);
    _axios2.default.get('/loginrefresh').then(function (data) {
      console.log(data.data);
      if (typeof data.data.username != 'undefined') {
        console.log("User Is Authenticated");
        _this.setUserData({ userData: data.data });
        _this.setLoggedIn({ loggedIn: true });
      }
    }).catch(function (err) {
      console.log("login refresh error", err);
    });
  },

  methods: _extends({}, (0, _vuex.mapMutations)(['setRegisterModal', 'setLoginModal', 'setLoggedIn', 'setUserData', 'logout', 'setManagedLeague', 'setLeagues']), {
    logout: function logout() {
      var _this2 = this;

      _axios2.default.get('logout').then(function (data) {
        _this2.$router.push("/");
      });
    }
  }),
  components: {
    'register': _register2.default,
    'login': _login2.default,
    'LeagueDropdown': _navbarDropdown2.default
  }
};

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(4);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      isActive: false,
      ManagedLeague: ''
    };
  },

  computed: {
    LeagueList: function LeagueList() {
      var _this = this;

      return this.allLeagues.filter(function (item) {
        return item.leagueid != _this.ManagedLeague.leagueid;
      });
    }
  },
  created: function created() {
    this.ManagedLeague = this.currentLeague;
  },

  props: {
    currentLeague: {
      type: Object,
      required: true
    },
    allLeagues: {
      type: Array,
      required: true
    }
  },
  methods: _extends({}, (0, _vuex.mapMutations)(['setManagedLeague']), {
    changeLeague: function changeLeague(league) {
      this.setManagedLeague(league);
      this.ManagedLeague = league;
    }
  })
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _vuex = __webpack_require__(5);

var _axios = __webpack_require__(4);

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      username: '',
      email: '',
      password: '',
      errorMessage: [],
      invalidUsername: false,
      invalidEmail: false,
      blankPassword: false,
      isLoading: false
    };
  },

  computed: (0, _vuex.mapGetters)(['ShowRegisterModal', 'getUserData']),
  methods: _extends({}, (0, _vuex.mapMutations)(['setRegisterModal', 'setUserData', 'setLoggedIn']), {
    Register: function Register() {
      var _this = this;

      this.isLoading = true;
      this.errorMessage = [];
      this.invalidEmail = false;
      this.blankPassword = false;
      this.invalidUsername = false;
      if (this.RegistrationIsValid()) {
        _axios2.default.post('/register', {
          username: this.username,
          email: this.email,
          password: this.password,
          captcha: grecaptcha.getResponse(1)
        }).then(function (data) {
          console.log(data);
          _this.isLoading = false;
          var isFalse = !data.data.ErrorMessage;
          console.log("isFalse", isFalse);
          if (!data.data.ErrorMessage) {
            _this.setUserData({ userData: data.data });
            console.log("getUserData", _this.getUserData);
            _this.setRegisterModal({ show: false });
            console.log(_this.$store.state);
          } else {
            _this.errorMessage.push(data.data.ErrorMessage);
            _this.errorMessage.forEach(function (msg) {
              if (msg.indexOf("Username") > -1) {
                _this.invalidUsername = true;
              }
              if (msg.indexOf("Email") > -1) {
                _this.invalidEmail = true;
              }
            });
            grecaptcha.reset(1);
          }
          _this.username = '';
          _this.email = '';
          _this.password = '';
          _this.isLoading = false;
        }).catch(function (e) {
          _this.errorMessage.push(e.response.data.error);
          grecaptcha.reset(1);
          _this.username = '';
          _this.email = '';
          _this.password = '';
          _this.isLoading = false;
        });
      }
    },
    RegistrationIsValid: function RegistrationIsValid() {
      var emailValidation = this.email.match(new RegExp(/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/), "i");
      console.log(emailValidation);
      if (this.email == "") {
        this.errorMessage.push("Username cannot be left empty.");
        this.invalidUsername = true;
      }
      if (emailValidation == null) {
        this.errorMessage.push("Please enter a valid email.");
        this.invalidEmail = true;
      }
      if (this.password == '' || this.password.length < 6) {
        this.errorMessage.push("Password cannot be left empty and must be at least 6 characters.");
        this.blankPassword = true;
      }
      if (this.errorMessage.length > 0) {
        this.isLoading = false;
        return false;
      }
      return true;
    }
  })
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(4);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(5);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      leagueData: [],
      raceData: [],
      isLoading: true,
      ws: null
    };
  },

  computed: _extends({}, (0, _vuex.mapGetters)(['getUserData']), {
    standings: function standings() {
      return this.leagueData.sort(function (a, b) {
        return a.total - b.total;
      });
    }
  }),
  created: function created() {
    console.log("production");
    this.ws =  true ? new WebSocket("wss://fantasysx.herokuapp.com/tracker") : new WebSocket("wss://fantasysx.herokuapp.com/tracker");

    var v = this;
    this.ws.onmessage = function (e) {
      var data = JSON.parse(e.data);
      v.isLoading = false;
      v.leagueData = data.LeagueData;
      v.raceData = data.RaceData;
      console.log(data);
    };
    this.ws.onerror = function (e) {
      console.log("Error", e);
    };
  },

  methods: {
    pointsbehind: function pointsbehind(user) {
      var objIndex = this.leagueData.indexOf(user);
      if (objIndex != 0) {
        return user.total - this.leagueData[0].total;
      }
      return '-';
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.ws.close();
  }
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _axios = __webpack_require__(4);

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      Username: '',
      ReportType: '',
      Registered: false,
      feature: '',
      bugreport: '',
      feedback: ''
    };
  },

  methods: {
    submit: function submit() {
      var data = {
        Username: this.Username,
        ReportType: this.ReportType,
        Registered: this.Registered,
        Feature: this.feature,
        BugReport: this.bugreport,
        Feedback: this.feedback
      };
      _axios2.default.post('/feedback', data).then(function (res) {
        console.log(res);
      });
    }
  }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _navbar = __webpack_require__(223);

var _navbar2 = _interopRequireDefault(_navbar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  computed: {
    username: function username() {
      return this.$store.state.username;
    },
    isLoggedIn: function isLoggedIn() {
      return this.$store.state.isLoggedIn;
    }
  },
  components: {
    'navigation': _navbar2.default
  }
}; //
//
//
//
//
//
//
//
//
//

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_register_vue__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_register_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_register_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_register_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_register_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_7b8a19b4_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_register_vue__ = __webpack_require__(238);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(252)
}
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_register_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_7b8a19b4_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_register_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\register.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7b8a19b4", Component.options)
  } else {
    hotAPI.reload("data-v-7b8a19b4", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRouter = createRouter;

var _vue = __webpack_require__(22);

var _vue2 = _interopRequireDefault(_vue);

var _vueRouter = __webpack_require__(201);

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _leaderboard = __webpack_require__(219);

var _leaderboard2 = _interopRequireDefault(_leaderboard);

var _register = __webpack_require__(68);

var _register2 = _interopRequireDefault(_register);

var _myteam = __webpack_require__(222);

var _myteam2 = _interopRequireDefault(_myteam);

var _rules = __webpack_require__(225);

var _rules2 = _interopRequireDefault(_rules);

var _stattracker = __webpack_require__(226);

var _stattracker2 = _interopRequireDefault(_stattracker);

var _suggestions = __webpack_require__(227);

var _suggestions2 = _interopRequireDefault(_suggestions);

var _myaccount = __webpack_require__(221);

var _myaccount2 = _interopRequireDefault(_myaccount);

var _CreateLeague = __webpack_require__(216);

var _CreateLeague2 = _interopRequireDefault(_CreateLeague);

var _joinleague = __webpack_require__(218);

var _joinleague2 = _interopRequireDefault(_joinleague);

var _deleteaccount = __webpack_require__(217);

var _deleteaccount2 = _interopRequireDefault(_deleteaccount);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vueRouter2.default);

function createRouter() {
  return new _vueRouter2.default({
    mode: 'history',
    routes: [{ path: "/", component: _leaderboard2.default }, { path: "/register", component: _register2.default }, { path: "/myteam", component: _myteam2.default }, { path: "/rules", component: _rules2.default }, { path: "/live", component: _stattracker2.default }, { path: "/suggestions", component: _suggestions2.default }, { path: "/home", component: _leaderboard2.default }, { path: "/myaccount", component: _myaccount2.default,
      children: [{ path: 'createleague', component: _CreateLeague2.default }, { path: 'joinleague', component: _joinleague2.default }, { path: 'deleteaccount', component: _deleteaccount2.default }] }]
  });
}

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(22);

var _vue2 = _interopRequireDefault(_vue);

var _vuex = __webpack_require__(5);

var _vuex2 = _interopRequireDefault(_vuex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vuex2.default);

var state = {
  user: {
    username: ''
  },
  isLoggedIn: false,
  modalControl: {
    showLoginModal: false,
    showRegisterModal: false
  }
};

var getters = {
  getUserData: function getUserData() {
    return state.user;
  },
  ShowLoginModal: function ShowLoginModal() {
    return state.modalControl.showLoginModal;
  },
  ShowRegisterModal: function ShowRegisterModal() {
    return state.modalControl.showRegisterModal;
  },
  GetAuthStatus: function GetAuthStatus() {
    return state.isLoggedIn;
  }
};

var mutations = {
  changeTeam: function changeTeam(state, riderArray) {
    state.user.riders = riderArray;
  },
  setLoginModal: function setLoginModal(state, _ref) {
    var show = _ref.show;

    state.modalControl.showLoginModal = show;
  },
  setRegisterModal: function setRegisterModal(state, _ref2) {
    var show = _ref2.show;

    state.modalControl.showRegisterModal = show;
  },
  setUserData: function setUserData(state, _ref3) {
    var userData = _ref3.userData;

    state.user = userData;
  },
  setLoggedIn: function setLoggedIn(state, _ref4) {
    var loggedIn = _ref4.loggedIn;

    state.isLoggedIn = loggedIn;
  },
  logout: function logout(state) {
    state.user.riders = [];
    state.user = {};
    state.isLoggedIn = false;
  },
  setManagedLeague: function setManagedLeague(state, _ref5) {
    var league = _ref5.league;

    state.user.currentLeague = league;
  },
  setLeagues: function setLeagues(state, _ref6) {
    var leagues = _ref6.leagues;

    state.user.leagues = leagues;
  }
};

exports.default = new _vuex2.default.Store({
  state: state,
  getters: getters,
  mutations: mutations
});

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6de5ab34_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_index_vue__ = __webpack_require__(235);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(249)
}
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6de5ab34_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_index_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "index.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-6de5ab34", Component.options)
  } else {
    hotAPI.reload("data-v-6de5ab34", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _vue = __webpack_require__(22);

var _vue2 = _interopRequireDefault(_vue);

var _index = __webpack_require__(71);

var _index2 = _interopRequireDefault(_index);

var _router = __webpack_require__(69);

var _store = __webpack_require__(70);

var _store2 = _interopRequireDefault(_store);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var router = (0, _router.createRouter)();
var app = new _vue2.default({
  el: "#app",
  router: router,
  store: _store2.default,
  render: function render(h) {
    return h(_index2.default);
  }
}).$mount("#app");

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(3);
var bind = __webpack_require__(39);
var Axios = __webpack_require__(75);
var defaults = __webpack_require__(23);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(36);
axios.CancelToken = __webpack_require__(74);
axios.isCancel = __webpack_require__(37);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(89);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(36);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(23);
var utils = __webpack_require__(3);
var InterceptorManager = __webpack_require__(76);
var dispatchRequest = __webpack_require__(77);
var isAbsoluteURL = __webpack_require__(85);
var combineURLs = __webpack_require__(83);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
  config.method = config.method.toLowerCase();

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(3);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(3);
var transformData = __webpack_require__(80);
var isCancel = __webpack_require__(37);
var defaults = __webpack_require__(23);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(config.data, config.headers, config.transformRequest);

  // Flatten headers
  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});

  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(response.data, response.headers, config.transformResponse);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(38);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(3);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error();
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
  // initialize result and counter
  var block, charCode, idx = 0, map = chars;
  // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1);
  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(3);

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(3);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },

    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },

    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() :

// Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
  );
};

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(3);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;

  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :

// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(3);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(3);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(8),
    root = __webpack_require__(6);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hashClear = __webpack_require__(145),
    hashDelete = __webpack_require__(146),
    hashGet = __webpack_require__(147),
    hashHas = __webpack_require__(148),
    hashSet = __webpack_require__(149);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(8),
    root = __webpack_require__(6);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(8),
    root = __webpack_require__(6);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MapCache = __webpack_require__(25),
    setCacheAdd = __webpack_require__(173),
    setCacheHas = __webpack_require__(174);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new MapCache();
    while (++index < length) {
        this.add(values[index]);
    }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(6);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(8),
    root = __webpack_require__(6);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseTimes = __webpack_require__(126),
    isArguments = __webpack_require__(31),
    isArray = __webpack_require__(7),
    isBuffer = __webpack_require__(50),
    isIndex = __webpack_require__(18),
    isTypedArray = __webpack_require__(52);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseForOwn = __webpack_require__(106),
    createBaseEach = __webpack_require__(133);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayPush = __webpack_require__(42),
    isFlattenable = __webpack_require__(150);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createBaseFor = __webpack_require__(134);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFor = __webpack_require__(105),
    keys = __webpack_require__(33);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayPush = __webpack_require__(42),
    isArray = __webpack_require__(7);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(10),
    isObjectLike = __webpack_require__(13);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Stack = __webpack_require__(40),
    equalArrays = __webpack_require__(45),
    equalByTag = __webpack_require__(136),
    equalObjects = __webpack_require__(137),
    getTag = __webpack_require__(142),
    isArray = __webpack_require__(7),
    isBuffer = __webpack_require__(50),
    isTypedArray = __webpack_require__(52);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Stack = __webpack_require__(40),
    baseIsEqual = __webpack_require__(43);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(51),
    isMasked = __webpack_require__(153),
    isObject = __webpack_require__(12),
    toSource = __webpack_require__(49);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(10),
    isLength = __webpack_require__(32),
    isObjectLike = __webpack_require__(13);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isPrototype = __webpack_require__(154),
    nativeKeys = __webpack_require__(167);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseEach = __webpack_require__(102),
    isArrayLike = __webpack_require__(21);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsMatch = __webpack_require__(111),
    getMatchData = __webpack_require__(139),
    matchesStrictComparable = __webpack_require__(48);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsEqual = __webpack_require__(43),
    get = __webpack_require__(186),
    hasIn = __webpack_require__(187),
    isKey = __webpack_require__(29),
    isStrictComparable = __webpack_require__(47),
    matchesStrictComparable = __webpack_require__(48),
    toKey = __webpack_require__(11);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayMap = __webpack_require__(41),
    baseIteratee = __webpack_require__(27),
    baseMap = __webpack_require__(115),
    baseSortBy = __webpack_require__(125),
    baseUnary = __webpack_require__(44),
    compareMultiple = __webpack_require__(131),
    identity = __webpack_require__(20);

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));

  var result = baseMap(collection, function (value, key, collection) {
    var criteria = arrayMap(iteratees, function (iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function (object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGet = __webpack_require__(26);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseUnset = __webpack_require__(128),
    isIndex = __webpack_require__(18);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * The base implementation of `_.pullAt` without support for individual
 * indexes or capturing the removed elements.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {number[]} indexes The indexes of elements to remove.
 * @returns {Array} Returns `array`.
 */
function basePullAt(array, indexes) {
  var length = array ? indexes.length : 0,
      lastIndex = length - 1;

  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex(index)) {
        splice.call(array, index, 1);
      } else {
        baseUnset(array, index);
      }
    }
  }
  return array;
}

module.exports = basePullAt;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var identity = __webpack_require__(20),
    overRest = __webpack_require__(171),
    setToString = __webpack_require__(176);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var constant = __webpack_require__(184),
    defineProperty = __webpack_require__(135),
    identity = __webpack_require__(20);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(9),
    arrayMap = __webpack_require__(41),
    isArray = __webpack_require__(7),
    isSymbol = __webpack_require__(14);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var castPath = __webpack_require__(28),
    last = __webpack_require__(188),
    parent = __webpack_require__(172),
    toKey = __webpack_require__(11);

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(14);

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compareAscending = __webpack_require__(130);

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(6);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArrayLike = __webpack_require__(21);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(8);

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(9),
    Uint8Array = __webpack_require__(96),
    eq = __webpack_require__(30),
    equalArrays = __webpack_require__(45),
    mapToArray = __webpack_require__(165),
    setToArray = __webpack_require__(175);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getAllKeys = __webpack_require__(138);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetAllKeys = __webpack_require__(107),
    getSymbols = __webpack_require__(141),
    keys = __webpack_require__(33);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isStrictComparable = __webpack_require__(47),
    keys = __webpack_require__(33);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
}

module.exports = getMatchData;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(9);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayFilter = __webpack_require__(99),
    stubArray = __webpack_require__(193);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DataView = __webpack_require__(91),
    Map = __webpack_require__(24),
    Promise = __webpack_require__(93),
    Set = __webpack_require__(94),
    WeakMap = __webpack_require__(97),
    baseGetTag = __webpack_require__(10),
    toSource = __webpack_require__(49);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
            switch (ctorString) {
                case dataViewCtorString:
                    return dataViewTag;
                case mapCtorString:
                    return mapTag;
                case promiseCtorString:
                    return promiseTag;
                case setCtorString:
                    return setTag;
                case weakMapCtorString:
                    return weakMapTag;
            }
        }
        return result;
    };
}

module.exports = getTag;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var castPath = __webpack_require__(28),
    isArguments = __webpack_require__(31),
    isArray = __webpack_require__(7),
    isIndex = __webpack_require__(18),
    isLength = __webpack_require__(32),
    toKey = __webpack_require__(11);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(19);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(19);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(19);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(19);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(9),
    isArguments = __webpack_require__(31),
    isArray = __webpack_require__(7);

/** Built-in value references. */
var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var eq = __webpack_require__(30),
    isArrayLike = __webpack_require__(21),
    isIndex = __webpack_require__(18),
    isObject = __webpack_require__(12);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index === 'undefined' ? 'undefined' : _typeof(index);
  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var coreJsData = __webpack_require__(132);

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(16);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(16);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(16);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(16);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Hash = __webpack_require__(92),
    ListCache = __webpack_require__(15),
    Map = __webpack_require__(24);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(17);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(17);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(17);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(17);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var memoize = __webpack_require__(189);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var overArg = __webpack_require__(170);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(46);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67)(module)))

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = __webpack_require__(98);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGet = __webpack_require__(26),
    baseSlice = __webpack_require__(124);

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseSetToString = __webpack_require__(123),
    shortOut = __webpack_require__(177);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ListCache = __webpack_require__(15);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ListCache = __webpack_require__(15),
    Map = __webpack_require__(24),
    MapCache = __webpack_require__(25);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var memoizeCapped = __webpack_require__(166);

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function (string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function (match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

module.exports = stringToPath;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFindIndex = __webpack_require__(103),
    baseIteratee = __webpack_require__(27),
    toInteger = __webpack_require__(196);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGet = __webpack_require__(26);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseHasIn = __webpack_require__(108),
    hasPath = __webpack_require__(144);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MapCache = __webpack_require__(25);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseProperty = __webpack_require__(119),
    basePropertyDeep = __webpack_require__(120),
    isKey = __webpack_require__(29),
    toKey = __webpack_require__(11);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIteratee = __webpack_require__(27),
    basePullAt = __webpack_require__(121);

/**
 * Removes all elements from `array` that `predicate` returns truthy for
 * and returns an array of the removed elements. The predicate is invoked
 * with three arguments: (value, index, array).
 *
 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
 * to pull elements from an array by value.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = [1, 2, 3, 4];
 * var evens = _.remove(array, function(n) {
 *   return n % 2 == 0;
 * });
 *
 * console.log(array);
 * // => [1, 3]
 *
 * console.log(evens);
 * // => [2, 4]
 */
function remove(array, predicate) {
  var result = [];
  if (!(array && array.length)) {
    return result;
  }
  var index = -1,
      indexes = [],
      length = array.length;

  predicate = baseIteratee(predicate, 3);
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result.push(value);
      indexes.push(index);
    }
  }
  basePullAt(array, indexes);
  return result;
}

module.exports = remove;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFlatten = __webpack_require__(104),
    baseOrderBy = __webpack_require__(118),
    baseRest = __webpack_require__(122),
    isIterateeCall = __webpack_require__(151);

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 */
var sortBy = baseRest(function (collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toNumber = __webpack_require__(197);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toFinite = __webpack_require__(195);

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? remainder ? result - remainder : result : 0;
}

module.exports = toInteger;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(12),
    isSymbol = __webpack_require__(14);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseToString = __webpack_require__(127);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34), __webpack_require__(53)))

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(199);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
  * vue-router v2.7.0
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if (false) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

function isError(err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1;
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent && parent._routerRoot !== parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name];

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (val && current !== vm || !val && current === vm) {
        matched.instances[name] = val;
      }
    }

    // also regiseter instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // resolve props
    data.props = resolveProps(route, matched.props && matched.props[name]);

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config === 'undefined' ? 'undefined' : _typeof(config)) {
    case 'undefined':
      return;
    case 'object':
      return config;
    case 'function':
      return config(route);
    case 'boolean':
      return config ? route.params : undefined;
    default:
      if (false) {
        warn(false, "props in \"" + route.path + "\" is a " + (typeof config === 'undefined' ? 'undefined' : _typeof(config)) + ", " + "expecting an object, function or boolean.");
      }
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function encodeReserveReplacer(c) {
  return '%' + c.charCodeAt(0).toString(16);
};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function encode(str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery, _parseQuery) {
  if (extraQuery === void 0) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    "production" !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    var val = extraQuery[key];
    parsedQuery[key] = Array.isArray(val) ? val.slice() : val;
  }
  return parsedQuery;
}

function parseQuery(query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom, router) {
  var stringifyQuery$$1 = router && router.options.stringifyQuery;
  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: location.query || {},
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }
  return Object.freeze(route);
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res;
}

function getFullPath(ref, _stringifyQuery) {
  var path = ref.path;
  var query = ref.query;if (query === void 0) query = {};
  var hash = ref.hash;if (hash === void 0) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {};

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(function (key) {
    var aVal = a[key];
    var bVal = b[key];
    // check nested equality
    if ((typeof aVal === 'undefined' ? 'undefined' : _typeof(aVal)) === 'object' && (typeof bVal === 'undefined' ? 'undefined' : _typeof(bVal)) === 'object') {
      return isObjectEqual(aVal, bVal);
    }
    return String(aVal) === String(bVal);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;
    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;
    var compareTarget = location.path ? createRoute(null, location, null, router) : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);

    var handler = function handler(e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {
    return;
  }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) {
    return;
  }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) {
    return;
  }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) {
      return;
    }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true;
}

function findAnchor(children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child;
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed) {
    return;
  }
  install.installed = true;

  _Vue = Vue;

  var isDef = function isDef(v) {
    return v !== undefined;
  };

  var registerInstance = function registerInstance(vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (isDef(this.$options.router)) {
        this._routerRoot = this;
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      } else {
        this._routerRoot = this.$parent && this.$parent._routerRoot || this;
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed() {
      registerInstance(this);
    }
  });

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this._routerRoot._router;
    }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this._routerRoot._route;
    }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath(relative, base, append) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative;
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative;
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

var index$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var index = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (_typeof(tokens[i]) === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (index$1(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!index$1(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!index$1(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (index$1(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

index.parse = parse_1;
index.compile = compile_1;
index.tokensToFunction = tokensToFunction_1;
index.tokensToRegExp = tokensToRegExp_1;

/*  */

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = index.compile(path));
    return filler(params || {}, { pretty: true });
  } catch (e) {
    if (false) {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }
    return '';
  }
}

/*  */

function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  var pathMap = oldPathMap || Object.create(null);
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;
  if (false) {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var normalizedPath = normalizePath(path, parent);
  var pathToRegexpOptions = route.pathToRegexpOptions || {};

  if (typeof route.caseSensitive === 'boolean') {
    pathToRegexpOptions.sensitive = route.caseSensitive;
  }

  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named, does not redirect and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (false) {
      if (route.name && !route.redirect && route.children.some(function (child) {
        return (/^\/?$/.test(child.path)
        );
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];

    aliases.forEach(function (alias) {
      var aliasRoute = {
        path: alias,
        children: route.children
      };
      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs
      );
    });
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (false) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function compileRouteRegex(path, pathToRegexpOptions) {
  var regex = index(path, [], pathToRegexpOptions);
  if (false) {
    var keys = {};
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], "Duplicate param keys in route with path: \"" + path + "\"");
      keys[key.name] = true;
    });
  }
  return regex;
}

function normalizePath(path, parent) {
  path = path.replace(/\/$/, '');
  if (path[0] === '/') {
    return path;
  }
  if (parent == null) {
    return path;
  }
  return cleanPath(parent.path + "/" + path);
}

/*  */

function normalizeLocation(raw, current, append, router) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next;
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched.length) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (false) {
      warn(false, "relative params navigation requires a current route.");
    }
    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;

  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
}

/*  */

function createMatcher(routes, router) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (false) {
        warn(record, "Route with name '" + name + "' does not exist");
      }
      if (!record) {
        return _createRoute(null, location);
      }
      var paramNames = record.regex.keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (_typeof(location.params) !== 'object') {
        location.params = {};
      }

      if (currentRoute && _typeof(currentRoute.params) === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom);
        }
      }
    }
    // no match
    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || (typeof redirect === 'undefined' ? 'undefined' : _typeof(redirect)) !== 'object') {
      if (false) {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (false) {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\"");
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      if (false) {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }
    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }
    return createRoute(record, location, redirectedFrom, router);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(regex, path, params) {
  var m = path.match(regex);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}

/*  */

var positionStore = Object.create(null);

function setupScroll() {
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return;
  }

  if (false) {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);
    if (!shouldScroll) {
      return;
    }
    var isObject = (typeof shouldScroll === 'undefined' ? 'undefined' : _typeof(shouldScroll)) === 'object';
    if (isObject && typeof shouldScroll.selector === 'string') {
      var el = document.querySelector(shouldScroll.selector);
      if (el) {
        var offset = shouldScroll.offset && _typeof(shouldScroll.offset) === 'object' ? shouldScroll.offset : {};
        offset = normalizeOffset(offset);
        position = getElementPosition(el, offset);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject && isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();
  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el, offset) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left - offset.x,
    y: elRect.top - docRect.top - offset.y
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function normalizeOffset(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : 0,
    y: isNumber(obj.y) ? obj.y : 0
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

/*  */

var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}

/*  */

function runQueue(queue, fn, cb) {
  var step = function step(index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

function resolveAsyncComponents(matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          if (resolvedDef.__esModule && resolvedDef.default) {
            resolvedDef = resolvedDef.default;
          }
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          "production" !== 'production' && warn(false, msg);
          if (!error) {
            error = isError(reason) ? reason : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) {
      next();
    }
  };
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once(fn) {
  var called = false;
  return function () {
    var args = [],
        len = arguments.length;
    while (len--) {
      args[len] = arguments[len];
    }if (called) {
      return;
    }
    called = true;
    return fn.apply(this, args);
  };
}

/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError(errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }
    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) {
        cb(err);
      });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;

  var current = this.current;
  var abort = function abort(err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  if (isSameRoute(route, current) &&
  // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;

  var queue = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),
  // global before hooks
  this.router.beforeHooks,
  // in-component update hooks
  extractUpdateHooks(updated),
  // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }),
  // async components
  resolveAsyncComponents(activated));

  this.pending = route;
  var iterator = function iterator(hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }
    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (typeof to === 'string' || (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();
          if ((typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function isValid() {
      return this$1.current === route;
    };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/';
      // strip full URL origin
      base = base.replace(/^https?:\/\/[^\/]+/, '');
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  if (instance) {
    return function boundRouteGuard() {
      return guard.apply(instance, arguments);
    };
  }
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

/*  */

var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    window.addEventListener('popstate', function (e) {
      var current = this$1.current;
      this$1.transitionTo(getLocation(this$1.base), function (route) {
        if (expectScroll) {
          handleScroll(router, route, current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash;
}

/*  */

var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return;
    }
    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    window.addEventListener('hashchange', function () {
      if (!ensureSlash()) {
        return;
      }
      this$1.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath);
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true;
  }
  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1);
}

function pushHash(path) {
  window.location.hash = path;
}

function replaceHash(path) {
  var href = window.location.href;
  var i = href.indexOf('#');
  var base = i >= 0 ? href.slice(0, i) : href;
  window.location.replace(base + "#" + path);
}

/*  */

var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {
    // noop
  };

  return AbstractHistory;
}(History);

/*  */

var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;
    default:
      if (false) {
        assert(false, "invalid mode: " + mode);
      }
  }
};

var prototypeAccessors = { currentRoute: {} };

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app /* Vue component instance */) {
  var this$1 = this;

  "production" !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return;
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function setupHashListener() {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  return registerHook(this.beforeHooks, fn);
};

VueRouter.prototype.beforeResolve = function beforeResolve(fn) {
  return registerHook(this.resolveHooks, fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  return registerHook(this.afterHooks, fn);
};

VueRouter.prototype.onReady = function onReady(cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError(errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;
  if (!route) {
    return [];
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append, this);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function registerHook(list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) {
      list.splice(i, 1);
    }
  };
}

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '2.7.0';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

exports.default = VueRouter;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] });
    } else {
      newStyles[id].parts.push(part);
    }
  }
  return styles;
};

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\n.successful-save {\r\n  text-align: center;\r\n  color: #00d1b2;\n}\n.myteam-table table td {\r\n  border: none;\r\n  font-family: 'Courier';\n}\n.myteam-table {\r\n  background-color: rgba(255, 255, 255, 1);\r\n  color: black;\r\n  box-shadow: 1px 1px 10px #222;\n}\n.myteam-table thead, tfoot {\r\n  background: linear-gradient(rgba(255, 106, 0, 1)0%, rgba(156, 52, 0, 1)100%);\n}\n.myteam-title {\r\n  color: #868686;\r\n  font-size: 16pt;\n}\n.myteam-table thead th, tfoot th {\r\n  color: #fff;\r\n  font-size: 12pt;\n}\n.myteam-table tr:hover {\r\n  background: rgba(255, 233, 120, .2);\n}\n.failure-save {\r\n  text-align: center;\r\n  color: #ff2b56;\n}\n.fade-enter-active, .fade-leave-active {\r\n  transition: opacity 1s;\n}\n.fade-enter, .fade-leave-to {\r\n  opacity: 0;\n}\n.page-header-container {\r\n  display: flex;\r\n  justify-content: center;\n}\nbutton {\r\n  margin-bottom: 0.25rem;\n}\n.page-header-block {\r\n  width: 15%;\r\n  min-width: 260px;\n}\n.riders-container {\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    justify-content: center;\n}\n.rider-block {\r\n    min-width: 15rem;\r\n    border: 1px solid #dedede;\r\n    margin: 1rem;\r\n    box-shadow: 1px 1px 1px #cecece;\r\n    padding: 1rem;\r\n    max-width: 15rem;\n}\n.page-title {\r\n    text-align: center;\r\n    text-decoration: underline;\r\n    font-weight: 700;\n}\n.page-title {\r\n    text-align: center;\r\n    text-decoration: underline;\r\n    font-weight: 700;\n}\n.page-subheader {\r\n    text-align:center;\n}\n.card-footer {\r\n    flex-direction: column;\r\n    border: 1px solid #eee;\n}\n.card-content {\r\n    min-height: 11rem;\r\n    max-height: 11rem;\r\n    overflow: hidden;\r\n    margin-bottom: 1rem;\n}\n.card-footer div:nth-child(even) {\r\n    background-color: #eee;\n}\n.footer-row {\r\n    display:flex;\r\n    justify-content: space-between;\n}\np.card-header-title {\r\n    display:flex;\r\n    justify-content: space-around;\n}\np span.icon {\r\n    color: #ff3860;\n}\nth:hover {\r\n    cursor: pointer;\n}\n.hide-pagination-button {\r\n    visibility: hidden;\n}\n.custom-pagination {\r\n    display: flex;\r\n    justify-content: space-between;\n}\n.lastRow {\r\n    border-bottom: 2px solid rgb(208, 83, 1);\n}\n.minus-icon {\r\n    color: #ff3860;\n}\n.plus-icon {\r\n    color: #23d160;\n}\n.boldest-header {\r\n    color: #fffc7f;\r\n    font-weight: 700;\r\n    font-size: xx-large;\n}\n.right {\r\n    float: right;\n}\n.lh-4r {\r\n    height: 4rem;\r\n    line-height: 4rem;\r\n    font-size: 1.75rem;\r\n    color:white;\n}\n.lh-4r:first-of-type {\r\n    border-bottom: 1px solid #ffe978;\n}\n.lh-4r:last-of-type {\r\n    margin-bottom: 2rem;\n}\r\n", "", {"version":3,"sources":["C:/Users/sdorris/fantasymx/client/components/client/components/myteam.vue"],"names":[],"mappings":";AAyQA;EACA,mBAAA;EACA,eAAA;CACA;AACA;EACA,aAAA;EACA,uBAAA;CACA;AACA;EACA,yCAAA;EACA,aAAA;EACA,8BAAA;CACA;AACA;EACA,6EAAA;CACA;AACA;EACA,eAAA;EACA,gBAAA;CACA;AACA;EACA,YAAA;EACA,gBAAA;CACA;AACA;EACA,oCAAA;CACA;AACA;EACA,mBAAA;EACA,eAAA;CACA;AACA;EACA,uBAAA;CACA;AACA;EACA,WAAA;CACA;AACA;EACA,cAAA;EACA,wBAAA;CACA;AACA;EACA,uBAAA;CACA;AACA;EACA,WAAA;EACA,iBAAA;CACA;AACA;IACA,cAAA;IACA,gBAAA;IACA,wBAAA;CACA;AACA;IACA,iBAAA;IACA,0BAAA;IACA,aAAA;IACA,gCAAA;IACA,cAAA;IACA,iBAAA;CACA;AACA;IACA,mBAAA;IACA,2BAAA;IACA,iBAAA;CACA;AACA;IACA,mBAAA;IACA,2BAAA;IACA,iBAAA;CACA;AACA;IACA,kBAAA;CACA;AACA;IACA,uBAAA;IACA,uBAAA;CACA;AACA;IACA,kBAAA;IACA,kBAAA;IACA,iBAAA;IACA,oBAAA;CACA;AACA;IACA,uBAAA;CACA;AACA;IACA,aAAA;IACA,+BAAA;CACA;AACA;IACA,aAAA;IACA,8BAAA;CACA;AACA;IACA,eAAA;CACA;AACA;IACA,gBAAA;CACA;AACA;IACA,mBAAA;CACA;AACA;IACA,cAAA;IACA,+BAAA;CACA;AACA;IACA,yCAAA;CACA;AACA;IACA,eAAA;CACA;AACA;IACA,eAAA;CACA;AACA;IACA,eAAA;IACA,iBAAA;IACA,oBAAA;CACA;AACA;IACA,aAAA;CACA;AACA;IACA,aAAA;IACA,kBAAA;IACA,mBAAA;IACA,YAAA;CACA;AACA;IACA,iCAAA;CACA;AACA;IACA,oBAAA;CACA","file":"myteam.vue","sourcesContent":["<template>\r\n  <div>\r\n    <div class=\"page-header-container\">\r\n      <div class=\"page-header-block\">\r\n        <div class=\"lh-4r\">Week: <span class=\"boldest-header right\">{{currentweek}}</span></div>\r\n        <div class=\"lh-4r\">Balance Remaining:<span class=\"boldest-header right\"> ${{dollars}}</span></div>\r\n      </div>\r\n    </div>\r\n    <div class=\"container\">\r\n      <transition name=\"fade\" mode=\"out-in\">\r\n        <p v-if=\"showSaveMessage\" class=\"successful-save\">Your team has been successfully saved!</p>\r\n        <p v-if=\"showFailMessage\" class=\"failure-save\">Oops! Something Went Wrong. Please try again later.</p>\r\n      </transition>\r\n      <table class=\"myteam-table\">\r\n        <thead>\r\n          <tr>\r\n            <th>Action</th>\r\n            <th @click=\"sortByPrice\">Price\r\n              <span class=\"icon\">\r\n                <i class=\"fa fa-caret-up\" v-if=\"CostSortByAsc\" aria-hidden=\"true\"></i>\r\n                <i class=\"fa fa-caret-down\" v-else aria-hidden=\"true\"></i>\r\n              </span>\r\n            </th>\r\n            <th>Racer Name</th>\r\n            <th>Racer Number</th>\r\n            <th>Highest Finish</th>\r\n            <th>Lowest Finish</th>\r\n            <th>Average Finish</th>\r\n          </tr>\r\n        </thead>\r\n        <tfoot>\r\n          <tr>\r\n            <th>Action</th>\r\n            <th>Price</th>\r\n            <th>Racer Name</th>\r\n            <th>Racer Number</th>\r\n            <th>Highest Finish</th>\r\n            <th>Lowest Finish</th>\r\n            <th>Average Finish</th>\r\n          </tr>\r\n        </tfoot>\r\n        <tbody>\r\n          <tr v-for=\"(racer, index) in selectedriders\">\r\n            <td>\r\n              <a href=\"#!\" v-if=\"racer.name != 'OPEN SLOT'\" @click=\"removeRacer(racer)\">\r\n                <span class=\"icon minus-icon\">\r\n                  <i class=\"fa fa-minus\" aria-hidden=\"true\"></i>\r\n                </span>\r\n              </a>\r\n            </td>\r\n            <td>${{racer.cost}}</td>\r\n            <td>{{racer.name}}</td>\r\n            <td>{{racer.rider_number}}</td>\r\n            <td>{{racer.highestFinish}}</td>\r\n            <td>{{racer.lowestFinish}}</td>\r\n            <td>{{racer.averageFinish}}</td>\r\n          </tr>\r\n          <tr class=\"lastRow\">\r\n            <td colspan=\"5\"></td>\r\n            <td colspan=\"1\">\r\n              <button class=\"button is-danger\" @click=\"RemoveAll\" :disabled=\"!showRemoveAll\">Remove All</button>\r\n            </td>\r\n            <td colspan=\"1\">\r\n              <button class=\"button is-success\" @click=\"SaveTeam\" :disabled=\"hasOpenSlots\" v-bind:class=\"{'is-loading':isLoading}\">Save Team</button>\r\n            </td>\r\n          </tr>\r\n          <tr v-for=\"rider in paginatedRiders\">\r\n            <td>\r\n              <a href=\"#!\" v-if=\"showSelect && rider.cost <= dollars\" @click=\"addRacer(rider)\">\r\n                <span class=\"icon plus-icon\">\r\n                  <i class=\"fa fa-plus\" aria-hidden=\"true\"></i>\r\n                </span>\r\n              </a>\r\n            </td>\r\n            <td>${{rider.cost}}</td>\r\n            <td>{{rider.name}}</td>\r\n            <td>{{rider.rider_number}}</td>\r\n            <td>{{rider.highestFinish}}</td>\r\n            <td>{{rider.lowestFinish}}</td>\r\n            <td>{{rider.averageFinish}}</td>\r\n          </tr>\r\n        </tbody>\r\n      </table>\r\n      <div class=\"custom-pagination\">\r\n        <div>\r\n          <a class=\"pagination-previous\" @click=\"page--\" v-bind:class=\"{ 'hide-pagination-button' : hidePrevious }\">Previous</a>\r\n        </div>\r\n        <div>\r\n          <a class=\"pagination-number\">{{page}}/{{paginationPages}}</a>\r\n        </div>\r\n        <div>\r\n          <a class=\"pagination-next\" @click=\"page++\" v-bind:class=\"{ 'hide-pagination-button' : hideNext }\">Next page</a>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport axios from 'axios';\r\nimport { mapGetters } from 'vuex';\r\nimport _findIndex from 'lodash/findIndex';\r\nimport _sortBy from 'lodash/sortBy';\r\nimport _remove from 'lodash/remove';\r\n  export default {\r\n    data() {\r\n      return {\r\n        currentweek: 0,\r\n        selectedriders: [],\r\n        availableRiders: [],\r\n        CostSortByAsc: true,\r\n        page: 1,\r\n        isLoading: false,\r\n        showSaveMessage: false,\r\n        showFailMessage: false\r\n      }\r\n    },\r\n    computed: {\r\n      ...mapGetters([\r\n        'getUserData'\r\n      ]),\r\n      dollars() {\r\n        var total = 10000;\r\n        this.selectedriders.forEach(rider => {\r\n          total -= rider.cost;\r\n        })\r\n        return total;\r\n      },\r\n      hidePrevious() {\r\n        return this.page <= 1;\r\n      },\r\n      hideNext() {\r\n        return this.page >= this.paginationPages;\r\n      },\r\n      paginatedRiders() {\r\n        if (this.page == 1) {\r\n          console.log(\"entire array\", this.availableRiders)\r\n          console.log(this.availableRiders.slice(0, 10));\r\n          return this.availableRiders.slice(0, 10);\r\n        } else {\r\n          var beginSlice = this.page * 10 - 9;\r\n          var endSlice = beginSlice + 10;\r\n          console.log(this.availableRiders)\r\n          console.log(this.availableRiders.slice(beginSlice, endSlice))\r\n          return this.availableRiders.slice(beginSlice, endSlice);\r\n        }\r\n      },\r\n      paginationPages() {\r\n        return Math.ceil(this.availableRiders.length / 10);\r\n      },\r\n      hasOpenSlots() {\r\n        return this.selectedriders.some(rider => { return rider.name == \"OPEN SLOT\" })\r\n      },\r\n      showRemoveAll() {\r\n        return this.selectedriders.some(rider => { return rider.name != \"OPEN SLOT\" })\r\n      },\r\n      showSelect() {\r\n        var openSlots = this.selectedriders.some((rider) => {return rider.name == \"OPEN SLOT\"});\r\n        var lowestCostAvailable = _sortBy(this.availableRiders, o => { return o.cost });\r\n        console.log(\"showSelect\", lowestCostAvailable[0])\r\n        if ((this.dollars >= lowestCostAvailable[0].cost) && openSlots) {\r\n          return true;\r\n        }\r\n        return false;\r\n      }\r\n    },\r\n    methods: {\r\n      removeRacer(racer) {\r\n        console.log(\"removed racers\", racer);\r\n        var selectedRacerIndex = _findIndex(this.selectedriders, o => { return o.riderid === racer.riderid });\r\n        var openSpace = {\r\n          id: this.selectedriders[selectedRacerIndex].id,\r\n          avatar_url: 'http://www.shopaardvark.com/media/catalog/product/W/S/WS-18655.jpg',\r\n          cost: 0,\r\n          highestFinish: '-',\r\n          lowestFinish: '-',\r\n          name: 'OPEN SLOT',\r\n          rider_number: 0,\r\n          riderid: 0,\r\n          leagueid: 1,\r\n          season_weeksid: this.currentweek\r\n        }\r\n        this.availableRiders.push(racer)\r\n        this.$set(this.selectedriders, selectedRacerIndex, openSpace)\r\n        this.sortByPrice();\r\n        console.log(\"My new team\", this.selectedriders)\r\n      },\r\n      addRacer(racer) {\r\n        var openSlotIndex = _findIndex(this.selectedriders, o => { return o.name == \"OPEN SLOT\" });\r\n        _remove(this.paginatedRiders, o => { return o.riderid == racer.riderid })\r\n        _remove(this.availableRiders, o => { return o.riderid == racer.riderid })\r\n        racer.id = this.selectedriders[openSlotIndex].id;\r\n        this.$set(this.selectedriders, openSlotIndex, racer);\r\n        console.log(\"Racers to Add\", this.selectedriders)\r\n      },\r\n      sortByPrice() {\r\n        if (this.CostSortByAsc) {\r\n          this.CostSortByAsc = false;\r\n          this.availableRiders = this.availableRiders.sort((a, b) => {\r\n            if (a.cost > b.cost) {\r\n              return -1\r\n            }\r\n            if (a.cost < b.cost) {\r\n              return 1\r\n            }\r\n            return 0\r\n          })\r\n        } else {\r\n          this.CostSortByAsc = true;\r\n          this.availableRiders = this.availableRiders.sort((a, b) => {\r\n            if (a.cost > b.cost) {\r\n              return 1\r\n            }\r\n            if (a.cost < b.cost) {\r\n              return -1\r\n            }\r\n            return 0\r\n          })\r\n        }\r\n      },\r\n      SaveTeam() {\r\n        this.isLoading = true;\r\n        axios.post(\"/SaveTeam\", this.selectedriders)\r\n        .then(data => {\r\n          this.isLoading = false;\r\n          this.SaveMessage();\r\n          console.log(data);\r\n        })\r\n        .catch(error => {\r\n          console.log(error);\r\n          this.isLoading = false;\r\n          this.FailMessage();\r\n        })\r\n      },\r\n      SaveMessage() {\r\n        this.showSaveMessage = true;\r\n        setTimeout(() => { this.showSaveMessage = false }, 5000)\r\n      },\r\n      FailMessage() {\r\n        this.showFailMessage = true;\r\n        setTimeout(() => { this.showFailMessage = false }, 5000)\r\n      },\r\n      RemoveAll() {\r\n        this.selectedriders.forEach(racer => {\r\n          if (racer.name != \"OPEN SLOT\") {\r\n            this.removeRacer(racer)\r\n          }\r\n        })\r\n      }\r\n    },\r\n    beforeCreate() {\r\n      axios.get('/CurrentMyTeamModel')\r\n      .then(data => {\r\n        console.log(\"data\", data.data);\r\n        this.currentweek = data.data.CurrentWeek;\r\n        console.log(this.currentweek);\r\n        this.availableRiders = _sortBy(data.data.AvailableRiders, o => { return o.cost });\r\n        this.selectedriders = data.data.CurrentTeam;\r\n      })\r\n    },\r\n    mounted() {\r\n      console.log(\"mounted\", this.getUserData)\r\n    }\r\n  }\r\n</script>\r\n<style>\r\n.successful-save {\r\n  text-align: center;\r\n  color: #00d1b2;\r\n}\r\n.myteam-table table td {\r\n  border: none;\r\n  font-family: 'Courier';\r\n}\r\n.myteam-table {\r\n  background-color: rgba(255, 255, 255, 1);\r\n  color: black;\r\n  box-shadow: 1px 1px 10px #222;\r\n}\r\n.myteam-table thead, tfoot {\r\n  background: linear-gradient(rgba(255, 106, 0, 1)0%, rgba(156, 52, 0, 1)100%);\r\n}\r\n.myteam-title {\r\n  color: #868686;\r\n  font-size: 16pt;\r\n}\r\n.myteam-table thead th, tfoot th {\r\n  color: #fff;\r\n  font-size: 12pt;\r\n}\r\n.myteam-table tr:hover {\r\n  background: rgba(255, 233, 120, .2);\r\n}\r\n.failure-save {\r\n  text-align: center;\r\n  color: #ff2b56;\r\n}\r\n.fade-enter-active, .fade-leave-active {\r\n  transition: opacity 1s;\r\n}\r\n.fade-enter, .fade-leave-to {\r\n  opacity: 0;\r\n}\r\n.page-header-container {\r\n  display: flex;\r\n  justify-content: center;\r\n}\r\nbutton {\r\n  margin-bottom: 0.25rem;\r\n}\r\n.page-header-block {\r\n  width: 15%;\r\n  min-width: 260px;\r\n}\r\n  .riders-container {\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    justify-content: center;\r\n  }\r\n  .rider-block {\r\n    min-width: 15rem;\r\n    border: 1px solid #dedede;\r\n    margin: 1rem;\r\n    box-shadow: 1px 1px 1px #cecece;\r\n    padding: 1rem;\r\n    max-width: 15rem;\r\n  }\r\n  .page-title {\r\n    text-align: center;\r\n    text-decoration: underline;\r\n    font-weight: 700;\r\n  }\r\n  .page-title {\r\n    text-align: center;\r\n    text-decoration: underline;\r\n    font-weight: 700;\r\n  }\r\n  .page-subheader {\r\n    text-align:center;\r\n  }\r\n  .card-footer {\r\n    flex-direction: column;\r\n    border: 1px solid #eee;\r\n  }\r\n  .card-content {\r\n    min-height: 11rem;\r\n    max-height: 11rem;\r\n    overflow: hidden;\r\n    margin-bottom: 1rem;\r\n  }\r\n  .card-footer div:nth-child(even) {\r\n    background-color: #eee;\r\n  }\r\n  .footer-row {\r\n    display:flex;\r\n    justify-content: space-between;\r\n  }\r\n  p.card-header-title {\r\n    display:flex;\r\n    justify-content: space-around;\r\n  }\r\n  p span.icon {\r\n    color: #ff3860;\r\n  }\r\n  th:hover {\r\n    cursor: pointer;\r\n  }\r\n  .hide-pagination-button {\r\n    visibility: hidden;\r\n  }\r\n  .custom-pagination {\r\n    display: flex;\r\n    justify-content: space-between;\r\n  }\r\n  .lastRow {\r\n    border-bottom: 2px solid rgb(208, 83, 1);\r\n  }\r\n  .minus-icon {\r\n    color: #ff3860;\r\n  }\r\n  .plus-icon {\r\n    color: #23d160;\r\n  }\r\n  .boldest-header {\r\n    color: #fffc7f;\r\n    font-weight: 700;\r\n    font-size: xx-large;\r\n  }\r\n  .right {\r\n    float: right;\r\n  }\r\n  .lh-4r {\r\n    height: 4rem;\r\n    line-height: 4rem;\r\n    font-size: 1.75rem;\r\n    color:white;\r\n  }\r\n  .lh-4r:first-of-type {\r\n    border-bottom: 1px solid #ffe978;\r\n  }\r\n  .lh-4r:last-of-type {\r\n    margin-bottom: 2rem;\r\n  }\r\n</style>\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "", {"version":3,"sources":[],"names":[],"mappings":"","file":"deleteaccount.vue","sourceRoot":""}]);

// exports


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\n.bold-message {\n  text-align: center;\n  font-size: 18pt;\n  color: #fffc7f;\n  font-weight: 800;\n}\n", "", {"version":3,"sources":["C:/Users/sdorris/fantasymx/client/components/client/components/CreateLeague.vue"],"names":[],"mappings":";AA0DA;EACA,mBAAA;EACA,gBAAA;EACA,eAAA;EACA,iBAAA;CACA","file":"CreateLeague.vue","sourcesContent":["<template>\r\n<div>\r\n  <div v-if=\"getUserData.accounttype == 2\" class=\"column is-half is-offset-one-quarter\">\r\n    <div class=\"field\">\r\n      <label>League Name</label>\r\n      <div class=\"control has-icons-left\">\r\n        <input class=\"input\" type=\"text\" placeholder=\"League Name\">\r\n        <span class=\"icon is-small is-left\">\r\n          <i class=\"fa fa-trophy\"></i>\r\n        </span>\r\n      </div>\r\n    </div>\r\n    <div class=\"field\">\r\n      <label>League Password</label>\r\n      <div class=\"control has-icons-left\">\r\n        <input class=\"input\" type=\"text\" placeholder=\"League Password\">\r\n        <span class=\"icon is-small is-left\">\r\n          <i class=\"fa fa-lock\"></i>\r\n        </span>\r\n      </div>\r\n    </div>\r\n    <div class=\"field\">\r\n      <label>Max Players</label>\r\n      <div class=\"control has-icons-left\">\r\n        <input class=\"input\" type=\"number\" placeholder=\"Max Players\">\r\n        <span class=\"icon is-small is-left\">\r\n          <i class=\"fa fa-hashtag\"></i>\r\n        </span>\r\n      </div>\r\n    </div>\r\n    <div class=\"field\">\r\n      <button class=\"button\">Submit</button>\r\n    </div>\r\n  </div>\r\n  <div v-if=\"getUserData.accounttype != 2\">\r\n    <p class=\"bold-message\">This feature requires a Premium account. Please upgrade your account in order to activate this feature.</p>\r\n  </div>\r\n</div>\r\n</template>\r\n\r\n<script>\r\nimport { mapGetters, mapMutations } from 'vuex';\r\nimport axios from 'axios';\r\n  export default {\r\n    data() {\r\n      return {\r\n\r\n      }\r\n    },\r\n    computed: mapGetters([\r\n      'getUserData'\r\n    ]),\r\n    methods: {\r\n      ...mapMutations([\r\n      ]),\r\n    }\r\n  }\r\n</script>\r\n<style>\r\n  .bold-message {\r\n    text-align: center;\r\n    font-size: 18pt;\r\n    color: #fffc7f;\r\n    font-weight: 800;\r\n  }\r\n</style>\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\n.navbar-menu {\n  padding: 0 100px 0 50px;\n}\n.navbar {\n  background: transparent;\n}\na {\n  color: white;\n  font-size: 16pt;\n}\n.router-link-active {\n  border-bottom: 1px solid #fffc7f;\n}\n", "", {"version":3,"sources":["C:/Users/sdorris/fantasymx/client/components/client/components/navbar.vue"],"names":[],"mappings":";AAsIA;EACA,wBAAA;CACA;AACA;EACA,wBAAA;CACA;AACA;EACA,aAAA;EACA,gBAAA;CACA;AACA;EACA,iCAAA;CACA","file":"navbar.vue","sourcesContent":["\r\n  <template>\r\n    <nav class=\"navbar\">\r\n       <div class=\"navbar-brand\">\r\n        <div class=\"navbar-item\">\r\n        </div>\r\n        </div>\r\n        <div class=\"navbar-burger burger\" data-target=\"navMenu\">\r\n          <span></span>\r\n          <span></span>\r\n          <span></span>\r\n        </div>\r\n      </div>\r\n      <div class=\"navbar-menu\" id=\"navMenu\">\r\n        <div class=\"navbar-start\">\r\n          <div class=\"navbar-item\">\r\n            <router-link to=\"/home\" exact>Home</router-link>\r\n          </div>\r\n          <div class=\"navbar-item\" v-if=\"GetAuthStatus\">\r\n            <router-link to=\"/myteam\">My Team</router-link>\r\n          </div>\r\n          <div class=\"navbar-item\" v-if=\"GetAuthStatus\">\r\n            <router-link to=\"/live\">Stat Tracker</router-link>\r\n          </div>\r\n          <div class=\"navbar-item\">\r\n            <router-link to=\"/rules\">Info</router-link>\r\n          </div>\r\n          <div class=\"navbar-item\">\r\n            <router-link to=\"/suggestions\">Suggestions</router-link>\r\n          </div>\r\n        </div>\r\n        <div class=\"navbar-end\">\r\n          <div class=\"navbar-item\" v-if=\"!GetAuthStatus\" @click=\"setRegisterModal({ show: !ShowRegisterModal })\">\r\n            <a href=\"#!\">Register</a>\r\n          </div>\r\n          <div class=\"navbar-item\" v-if=\"!GetAuthStatus\" @click=\"setLoginModal({ show: !ShowLoginModal })\">\r\n            <span class=\"icon\">\r\n              <i class=\"fa fa-sign-in\"></i>\r\n            </span>\r\n            <a href=\"#!\">Login</a>\r\n          </div>\r\n          <div class=\"navbar-item\" v-if=\"GetAuthStatus\">\r\n            <router-link to=\"/myaccount\">Welcome, {{ getUserData.username }}!</router-link>\r\n          </div>\r\n          <div class=\"navbar-item\" v-if=\"GetAuthStatus\" @click=\"setLoggedIn({ isLoggedIn: !GetAuthStatus })\">\r\n            <span class=\"icon\" v-if=\"GetAuthStatus\">\r\n              <i class=\"fa fa-sign-out\" aria-hidden=\"true\"></i>\r\n            </span>\r\n            <a href=\"#!\" @click=\"logout\">Logout</a>\r\n          </div>\r\n        </div>\r\n      </div>\r\n      <register :show=\"ShowRegisterModal\"></register>\r\n      <login v-bind:show=\"ShowLoginModal\"></login>\r\n    </nav>\r\n  </template>\r\n  <script>\r\n    import axios from 'axios';\r\n    import { mapGetters, mapMutations } from 'vuex';\r\n    import register from './register.vue';\r\n    import login from './login.vue';\r\n    import LeagueDropdown from './navbarDropdown.vue';\r\n    export default {\r\n      data() {\r\n        return  {\r\n          username: '',\r\n          password: '',\r\n          showRegisterModal: false,\r\n        }\r\n      },\r\n      computed: mapGetters([\r\n        'ShowLoginModal',\r\n        'ShowRegisterModal',\r\n        'getUserData',\r\n        'GetAuthStatus'\r\n      ]),\r\n      mounted() {\r\n        // Get all \"navbar-burger\" elements\r\n        var $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);\r\n        // Check if there are any nav burgers\r\n        if ($navbarBurgers.length > 0) {\r\n\r\n          // Add a click event on each of them\r\n          $navbarBurgers.forEach(function ($el) {\r\n            $el.addEventListener('click', () => {\r\n\r\n              // Get the target from the \"data-target\" attribute\r\n              var target = $el.dataset.target;\r\n              var $target = document.getElementById(target);\r\n\r\n              // Toggle the class on both the \"navbar-burger\" and the \"navbar-menu\"\r\n              $el.classList.toggle('is-active');\r\n              $target.classList.toggle('is-active');\r\n\r\n            });\r\n          });\r\n        }\r\n      },\r\n      created() {\r\n        console.log(\"src\", this.logosrc)\r\n        axios.get('/loginrefresh').then(data => {\r\n          console.log(data.data)\r\n          if (typeof data.data.username != 'undefined') {\r\n            console.log(\"User Is Authenticated\")\r\n            this.setUserData({ userData: data.data })\r\n            this.setLoggedIn({ loggedIn: true })\r\n          }\r\n        }).catch(err => {\r\n          console.log(\"login refresh error\", err);\r\n        })\r\n      },\r\n      methods: {\r\n        ...mapMutations([\r\n          'setRegisterModal',\r\n          'setLoginModal',\r\n          'setLoggedIn',\r\n          'setUserData',\r\n          'logout',\r\n          'setManagedLeague',\r\n          'setLeagues'\r\n        ]),\r\n        logout() {\r\n          axios.get('logout').then(data => {\r\n            this.$router.push(\"/\");\r\n          })\r\n        }\r\n      },\r\n      components: {\r\n        'register': register,\r\n        'login': login,\r\n        'LeagueDropdown': LeagueDropdown\r\n      }\r\n    }\r\n  </script>\r\n  <style>\r\n    .navbar-menu {\r\n      padding: 0 100px 0 50px;\r\n    }\r\n    .navbar {\r\n      background: transparent;\r\n    }\r\n    a {\r\n      color: white;\r\n      font-size: 16pt;\r\n    }\r\n    .router-link-active {\r\n      border-bottom: 1px solid #fffc7f;\r\n    }\r\n  </style>\r\n})\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\n.myaccount-container {\n  display:flex;\n  flex-direction:column;\n  width: 45%;\n  color: white;\n  margin-top: 2rem;\n}\n.ul {\n  list-style-type: none;\n  display: flex;\n  justify-content: space-around;\n  margin-bottom: 2rem;\n}\n.ul > li {\n  display: inline;\n}\nlabel {\n  color: white;\n  font-size: 1rem;\n  font-weight: 600;\n}\ninput[type='radio'] {\n  margin-left: 2rem;\n}\n", "", {"version":3,"sources":["C:/Users/sdorris/fantasymx/client/components/client/components/myaccount.vue"],"names":[],"mappings":";AAqBA;EACA,aAAA;EACA,sBAAA;EACA,WAAA;EACA,aAAA;EACA,iBAAA;CACA;AACA;EACA,sBAAA;EACA,cAAA;EACA,8BAAA;EACA,oBAAA;CACA;AACA;EACA,gBAAA;CACA;AACA;EACA,aAAA;EACA,gBAAA;EACA,iBAAA;CACA;AACA;EACA,kBAAA;CACA","file":"myaccount.vue","sourcesContent":["<template>\r\n    <div class=\"container myaccount-container\">\r\n      <ul class=\"ul\">\r\n        <li><router-link to=\"/myaccount/createleague\">Create League</router-link></li>\r\n        <li><router-link to=\"/myaccount/joinleague\">Join League</router-link></li>\r\n        <li><router-link to=\"/myaccount/deleteaccount\">Delete Account</router-link></li>\r\n        <li><router-link to=\"/myaccount/upgradeaccount\">Upgrade Account</router-link></li>\r\n      </ul>\r\n      <router-view></router-view>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n  export default {\r\n    data() {\r\n      return {\r\n\r\n      }\r\n    }\r\n  }\r\n</script>\r\n<style>\r\n  .myaccount-container {\r\n    display:flex;\r\n    flex-direction:column;\r\n    width: 45%;\r\n    color: white;\r\n    margin-top: 2rem;\r\n  }\r\n  .ul {\r\n    list-style-type: none;\r\n    display: flex;\r\n    justify-content: space-around;\r\n    margin-bottom: 2rem;\r\n  }\r\n  .ul > li {\r\n    display: inline;\r\n  }\r\n  label {\r\n    color: white;\r\n    font-size: 1rem;\r\n    font-weight: 600;\r\n  }\r\n  input[type='radio'] {\r\n    margin-left: 2rem;\r\n  }\r\n</style>\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\n.flex-center {\r\n  display:flex;\r\n  justify-content:center;\n}\n.live-header-box {\r\n  min-width: 360px;\n}\n.live-header {\r\n  color: white;\r\n  font-size: 12pt;\r\n  margin-top: 3rem;\r\n  font-weight: 700;\n}\n.text-highlight {\r\n    font-size: 12pt;\r\n    font-weight: 700;\r\n    color: #fffc7f;\n}\n.fl-right {\r\n  float: right;\n}\n.myRow {\r\n    background-color:rgba(255, 233, 120, .7) !important;\r\n    color: #d24a00;\r\n    font-weight: 600;\n}\n.table-live table td {\r\n    border: none;\n}\n.table-live {\r\n    background-color: rgba(255, 255, 255, .8);\r\n    color: #7b7b7b;\r\n    box-shadow: 1px 1px 10px #222;\n}\n.table-live thead, tfoot {\r\n    background: linear-gradient(rgba(255, 106, 0, 1)0%, rgba(156, 52, 0, 1)100%);\n}\n.table-live thead th, tfoot th {\r\n    color: #fff;\r\n    font-size: 12pt;\n}\n.table-live tr:hover {\r\n    background: rgba(255, 233, 120, .2);\n}\r\n", "", {"version":3,"sources":["C:/Users/sdorris/fantasymx/client/components/client/components/stattracker.vue"],"names":[],"mappings":";AA+FA;EACA,aAAA;EACA,uBAAA;CACA;AACA;EACA,iBAAA;CACA;AACA;EACA,aAAA;EACA,gBAAA;EACA,iBAAA;EACA,iBAAA;CACA;AACA;IACA,gBAAA;IACA,iBAAA;IACA,eAAA;CACA;AACA;EACA,aAAA;CACA;AACA;IACA,oDAAA;IACA,eAAA;IACA,iBAAA;CACA;AACA;IACA,aAAA;CACA;AACA;IACA,0CAAA;IACA,eAAA;IACA,8BAAA;CACA;AACA;IACA,6EAAA;CACA;AACA;IACA,YAAA;IACA,gBAAA;CACA;AACA;IACA,oCAAA;CACA","file":"stattracker.vue","sourcesContent":["<template>\r\n  <div>\r\n    <div class=\"flex-center fl live-header\" v-if=\"!isLoading\">\r\n      <div class=\"live-header-box\">\r\n        <div>Session Event: <span class=\"text-highlight fl-right\">{{raceData.raceData.S}}</span></div>\r\n        <div>Season Event:<span class=\"text-highlight fl-right\"> {{raceData.raceData.E}}</span></div>\r\n        <div>Session Status:<span class=\"text-highlight fl-right\"> {{raceData.raceDetails.B}}</span></div>\r\n      </div>\r\n    </div>\r\n    <div class=\"columns leaderboard\">\r\n      <div class=\"column is-half is-offset-one-quarter\">\r\n        <table class=\"table-live\" v-if=\"!isLoading\">\r\n          <thead>\r\n            <tr>\r\n              <th>Position</th>\r\n              <th>Total Points</th>\r\n              <th>Username</th>\r\n              <th>Points Back</th>\r\n            </tr>\r\n          </thead>\r\n          <tfoot>\r\n            <tr>\r\n              <th>Position</th>\r\n              <th>Total Points</th>\r\n              <th>Username</th>\r\n              <th>Points Back</th>\r\n            </tr>\r\n          </tfoot>\r\n          <tbody>\r\n            <tr v-for=\"(user, index) in standings\" v-bind:class=\"[ user.username == getUserData.username ? 'myRow' : '']\">\r\n              <td>{{ index + 1 }}.</td>\r\n              <td>{{user.total}}</td>\r\n              <td>{{user.username}}</td>\r\n              <td class=\"pointsback\">{{ pointsbehind(user) }}</td>\r\n            </tr>\r\n          </tbody>\r\n        </table>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n<script>\r\nimport axios from 'axios';\r\nimport { mapGetters } from 'vuex';\r\n  export default {\r\n    data() {\r\n      return {\r\n        leagueData: [],\r\n        raceData: [],\r\n        isLoading: true,\r\n        ws: null\r\n      }\r\n    },\r\n    computed: {\r\n      ...mapGetters([\r\n        'getUserData'\r\n      ]),\r\n      standings: function() {\r\n        return this.leagueData.sort((a, b) => {\r\n          return a.total - b.total;\r\n        })\r\n      }\r\n    },\r\n    created() {\r\n      console.log(process.env.NODE_ENV)\r\n      this.ws = process.env.NODE_ENV == 'production'\r\n        ? new WebSocket(\"wss://fantasysx.herokuapp.com/tracker\")\r\n        : new WebSocket(\"wss://fantasysx.herokuapp.com/tracker\");\r\n\r\n      var v = this;\r\n      this.ws.onmessage = function (e) {\r\n        var data = JSON.parse(e.data);\r\n        v.isLoading = false;\r\n        v.leagueData = data.LeagueData;\r\n        v.raceData = data.RaceData;\r\n        console.log(data)\r\n      }\r\n      this.ws.onerror = function (e) {\r\n        console.log(\"Error\", e)\r\n      }\r\n    },\r\n    methods:  {\r\n      pointsbehind: function(user) {\r\n        var objIndex = this.leagueData.indexOf(user);\r\n        if (objIndex != 0) {\r\n          return user.total - this.leagueData[0].total;\r\n        }\r\n        return '-'\r\n      }\r\n    },\r\n    beforeDestroy() {\r\n      this.ws.close();\r\n    }\r\n  }\r\n</script>\r\n<style>\r\n.flex-center {\r\n  display:flex;\r\n  justify-content:center;\r\n}\r\n.live-header-box {\r\n  min-width: 360px;\r\n}\r\n.live-header {\r\n  color: white;\r\n  font-size: 12pt;\r\n  margin-top: 3rem;\r\n  font-weight: 700;\r\n}\r\n.text-highlight {\r\n    font-size: 12pt;\r\n    font-weight: 700;\r\n    color: #fffc7f;\r\n}\r\n.fl-right {\r\n  float: right;\r\n}\r\n  .myRow {\r\n    background-color:rgba(255, 233, 120, .7) !important;\r\n    color: #d24a00;\r\n    font-weight: 600;\r\n  }\r\n  .table-live table td {\r\n    border: none;\r\n  }\r\n  .table-live {\r\n    background-color: rgba(255, 255, 255, .8);\r\n    color: #7b7b7b;\r\n    box-shadow: 1px 1px 10px #222;\r\n  }\r\n  .table-live thead, tfoot {\r\n    background: linear-gradient(rgba(255, 106, 0, 1)0%, rgba(156, 52, 0, 1)100%);\r\n  }\r\n  .table-live thead th, tfoot th {\r\n    color: #fff;\r\n    font-size: 12pt;\r\n  }\r\n  .table-live tr:hover {\r\n    background: rgba(255, 233, 120, .2);\r\n  }\r\n</style>\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\nh3 {\n  font-size: 16pt;\n  color: white;\n}\ndiv.dropdown.navbar-item:hover {\n  cursor: pointer;\n}\n", "", {"version":3,"sources":["C:/Users/sdorris/fantasymx/client/components/client/components/navbarDropdown.vue"],"names":[],"mappings":";AA4DA;EACA,gBAAA;EACA,aAAA;CACA;AACA;EACA,gBAAA;CACA","file":"navbarDropdown.vue","sourcesContent":["<template>\r\n  <div class=\"dropdown\" @click=\"isActive = !isActive\" v-bind:class=\"{ 'is-active': isActive }\">\r\n  <div class=\"dropdown-trigger\">\r\n    <h3 aria-haspopup=\"true\" aria-controls=\"dropdown-menu\">\r\n      <span>Currently Managing: {{ ManagedLeague.name }}</span>\r\n      <span class=\"icon is-small\">\r\n        <i class=\"fa fa-angle-down\" aria-hidden=\"true\"></i>\r\n      </span>\r\n    </h3>\r\n  </div>\r\n  <div class=\"dropdown-menu\" id=\"dropdown-menu\" role=\"menu\">\r\n    <div class=\"dropdown-content\" v-for=\"league in LeagueList\">\r\n      <a href=\"#\" class=\"dropdown-item\" @click=\"changeLeague(league)\">\r\n        {{league.name}}\r\n      </a>\r\n    </div>\r\n  </div>\r\n</div>\r\n</template>\r\n<script>\r\nimport axios from 'axios';\r\nimport { mapMutations, mapGetters } from 'vuex';\r\nexport default {\r\n    data() {\r\n      return {\r\n        isActive: false,\r\n        ManagedLeague: '',\r\n      }\r\n    },\r\n    computed: {\r\n      LeagueList() {\r\n        return this.allLeagues.filter(item => {\r\n          return item.leagueid != this.ManagedLeague.leagueid;\r\n        })\r\n      }\r\n    },\r\n    created() {\r\n      this.ManagedLeague = this.currentLeague;\r\n    },\r\n    props: {\r\n      currentLeague: {\r\n        type: Object,\r\n        required: true\r\n      },\r\n      allLeagues: {\r\n        type: Array,\r\n        required: true\r\n      }\r\n    },\r\n    methods: {\r\n      ...mapMutations([\r\n        'setManagedLeague'\r\n      ]),\r\n      changeLeague(league) {\r\n        this.setManagedLeague(league)\r\n        this.ManagedLeague = league;\r\n      }\r\n    }\r\n}\r\n</script>\r\n<style>\r\n  h3 {\r\n    font-size: 16pt;\r\n    color: white;\r\n  }\r\n  div.dropdown.navbar-item:hover {\r\n    cursor: pointer;\r\n  }\r\n</style>\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\n\n\n\n\n\n\n\n", "", {"version":3,"sources":[],"names":[],"mappings":"","file":"index.vue","sourceRoot":""}]);

// exports


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\nbody {\r\n  font-family: \"Open Sans Condensed\";\r\n  height: 100%;\r\n  min-height: 100vh;\r\n  background:\r\n    linear-gradient(to bottom right, rgba(251, 109, 8, .8)0%, rgba(204, 66, 0, 1)100%),\r\n    url('https://images.pexels.com/photos/37527/sports-games-fun-holiday-37527.jpeg?w=1260&h=750&auto=compress&cs=tinysrgb');\r\n  background-size: cover;\r\n  background-position:center;\r\n  background-repeat: no-repeat;\n}\n.leaderboard-table .title > th {\r\n  border-bottom: 1px solid #f5f5a2;\r\n  font-size: 16pt;\r\n  padding: .5rem;\n}\n.leaderboard-table {\r\n  background-color: rgba(255, 255, 255, .8);\r\n  color: #7b7b7b;\r\n  box-shadow: 1px 1px 10px #222;\n}\n.leaderboard-table thead th, tfoot th {\r\n  color: #fff;\r\n  font-size: 12pt;\n}\n.leaderboard-table thead, tfoot {\r\n  background: linear-gradient(rgba(255, 106, 0, 1)0%, rgba(156, 52, 0, 1)100%);\n}\n.leaderboard-table td {\r\n  border: none;\n}\n.leaderboard-table tr:hover {\r\n  background-color: rgba(255, 233, 120, .2);\n}\n.pointsback {\r\n    font-weight: bolder;\r\n    color: #ff3860;\n}\n.leaderboard {\r\n    margin-top: 50px;\n}\ntable td, th {\r\n    text-align: center !important;\n}\n.leaderboard-main {\r\n    margin-top: 25px;\n}\n.Me {\r\n    background-color: rgba(255, 233, 120, .7);\r\n    color: #d24a00;\r\n    font-weight: 600;\n}\r\n", "", {"version":3,"sources":["C:/Users/sdorris/fantasymx/client/components/client/components/leaderboard.vue"],"names":[],"mappings":";AAsGA;EACA,mCAAA;EACA,aAAA;EACA,kBAAA;EACA;;6HAEA;EACA,uBAAA;EACA,2BAAA;EACA,6BAAA;CACA;AACA;EACA,iCAAA;EACA,gBAAA;EACA,eAAA;CACA;AACA;EACA,0CAAA;EACA,eAAA;EACA,8BAAA;CACA;AACA;EACA,YAAA;EACA,gBAAA;CACA;AACA;EACA,6EAAA;CACA;AACA;EACA,aAAA;CACA;AACA;EACA,0CAAA;CACA;AACA;IACA,oBAAA;IACA,eAAA;CACA;AACA;IACA,iBAAA;CACA;AACA;IACA,8BAAA;CACA;AACA;IACA,iBAAA;CACA;AACA;IACA,0CAAA;IACA,eAAA;IACA,iBAAA;CACA","file":"leaderboard.vue","sourcesContent":["<template>\r\n  <div>\r\n    <div class=\"columns leaderboard\">\r\n      <div class=\"column is-half is-offset-one-quarter\">\r\n        <table class=\"leaderboard-table\" v-if=\"doneLoading\">\r\n          <thead>\r\n            <tr class=\"title\">\r\n              <th colspan=\"4\">2018 Fantasy SX: Main League Standings</th>\r\n            </tr>\r\n            <tr>\r\n              <th>Position</th>\r\n              <th>Total Points</th>\r\n              <th>Username</th>\r\n              <th>Points Back</th>\r\n            </tr>\r\n          </thead>\r\n          <tfoot>\r\n            <tr>\r\n              <th>Position</th>\r\n              <th>Total Points</th>\r\n              <th>Username</th>\r\n              <th>Points Back</th>\r\n            </tr>\r\n          </tfoot>\r\n          <tbody>\r\n            <tr v-for=\"(user, index) in standings\" v-bind:class=\"{ 'Me': IsMe(user) }\">\r\n              <td>{{ index + 1 }}.</td>\r\n              <td>{{user.totalpoints}}</td>\r\n              <td>{{user.weeklyteams[0].username}}</td>\r\n              <td v-bind:class=\"{ 'pointsback': index > 0 }\">{{ pointsbehind(user) }}</td>\r\n            </tr>\r\n          </tbody>\r\n        </table>\r\n        <div v-if=\"!doneLoading\">\r\n          <p>\"This data doesn't fetch itself.. Loading Race Tracker.\"</p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n</div>\r\n</template>\r\n<script>\r\nimport axios from 'axios';\r\nimport { mapGetters } from 'vuex';\r\n  export default {\r\n    data() {\r\n      return {\r\n        doneLoading: false,\r\n        results: [],\r\n        mainLeagueUsers: [],\r\n        weeklyteams: []\r\n      }\r\n    },\r\n    computed: {\r\n      standings: function() {\r\n        return this.mainLeagueUsers.sort((a, b) => {\r\n          var aPoints = 0;\r\n          var bPoints = 0;\r\n          a.weeklyteams.forEach(team => { aPoints += team.place })\r\n          b.weeklyteams.forEach(team => { bPoints += team.place })\r\n          return aPoints - bPoints;\r\n        })\r\n      },\r\n      newstandings: function() {\r\n\r\n      },\r\n      ...mapGetters([\r\n        'getUserData'\r\n      ])\r\n    },\r\n    created() {\r\n      console.log(\"environment\", process.env.NODE_ENV)\r\n      axios.get('/MainLeagueStandings')\r\n      .then(data => {\r\n        this.mainLeagueUsers = data.data;\r\n        this.mainLeagueUsers.forEach((user) => {\r\n          user.totalpoints = 0\r\n          user.weeklyteams.forEach(wt => { user.totalpoints += wt.place })\r\n          user.weeklyteams.sort((a, b) => {\r\n            return a - b;\r\n          })\r\n        })\r\n        this.doneLoading = true;\r\n      })\r\n    },\r\n    methods: {\r\n      pointsbehind: function(user) {\r\n        var objIndex = this.standings.indexOf(user);\r\n        if (objIndex != 0) {\r\n          return user.totalpoints - this.standings[0].totalpoints;\r\n        }\r\n        return '-'\r\n      },\r\n      IsMe: function (user) {\r\n        if (user.weeklyteams[0].username == this.getUserData.username) {\r\n          console.log(\"username\", this.getUserData.username)\r\n          return true;\r\n        }\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n</script>\r\n<style>\r\nbody {\r\n  font-family: \"Open Sans Condensed\";\r\n  height: 100%;\r\n  min-height: 100vh;\r\n  background:\r\n    linear-gradient(to bottom right, rgba(251, 109, 8, .8)0%, rgba(204, 66, 0, 1)100%),\r\n    url('https://images.pexels.com/photos/37527/sports-games-fun-holiday-37527.jpeg?w=1260&h=750&auto=compress&cs=tinysrgb');\r\n  background-size: cover;\r\n  background-position:center;\r\n  background-repeat: no-repeat;\r\n}\r\n.leaderboard-table .title > th {\r\n  border-bottom: 1px solid #f5f5a2;\r\n  font-size: 16pt;\r\n  padding: .5rem;\r\n}\r\n.leaderboard-table {\r\n  background-color: rgba(255, 255, 255, .8);\r\n  color: #7b7b7b;\r\n  box-shadow: 1px 1px 10px #222;\r\n}\r\n.leaderboard-table thead th, tfoot th {\r\n  color: #fff;\r\n  font-size: 12pt;\r\n}\r\n.leaderboard-table thead, tfoot {\r\n  background: linear-gradient(rgba(255, 106, 0, 1)0%, rgba(156, 52, 0, 1)100%);\r\n}\r\n.leaderboard-table td {\r\n  border: none;\r\n}\r\n.leaderboard-table tr:hover {\r\n  background-color: rgba(255, 233, 120, .2);\r\n}\r\n  .pointsback {\r\n    font-weight: bolder;\r\n    color: #ff3860;\r\n  }\r\n  .leaderboard {\r\n    margin-top: 50px;\r\n  }\r\n  table td, th {\r\n    text-align: center !important;\r\n  }\r\n  .leaderboard-main {\r\n    margin-top: 25px;\r\n  }\r\n  .Me {\r\n    background-color: rgba(255, 233, 120, .7);\r\n    color: #d24a00;\r\n    font-weight: 600;\r\n  }\r\n</style>\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\nh1 {\r\n  text-align: center;\n}\r\n/* Acordeon styles */\n.tab {\r\n  position: relative;\r\n  margin-bottom: 1px;\r\n  width: 100%;\r\n  color: #fff;\r\n  overflow: hidden;\n}\ninput {\r\n  position: absolute;\r\n  opacity: 0;\r\n  z-index: -1;\n}\nlabel {\r\n  position: relative;\r\n  display: block;\r\n  padding: 0 0 0 1em;\r\n  background: rgba(255, 255, 255, 0.3);\r\n  font-weight: bold;\r\n  line-height: 3;\r\n  cursor: pointer;\r\n  color: #fffc7f;\n}\n.tab-content {\r\n  max-height: 0;\r\n  overflow: hidden;\r\n  background: transparent;\r\n  -webkit-transition: max-height .35s;\r\n  -o-transition: max-height .35s;\r\n  transition: max-height .35s;\r\n  color: #fff;\n}\n.tab-content p {\r\n  margin: 1em;\n}\r\n/* :checked */\ninput:checked ~ .tab-content {\r\n  max-height: 10em;\n}\r\n/* Icon */\nlabel::after {\r\n  position: absolute;\r\n  right: 0;\r\n  top: 0;\r\n  display: block;\r\n  width: 3em;\r\n  height: 3em;\r\n  line-height: 3;\r\n  text-align: center;\r\n  -webkit-transition: all .35s;\r\n  -o-transition: all .35s;\r\n  transition: all .35s;\n}\ninput[type=checkbox] + label::after {\r\n  content: \"+\";\n}\ninput[type=radio] + label::after {\r\n  content: \"\\25BC\";\n}\ninput[type=checkbox]:checked + label::after {\r\n  transform: rotate(315deg);\n}\ninput[type=radio]:checked + label::after {\r\n  transform: rotateX(180deg);\n}\r\n", "", {"version":3,"sources":["C:/Users/sdorris/fantasymx/client/components/client/components/rules.vue"],"names":[],"mappings":";AAiCA;EACA,mBAAA;CACA;AACA,qBAAA;AACA;EACA,mBAAA;EACA,mBAAA;EACA,YAAA;EACA,YAAA;EACA,iBAAA;CACA;AACA;EACA,mBAAA;EACA,WAAA;EACA,YAAA;CACA;AACA;EACA,mBAAA;EACA,eAAA;EACA,mBAAA;EACA,qCAAA;EACA,kBAAA;EACA,eAAA;EACA,gBAAA;EACA,eAAA;CACA;AACA;EACA,cAAA;EACA,iBAAA;EACA,wBAAA;EACA,oCAAA;EACA,+BAAA;EACA,4BAAA;EACA,YAAA;CACA;AACA;EACA,YAAA;CACA;AACA,cAAA;AACA;EACA,iBAAA;CACA;AACA,UAAA;AACA;EACA,mBAAA;EACA,SAAA;EACA,OAAA;EACA,eAAA;EACA,WAAA;EACA,YAAA;EACA,eAAA;EACA,mBAAA;EACA,6BAAA;EACA,wBAAA;EACA,qBAAA;CACA;AACA;EACA,aAAA;CACA;AACA;EACA,iBAAA;CACA;AACA;EACA,0BAAA;CACA;AACA;EACA,2BAAA;CACA","file":"rules.vue","sourcesContent":["<template>\r\n  <div class=\"container\">\r\n    <div class=\"\">\r\n      <p>Rules</p>\r\n      <div class=\"tab\">\r\n        <input id=\"tab-one\" type=\"checkbox\" name=\"tabs\">\r\n        <label for=\"tab-one\">How does scoring work?</label>\r\n        <div class=\"tab-content\">\r\n          <p>Right now, scoring is set by racer finish. If a selected racer for that week finishes in first, that racer is awarded 1 point. If a racer finishes in fourth, that racer is awarded 4 points. The lower the point total the better score.</p>\r\n        </div>\r\n      </div>\r\n      <div class=\"tab\">\r\n        <input id=\"tab-two\" type=\"checkbox\" name=\"tabs\">\r\n        <label for=\"tab-two\">How does team selection work?</label>\r\n        <div class=\"tab-content\">\r\n          <p>As of now, each user is REQUIRED to select 4 racers for each week. The deadline for making racer selection is 3am Mountain Time on the day of the scheduled race. After that time\r\n            users will no longer be able to select racers for that week's race; the team selection for the next week will be available for selection</p>\r\n          <p>Users may only SAVE a roster if ALL 4 roster slots have a racer chosen. The SAVE button is disabled if an OPEN SLOT still exists for a weekly lineup.</p>\r\n          <p>Each user begins each week with $10,000 salary cap to spend on filling out their weekly lineup, and that cap room is used to select racers for their week's lineup from the available racers pool.\r\n            The selected racer's cost, once selected, will be deducted from the current week's available salary cap. You are NOT REQUIRED to utilize your entire cap space each week.</p>\r\n        </div>\r\n      </div>\r\n      <div class=\"tab\">\r\n        <input id=\"tab-three\" type=\"checkbox\" name=\"tabs\">\r\n        <label for=\"tab-three\">Custom Leagues</label>\r\n        <div class=\"tab-content\">\r\n          <p>Currently, the application does not support custom / private leagues; We are looking into how best to incorporate this feature with the UI. If you have suggestions please let us know\r\n          by dropping a suggestion.</p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n<style>\r\nh1 {\r\n  text-align: center;\r\n}\r\n/* Acordeon styles */\r\n.tab {\r\n  position: relative;\r\n  margin-bottom: 1px;\r\n  width: 100%;\r\n  color: #fff;\r\n  overflow: hidden;\r\n}\r\ninput {\r\n  position: absolute;\r\n  opacity: 0;\r\n  z-index: -1;\r\n}\r\nlabel {\r\n  position: relative;\r\n  display: block;\r\n  padding: 0 0 0 1em;\r\n  background: rgba(255, 255, 255, 0.3);\r\n  font-weight: bold;\r\n  line-height: 3;\r\n  cursor: pointer;\r\n  color: #fffc7f;\r\n}\r\n.tab-content {\r\n  max-height: 0;\r\n  overflow: hidden;\r\n  background: transparent;\r\n  -webkit-transition: max-height .35s;\r\n  -o-transition: max-height .35s;\r\n  transition: max-height .35s;\r\n  color: #fff;\r\n}\r\n.tab-content p {\r\n  margin: 1em;\r\n}\r\n/* :checked */\r\ninput:checked ~ .tab-content {\r\n  max-height: 10em;\r\n}\r\n/* Icon */\r\nlabel::after {\r\n  position: absolute;\r\n  right: 0;\r\n  top: 0;\r\n  display: block;\r\n  width: 3em;\r\n  height: 3em;\r\n  line-height: 3;\r\n  text-align: center;\r\n  -webkit-transition: all .35s;\r\n  -o-transition: all .35s;\r\n  transition: all .35s;\r\n}\r\ninput[type=checkbox] + label::after {\r\n  content: \"+\";\r\n}\r\ninput[type=radio] + label::after {\r\n  content: \"\\25BC\";\r\n}\r\ninput[type=checkbox]:checked + label::after {\r\n  transform: rotate(315deg);\r\n}\r\ninput[type=radio]:checked + label::after {\r\n  transform: rotateX(180deg);\r\n}\r\n</style>\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\n.errorMessage {\n  color: #ff3860;\n}\n", "", {"version":3,"sources":["C:/Users/sdorris/fantasymx/client/components/client/components/register.vue"],"names":[],"mappings":";AAyJA;EACA,eAAA;CACA","file":"register.vue","sourcesContent":["<template>\r\n  <div class=\"modal\" v-bind:class=\"{'is-active': ShowRegisterModal}\" id=\"registerModal\">\r\n    <div class=\"modal-background\"></div>\r\n    <div class=\"modal-card\">\r\n      <header class=\"modal-card-head\">\r\n        <p class=\"modal-card-title\">New User Registration</p>\r\n        <button class=\"delete\" @click=\"setRegisterModal({ show: !ShowRegisterModal})\"></button>\r\n      </header>\r\n      <section class=\"modal-card-body\">\r\n        <div class=\"content\">\r\n            <div class=\"field\">\r\n              <label class=\"label\">Username: </label>\r\n              <div class=\"control has-icons-left\">\r\n                <input type=\"text\" class=\"input\" v-bind:class=\"{ 'is-danger': invalidUsername }\" id=\"reg-username\" v-model=\"username\" placeholder=\"Username\" required>\r\n                <span class=\"icon is-small is-left\">\r\n                  <i class=\"fa fa-user\"></i>\r\n                </span>\r\n              </div>\r\n            </div>\r\n            <div class=\"field\">\r\n              <label class=\"label\">Email: </label>\r\n              <div class=\"control has-icons-left\">\n                <input type=\"email\" class=\"input\" v-bind:class=\"{ 'is-danger': invalidEmail }\"  id=\"reg-email\" v-model=\"email\" placeholder=\"Email\" required>\r\n                <span class=\"icon is-small is-left\">\r\n                  <i class=\"fa fa-envelope\"></i>\r\n                </span>\r\n              </div>\r\n            </div>\r\n            <div class=\"field\">\r\n              <label class=\"label\">Password: </label>\r\n              <div class=\"control has-icons-left\">\n                <input type=\"password\" class=\"input\" v-bind:class=\"{ 'is-danger': blankPassword }\" v-model=\"password\" placeholder=\"Password\" required>\r\n                <span class=\"icon is-small is-left\">\r\n                  <i class=\"fa fa-lock\"></i>\r\n                </span>\r\n              </div>\r\n            </div>\r\n            <div class=\"field\">\r\n              <div id=\"register-recaptcha\"></div>\r\n            </div>\r\n            <div class=\"errorMessage\" v-for=\"error in errorMessage\" v-if=\"errorMessage != ''\">\r\n              {{ error }}\r\n            </div>\r\n        </div>\r\n      </section>\r\n      <footer class=\"modal-card-foot\">\r\n        <button class=\"button is-success\" @click=\"Register\" v-bind:class=\"{ 'is-loading': isLoading }\">Register</button>\r\n        <button class=\"button\" @click=\"setRegisterModal({ show: !ShowRegisterModal })\">Cancel</button>\r\n      </footer>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { mapGetters, mapMutations } from 'vuex';\r\nimport axios from 'axios';\r\n  export default {\r\n    data() {\r\n      return {\r\n        username: '',\r\n        email: '',\r\n        password: '',\r\n        errorMessage: [],\r\n        invalidUsername: false,\r\n        invalidEmail: false,\r\n        blankPassword: false,\r\n        isLoading: false\r\n      }\r\n    },\r\n    computed: mapGetters([\r\n      'ShowRegisterModal',\r\n      'getUserData'\r\n    ]),\r\n    methods: {\r\n      ...mapMutations([\r\n        'setRegisterModal',\r\n        'setUserData',\r\n        'setLoggedIn'\r\n      ]),\r\n      Register() {\r\n        this.isLoading = true;\r\n        this.errorMessage = [];\r\n        this.invalidEmail = false;\r\n        this.blankPassword = false;\r\n        this.invalidUsername = false;\r\n        if (this.RegistrationIsValid()) {\r\n          axios.post('/register', {\r\n            username: this.username,\r\n            email: this.email,\r\n            password: this.password,\r\n            captcha: grecaptcha.getResponse(1)\r\n          }).then(data => {\r\n            console.log(data);\r\n            this.isLoading = false;\r\n            var isFalse = !data.data.ErrorMessage;\r\n            console.log(\"isFalse\", isFalse)\r\n            if (!data.data.ErrorMessage) {\r\n              this.setUserData({ userData: data.data })\r\n              console.log(\"getUserData\", this.getUserData)\r\n              this.setRegisterModal({ show: false })\r\n              console.log(this.$store.state);\r\n            } else {\r\n              this.errorMessage.push(data.data.ErrorMessage);\r\n              this.errorMessage.forEach(msg => {\r\n                if (msg.indexOf(\"Username\") > -1) {\r\n                  this.invalidUsername = true;\r\n                }\r\n                if (msg.indexOf(\"Email\") >-1) {\r\n                  this.invalidEmail = true;\r\n                }\r\n              })\r\n              grecaptcha.reset(1);\r\n            }\r\n            this.username = '';\r\n            this.email = '';\r\n            this.password = ''\r\n            this.isLoading = false;\r\n          })\r\n          .catch(e => {\r\n            this.errorMessage.push(e.response.data.error);\r\n            grecaptcha.reset(1);\r\n            this.username = '';\r\n            this.email = '';\r\n            this.password = ''\r\n            this.isLoading = false;\r\n          })\r\n\r\n        }\r\n      },\r\n      RegistrationIsValid() {\r\n        var emailValidation = this.email.match(new RegExp(/^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/), \"i\");\r\n        console.log(emailValidation);\r\n        if (this.email == \"\") {\r\n          this.errorMessage.push(\"Username cannot be left empty.\")\r\n          this.invalidUsername = true;\r\n        }\r\n        if (emailValidation == null) {\r\n          this.errorMessage.push(\"Please enter a valid email.\")\r\n          this.invalidEmail = true;\r\n        }\r\n        if (this.password == '' || this.password.length < 6) {\r\n          this.errorMessage.push(\"Password cannot be left empty and must be at least 6 characters.\")\r\n          this.blankPassword = true;\r\n        }\r\n        if (this.errorMessage.length > 0) {\r\n          this.isLoading = false;\r\n          return false;\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n</script>\r\n<style>\r\n  .errorMessage {\r\n    color: #ff3860;\r\n  }\r\n</style>\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\n.bold-message {\r\n  text-align: center;\r\n  font-size: 18pt;\r\n  color: #fffc7f;\r\n  font-weight: 800;\n}\r\n", "", {"version":3,"sources":["C:/Users/sdorris/fantasymx/client/components/client/components/joinleague.vue"],"names":[],"mappings":";AAiDA;EACA,mBAAA;EACA,gBAAA;EACA,eAAA;EACA,iBAAA;CACA","file":"joinleague.vue","sourcesContent":["<template>\r\n  <div>\r\n  <div v-if=\"getUserData.accounttype > 0\" class=\"column is-half is-offset-one-quarter\">\r\n    <div class=\"field\">\r\n      <label>League Name</label>\r\n      <div class=\"control has-icons-left\">\r\n        <input class=\"input\" type=\"text\" placeholder=\"League ID\">\r\n        <span class=\"icon is-small is-left\">\r\n          <i class=\"fa fa-trophy\"></i>\r\n        </span>\r\n      </div>\r\n    </div>\r\n    <div class=\"field\">\r\n      <label>League Password</label>\r\n      <div class=\"control has-icons-left\">\r\n        <input class=\"input\" type=\"text\" placeholder=\"League Password\">\r\n        <span class=\"icon is-small is-left\">\r\n          <i class=\"fa fa-lock\"></i>\r\n        </span>\r\n      </div>\r\n    </div>\r\n    <div class=\"field\">\r\n      <button class=\"button\">Submit</button>\r\n    </div>\r\n  </div>\r\n  <div v-if=\"getUserData.accounttype == 0\">\r\n    <p class=\"bold-message\">This feature requires at least a Basic account. Please upgrade your account in order to activate this feature.</p>\r\n  </div>\r\n</div>\r\n</template>\r\n\r\n<script>\r\nimport { mapGetters, mapMutations } from 'vuex';\r\nimport axios from 'axios';\r\n  export default {\r\n    data() {\r\n      return {\r\n\r\n      }\r\n    },\r\n    computed: mapGetters([\r\n      'getUserData'\r\n    ]),\r\n    methods: {\r\n      ...mapMutations([\r\n      ]),\r\n    }\r\n  }\r\n</script>\r\n<style>\r\n.bold-message {\r\n  text-align: center;\r\n  font-size: 18pt;\r\n  color: #fffc7f;\r\n  font-weight: 800;\r\n}\r\n</style>\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(1)(true);
// imports


// module
exports.push([module.i, "\n.suggestions-container {\n  display: flex;\n  justify-content: center;\n  margin-top: 3rem;\n  color: white;\n}\n", "", {"version":3,"sources":["C:/Users/sdorris/fantasymx/client/components/client/components/suggestions.vue"],"names":[],"mappings":";AAqGA;EACA,cAAA;EACA,wBAAA;EACA,iBAAA;EACA,aAAA;CACA","file":"suggestions.vue","sourcesContent":["<template>\r\n  <div class=\"container suggestions-container\">\r\n      <section>\r\n        <div class=\"field\">\r\n          <div class=\"control\">\r\n            <label>Are you a registered user?</label>\r\n            <label class=\"radio\">\r\n              <input type=\"radio\" name=\"Registered\" value=\"true\" v-model=\"Registered\">\r\n              Yes\r\n            </label>\r\n            <label class=\"radio\">\r\n              <input type=\"radio\" name=\"Registered\" value=\"false\" v-model=\"Registered\">\r\n              No\r\n            </label>\r\n          </div>\r\n        </div>\r\n        <div class=\"field\">\r\n          <div class=\"control\">\r\n            <label>Is this feedback or a bug report?</label>\r\n            <label class=\"radio\">\r\n              <input type=\"radio\" name=\"feedback\" v-model=\"ReportType\" value=\"feedback\">\r\n              Feedback\r\n            </label>\r\n            <label class=\"radio\">\r\n              <input type=\"radio\" name=\"feedback\" v-model=\"ReportType\" value=\"bug\">\r\n              Bug Report\r\n            </label>\r\n          </div>\r\n        </div>\r\n        <div class=\"field\">\r\n          <label class=\"label\">Username</label>\r\n            <div class=\"control\">\r\n              <input class=\"input\" type=\"text\" placeholder=\"Username\" v-model=\"Username\">\r\n            </div>\r\n        </div>\r\n        <div class=\"field\" v-if=\"ReportType == 'feedback'\">\r\n          <label class=\"label\">Suggest Features</label>\r\n          <div class=\"control\">\r\n            <div class=\"select\">\r\n              <select v-model=\"feature\">\r\n                <option disabled value=\"\">SELECT CATEGORY</option>\r\n                <option>User Interface</option>\r\n                <option>Navigation Content</option>\r\n                <option>My Team</option>\r\n                <option>Scoring</option>\r\n                <option>New Features</option>\r\n                <option>Stat Tracker</option>\r\n                <option>Account</option>\r\n              </select>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        <div class=\"field\" v-if=\"ReportType == 'feedback'\">\r\n          <label class=\"label\">Feedback</label>\r\n          <div class=\"control\">\r\n            <textarea class=\"textarea\" v-model=\"feedback\" placeholder=\"Describe your suggestions here.\"></textarea>\r\n          </div>\r\n        </div>\r\n        <div class=\"field\" v-if=\"ReportType == 'bug'\">\r\n          <label class=\"label\">Report Bug</label>\r\n          <div class=\"control\">\r\n            <textarea class=\"textarea\" v-model=\"bugreport\" placeholder=\"Describe the actions you took, your desired outcome and the actual outcome of those actions. We should be able to replicate the bug based off the steps you provide here.\"></textarea>\r\n          </div>\r\n        </div>\r\n        <div class=\"field\">\r\n          <button class=\"button is-primary\" v-on:click=\"submit\" type=\"button\">Submit</button>\r\n        </div>\r\n      </section>\r\n  </div>\r\n</template>\r\n<script>\r\nimport axios from 'axios';\r\n  export default {\r\n    data() {\r\n      return {\r\n        Username: '',\r\n        ReportType: '',\r\n        Registered: false,\r\n        feature: '',\r\n        bugreport: '',\r\n        feedback: ''\r\n      }\r\n    },\r\n    methods: {\r\n      submit() {\r\n        var data = {\r\n          Username: this.Username,\r\n          ReportType: this.ReportType,\r\n          Registered: this.Registered,\r\n          Feature: this.feature,\r\n          BugReport: this.bugreport,\r\n          Feedback: this.feedback\r\n        }\r\n        axios.post('/feedback', data)\r\n        .then(res => {\r\n          console.log(res)\r\n        })\r\n      }\r\n    }\r\n  }\r\n</script>\r\n<style>\r\n  .suggestions-container {\r\n    display: flex;\r\n    justify-content: center;\r\n    margin-top: 3rem;\r\n    color: white;\r\n  }\r\n</style>\r\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_CreateLeague_vue__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_CreateLeague_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_CreateLeague_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_CreateLeague_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_CreateLeague_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2b770d24_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_CreateLeague_vue__ = __webpack_require__(230);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(244)
}
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_CreateLeague_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_2b770d24_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_CreateLeague_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\CreateLeague.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2b770d24", Component.options)
  } else {
    hotAPI.reload("data-v-2b770d24", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_deleteaccount_vue__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_deleteaccount_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_deleteaccount_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_deleteaccount_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_deleteaccount_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_15167f2f_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_deleteaccount_vue__ = __webpack_require__(229);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(243)
}
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_deleteaccount_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_15167f2f_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_deleteaccount_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\deleteaccount.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-15167f2f", Component.options)
  } else {
    hotAPI.reload("data-v-15167f2f", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_joinleague_vue__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_joinleague_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_joinleague_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_joinleague_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_joinleague_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_e3ff9ac8_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_joinleague_vue__ = __webpack_require__(239);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(253)
}
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_joinleague_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_e3ff9ac8_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_joinleague_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\joinleague.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-e3ff9ac8", Component.options)
  } else {
    hotAPI.reload("data-v-e3ff9ac8", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_leaderboard_vue__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_leaderboard_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_leaderboard_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_leaderboard_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_leaderboard_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_71dcbc4a_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_leaderboard_vue__ = __webpack_require__(236);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(250)
}
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_leaderboard_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_71dcbc4a_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_leaderboard_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\leaderboard.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-71dcbc4a", Component.options)
  } else {
    hotAPI.reload("data-v-71dcbc4a", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_login_vue__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_login_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_login_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_login_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_login_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_e9c94c14_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_login_vue__ = __webpack_require__(240);
var disposed = false
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_login_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_e9c94c14_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_login_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\login.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-e9c94c14", Component.options)
  } else {
    hotAPI.reload("data-v-e9c94c14", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myaccount_vue__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myaccount_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myaccount_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myaccount_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myaccount_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3efd9f0e_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_myaccount_vue__ = __webpack_require__(232);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(246)
}
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myaccount_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3efd9f0e_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_myaccount_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\myaccount.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-3efd9f0e", Component.options)
  } else {
    hotAPI.reload("data-v-3efd9f0e", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myteam_vue__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myteam_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myteam_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myteam_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myteam_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1177cb68_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_myteam_vue__ = __webpack_require__(228);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(242)
}
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_myteam_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1177cb68_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_myteam_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\myteam.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-1177cb68", Component.options)
  } else {
    hotAPI.reload("data-v-1177cb68", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navbar_vue__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navbar_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navbar_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navbar_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navbar_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_367940d3_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_navbar_vue__ = __webpack_require__(231);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(245)
}
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navbar_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_367940d3_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_navbar_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\navbar.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-367940d3", Component.options)
  } else {
    hotAPI.reload("data-v-367940d3", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 224 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navbarDropdown_vue__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navbarDropdown_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navbarDropdown_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navbarDropdown_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navbarDropdown_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4d88fd84_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_navbarDropdown_vue__ = __webpack_require__(234);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(248)
}
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_navbarDropdown_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_4d88fd84_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_navbarDropdown_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\navbarDropdown.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4d88fd84", Component.options)
  } else {
    hotAPI.reload("data-v-4d88fd84", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 225 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_template_compiler_index_id_data_v_75ef3c84_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_rules_vue__ = __webpack_require__(237);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(251)
}
var normalizeComponent = __webpack_require__(0)
/* script */
var __vue_script__ = null
/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_template_compiler_index_id_data_v_75ef3c84_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_rules_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\rules.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-75ef3c84", Component.options)
  } else {
    hotAPI.reload("data-v-75ef3c84", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 226 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_stattracker_vue__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_stattracker_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_stattracker_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_stattracker_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_stattracker_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3fc3589e_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_stattracker_vue__ = __webpack_require__(233);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(247)
}
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_stattracker_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_3fc3589e_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_stattracker_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\stattracker.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-3fc3589e", Component.options)
  } else {
    hotAPI.reload("data-v-3fc3589e", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 227 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_suggestions_vue__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_suggestions_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_suggestions_vue__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_suggestions_vue__) if(["default","default"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_suggestions_vue__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_f96c7a88_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_suggestions_vue__ = __webpack_require__(241);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(254)
}
var normalizeComponent = __webpack_require__(0)
/* script */


/* template */

/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_suggestions_vue___default.a,
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_f96c7a88_hasScoped_false_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_suggestions_vue__["a" /* default */],
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "client\\components\\suggestions.vue"

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-f96c7a88", Component.options)
  } else {
    hotAPI.reload("data-v-f96c7a88", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["default"] = (Component.exports);


/***/ }),
/* 228 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _c("div", { staticClass: "page-header-container" }, [
      _c("div", { staticClass: "page-header-block" }, [
        _c("div", { staticClass: "lh-4r" }, [
          _vm._v("Week: "),
          _c("span", { staticClass: "boldest-header right" }, [
            _vm._v(_vm._s(_vm.currentweek))
          ])
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "lh-4r" }, [
          _vm._v("Balance Remaining:"),
          _c("span", { staticClass: "boldest-header right" }, [
            _vm._v(" $" + _vm._s(_vm.dollars))
          ])
        ])
      ])
    ]),
    _vm._v(" "),
    _c(
      "div",
      { staticClass: "container" },
      [
        _c("transition", { attrs: { name: "fade", mode: "out-in" } }, [
          _vm.showSaveMessage
            ? _c("p", { staticClass: "successful-save" }, [
                _vm._v("Your team has been successfully saved!")
              ])
            : _vm._e(),
          _vm._v(" "),
          _vm.showFailMessage
            ? _c("p", { staticClass: "failure-save" }, [
                _vm._v("Oops! Something Went Wrong. Please try again later.")
              ])
            : _vm._e()
        ]),
        _vm._v(" "),
        _c("table", { staticClass: "myteam-table" }, [
          _c("thead", [
            _c("tr", [
              _c("th", [_vm._v("Action")]),
              _vm._v(" "),
              _c("th", { on: { click: _vm.sortByPrice } }, [
                _vm._v("Price\n            "),
                _c("span", { staticClass: "icon" }, [
                  _vm.CostSortByAsc
                    ? _c("i", {
                        staticClass: "fa fa-caret-up",
                        attrs: { "aria-hidden": "true" }
                      })
                    : _c("i", {
                        staticClass: "fa fa-caret-down",
                        attrs: { "aria-hidden": "true" }
                      })
                ])
              ]),
              _vm._v(" "),
              _c("th", [_vm._v("Racer Name")]),
              _vm._v(" "),
              _c("th", [_vm._v("Racer Number")]),
              _vm._v(" "),
              _c("th", [_vm._v("Highest Finish")]),
              _vm._v(" "),
              _c("th", [_vm._v("Lowest Finish")]),
              _vm._v(" "),
              _c("th", [_vm._v("Average Finish")])
            ])
          ]),
          _vm._v(" "),
          _vm._m(0),
          _vm._v(" "),
          _c(
            "tbody",
            [
              _vm._l(_vm.selectedriders, function(racer, index) {
                return _c("tr", [
                  _c("td", [
                    racer.name != "OPEN SLOT"
                      ? _c(
                          "a",
                          {
                            attrs: { href: "#!" },
                            on: {
                              click: function($event) {
                                _vm.removeRacer(racer)
                              }
                            }
                          },
                          [_vm._m(1, true)]
                        )
                      : _vm._e()
                  ]),
                  _vm._v(" "),
                  _c("td", [_vm._v("$" + _vm._s(racer.cost))]),
                  _vm._v(" "),
                  _c("td", [_vm._v(_vm._s(racer.name))]),
                  _vm._v(" "),
                  _c("td", [_vm._v(_vm._s(racer.rider_number))]),
                  _vm._v(" "),
                  _c("td", [_vm._v(_vm._s(racer.highestFinish))]),
                  _vm._v(" "),
                  _c("td", [_vm._v(_vm._s(racer.lowestFinish))]),
                  _vm._v(" "),
                  _c("td", [_vm._v(_vm._s(racer.averageFinish))])
                ])
              }),
              _vm._v(" "),
              _c("tr", { staticClass: "lastRow" }, [
                _c("td", { attrs: { colspan: "5" } }),
                _vm._v(" "),
                _c("td", { attrs: { colspan: "1" } }, [
                  _c(
                    "button",
                    {
                      staticClass: "button is-danger",
                      attrs: { disabled: !_vm.showRemoveAll },
                      on: { click: _vm.RemoveAll }
                    },
                    [_vm._v("Remove All")]
                  )
                ]),
                _vm._v(" "),
                _c("td", { attrs: { colspan: "1" } }, [
                  _c(
                    "button",
                    {
                      staticClass: "button is-success",
                      class: { "is-loading": _vm.isLoading },
                      attrs: { disabled: _vm.hasOpenSlots },
                      on: { click: _vm.SaveTeam }
                    },
                    [_vm._v("Save Team")]
                  )
                ])
              ]),
              _vm._v(" "),
              _vm._l(_vm.paginatedRiders, function(rider) {
                return _c("tr", [
                  _c("td", [
                    _vm.showSelect && rider.cost <= _vm.dollars
                      ? _c(
                          "a",
                          {
                            attrs: { href: "#!" },
                            on: {
                              click: function($event) {
                                _vm.addRacer(rider)
                              }
                            }
                          },
                          [_vm._m(2, true)]
                        )
                      : _vm._e()
                  ]),
                  _vm._v(" "),
                  _c("td", [_vm._v("$" + _vm._s(rider.cost))]),
                  _vm._v(" "),
                  _c("td", [_vm._v(_vm._s(rider.name))]),
                  _vm._v(" "),
                  _c("td", [_vm._v(_vm._s(rider.rider_number))]),
                  _vm._v(" "),
                  _c("td", [_vm._v(_vm._s(rider.highestFinish))]),
                  _vm._v(" "),
                  _c("td", [_vm._v(_vm._s(rider.lowestFinish))]),
                  _vm._v(" "),
                  _c("td", [_vm._v(_vm._s(rider.averageFinish))])
                ])
              })
            ],
            2
          )
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "custom-pagination" }, [
          _c("div", [
            _c(
              "a",
              {
                staticClass: "pagination-previous",
                class: { "hide-pagination-button": _vm.hidePrevious },
                on: {
                  click: function($event) {
                    _vm.page--
                  }
                }
              },
              [_vm._v("Previous")]
            )
          ]),
          _vm._v(" "),
          _c("div", [
            _c("a", { staticClass: "pagination-number" }, [
              _vm._v(_vm._s(_vm.page) + "/" + _vm._s(_vm.paginationPages))
            ])
          ]),
          _vm._v(" "),
          _c("div", [
            _c(
              "a",
              {
                staticClass: "pagination-next",
                class: { "hide-pagination-button": _vm.hideNext },
                on: {
                  click: function($event) {
                    _vm.page++
                  }
                }
              },
              [_vm._v("Next page")]
            )
          ])
        ])
      ],
      1
    )
  ])
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("tfoot", [
      _c("tr", [
        _c("th", [_vm._v("Action")]),
        _vm._v(" "),
        _c("th", [_vm._v("Price")]),
        _vm._v(" "),
        _c("th", [_vm._v("Racer Name")]),
        _vm._v(" "),
        _c("th", [_vm._v("Racer Number")]),
        _vm._v(" "),
        _c("th", [_vm._v("Highest Finish")]),
        _vm._v(" "),
        _c("th", [_vm._v("Lowest Finish")]),
        _vm._v(" "),
        _c("th", [_vm._v("Average Finish")])
      ])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("span", { staticClass: "icon minus-icon" }, [
      _c("i", { staticClass: "fa fa-minus", attrs: { "aria-hidden": "true" } })
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("span", { staticClass: "icon plus-icon" }, [
      _c("i", { staticClass: "fa fa-plus", attrs: { "aria-hidden": "true" } })
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-1177cb68", esExports)
  }
}

/***/ }),
/* 229 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "column is-half is-offset-one-quarter" }, [
      _c("div", { staticClass: "field" }, [
        _c("div", { staticClass: "control" }, [
          _c("label", { staticClass: "radio" }, [
            _vm._v("Are you sure you want to delete your account?\n        "),
            _c("input", { attrs: { type: "radio", name: "question" } }),
            _vm._v("\n        Yes\n      ")
          ]),
          _vm._v(" "),
          _c("label", { staticClass: "radio" }, [
            _c("input", { attrs: { type: "radio", name: "question" } }),
            _vm._v("\n        No\n      ")
          ])
        ])
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "field" }, [
        _c("button", { staticClass: "button" }, [_vm._v("Submit")])
      ])
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-15167f2f", esExports)
  }
}

/***/ }),
/* 230 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _vm.getUserData.accounttype == 2
      ? _c("div", { staticClass: "column is-half is-offset-one-quarter" }, [
          _vm._m(0),
          _vm._v(" "),
          _vm._m(1),
          _vm._v(" "),
          _vm._m(2),
          _vm._v(" "),
          _vm._m(3)
        ])
      : _vm._e(),
    _vm._v(" "),
    _vm.getUserData.accounttype != 2
      ? _c("div", [
          _c("p", { staticClass: "bold-message" }, [
            _vm._v(
              "This feature requires a Premium account. Please upgrade your account in order to activate this feature."
            )
          ])
        ])
      : _vm._e()
  ])
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "field" }, [
      _c("label", [_vm._v("League Name")]),
      _vm._v(" "),
      _c("div", { staticClass: "control has-icons-left" }, [
        _c("input", {
          staticClass: "input",
          attrs: { type: "text", placeholder: "League Name" }
        }),
        _vm._v(" "),
        _c("span", { staticClass: "icon is-small is-left" }, [
          _c("i", { staticClass: "fa fa-trophy" })
        ])
      ])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "field" }, [
      _c("label", [_vm._v("League Password")]),
      _vm._v(" "),
      _c("div", { staticClass: "control has-icons-left" }, [
        _c("input", {
          staticClass: "input",
          attrs: { type: "text", placeholder: "League Password" }
        }),
        _vm._v(" "),
        _c("span", { staticClass: "icon is-small is-left" }, [
          _c("i", { staticClass: "fa fa-lock" })
        ])
      ])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "field" }, [
      _c("label", [_vm._v("Max Players")]),
      _vm._v(" "),
      _c("div", { staticClass: "control has-icons-left" }, [
        _c("input", {
          staticClass: "input",
          attrs: { type: "number", placeholder: "Max Players" }
        }),
        _vm._v(" "),
        _c("span", { staticClass: "icon is-small is-left" }, [
          _c("i", { staticClass: "fa fa-hashtag" })
        ])
      ])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "field" }, [
      _c("button", { staticClass: "button" }, [_vm._v("Submit")])
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-2b770d24", esExports)
  }
}

/***/ }),
/* 231 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "nav",
    { staticClass: "navbar" },
    [
      _vm._m(0),
      _vm._v(" "),
      _vm._m(1),
      _vm._v(" "),
      _c("div", { staticClass: "navbar-menu", attrs: { id: "navMenu" } }, [
        _c("div", { staticClass: "navbar-start" }, [
          _c(
            "div",
            { staticClass: "navbar-item" },
            [
              _c("router-link", { attrs: { to: "/home", exact: "" } }, [
                _vm._v("Home")
              ])
            ],
            1
          ),
          _vm._v(" "),
          _vm.GetAuthStatus
            ? _c(
                "div",
                { staticClass: "navbar-item" },
                [
                  _c("router-link", { attrs: { to: "/myteam" } }, [
                    _vm._v("My Team")
                  ])
                ],
                1
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.GetAuthStatus
            ? _c(
                "div",
                { staticClass: "navbar-item" },
                [
                  _c("router-link", { attrs: { to: "/live" } }, [
                    _vm._v("Stat Tracker")
                  ])
                ],
                1
              )
            : _vm._e(),
          _vm._v(" "),
          _c(
            "div",
            { staticClass: "navbar-item" },
            [_c("router-link", { attrs: { to: "/rules" } }, [_vm._v("Info")])],
            1
          ),
          _vm._v(" "),
          _c(
            "div",
            { staticClass: "navbar-item" },
            [
              _c("router-link", { attrs: { to: "/suggestions" } }, [
                _vm._v("Suggestions")
              ])
            ],
            1
          )
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "navbar-end" }, [
          !_vm.GetAuthStatus
            ? _c(
                "div",
                {
                  staticClass: "navbar-item",
                  on: {
                    click: function($event) {
                      _vm.setRegisterModal({ show: !_vm.ShowRegisterModal })
                    }
                  }
                },
                [_c("a", { attrs: { href: "#!" } }, [_vm._v("Register")])]
              )
            : _vm._e(),
          _vm._v(" "),
          !_vm.GetAuthStatus
            ? _c(
                "div",
                {
                  staticClass: "navbar-item",
                  on: {
                    click: function($event) {
                      _vm.setLoginModal({ show: !_vm.ShowLoginModal })
                    }
                  }
                },
                [
                  _vm._m(2),
                  _vm._v(" "),
                  _c("a", { attrs: { href: "#!" } }, [_vm._v("Login")])
                ]
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.GetAuthStatus
            ? _c(
                "div",
                { staticClass: "navbar-item" },
                [
                  _c("router-link", { attrs: { to: "/myaccount" } }, [
                    _vm._v("Welcome, " + _vm._s(_vm.getUserData.username) + "!")
                  ])
                ],
                1
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.GetAuthStatus
            ? _c(
                "div",
                {
                  staticClass: "navbar-item",
                  on: {
                    click: function($event) {
                      _vm.setLoggedIn({ isLoggedIn: !_vm.GetAuthStatus })
                    }
                  }
                },
                [
                  _vm.GetAuthStatus
                    ? _c("span", { staticClass: "icon" }, [
                        _c("i", {
                          staticClass: "fa fa-sign-out",
                          attrs: { "aria-hidden": "true" }
                        })
                      ])
                    : _vm._e(),
                  _vm._v(" "),
                  _c(
                    "a",
                    { attrs: { href: "#!" }, on: { click: _vm.logout } },
                    [_vm._v("Logout")]
                  )
                ]
              )
            : _vm._e()
        ])
      ]),
      _vm._v(" "),
      _c("register", { attrs: { show: _vm.ShowRegisterModal } }),
      _vm._v(" "),
      _c("login", { attrs: { show: _vm.ShowLoginModal } })
    ],
    1
  )
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "navbar-brand" }, [
      _c("div", { staticClass: "navbar-item" })
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
      "div",
      {
        staticClass: "navbar-burger burger",
        attrs: { "data-target": "navMenu" }
      },
      [_c("span"), _vm._v(" "), _c("span"), _vm._v(" "), _c("span")]
    )
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("span", { staticClass: "icon" }, [
      _c("i", { staticClass: "fa fa-sign-in" })
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-367940d3", esExports)
  }
}

/***/ }),
/* 232 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "container myaccount-container" },
    [
      _c("ul", { staticClass: "ul" }, [
        _c(
          "li",
          [
            _c("router-link", { attrs: { to: "/myaccount/createleague" } }, [
              _vm._v("Create League")
            ])
          ],
          1
        ),
        _vm._v(" "),
        _c(
          "li",
          [
            _c("router-link", { attrs: { to: "/myaccount/joinleague" } }, [
              _vm._v("Join League")
            ])
          ],
          1
        ),
        _vm._v(" "),
        _c(
          "li",
          [
            _c("router-link", { attrs: { to: "/myaccount/deleteaccount" } }, [
              _vm._v("Delete Account")
            ])
          ],
          1
        ),
        _vm._v(" "),
        _c(
          "li",
          [
            _c("router-link", { attrs: { to: "/myaccount/upgradeaccount" } }, [
              _vm._v("Upgrade Account")
            ])
          ],
          1
        )
      ]),
      _vm._v(" "),
      _c("router-view")
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-3efd9f0e", esExports)
  }
}

/***/ }),
/* 233 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    !_vm.isLoading
      ? _c("div", { staticClass: "flex-center fl live-header" }, [
          _c("div", { staticClass: "live-header-box" }, [
            _c("div", [
              _vm._v("Session Event: "),
              _c("span", { staticClass: "text-highlight fl-right" }, [
                _vm._v(_vm._s(_vm.raceData.raceData.S))
              ])
            ]),
            _vm._v(" "),
            _c("div", [
              _vm._v("Season Event:"),
              _c("span", { staticClass: "text-highlight fl-right" }, [
                _vm._v(" " + _vm._s(_vm.raceData.raceData.E))
              ])
            ]),
            _vm._v(" "),
            _c("div", [
              _vm._v("Session Status:"),
              _c("span", { staticClass: "text-highlight fl-right" }, [
                _vm._v(" " + _vm._s(_vm.raceData.raceDetails.B))
              ])
            ])
          ])
        ])
      : _vm._e(),
    _vm._v(" "),
    _c("div", { staticClass: "columns leaderboard" }, [
      _c("div", { staticClass: "column is-half is-offset-one-quarter" }, [
        !_vm.isLoading
          ? _c("table", { staticClass: "table-live" }, [
              _vm._m(0),
              _vm._v(" "),
              _vm._m(1),
              _vm._v(" "),
              _c(
                "tbody",
                _vm._l(_vm.standings, function(user, index) {
                  return _c(
                    "tr",
                    {
                      class: [
                        user.username == _vm.getUserData.username ? "myRow" : ""
                      ]
                    },
                    [
                      _c("td", [_vm._v(_vm._s(index + 1) + ".")]),
                      _vm._v(" "),
                      _c("td", [_vm._v(_vm._s(user.total))]),
                      _vm._v(" "),
                      _c("td", [_vm._v(_vm._s(user.username))]),
                      _vm._v(" "),
                      _c("td", { staticClass: "pointsback" }, [
                        _vm._v(_vm._s(_vm.pointsbehind(user)))
                      ])
                    ]
                  )
                })
              )
            ])
          : _vm._e()
      ])
    ])
  ])
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("thead", [
      _c("tr", [
        _c("th", [_vm._v("Position")]),
        _vm._v(" "),
        _c("th", [_vm._v("Total Points")]),
        _vm._v(" "),
        _c("th", [_vm._v("Username")]),
        _vm._v(" "),
        _c("th", [_vm._v("Points Back")])
      ])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("tfoot", [
      _c("tr", [
        _c("th", [_vm._v("Position")]),
        _vm._v(" "),
        _c("th", [_vm._v("Total Points")]),
        _vm._v(" "),
        _c("th", [_vm._v("Username")]),
        _vm._v(" "),
        _c("th", [_vm._v("Points Back")])
      ])
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-3fc3589e", esExports)
  }
}

/***/ }),
/* 234 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "dropdown",
      class: { "is-active": _vm.isActive },
      on: {
        click: function($event) {
          _vm.isActive = !_vm.isActive
        }
      }
    },
    [
      _c("div", { staticClass: "dropdown-trigger" }, [
        _c(
          "h3",
          {
            attrs: { "aria-haspopup": "true", "aria-controls": "dropdown-menu" }
          },
          [
            _c("span", [
              _vm._v("Currently Managing: " + _vm._s(_vm.ManagedLeague.name))
            ]),
            _vm._v(" "),
            _vm._m(0)
          ]
        )
      ]),
      _vm._v(" "),
      _c(
        "div",
        {
          staticClass: "dropdown-menu",
          attrs: { id: "dropdown-menu", role: "menu" }
        },
        _vm._l(_vm.LeagueList, function(league) {
          return _c("div", { staticClass: "dropdown-content" }, [
            _c(
              "a",
              {
                staticClass: "dropdown-item",
                attrs: { href: "#" },
                on: {
                  click: function($event) {
                    _vm.changeLeague(league)
                  }
                }
              },
              [_vm._v("\n        " + _vm._s(league.name) + "\n      ")]
            )
          ])
        })
      )
    ]
  )
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("span", { staticClass: "icon is-small" }, [
      _c("i", {
        staticClass: "fa fa-angle-down",
        attrs: { "aria-hidden": "true" }
      })
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-4d88fd84", esExports)
  }
}

/***/ }),
/* 235 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { attrs: { id: "app" } },
    [_c("navigation"), _vm._v(" "), _c("router-view")],
    1
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-6de5ab34", esExports)
  }
}

/***/ }),
/* 236 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _c("div", { staticClass: "columns leaderboard" }, [
      _c("div", { staticClass: "column is-half is-offset-one-quarter" }, [
        _vm.doneLoading
          ? _c("table", { staticClass: "leaderboard-table" }, [
              _vm._m(0),
              _vm._v(" "),
              _vm._m(1),
              _vm._v(" "),
              _c(
                "tbody",
                _vm._l(_vm.standings, function(user, index) {
                  return _c("tr", { class: { Me: _vm.IsMe(user) } }, [
                    _c("td", [_vm._v(_vm._s(index + 1) + ".")]),
                    _vm._v(" "),
                    _c("td", [_vm._v(_vm._s(user.totalpoints))]),
                    _vm._v(" "),
                    _c("td", [_vm._v(_vm._s(user.weeklyteams[0].username))]),
                    _vm._v(" "),
                    _c("td", { class: { pointsback: index > 0 } }, [
                      _vm._v(_vm._s(_vm.pointsbehind(user)))
                    ])
                  ])
                })
              )
            ])
          : _vm._e(),
        _vm._v(" "),
        !_vm.doneLoading
          ? _c("div", [
              _c("p", [
                _vm._v(
                  '"This data doesn\'t fetch itself.. Loading Race Tracker."'
                )
              ])
            ])
          : _vm._e()
      ])
    ])
  ])
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("thead", [
      _c("tr", { staticClass: "title" }, [
        _c("th", { attrs: { colspan: "4" } }, [
          _vm._v("2018 Fantasy SX: Main League Standings")
        ])
      ]),
      _vm._v(" "),
      _c("tr", [
        _c("th", [_vm._v("Position")]),
        _vm._v(" "),
        _c("th", [_vm._v("Total Points")]),
        _vm._v(" "),
        _c("th", [_vm._v("Username")]),
        _vm._v(" "),
        _c("th", [_vm._v("Points Back")])
      ])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("tfoot", [
      _c("tr", [
        _c("th", [_vm._v("Position")]),
        _vm._v(" "),
        _c("th", [_vm._v("Total Points")]),
        _vm._v(" "),
        _c("th", [_vm._v("Username")]),
        _vm._v(" "),
        _c("th", [_vm._v("Points Back")])
      ])
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-71dcbc4a", esExports)
  }
}

/***/ }),
/* 237 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _vm._m(0)
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "container" }, [
      _c("div", {}, [
        _c("p", [_vm._v("Rules")]),
        _vm._v(" "),
        _c("div", { staticClass: "tab" }, [
          _c("input", {
            attrs: { id: "tab-one", type: "checkbox", name: "tabs" }
          }),
          _vm._v(" "),
          _c("label", { attrs: { for: "tab-one" } }, [
            _vm._v("How does scoring work?")
          ]),
          _vm._v(" "),
          _c("div", { staticClass: "tab-content" }, [
            _c("p", [
              _vm._v(
                "Right now, scoring is set by racer finish. If a selected racer for that week finishes in first, that racer is awarded 1 point. If a racer finishes in fourth, that racer is awarded 4 points. The lower the point total the better score."
              )
            ])
          ])
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "tab" }, [
          _c("input", {
            attrs: { id: "tab-two", type: "checkbox", name: "tabs" }
          }),
          _vm._v(" "),
          _c("label", { attrs: { for: "tab-two" } }, [
            _vm._v("How does team selection work?")
          ]),
          _vm._v(" "),
          _c("div", { staticClass: "tab-content" }, [
            _c("p", [
              _vm._v(
                "As of now, each user is REQUIRED to select 4 racers for each week. The deadline for making racer selection is 3am Mountain Time on the day of the scheduled race. After that time\n          users will no longer be able to select racers for that week's race; the team selection for the next week will be available for selection"
              )
            ]),
            _vm._v(" "),
            _c("p", [
              _vm._v(
                "Users may only SAVE a roster if ALL 4 roster slots have a racer chosen. The SAVE button is disabled if an OPEN SLOT still exists for a weekly lineup."
              )
            ]),
            _vm._v(" "),
            _c("p", [
              _vm._v(
                "Each user begins each week with $10,000 salary cap to spend on filling out their weekly lineup, and that cap room is used to select racers for their week's lineup from the available racers pool.\n          The selected racer's cost, once selected, will be deducted from the current week's available salary cap. You are NOT REQUIRED to utilize your entire cap space each week."
              )
            ])
          ])
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "tab" }, [
          _c("input", {
            attrs: { id: "tab-three", type: "checkbox", name: "tabs" }
          }),
          _vm._v(" "),
          _c("label", { attrs: { for: "tab-three" } }, [
            _vm._v("Custom Leagues")
          ]),
          _vm._v(" "),
          _c("div", { staticClass: "tab-content" }, [
            _c("p", [
              _vm._v(
                "Currently, the application does not support custom / private leagues; We are looking into how best to incorporate this feature with the UI. If you have suggestions please let us know\n        by dropping a suggestion."
              )
            ])
          ])
        ])
      ])
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-75ef3c84", esExports)
  }
}

/***/ }),
/* 238 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "modal",
      class: { "is-active": _vm.ShowRegisterModal },
      attrs: { id: "registerModal" }
    },
    [
      _c("div", { staticClass: "modal-background" }),
      _vm._v(" "),
      _c("div", { staticClass: "modal-card" }, [
        _c("header", { staticClass: "modal-card-head" }, [
          _c("p", { staticClass: "modal-card-title" }, [
            _vm._v("New User Registration")
          ]),
          _vm._v(" "),
          _c("button", {
            staticClass: "delete",
            on: {
              click: function($event) {
                _vm.setRegisterModal({ show: !_vm.ShowRegisterModal })
              }
            }
          })
        ]),
        _vm._v(" "),
        _c("section", { staticClass: "modal-card-body" }, [
          _c(
            "div",
            { staticClass: "content" },
            [
              _c("div", { staticClass: "field" }, [
                _c("label", { staticClass: "label" }, [_vm._v("Username: ")]),
                _vm._v(" "),
                _c("div", { staticClass: "control has-icons-left" }, [
                  _c("input", {
                    directives: [
                      {
                        name: "model",
                        rawName: "v-model",
                        value: _vm.username,
                        expression: "username"
                      }
                    ],
                    staticClass: "input",
                    class: { "is-danger": _vm.invalidUsername },
                    attrs: {
                      type: "text",
                      id: "reg-username",
                      placeholder: "Username",
                      required: ""
                    },
                    domProps: { value: _vm.username },
                    on: {
                      input: function($event) {
                        if ($event.target.composing) {
                          return
                        }
                        _vm.username = $event.target.value
                      }
                    }
                  }),
                  _vm._v(" "),
                  _vm._m(0)
                ])
              ]),
              _vm._v(" "),
              _c("div", { staticClass: "field" }, [
                _c("label", { staticClass: "label" }, [_vm._v("Email: ")]),
                _vm._v(" "),
                _c("div", { staticClass: "control has-icons-left" }, [
                  _c("input", {
                    directives: [
                      {
                        name: "model",
                        rawName: "v-model",
                        value: _vm.email,
                        expression: "email"
                      }
                    ],
                    staticClass: "input",
                    class: { "is-danger": _vm.invalidEmail },
                    attrs: {
                      type: "email",
                      id: "reg-email",
                      placeholder: "Email",
                      required: ""
                    },
                    domProps: { value: _vm.email },
                    on: {
                      input: function($event) {
                        if ($event.target.composing) {
                          return
                        }
                        _vm.email = $event.target.value
                      }
                    }
                  }),
                  _vm._v(" "),
                  _vm._m(1)
                ])
              ]),
              _vm._v(" "),
              _c("div", { staticClass: "field" }, [
                _c("label", { staticClass: "label" }, [_vm._v("Password: ")]),
                _vm._v(" "),
                _c("div", { staticClass: "control has-icons-left" }, [
                  _c("input", {
                    directives: [
                      {
                        name: "model",
                        rawName: "v-model",
                        value: _vm.password,
                        expression: "password"
                      }
                    ],
                    staticClass: "input",
                    class: { "is-danger": _vm.blankPassword },
                    attrs: {
                      type: "password",
                      placeholder: "Password",
                      required: ""
                    },
                    domProps: { value: _vm.password },
                    on: {
                      input: function($event) {
                        if ($event.target.composing) {
                          return
                        }
                        _vm.password = $event.target.value
                      }
                    }
                  }),
                  _vm._v(" "),
                  _vm._m(2)
                ])
              ]),
              _vm._v(" "),
              _vm._m(3),
              _vm._v(" "),
              _vm._l(_vm.errorMessage, function(error) {
                return _vm.errorMessage != ""
                  ? _c("div", { staticClass: "errorMessage" }, [
                      _vm._v("\n            " + _vm._s(error) + "\n          ")
                    ])
                  : _vm._e()
              })
            ],
            2
          )
        ]),
        _vm._v(" "),
        _c("footer", { staticClass: "modal-card-foot" }, [
          _c(
            "button",
            {
              staticClass: "button is-success",
              class: { "is-loading": _vm.isLoading },
              on: { click: _vm.Register }
            },
            [_vm._v("Register")]
          ),
          _vm._v(" "),
          _c(
            "button",
            {
              staticClass: "button",
              on: {
                click: function($event) {
                  _vm.setRegisterModal({ show: !_vm.ShowRegisterModal })
                }
              }
            },
            [_vm._v("Cancel")]
          )
        ])
      ])
    ]
  )
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("span", { staticClass: "icon is-small is-left" }, [
      _c("i", { staticClass: "fa fa-user" })
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("span", { staticClass: "icon is-small is-left" }, [
      _c("i", { staticClass: "fa fa-envelope" })
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("span", { staticClass: "icon is-small is-left" }, [
      _c("i", { staticClass: "fa fa-lock" })
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "field" }, [
      _c("div", { attrs: { id: "register-recaptcha" } })
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-7b8a19b4", esExports)
  }
}

/***/ }),
/* 239 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _vm.getUserData.accounttype > 0
      ? _c("div", { staticClass: "column is-half is-offset-one-quarter" }, [
          _vm._m(0),
          _vm._v(" "),
          _vm._m(1),
          _vm._v(" "),
          _vm._m(2)
        ])
      : _vm._e(),
    _vm._v(" "),
    _vm.getUserData.accounttype == 0
      ? _c("div", [
          _c("p", { staticClass: "bold-message" }, [
            _vm._v(
              "This feature requires at least a Basic account. Please upgrade your account in order to activate this feature."
            )
          ])
        ])
      : _vm._e()
  ])
}
var staticRenderFns = [
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "field" }, [
      _c("label", [_vm._v("League Name")]),
      _vm._v(" "),
      _c("div", { staticClass: "control has-icons-left" }, [
        _c("input", {
          staticClass: "input",
          attrs: { type: "text", placeholder: "League ID" }
        }),
        _vm._v(" "),
        _c("span", { staticClass: "icon is-small is-left" }, [
          _c("i", { staticClass: "fa fa-trophy" })
        ])
      ])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "field" }, [
      _c("label", [_vm._v("League Password")]),
      _vm._v(" "),
      _c("div", { staticClass: "control has-icons-left" }, [
        _c("input", {
          staticClass: "input",
          attrs: { type: "text", placeholder: "League Password" }
        }),
        _vm._v(" "),
        _c("span", { staticClass: "icon is-small is-left" }, [
          _c("i", { staticClass: "fa fa-lock" })
        ])
      ])
    ])
  },
  function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c("div", { staticClass: "field" }, [
      _c("button", { staticClass: "button" }, [_vm._v("Submit")])
    ])
  }
]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-e3ff9ac8", esExports)
  }
}

/***/ }),
/* 240 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "modal",
      class: { "is-active": _vm.show },
      attrs: { id: "loginModal" }
    },
    [
      _c("div", { staticClass: "modal-background" }),
      _vm._v(" "),
      _c("div", { staticClass: "modal-card" }, [
        _c("header", { staticClass: "modal-card-head" }, [
          _c("p", { staticClass: "modal-card-title" }, [_vm._v("User Login")]),
          _vm._v(" "),
          _c("button", {
            staticClass: "delete",
            on: {
              click: function($event) {
                _vm.setLoginModal({ show: !_vm.ShowLoginModal })
              }
            }
          })
        ]),
        _vm._v(" "),
        _c("section", { staticClass: "modal-card-body" }, [
          _c("div", { staticClass: "content" }, [
            _c("div", { staticClass: "field" }, [
              _c(
                "label",
                { staticClass: "label", attrs: { for: "reg-username" } },
                [_vm._v("Username: ")]
              ),
              _vm._v(" "),
              _c("div", { staticClass: "control" }, [
                _c("input", {
                  directives: [
                    {
                      name: "model",
                      rawName: "v-model",
                      value: _vm.username,
                      expression: "username"
                    }
                  ],
                  staticClass: "input",
                  attrs: { type: "text" },
                  domProps: { value: _vm.username },
                  on: {
                    input: function($event) {
                      if ($event.target.composing) {
                        return
                      }
                      _vm.username = $event.target.value
                    }
                  }
                })
              ])
            ]),
            _vm._v(" "),
            _c("div", { staticClass: "field" }, [
              _c(
                "label",
                { staticClass: "label", attrs: { for: "reg-password" } },
                [_vm._v("Password: ")]
              ),
              _vm._v(" "),
              _c("div", { staticClass: "control" }, [
                _c("input", {
                  directives: [
                    {
                      name: "model",
                      rawName: "v-model",
                      value: _vm.password,
                      expression: "password"
                    }
                  ],
                  staticClass: "input",
                  attrs: { type: "password", id: "reg-password" },
                  domProps: { value: _vm.password },
                  on: {
                    input: function($event) {
                      if ($event.target.composing) {
                        return
                      }
                      _vm.password = $event.target.value
                    }
                  }
                })
              ])
            ])
          ]),
          _vm._v(" "),
          _c("div", { attrs: { id: "login-recaptcha" } }),
          _vm._v(" "),
          _vm.errorMessage != ""
            ? _c("div", { staticClass: "errorMessage" }, [
                _vm._v("\n          " + _vm._s(_vm.errorMessage) + "\n        ")
              ])
            : _vm._e()
        ]),
        _vm._v(" "),
        _c("footer", { staticClass: "modal-card-foot" }, [
          _c("div", { staticClass: "field" }, [
            _c(
              "button",
              {
                staticClass: "button is-primary",
                class: { "is-loading": _vm.isLoading },
                attrs: { type: "button", value: "Login", id: "submit-login" },
                on: { click: _vm.submit }
              },
              [_vm._v("Login")]
            ),
            _vm._v(" "),
            _c(
              "a",
              {
                staticClass: "button",
                on: {
                  click: function($event) {
                    _vm.setLoginModal({ show: !_vm.ShowLoginModal })
                  }
                }
              },
              [_vm._v("Cancel")]
            )
          ])
        ])
      ])
    ]
  )
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-e9c94c14", esExports)
  }
}

/***/ }),
/* 241 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "container suggestions-container" }, [
    _c("section", [
      _c("div", { staticClass: "field" }, [
        _c("div", { staticClass: "control" }, [
          _c("label", [_vm._v("Are you a registered user?")]),
          _vm._v(" "),
          _c("label", { staticClass: "radio" }, [
            _c("input", {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.Registered,
                  expression: "Registered"
                }
              ],
              attrs: { type: "radio", name: "Registered", value: "true" },
              domProps: { checked: _vm._q(_vm.Registered, "true") },
              on: {
                change: function($event) {
                  _vm.Registered = "true"
                }
              }
            }),
            _vm._v("\n            Yes\n          ")
          ]),
          _vm._v(" "),
          _c("label", { staticClass: "radio" }, [
            _c("input", {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.Registered,
                  expression: "Registered"
                }
              ],
              attrs: { type: "radio", name: "Registered", value: "false" },
              domProps: { checked: _vm._q(_vm.Registered, "false") },
              on: {
                change: function($event) {
                  _vm.Registered = "false"
                }
              }
            }),
            _vm._v("\n            No\n          ")
          ])
        ])
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "field" }, [
        _c("div", { staticClass: "control" }, [
          _c("label", [_vm._v("Is this feedback or a bug report?")]),
          _vm._v(" "),
          _c("label", { staticClass: "radio" }, [
            _c("input", {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.ReportType,
                  expression: "ReportType"
                }
              ],
              attrs: { type: "radio", name: "feedback", value: "feedback" },
              domProps: { checked: _vm._q(_vm.ReportType, "feedback") },
              on: {
                change: function($event) {
                  _vm.ReportType = "feedback"
                }
              }
            }),
            _vm._v("\n            Feedback\n          ")
          ]),
          _vm._v(" "),
          _c("label", { staticClass: "radio" }, [
            _c("input", {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.ReportType,
                  expression: "ReportType"
                }
              ],
              attrs: { type: "radio", name: "feedback", value: "bug" },
              domProps: { checked: _vm._q(_vm.ReportType, "bug") },
              on: {
                change: function($event) {
                  _vm.ReportType = "bug"
                }
              }
            }),
            _vm._v("\n            Bug Report\n          ")
          ])
        ])
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "field" }, [
        _c("label", { staticClass: "label" }, [_vm._v("Username")]),
        _vm._v(" "),
        _c("div", { staticClass: "control" }, [
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.Username,
                expression: "Username"
              }
            ],
            staticClass: "input",
            attrs: { type: "text", placeholder: "Username" },
            domProps: { value: _vm.Username },
            on: {
              input: function($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.Username = $event.target.value
              }
            }
          })
        ])
      ]),
      _vm._v(" "),
      _vm.ReportType == "feedback"
        ? _c("div", { staticClass: "field" }, [
            _c("label", { staticClass: "label" }, [_vm._v("Suggest Features")]),
            _vm._v(" "),
            _c("div", { staticClass: "control" }, [
              _c("div", { staticClass: "select" }, [
                _c(
                  "select",
                  {
                    directives: [
                      {
                        name: "model",
                        rawName: "v-model",
                        value: _vm.feature,
                        expression: "feature"
                      }
                    ],
                    on: {
                      change: function($event) {
                        var $$selectedVal = Array.prototype.filter
                          .call($event.target.options, function(o) {
                            return o.selected
                          })
                          .map(function(o) {
                            var val = "_value" in o ? o._value : o.value
                            return val
                          })
                        _vm.feature = $event.target.multiple
                          ? $$selectedVal
                          : $$selectedVal[0]
                      }
                    }
                  },
                  [
                    _c("option", { attrs: { disabled: "", value: "" } }, [
                      _vm._v("SELECT CATEGORY")
                    ]),
                    _vm._v(" "),
                    _c("option", [_vm._v("User Interface")]),
                    _vm._v(" "),
                    _c("option", [_vm._v("Navigation Content")]),
                    _vm._v(" "),
                    _c("option", [_vm._v("My Team")]),
                    _vm._v(" "),
                    _c("option", [_vm._v("Scoring")]),
                    _vm._v(" "),
                    _c("option", [_vm._v("New Features")]),
                    _vm._v(" "),
                    _c("option", [_vm._v("Stat Tracker")]),
                    _vm._v(" "),
                    _c("option", [_vm._v("Account")])
                  ]
                )
              ])
            ])
          ])
        : _vm._e(),
      _vm._v(" "),
      _vm.ReportType == "feedback"
        ? _c("div", { staticClass: "field" }, [
            _c("label", { staticClass: "label" }, [_vm._v("Feedback")]),
            _vm._v(" "),
            _c("div", { staticClass: "control" }, [
              _c("textarea", {
                directives: [
                  {
                    name: "model",
                    rawName: "v-model",
                    value: _vm.feedback,
                    expression: "feedback"
                  }
                ],
                staticClass: "textarea",
                attrs: { placeholder: "Describe your suggestions here." },
                domProps: { value: _vm.feedback },
                on: {
                  input: function($event) {
                    if ($event.target.composing) {
                      return
                    }
                    _vm.feedback = $event.target.value
                  }
                }
              })
            ])
          ])
        : _vm._e(),
      _vm._v(" "),
      _vm.ReportType == "bug"
        ? _c("div", { staticClass: "field" }, [
            _c("label", { staticClass: "label" }, [_vm._v("Report Bug")]),
            _vm._v(" "),
            _c("div", { staticClass: "control" }, [
              _c("textarea", {
                directives: [
                  {
                    name: "model",
                    rawName: "v-model",
                    value: _vm.bugreport,
                    expression: "bugreport"
                  }
                ],
                staticClass: "textarea",
                attrs: {
                  placeholder:
                    "Describe the actions you took, your desired outcome and the actual outcome of those actions. We should be able to replicate the bug based off the steps you provide here."
                },
                domProps: { value: _vm.bugreport },
                on: {
                  input: function($event) {
                    if ($event.target.composing) {
                      return
                    }
                    _vm.bugreport = $event.target.value
                  }
                }
              })
            ])
          ])
        : _vm._e(),
      _vm._v(" "),
      _c("div", { staticClass: "field" }, [
        _c(
          "button",
          {
            staticClass: "button is-primary",
            attrs: { type: "button" },
            on: { click: _vm.submit }
          },
          [_vm._v("Submit")]
        )
      ])
    ])
  ])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-f96c7a88", esExports)
  }
}

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(203);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("1647569a", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-1177cb68\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./myteam.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-1177cb68\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./myteam.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(204);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("a3239cea", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-15167f2f\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./deleteaccount.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-15167f2f\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./deleteaccount.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(205);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("3d74f1f6", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-2b770d24\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./CreateLeague.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-2b770d24\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./CreateLeague.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(206);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("43a83c3b", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-367940d3\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./navbar.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-367940d3\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./navbar.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(207);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("a513ac74", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3efd9f0e\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./myaccount.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3efd9f0e\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./myaccount.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(208);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("87fcc73a", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3fc3589e\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./stattracker.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-3fc3589e\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./stattracker.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(209);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("2bfe3a44", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-4d88fd84\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./navbarDropdown.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-4d88fd84\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./navbarDropdown.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(210);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("1bec54c8", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-6de5ab34\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./index.vue", function() {
     var newContent = require("!!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-6de5ab34\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./index.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(211);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("75485575", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-71dcbc4a\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./leaderboard.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-71dcbc4a\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./leaderboard.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(212);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("77e235b7", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-75ef3c84\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./rules.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-75ef3c84\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./rules.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(213);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("779ea5b4", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-7b8a19b4\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./register.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-7b8a19b4\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./register.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(214);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("d4990da6", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-e3ff9ac8\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./joinleague.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-e3ff9ac8\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./joinleague.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(215);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(2)("168dcb20", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-f96c7a88\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./suggestions.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-f96c7a88\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./suggestions.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjM5MjIyMzY4YTdiYzVmNmVmYzEiLCJ3ZWJwYWNrOi8vLy4vfi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi92dWV4L2Rpc3QvdnVleC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3RvS2V5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jYXN0UGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gva2V5cy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FycmF5TWFwLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vY2xpZW50L2NvbXBvbmVudHMvQ3JlYXRlTGVhZ3VlLnZ1ZSIsIndlYnBhY2s6Ly8vY2xpZW50L2NvbXBvbmVudHMvZGVsZXRlYWNjb3VudC52dWUiLCJ3ZWJwYWNrOi8vL2NsaWVudC9jb21wb25lbnRzL2pvaW5sZWFndWUudnVlIiwid2VicGFjazovLy9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWUiLCJ3ZWJwYWNrOi8vL2NsaWVudC9jb21wb25lbnRzL2xvZ2luLnZ1ZSIsIndlYnBhY2s6Ly8vY2xpZW50L2NvbXBvbmVudHMvbXlhY2NvdW50LnZ1ZSIsIndlYnBhY2s6Ly8vY2xpZW50L2NvbXBvbmVudHMvbXl0ZWFtLnZ1ZSIsIndlYnBhY2s6Ly8vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZSIsIndlYnBhY2s6Ly8vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyRHJvcGRvd24udnVlIiwid2VicGFjazovLy9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWUiLCJ3ZWJwYWNrOi8vL2NsaWVudC9jb21wb25lbnRzL3N0YXR0cmFja2VyLnZ1ZSIsIndlYnBhY2s6Ly8vY2xpZW50L2NvbXBvbmVudHMvc3VnZ2VzdGlvbnMudnVlIiwid2VicGFjazovLy9pbmRleC52dWUiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWUiLCJ3ZWJwYWNrOi8vLy4vcm91dGVyLmpzIiwid2VicGFjazovLy8uL3N0b3JlL3N0b3JlLmpzIiwid2VicGFjazovLy8uL2luZGV4LnZ1ZSIsIndlYnBhY2s6Ly8vLi9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9pcy1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX0RhdGFWaWV3LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19IYXNoLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19Qcm9taXNlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19TZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX1NldENhY2hlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19VaW50OEFycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19XZWFrTWFwLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcHBseS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYXJyYXlGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FycmF5U29tZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUVhY2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlRm9yLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlRm9yT3duLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUhhc0luLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUlzTWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlT3JkZXJCeS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlUHVsbEF0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlU2xpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VTb3J0QnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlVW5zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jb21wYXJlQXNjZW5kaW5nLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jb21wYXJlTXVsdGlwbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jcmVhdGVCYXNlRm9yLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZXF1YWxPYmplY3RzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXRNYXRjaERhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0VGFnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaENsZWFyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoSGFzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNLZXlhYmxlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXBUb0FycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19ub2RlVXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX292ZXJSZXN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19wYXJlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zZXRDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc2V0VG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zdGFja1NldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2NvbnN0YW50LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2ZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9nZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaGFzSW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvbGFzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3Byb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9zb3J0QnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvc3R1YkFycmF5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC90b0Zpbml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC90b0ludGVnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvdG9OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS1yb3V0ZXIvZGlzdC92dWUtcm91dGVyLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2xpc3RUb1N0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9teXRlYW0udnVlP2M2ODAiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvZGVsZXRlYWNjb3VudC52dWU/M2YyNiIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9DcmVhdGVMZWFndWUudnVlPzBiMjQiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZT82YzJlIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL215YWNjb3VudC52dWU/YTRkMyIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9zdGF0dHJhY2tlci52dWU/MDIyOCIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXJEcm9wZG93bi52dWU/NzI2ZCIsIndlYnBhY2s6Ly8vLi9pbmRleC52dWU/OTEzNSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWU/YWYwOCIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9ydWxlcy52dWU/OWNhNCIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWU/ZWY1NyIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9qb2lubGVhZ3VlLnZ1ZT9iMDI2Iiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL3N1Z2dlc3Rpb25zLnZ1ZT9jZWRlIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL0NyZWF0ZUxlYWd1ZS52dWUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvZGVsZXRlYWNjb3VudC52dWUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvam9pbmxlYWd1ZS52dWUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbGVhZGVyYm9hcmQudnVlIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL2xvZ2luLnZ1ZSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9teWFjY291bnQudnVlIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL215dGVhbS52dWUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXJEcm9wZG93bi52dWUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvcnVsZXMudnVlIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL3N0YXR0cmFja2VyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9zdWdnZXN0aW9ucy52dWUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbXl0ZWFtLnZ1ZT8xN2I3Iiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL2RlbGV0ZWFjY291bnQudnVlPzViY2UiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvQ3JlYXRlTGVhZ3VlLnZ1ZT81NmYzIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL25hdmJhci52dWU/Yzg0YyIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9teWFjY291bnQudnVlPzQ4NDciLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvc3RhdHRyYWNrZXIudnVlPzg3OTUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyRHJvcGRvd24udnVlPzc1NDgiLCJ3ZWJwYWNrOi8vLy4vaW5kZXgudnVlPzc1MzgiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbGVhZGVyYm9hcmQudnVlPzk1MjkiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvcnVsZXMudnVlPzJjYTciLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlP2JjNmMiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvam9pbmxlYWd1ZS52dWU/MWQ5NCIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9sb2dpbi52dWU/Yzc0NyIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9zdWdnZXN0aW9ucy52dWU/NjM0ZSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9teXRlYW0udnVlPzkyZjkiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvZGVsZXRlYWNjb3VudC52dWU/ZTg4ZSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9DcmVhdGVMZWFndWUudnVlP2ZkYTMiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZT8xMTQ5Iiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL215YWNjb3VudC52dWU/NmNhOCIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9zdGF0dHJhY2tlci52dWU/MDdiYSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXJEcm9wZG93bi52dWU/OTBlYSIsIndlYnBhY2s6Ly8vLi9pbmRleC52dWU/ODk4NiIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWU/NDMyMSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9ydWxlcy52dWU/NGM4ZSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWU/YjgzYyIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9qb2lubGVhZ3VlLnZ1ZT8zZDBiIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL3N1Z2dlc3Rpb25zLnZ1ZT9lYWJjIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJ1c2VTb3VyY2VNYXAiLCJsaXN0IiwidG9TdHJpbmciLCJtYXAiLCJpdGVtIiwiY29udGVudCIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJqb2luIiwiaSIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImxlbmd0aCIsImlkIiwicHVzaCIsImNzc01hcHBpbmciLCJidG9hIiwic291cmNlTWFwcGluZyIsInRvQ29tbWVudCIsInNvdXJjZVVSTHMiLCJzb3VyY2VzIiwic291cmNlIiwic291cmNlUm9vdCIsImNvbmNhdCIsInNvdXJjZU1hcCIsImJhc2U2NCIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsImRhdGEiLCJiaW5kIiwicmVxdWlyZSIsImlzQnVmZmVyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaXNBcnJheSIsInZhbCIsImNhbGwiLCJpc0FycmF5QnVmZmVyIiwiaXNGb3JtRGF0YSIsIkZvcm1EYXRhIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJyZXN1bHQiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc1VuZGVmaW5lZCIsImlzT2JqZWN0IiwiaXNEYXRlIiwiaXNGaWxlIiwiaXNCbG9iIiwiaXNGdW5jdGlvbiIsImlzU3RyZWFtIiwicGlwZSIsImlzVVJMU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidHJpbSIsInN0ciIsInJlcGxhY2UiLCJpc1N0YW5kYXJkQnJvd3NlckVudiIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImZvckVhY2giLCJvYmoiLCJmbiIsImwiLCJrZXkiLCJoYXNPd25Qcm9wZXJ0eSIsIm1lcmdlIiwiYXNzaWduVmFsdWUiLCJhcmd1bWVudHMiLCJleHRlbmQiLCJhIiwiYiIsInRoaXNBcmciLCJhcHBseU1peGluIiwiVnVlIiwidmVyc2lvbiIsIk51bWJlciIsInNwbGl0IiwidXNlc0luaXQiLCJjb25maWciLCJfbGlmZWN5Y2xlSG9va3MiLCJpbmRleE9mIiwibWl4aW4iLCJpbml0IiwidnVleEluaXQiLCJiZWZvcmVDcmVhdGUiLCJfaW5pdCIsIm9wdGlvbnMiLCIkb3B0aW9ucyIsInN0b3JlIiwiJHN0b3JlIiwicGFyZW50IiwiZGV2dG9vbEhvb2siLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiZGV2dG9vbFBsdWdpbiIsIl9kZXZ0b29sSG9vayIsImVtaXQiLCJvbiIsInRhcmdldFN0YXRlIiwicmVwbGFjZVN0YXRlIiwic3Vic2NyaWJlIiwibXV0YXRpb24iLCJzdGF0ZSIsImZvckVhY2hWYWx1ZSIsImtleXMiLCJpc1Byb21pc2UiLCJ0aGVuIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibXNnIiwiRXJyb3IiLCJNb2R1bGUiLCJyYXdNb2R1bGUiLCJydW50aW1lIiwiX2NoaWxkcmVuIiwiY3JlYXRlIiwiX3Jhd01vZHVsZSIsInJhd1N0YXRlIiwicHJvdG90eXBlQWNjZXNzb3JzJDEiLCJuYW1lc3BhY2VkIiwiZ2V0IiwiYWRkQ2hpbGQiLCJyZW1vdmVDaGlsZCIsImdldENoaWxkIiwidXBkYXRlIiwiYWN0aW9ucyIsIm11dGF0aW9ucyIsImdldHRlcnMiLCJmb3JFYWNoQ2hpbGQiLCJmb3JFYWNoR2V0dGVyIiwiZm9yRWFjaEFjdGlvbiIsImZvckVhY2hNdXRhdGlvbiIsImRlZmluZVByb3BlcnRpZXMiLCJNb2R1bGVDb2xsZWN0aW9uIiwicmF3Um9vdE1vZHVsZSIsInRoaXMkMSIsInJvb3QiLCJyZWdpc3RlciIsInBhdGgiLCJyZWR1Y2UiLCJnZXROYW1lc3BhY2UiLCJuYW1lc3BhY2UiLCJ1cGRhdGUkMSIsInNsaWNlIiwibmV3TW9kdWxlIiwicmF3Q2hpbGRNb2R1bGUiLCJ1bnJlZ2lzdGVyIiwidGFyZ2V0TW9kdWxlIiwiY29uc29sZSIsIndhcm4iLCJTdG9yZSIsIlByb21pc2UiLCJwbHVnaW5zIiwic3RyaWN0IiwiX2NvbW1pdHRpbmciLCJfYWN0aW9ucyIsIl9tdXRhdGlvbnMiLCJfd3JhcHBlZEdldHRlcnMiLCJfbW9kdWxlcyIsIl9tb2R1bGVzTmFtZXNwYWNlTWFwIiwiX3N1YnNjcmliZXJzIiwiX3dhdGNoZXJWTSIsInJlZiIsImRpc3BhdGNoIiwiY29tbWl0IiwiYm91bmREaXNwYXRjaCIsInR5cGUiLCJwYXlsb2FkIiwiYm91bmRDb21taXQiLCJpbnN0YWxsTW9kdWxlIiwicmVzZXRTdG9yZVZNIiwicGx1Z2luIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiX3ZtIiwiX2RhdGEiLCIkJHN0YXRlIiwic2V0IiwidiIsIl90eXBlIiwiX3BheWxvYWQiLCJfb3B0aW9ucyIsInVuaWZ5T2JqZWN0U3R5bGUiLCJlbnRyeSIsImVycm9yIiwiX3dpdGhDb21taXQiLCJjb21taXRJdGVyYXRvciIsImhhbmRsZXIiLCJzdWIiLCJzaWxlbnQiLCJhbGwiLCJzdWJzIiwic3BsaWNlIiwid2F0Y2giLCJnZXR0ZXIiLCJjYiIsIiR3YXRjaCIsInJlZ2lzdGVyTW9kdWxlIiwiQXJyYXkiLCJ1bnJlZ2lzdGVyTW9kdWxlIiwicGFyZW50U3RhdGUiLCJnZXROZXN0ZWRTdGF0ZSIsImRlbGV0ZSIsInJlc2V0U3RvcmUiLCJob3RVcGRhdGUiLCJuZXdPcHRpb25zIiwiY29tbWl0dGluZyIsImhvdCIsIm9sZFZtIiwid3JhcHBlZEdldHRlcnMiLCJjb21wdXRlZCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImVuYWJsZVN0cmljdE1vZGUiLCJuZXh0VGljayIsIiRkZXN0cm95Iiwicm9vdFN0YXRlIiwiaXNSb290IiwibW9kdWxlTmFtZSIsImxvY2FsIiwiY29udGV4dCIsIm1ha2VMb2NhbENvbnRleHQiLCJuYW1lc3BhY2VkVHlwZSIsInJlZ2lzdGVyTXV0YXRpb24iLCJhY3Rpb24iLCJyZWdpc3RlckFjdGlvbiIsInJlZ2lzdGVyR2V0dGVyIiwiY2hpbGQiLCJub05hbWVzcGFjZSIsImFyZ3MiLCJtYWtlTG9jYWxHZXR0ZXJzIiwiZ2V0dGVyc1Byb3h5Iiwic3BsaXRQb3MiLCJsb2NhbFR5cGUiLCJ3cmFwcGVkTXV0YXRpb25IYW5kbGVyIiwid3JhcHBlZEFjdGlvbkhhbmRsZXIiLCJyZXMiLCJyb290R2V0dGVycyIsInJlc29sdmUiLCJjYXRjaCIsImVyciIsInJhd0dldHRlciIsIndyYXBwZWRHZXR0ZXIiLCJkZWVwIiwic3luYyIsImluc3RhbGwiLCJfVnVlIiwibWFwU3RhdGUiLCJub3JtYWxpemVOYW1lc3BhY2UiLCJzdGF0ZXMiLCJub3JtYWxpemVNYXAiLCJtYXBwZWRTdGF0ZSIsImdldE1vZHVsZUJ5TmFtZXNwYWNlIiwidnVleCIsIm1hcE11dGF0aW9ucyIsIm1hcHBlZE11dGF0aW9uIiwibGVuIiwiYXBwbHkiLCJtYXBHZXR0ZXJzIiwibWFwcGVkR2V0dGVyIiwibWFwQWN0aW9ucyIsIm1hcHBlZEFjdGlvbiIsImNoYXJBdCIsImhlbHBlciIsImluZGV4X2VzbSIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInNlbGYiLCJGdW5jdGlvbiIsImJhc2VJc05hdGl2ZSIsImdldFZhbHVlIiwiZ2V0TmF0aXZlIiwib2JqZWN0IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJTeW1ib2wiLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiYmFzZUdldFRhZyIsImlzU3ltYm9sIiwiSU5GSU5JVFkiLCJ0b0tleSIsImlzT2JqZWN0TGlrZSIsInN5bWJvbFRhZyIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTGlzdENhY2hlIiwiZW50cmllcyIsImluZGV4IiwiY2xlYXIiLCJoYXMiLCJlcSIsImFzc29jSW5kZXhPZiIsImFycmF5IiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsIl9fZGF0YV9fIiwiTUFYX1NBRkVfSU5URUdFUiIsInJlSXNVaW50IiwiaXNJbmRleCIsInRlc3QiLCJuYXRpdmVDcmVhdGUiLCJpZGVudGl0eSIsImlzTGVuZ3RoIiwiaXNBcnJheUxpa2UiLCJlbXB0eU9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJpc0RlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsIl90b1N0cmluZyIsInRvUmF3VHlwZSIsImlzUGxhaW5PYmplY3QiLCJpc1JlZ0V4cCIsImlzVmFsaWRBcnJheUluZGV4IiwibiIsInBhcnNlRmxvYXQiLCJTdHJpbmciLCJNYXRoIiwiZmxvb3IiLCJpc0Zpbml0ZSIsInRvTnVtYmVyIiwiaXNOYU4iLCJtYWtlTWFwIiwiZXhwZWN0c0xvd2VyQ2FzZSIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsImhhc093biIsImNhY2hlZCIsImNhY2hlIiwiY2FjaGVkRm4iLCJoaXQiLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwiY3R4IiwiYm91bmRGbiIsIl9sZW5ndGgiLCJ0b0FycmF5Iiwic3RhcnQiLCJyZXQiLCJ0byIsIl9mcm9tIiwidG9PYmplY3QiLCJub29wIiwibm8iLCJsb29zZUVxdWFsIiwiaXNPYmplY3RBIiwiaXNPYmplY3RCIiwiaXNBcnJheUEiLCJpc0FycmF5QiIsImV2ZXJ5IiwiZSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsInBlcmZvcm1hbmNlIiwiZXJyb3JIYW5kbGVyIiwid2FybkhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Jlc2VydmVkQXR0ciIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiaXNSZXNlcnZlZCIsImNoYXJDb2RlQXQiLCJkZWYiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImJhaWxSRSIsInBhcnNlUGF0aCIsInNlZ21lbnRzIiwiaGFzUHJvdG8iLCJpbkJyb3dzZXIiLCJpbldlZXgiLCJXWEVudmlyb25tZW50IiwicGxhdGZvcm0iLCJ3ZWV4UGxhdGZvcm0iLCJVQSIsInVzZXJBZ2VudCIsImlzSUUiLCJpc0lFOSIsImlzRWRnZSIsImlzQW5kcm9pZCIsImlzSU9TIiwiaXNDaHJvbWUiLCJuYXRpdmVXYXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJhZGRFdmVudExpc3RlbmVyIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJnbG9iYWwiLCJlbnYiLCJWVUVfRU5WIiwiaXNOYXRpdmUiLCJDdG9yIiwiaGFzU3ltYm9sIiwiUmVmbGVjdCIsIm93bktleXMiLCJfU2V0IiwiU2V0IiwiYWRkIiwidGlwIiwiZ2VuZXJhdGVDb21wb25lbnRUcmFjZSIsImZvcm1hdENvbXBvbmVudE5hbWUiLCJoYXNDb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5Iiwidm0iLCJ0cmFjZSIsImluY2x1ZGVGaWxlIiwiJHJvb3QiLCJjaWQiLCJfaXNWdWUiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJfY29tcG9uZW50VGFnIiwiZmlsZSIsIl9fZmlsZSIsIm1hdGNoIiwicmVwZWF0IiwiJHBhcmVudCIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJsYXN0IiwidWlkJDEiLCJEZXAiLCJhZGRTdWIiLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJ0YXJnZXQiLCJhZGREZXAiLCJub3RpZnkiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiVk5vZGUiLCJ0YWciLCJjaGlsZHJlbiIsInRleHQiLCJlbG0iLCJjb21wb25lbnRPcHRpb25zIiwiYXN5bmNGYWN0b3J5IiwibnMiLCJmbkNvbnRleHQiLCJmbk9wdGlvbnMiLCJmblNjb3BlSWQiLCJjb21wb25lbnRJbnN0YW5jZSIsInJhdyIsImlzU3RhdGljIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJhc3luY01ldGEiLCJpc0FzeW5jUGxhY2Vob2xkZXIiLCJjcmVhdGVFbXB0eVZOb2RlIiwibm9kZSIsImNyZWF0ZVRleHRWTm9kZSIsImNsb25lVk5vZGUiLCJ2bm9kZSIsImNsb25lZCIsImNsb25lVk5vZGVzIiwidm5vZGVzIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsIm1ldGhvZCIsIm9yaWdpbmFsIiwibXV0YXRvciIsIm9iIiwiX19vYl9fIiwiaW5zZXJ0ZWQiLCJvYnNlcnZlQXJyYXkiLCJkZXAiLCJhcnJheUtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwib2JzZXJ2ZXJTdGF0ZSIsInNob3VsZENvbnZlcnQiLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUiLCJpdGVtcyIsIm9ic2VydmUiLCJzcmMiLCJfX3Byb3RvX18iLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsInByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwic2V0dGVyIiwiY2hpbGRPYiIsInJlYWN0aXZlR2V0dGVyIiwiZGVwZW5kQXJyYXkiLCJyZWFjdGl2ZVNldHRlciIsIm5ld1ZhbCIsIm1heCIsInByb2Nlc3MiLCJkZWwiLCJzdHJhdHMiLCJlbCIsInByb3BzRGF0YSIsImRlZmF1bHRTdHJhdCIsIm1lcmdlRGF0YSIsImZyb20iLCJ0b1ZhbCIsImZyb21WYWwiLCJtZXJnZURhdGFPckZuIiwicGFyZW50VmFsIiwiY2hpbGRWYWwiLCJtZXJnZWREYXRhRm4iLCJtZXJnZWRJbnN0YW5jZURhdGFGbiIsImluc3RhbmNlRGF0YSIsImRlZmF1bHREYXRhIiwibWVyZ2VIb29rIiwiaG9vayIsIm1lcmdlQXNzZXRzIiwiYXNzZXJ0T2JqZWN0VHlwZSIsImtleSQxIiwicHJvcHMiLCJtZXRob2RzIiwiaW5qZWN0IiwicHJvdmlkZSIsImNoZWNrQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJ2YWxpZGF0ZUNvbXBvbmVudE5hbWUiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZUluamVjdCIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJtZXJnZU9wdGlvbnMiLCJleHRlbmRzRnJvbSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJyZXNvbHZlQXNzZXQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJwcm9wIiwiYWJzZW50IiwiaXNUeXBlIiwiQm9vbGVhbiIsImdldFByb3BEZWZhdWx0VmFsdWUiLCJwcmV2U2hvdWxkQ29udmVydCIsImFzc2VydFByb3AiLCJkZWZhdWx0IiwiX3Byb3BzIiwiZ2V0VHlwZSIsInJlcXVpcmVkIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsInZhbGlkYXRvciIsInNpbXBsZUNoZWNrUkUiLCJ0IiwiaGFuZGxlRXJyb3IiLCJpbmZvIiwiY3VyIiwiaG9va3MiLCJlcnJvckNhcHR1cmVkIiwiY2FwdHVyZSIsImdsb2JhbEhhbmRsZUVycm9yIiwibG9nRXJyb3IiLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwiZmx1c2hDYWxsYmFja3MiLCJjb3BpZXMiLCJtaWNyb1RpbWVyRnVuYyIsIm1hY3JvVGltZXJGdW5jIiwidXNlTWFjcm9UYXNrIiwic2V0SW1tZWRpYXRlIiwiTWVzc2FnZUNoYW5uZWwiLCJjaGFubmVsIiwicG9ydCIsInBvcnQyIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsInNldFRpbWVvdXQiLCJwIiwid2l0aE1hY3JvVGFzayIsIl93aXRoVGFzayIsIl9yZXNvbHZlIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJyZW5kZXIiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5Iiwic2Vlbk9iamVjdHMiLCJ0cmF2ZXJzZSIsIl90cmF2ZXJzZSIsInNlZW4iLCJpc0EiLCJpc0Zyb3plbiIsImRlcElkIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsIm5vcm1hbGl6ZUV2ZW50IiwicGFzc2l2ZSIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbGRPbiIsInJlbW92ZSQkMSIsIm9sZCIsImV2ZW50IiwicGFyYW1zIiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5Iiwib2xkSG9vayIsIndyYXBwZWRIb29rIiwibWVyZ2VkIiwiZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSIsImF0dHJzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJoYXNoIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsImxhc3RJbmRleCIsInNoaWZ0IiwiX2lzVkxpc3QiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwiY3JlYXRlQXN5bmNQbGFjZWhvbGRlciIsImZhY3RvcnkiLCJyZXNvbHZlQXN5bmNDb21wb25lbnQiLCJiYXNlQ3RvciIsImVycm9yQ29tcCIsInJlc29sdmVkIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwiY29udGV4dHMiLCJmb3JjZVJlbmRlciIsIiRmb3JjZVVwZGF0ZSIsInJlamVjdCIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsImhvb2tSRSIsImNicyIsImkkMSIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsInNsb3QiLCJuYW1lJDEiLCJpc1doaXRlc3BhY2UiLCJyZXNvbHZlU2NvcGVkU2xvdHMiLCJhY3RpdmVJbnN0YW5jZSIsImlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCIsImluaXRMaWZlY3ljbGUiLCJhYnN0cmFjdCIsIiRjaGlsZHJlbiIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNNb3VudGVkIiwiX2lzRGVzdHJveWVkIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJoeWRyYXRpbmciLCJjYWxsSG9vayIsInByZXZFbCIsIiRlbCIsInByZXZWbm9kZSIsIl92bm9kZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9wYXJlbnRFbG0iLCJfcmVmRWxtIiwiX192dWVfXyIsIiR2bm9kZSIsInRlYXJkb3duIiwiX3dhdGNoZXJzIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsInF1ZXVlV2F0Y2hlciIsInVpZCQyIiwiZXhwT3JGbiIsImlzUmVuZGVyV2F0Y2hlciIsImxhenkiLCJhY3RpdmUiLCJkaXJ0eSIsImRlcHMiLCJuZXdEZXBzIiwiZGVwSWRzIiwibmV3RGVwSWRzIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsInByb3BzT3B0aW9ucyIsImxvb3AiLCJoeXBoZW5hdGVkS2V5IiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwiaXNTU1IiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCIkZGF0YSIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjb21wdXRlZEdldHRlciIsImNyZWF0ZVdhdGNoZXIiLCJrZXlPckZuIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIm5ld0RhdGEiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsImluaXRQcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwiZmlsdGVyIiwicHJvdmlkZUtleSIsInByb3ZpZGVEZWZhdWx0IiwicmVuZGVyTGlzdCIsInJlbmRlclNsb3QiLCJmYWxsYmFjayIsImJpbmRPYmplY3QiLCJzY29wZWRTbG90Rm4iLCJub2RlcyIsInNsb3ROb2RlcyIsIl9yZW5kZXJlZCIsIiRjcmVhdGVFbGVtZW50IiwicmVzb2x2ZUZpbHRlciIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluQWxpYXMiLCJldmVudEtleU5hbWUiLCJiaW5kT2JqZWN0UHJvcHMiLCJhc1Byb3AiLCJpc1N5bmMiLCJkb21Qcm9wcyIsIiRldmVudCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJfc3RhdGljVHJlZXMiLCJzdGF0aWNSZW5kZXJGbnMiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImJpbmRPYmplY3RMaXN0ZW5lcnMiLCJleGlzdGluZyIsIm91cnMiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIkZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IiwiaW5qZWN0aW9ucyIsImNvbnRleHRWbSIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsIl9zY29wZUlkIiwiX2MiLCJkIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIiwiJG1vdW50Iiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsIm9sZFZub2RlIiwiaW5zZXJ0IiwiZGVzdHJveSIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsIl9iYXNlIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJtZXJnZUhvb2tzIiwiX2lzQ29tcG9uZW50IiwiaW5saW5lVGVtcGxhdGUiLCJmcm9tUGFyZW50IiwibWVyZ2VIb29rJDEiLCJvbmUiLCJ0d28iLCJjYWxsYmFjayIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsImlzIiwiYXBwbHlOUyIsImZvcmNlIiwiaW5pdFJlbmRlciIsInBhcmVudERhdGEiLCJyZW5kZXJNaXhpbiIsIiRuZXh0VGljayIsInJlbmRlckVycm9yIiwidWlkIiwiaW5pdE1peGluIiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJleHRlbmRlZCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJWdWUkMyIsImluaXRVc2UiLCJ1c2UiLCJpbnN0YWxsZWRQbHVnaW5zIiwiX2luc3RhbGxlZFBsdWdpbnMiLCJ1bnNoaWZ0IiwiaW5pdE1peGluJDEiLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJrZWVwQWxpdmVJbnN0YW5jZSIsImNhY2hlZE5vZGUiLCJwcnVuZUNhY2hlRW50cnkiLCJjdXJyZW50IiwiY2FjaGVkJCQxIiwicGF0dGVyblR5cGVzIiwiUmVnRXhwIiwiS2VlcEFsaXZlIiwiaW5jbHVkZSIsImV4Y2x1ZGUiLCJjcmVhdGVkIiwiZGVzdHJveWVkIiwicmVmJDEiLCJwYXJzZUludCIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsInV0aWwiLCJzc3JDb250ZXh0IiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImlzRmFsc3lBdHRyVmFsdWUiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImNsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZnlBcnJheSIsInN0cmluZ2lmeU9iamVjdCIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwicXVlcnkiLCJzZWxlY3RlZCIsInF1ZXJ5U2VsZWN0b3IiLCJjcmVhdGVFbGVtZW50JDEiLCJ0YWdOYW1lIiwibXVsdGlwbGUiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwibm9kZU9wcyIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpc1Vua25vd25FbGVtZW50JCQxIiwiaW5WUHJlIiwic29tZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwibmVzdGVkIiwicHJlIiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiY2hlY2tEdXBsaWNhdGVLZXlzIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwic2VlbktleXMiLCJlbmQiLCJoeWRyYXRlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJoeWRyYXRpb25CYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiYXNzZXJ0Tm9kZU1hdGNoIiwiaGFzQ2hpbGROb2RlcyIsImlubmVySFRNTCIsImNoaWxkcmVuTWF0Y2giLCJmaXJzdENoaWxkIiwiY2hpbGROb2RlcyIsImZ1bGxJbnZva2UiLCJub2RlVHlwZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwicGFyZW50RWxtJDEiLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsImkkMiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJkaXIiLCJjYWxsSG9vayQxIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlTlMiLCJfX2llcGgiLCJibG9ja2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyIiwib25jZUhhbmRsZXIiLCJyZW1vdmUkMiIsImFkZCQxIiwidXBkYXRlRE9NTGlzdGVuZXJzIiwiZXZlbnRzIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc05vdEluRm9jdXNBbmREaXJ0eSIsImlzRGlydHlXaXRoTW9kaWZpZXJzIiwibm90SW5Gb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJfdk1vZGlmaWVycyIsIm51bWJlciIsInBhcnNlU3R5bGVUZXh0IiwiY3NzVGV4dCIsImxpc3REZWxpbWl0ZXIiLCJwcm9wZXJ0eURlbGltaXRlciIsIm5vcm1hbGl6ZVN0eWxlRGF0YSIsInN0eWxlIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJub3JtYWxpemUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRlZCIsIm9uRW5kIiwidHJhbnNmb3JtUkUiLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsInMiLCJlbnRlciIsInRvZ2dsZURpc3BsYXkiLCJjYW5jZWxsZWQiLCJfZW50ZXJDYiIsImFwcGVhckNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYmVmb3JlRW50ZXIiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWQiLCJiZWZvcmVBcHBlYXIiLCJhcHBlYXIiLCJhZnRlckFwcGVhciIsImFwcGVhckNhbmNlbGxlZCIsImR1cmF0aW9uIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsInN0YXJ0Q2xhc3MiLCJhY3RpdmVDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiYmVmb3JlTGVhdmUiLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwicGVyZm9ybUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsInRyaWdnZXIiLCJkaXJlY3RpdmUiLCJiaW5kaW5nIiwiX3ZPcHRpb25zIiwic2V0U2VsZWN0ZWQiLCJvbkNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvblN0YXJ0IiwicHJldk9wdGlvbnMiLCJjdXJPcHRpb25zIiwibyIsIm5lZWRSZXNldCIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJhY3R1YWxseVNldFNlbGVjdGVkIiwiaXNNdWx0aXBsZSIsIm9wdGlvbiIsInNlbGVjdGVkSW5kZXgiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2NhdGVOb2RlIiwidHJhbnNpdGlvbiQkMSIsIm9yaWdpbmFsRGlzcGxheSIsIl9fdk9yaWdpbmFsRGlzcGxheSIsImRpc3BsYXkiLCJ1bmJpbmQiLCJwbGF0Zm9ybURpcmVjdGl2ZXMiLCJ0cmFuc2l0aW9uUHJvcHMiLCJtb2RlIiwiZ2V0UmVhbENoaWxkIiwiY29tcE9wdGlvbnMiLCJleHRyYWN0VHJhbnNpdGlvbkRhdGEiLCJwbGFjZWhvbGRlciIsImgiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJiZWZvcmVVcGRhdGUiLCJ1cGRhdGVkIiwiaGFzTW92ZSIsImNhbGxQZW5kaW5nQ2JzIiwicmVjb3JkUG9zaXRpb24iLCJhcHBseVRyYW5zbGF0aW9uIiwiX3JlZmxvdyIsImJvZHkiLCJvZmZzZXRIZWlnaHQiLCJtb3ZlZCIsInRyYW5zZm9ybSIsIldlYmtpdFRyYW5zZm9ybSIsInRyYW5zaXRpb25EdXJhdGlvbiIsIl9tb3ZlQ2IiLCJwcm9wZXJ0eU5hbWUiLCJfaGFzTW92ZSIsImNsb25lIiwiY2xvbmVOb2RlIiwibmV3UG9zIiwib2xkUG9zIiwiZHgiLCJsZWZ0IiwiZHkiLCJ0b3AiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJ1dGlscyIsIm5vcm1hbGl6ZUhlYWRlck5hbWUiLCJERUZBVUxUX0NPTlRFTlRfVFlQRSIsInNldENvbnRlbnRUeXBlSWZVbnNldCIsImhlYWRlcnMiLCJnZXREZWZhdWx0QWRhcHRlciIsImFkYXB0ZXIiLCJYTUxIdHRwUmVxdWVzdCIsImRlZmF1bHRzIiwidHJhbnNmb3JtUmVxdWVzdCIsInRyYW5zZm9ybVJlc3BvbnNlIiwicGFyc2UiLCJ4c3JmQ29va2llTmFtZSIsInhzcmZIZWFkZXJOYW1lIiwibWF4Q29udGVudExlbmd0aCIsInZhbGlkYXRlU3RhdHVzIiwic3RhdHVzIiwiY29tbW9uIiwiZm9yRWFjaE1ldGhvZE5vRGF0YSIsImZvckVhY2hNZXRob2RXaXRoRGF0YSIsIk1hcCIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwiY2FzdFBhdGgiLCJiYXNlR2V0IiwiYmFzZU1hdGNoZXMiLCJiYXNlTWF0Y2hlc1Byb3BlcnR5IiwiYmFzZUl0ZXJhdGVlIiwiaXNLZXkiLCJzdHJpbmdUb1BhdGgiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwib3RoZXIiLCJiYXNlSXNBcmd1bWVudHMiLCJvYmplY3RQcm90byIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiaXNBcmd1bWVudHMiLCJhcnJheUxpa2VLZXlzIiwiYmFzZUtleXMiLCJnIiwiZXZhbCIsInNldHRsZSIsImJ1aWxkVVJMIiwicGFyc2VIZWFkZXJzIiwiaXNVUkxTYW1lT3JpZ2luIiwiY3JlYXRlRXJyb3IiLCJ4aHJBZGFwdGVyIiwiZGlzcGF0Y2hYaHJSZXF1ZXN0IiwicmVxdWVzdERhdGEiLCJyZXF1ZXN0SGVhZGVycyIsInJlcXVlc3QiLCJsb2FkRXZlbnQiLCJ4RG9tYWluIiwiWERvbWFpblJlcXVlc3QiLCJ1cmwiLCJvbnByb2dyZXNzIiwiaGFuZGxlUHJvZ3Jlc3MiLCJvbnRpbWVvdXQiLCJoYW5kbGVUaW1lb3V0IiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJBdXRob3JpemF0aW9uIiwib3BlbiIsInBhcmFtc1NlcmlhbGl6ZXIiLCJoYW5kbGVMb2FkIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlVVJMIiwicmVzcG9uc2VIZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwicmVzcG9uc2VEYXRhIiwicmVzcG9uc2VUeXBlIiwicmVzcG9uc2VUZXh0IiwicmVzcG9uc2UiLCJzdGF0dXNUZXh0Iiwib25lcnJvciIsImNvb2tpZXMiLCJ4c3JmVmFsdWUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJyZWFkIiwic2V0UmVxdWVzdEhlYWRlciIsIm9uRG93bmxvYWRQcm9ncmVzcyIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJ1cGxvYWQiLCJjYW5jZWxUb2tlbiIsInByb21pc2UiLCJvbkNhbmNlbGVkIiwiY2FuY2VsIiwiYWJvcnQiLCJzZW5kIiwiQ2FuY2VsIiwibWVzc2FnZSIsIl9fQ0FOQ0VMX18iLCJpc0NhbmNlbCIsImVuaGFuY2VFcnJvciIsImNvZGUiLCJ3cmFwIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwiU3RhY2siLCJzaXplIiwiYXJyYXlNYXAiLCJpdGVyYXRlZSIsImFycmF5UHVzaCIsInZhbHVlcyIsIm9mZnNldCIsImJhc2VJc0VxdWFsRGVlcCIsImJhc2VJc0VxdWFsIiwiYml0bWFzayIsImN1c3RvbWl6ZXIiLCJzdGFjayIsImJhc2VVbmFyeSIsImZ1bmMiLCJTZXRDYWNoZSIsImFycmF5U29tZSIsImNhY2hlSGFzIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwiZXF1YWxBcnJheXMiLCJlcXVhbEZ1bmMiLCJpc1BhcnRpYWwiLCJhcnJMZW5ndGgiLCJvdGhMZW5ndGgiLCJzdGFja2VkIiwiYXJyVmFsdWUiLCJvdGhWYWx1ZSIsImNvbXBhcmVkIiwib3RoSW5kZXgiLCJpc1N0cmljdENvbXBhcmFibGUiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSIsInNyY1ZhbHVlIiwiZnVuY1Byb3RvIiwiZnVuY1RvU3RyaW5nIiwidG9Tb3VyY2UiLCJzdHViRmFsc2UiLCJmcmVlRXhwb3J0cyIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiQnVmZmVyIiwibmF0aXZlSXNCdWZmZXIiLCJhc3luY1RhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImJhc2VJc1R5cGVkQXJyYXkiLCJub2RlVXRpbCIsIm5vZGVJc1R5cGVkQXJyYXkiLCJpc1R5cGVkQXJyYXkiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsIkl0ZW0iLCJ0aXRsZSIsImJyb3dzZXIiLCJhcmd2IiwidmVyc2lvbnMiLCJhZGRMaXN0ZW5lciIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJ3ZWJwYWNrUG9seWZpbGwiLCJkZXByZWNhdGUiLCJwYXRocyIsImNyZWF0ZVJvdXRlciIsInJvdXRlcyIsImlzTG9nZ2VkSW4iLCJtb2RhbENvbnRyb2wiLCJzaG93TG9naW5Nb2RhbCIsInNob3dSZWdpc3Rlck1vZGFsIiwiZ2V0VXNlckRhdGEiLCJTaG93TG9naW5Nb2RhbCIsIlNob3dSZWdpc3Rlck1vZGFsIiwiR2V0QXV0aFN0YXR1cyIsImNoYW5nZVRlYW0iLCJyaWRlckFycmF5IiwicmlkZXJzIiwic2V0TG9naW5Nb2RhbCIsInNldFJlZ2lzdGVyTW9kYWwiLCJzZXRVc2VyRGF0YSIsInVzZXJEYXRhIiwic2V0TG9nZ2VkSW4iLCJsb2dnZWRJbiIsImxvZ291dCIsInNldE1hbmFnZWRMZWFndWUiLCJsZWFndWUiLCJjdXJyZW50TGVhZ3VlIiwic2V0TGVhZ3VlcyIsImxlYWd1ZXMiLCJyb3V0ZXIiLCJhcHAiLCJBeGlvcyIsImNyZWF0ZUluc3RhbmNlIiwiZGVmYXVsdENvbmZpZyIsImluc3RhbmNlIiwiYXhpb3MiLCJpbnN0YW5jZUNvbmZpZyIsIkNhbmNlbFRva2VuIiwicHJvbWlzZXMiLCJzcHJlYWQiLCJleGVjdXRvciIsIlR5cGVFcnJvciIsInJlc29sdmVQcm9taXNlIiwicHJvbWlzZUV4ZWN1dG9yIiwidG9rZW4iLCJ0aHJvd0lmUmVxdWVzdGVkIiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiZGlzcGF0Y2hSZXF1ZXN0IiwiaXNBYnNvbHV0ZVVSTCIsImNvbWJpbmVVUkxzIiwiaW50ZXJjZXB0b3JzIiwiYmFzZVVSTCIsImNoYWluIiwidW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMiLCJpbnRlcmNlcHRvciIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwicHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzIiwiZWplY3QiLCJmb3JFYWNoSGFuZGxlciIsInRyYW5zZm9ybURhdGEiLCJ0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwiY2xlYW5IZWFkZXJDb25maWciLCJvbkFkYXB0ZXJSZXNvbHV0aW9uIiwib25BZGFwdGVyUmVqZWN0aW9uIiwiY2hhcnMiLCJFIiwiaW5wdXQiLCJvdXRwdXQiLCJibG9jayIsImNoYXJDb2RlIiwiaWR4IiwiZW5jb2RlIiwic2VyaWFsaXplZFBhcmFtcyIsInBhcnRzIiwic2VyaWFsaXplIiwicGFyc2VWYWx1ZSIsInRvSVNPU3RyaW5nIiwicmVsYXRpdmVVUkwiLCJzdGFuZGFyZEJyb3dzZXJFbnYiLCJ3cml0ZSIsImV4cGlyZXMiLCJkb21haW4iLCJzZWN1cmUiLCJjb29raWUiLCJEYXRlIiwidG9HTVRTdHJpbmciLCJkZWNvZGVVUklDb21wb25lbnQiLCJub3ciLCJub25TdGFuZGFyZEJyb3dzZXJFbnYiLCJtc2llIiwidXJsUGFyc2luZ05vZGUiLCJvcmlnaW5VUkwiLCJyZXNvbHZlVVJMIiwiaHJlZiIsInByb3RvY29sIiwiaG9zdCIsInNlYXJjaCIsImhvc3RuYW1lIiwicGF0aG5hbWUiLCJsb2NhdGlvbiIsInJlcXVlc3RVUkwiLCJwYXJzZWQiLCJwcm9jZXNzSGVhZGVyIiwicGFyc2VyIiwibGluZSIsInN1YnN0ciIsImlzU2xvd0J1ZmZlciIsIl9pc0J1ZmZlciIsInJlYWRGbG9hdExFIiwiRGF0YVZpZXciLCJoYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSGFzaCIsInNldENhY2hlQWRkIiwic2V0Q2FjaGVIYXMiLCJVaW50OEFycmF5IiwiV2Vha01hcCIsImFycmF5RmlsdGVyIiwicHJlZGljYXRlIiwicmVzSW5kZXgiLCJiYXNlVGltZXMiLCJpbmhlcml0ZWQiLCJpc0FyciIsImlzQXJnIiwiaXNCdWZmIiwic2tpcEluZGV4ZXMiLCJiYXNlRm9yT3duIiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRWFjaCIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJmcm9tUmlnaHQiLCJpc0ZsYXR0ZW5hYmxlIiwiYmFzZUZsYXR0ZW4iLCJkZXB0aCIsImlzU3RyaWN0IiwiY3JlYXRlQmFzZUZvciIsImJhc2VGb3IiLCJiYXNlR2V0QWxsS2V5cyIsImtleXNGdW5jIiwic3ltYm9sc0Z1bmMiLCJiYXNlSGFzSW4iLCJhcmdzVGFnIiwiZXF1YWxCeVRhZyIsImVxdWFsT2JqZWN0cyIsImdldFRhZyIsImFycmF5VGFnIiwib2JqZWN0VGFnIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJvYmpJc1dyYXBwZWQiLCJvdGhJc1dyYXBwZWQiLCJvYmpVbndyYXBwZWQiLCJvdGhVbndyYXBwZWQiLCJiYXNlSXNNYXRjaCIsIm1hdGNoRGF0YSIsIm5vQ3VzdG9taXplciIsIm9ialZhbHVlIiwiaXNNYXNrZWQiLCJyZVJlZ0V4cENoYXIiLCJyZUlzSG9zdEN0b3IiLCJyZUlzTmF0aXZlIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwidHlwZWRBcnJheVRhZ3MiLCJpc1Byb3RvdHlwZSIsIm5hdGl2ZUtleXMiLCJiYXNlTWFwIiwiY29sbGVjdGlvbiIsImdldE1hdGNoRGF0YSIsImhhc0luIiwiYmFzZVNvcnRCeSIsImNvbXBhcmVNdWx0aXBsZSIsImJhc2VPcmRlckJ5IiwiaXRlcmF0ZWVzIiwib3JkZXJzIiwiY3JpdGVyaWEiLCJiYXNlUHJvcGVydHkiLCJiYXNlUHJvcGVydHlEZWVwIiwiYmFzZVVuc2V0IiwiYmFzZVB1bGxBdCIsImluZGV4ZXMiLCJwcmV2aW91cyIsIm92ZXJSZXN0Iiwic2V0VG9TdHJpbmciLCJiYXNlUmVzdCIsImNvbnN0YW50IiwiYmFzZVNldFRvU3RyaW5nIiwic3RyaW5nIiwiYmFzZVNsaWNlIiwiY29tcGFyZXIiLCJzeW1ib2xQcm90byIsInN5bWJvbFRvU3RyaW5nIiwiYmFzZVRvU3RyaW5nIiwiY29tcGFyZUFzY2VuZGluZyIsInZhbElzRGVmaW5lZCIsInZhbElzTnVsbCIsInZhbElzUmVmbGV4aXZlIiwidmFsSXNTeW1ib2wiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwib2JqQ3JpdGVyaWEiLCJvdGhDcml0ZXJpYSIsIm9yZGVyc0xlbmd0aCIsIm9yZGVyIiwiY29yZUpzRGF0YSIsImVhY2hGdW5jIiwiaXRlcmFibGUiLCJtYXBUb0FycmF5Iiwic2V0VG9BcnJheSIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwiYnl0ZUxlbmd0aCIsImJ5dGVPZmZzZXQiLCJjb252ZXJ0IiwiZ2V0QWxsS2V5cyIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiZ2V0U3ltYm9scyIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwiaXNPd24iLCJ1bm1hc2tlZCIsInN0dWJBcnJheSIsIm5hdGl2ZUdldFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2wiLCJwcm9taXNlVGFnIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwiY3RvclN0cmluZyIsImhhc1BhdGgiLCJoYXNGdW5jIiwiSEFTSF9VTkRFRklORUQiLCJzcHJlYWRhYmxlU3ltYm9sIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwiaXNJdGVyYXRlZUNhbGwiLCJtYXNrU3JjS2V5IiwiZXhlYyIsIklFX1BST1RPIiwicHJvdG8iLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQiLCJvdmVyQXJnIiwiZnJlZVByb2Nlc3MiLCJhcmciLCJuYXRpdmVNYXgiLCJvdGhlckFyZ3MiLCJzaG9ydE91dCIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93IiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJMQVJHRV9BUlJBWV9TSVpFIiwicGFpcnMiLCJyZUxlYWRpbmdEb3QiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwicXVvdGUiLCJ0b0ludGVnZXIiLCJmaW5kSW5kZXgiLCJkZWZhdWx0VmFsdWUiLCJGVU5DX0VSUk9SX1RFWFQiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiQ2FjaGUiLCJzb3J0QnkiLCJNQVhfSU5URUdFUiIsInRvRmluaXRlIiwic2lnbiIsInJlbWFpbmRlciIsIk5BTiIsInJlVHJpbSIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc09jdGFsIiwiZnJlZVBhcnNlSW50IiwiaXNCaW5hcnkiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsInJlZ2lzdGVySW1tZWRpYXRlIiwidGFzayIsImNsZWFySW1tZWRpYXRlIiwiaGFuZGxlIiwicnVuSWZQcmVzZW50IiwiaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24iLCJjYW5Vc2VQb3N0TWVzc2FnZSIsImltcG9ydFNjcmlwdHMiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4IiwicmFuZG9tIiwib25HbG9iYWxNZXNzYWdlIiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24iLCJodG1sIiwiZG9jdW1lbnRFbGVtZW50Iiwic2NyaXB0Iiwib25yZWFkeXN0YXRlY2hhbmdlIiwiaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbiIsImF0dGFjaFRvIiwiZ2V0UHJvdG90eXBlT2YiLCJUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiY2xvc2UiLCJjbGVhckZuIiwiX2lkIiwiX2NsZWFyRm4iLCJ1bnJlZiIsImVucm9sbCIsIm1zZWNzIiwiX2lkbGVUaW1lb3V0SWQiLCJfaWRsZVRpbWVvdXQiLCJ1bmVucm9sbCIsIl91bnJlZkFjdGl2ZSIsIm9uVGltZW91dCIsIl9vblRpbWVvdXQiLCJpc0Vycm9yIiwiVmlldyIsInJvdXRlclZpZXciLCJyb3V0ZSIsIiRyb3V0ZSIsIl9yb3V0ZXJWaWV3Q2FjaGUiLCJpbmFjdGl2ZSIsIl9yb3V0ZXJSb290Iiwicm91dGVyVmlld0RlcHRoIiwibWF0Y2hlZCIsInJlZ2lzdGVyUm91dGVJbnN0YW5jZSIsImluc3RhbmNlcyIsInJlc29sdmVQcm9wcyIsImVuY29kZVJlc2VydmVSRSIsImVuY29kZVJlc2VydmVSZXBsYWNlciIsImNvbW1hUkUiLCJkZWNvZGUiLCJyZXNvbHZlUXVlcnkiLCJleHRyYVF1ZXJ5IiwiX3BhcnNlUXVlcnkiLCJwYXJzZVF1ZXJ5IiwicGFyc2VkUXVlcnkiLCJwYXJhbSIsInN0cmluZ2lmeVF1ZXJ5IiwidmFsMiIsIngiLCJ0cmFpbGluZ1NsYXNoUkUiLCJjcmVhdGVSb3V0ZSIsInJlY29yZCIsInJlZGlyZWN0ZWRGcm9tIiwic3RyaW5naWZ5UXVlcnkkJDEiLCJtZXRhIiwiZnVsbFBhdGgiLCJnZXRGdWxsUGF0aCIsImZvcm1hdE1hdGNoIiwiU1RBUlQiLCJfc3RyaW5naWZ5UXVlcnkiLCJpc1NhbWVSb3V0ZSIsImlzT2JqZWN0RXF1YWwiLCJhS2V5cyIsImJLZXlzIiwiYVZhbCIsImJWYWwiLCJpc0luY2x1ZGVkUm91dGUiLCJxdWVyeUluY2x1ZGVzIiwidG9UeXBlcyIsImV2ZW50VHlwZXMiLCJMaW5rIiwiZXhhY3QiLCJhcHBlbmQiLCJleGFjdEFjdGl2ZUNsYXNzIiwiJHJvdXRlciIsImNsYXNzZXMiLCJnbG9iYWxBY3RpdmVDbGFzcyIsImxpbmtBY3RpdmVDbGFzcyIsImdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MiLCJsaW5rRXhhY3RBY3RpdmVDbGFzcyIsImFjdGl2ZUNsYXNzRmFsbGJhY2siLCJleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2siLCJjb21wYXJlVGFyZ2V0IiwiZ3VhcmRFdmVudCIsImNsaWNrIiwiZmluZEFuY2hvciIsImFEYXRhIiwiYUF0dHJzIiwibWV0YUtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImRlZmF1bHRQcmV2ZW50ZWQiLCJidXR0b24iLCJjdXJyZW50VGFyZ2V0IiwicHJldmVudERlZmF1bHQiLCJpbnN0YWxsZWQiLCJyZWdpc3Rlckluc3RhbmNlIiwiY2FsbFZhbCIsIl9yb3V0ZXIiLCJoaXN0b3J5IiwiX3JvdXRlIiwiYmVmb3JlUm91dGVFbnRlciIsImJlZm9yZVJvdXRlTGVhdmUiLCJiZWZvcmVSb3V0ZVVwZGF0ZSIsInJlc29sdmVQYXRoIiwicmVsYXRpdmUiLCJmaXJzdENoYXIiLCJzZWdtZW50IiwiaGFzaEluZGV4IiwicXVlcnlJbmRleCIsImNsZWFuUGF0aCIsImluZGV4JDEiLCJwYXRoVG9SZWdleHAiLCJwYXJzZV8xIiwiY29tcGlsZV8xIiwiY29tcGlsZSIsInRva2Vuc1RvRnVuY3Rpb25fMSIsInRva2Vuc1RvRnVuY3Rpb24iLCJ0b2tlbnNUb1JlZ0V4cF8xIiwidG9rZW5zVG9SZWdFeHAiLCJQQVRIX1JFR0VYUCIsInRva2VucyIsImRlZmF1bHREZWxpbWl0ZXIiLCJkZWxpbWl0ZXIiLCJtIiwiZXNjYXBlZCIsIm5leHQiLCJwcmVmaXgiLCJncm91cCIsIm1vZGlmaWVyIiwiYXN0ZXJpc2siLCJwYXJ0aWFsIiwib3B0aW9uYWwiLCJlc2NhcGVHcm91cCIsImVzY2FwZVN0cmluZyIsImVuY29kZVVSSUNvbXBvbmVudFByZXR0eSIsImVuY29kZVVSSSIsImVuY29kZUFzdGVyaXNrIiwicHJldHR5IiwiYXR0YWNoS2V5cyIsInJlIiwiZmxhZ3MiLCJzZW5zaXRpdmUiLCJyZWdleHBUb1JlZ2V4cCIsImdyb3VwcyIsImFycmF5VG9SZWdleHAiLCJyZWdleHAiLCJzdHJpbmdUb1JlZ2V4cCIsImVuZHNXaXRoRGVsaW1pdGVyIiwicmVnZXhwQ29tcGlsZUNhY2hlIiwiZmlsbFBhcmFtcyIsInJvdXRlTXNnIiwiZmlsbGVyIiwiY3JlYXRlUm91dGVNYXAiLCJvbGRQYXRoTGlzdCIsIm9sZFBhdGhNYXAiLCJvbGROYW1lTWFwIiwicGF0aExpc3QiLCJwYXRoTWFwIiwibmFtZU1hcCIsImFkZFJvdXRlUmVjb3JkIiwibWF0Y2hBcyIsIm5vcm1hbGl6ZWRQYXRoIiwibm9ybWFsaXplUGF0aCIsInBhdGhUb1JlZ2V4cE9wdGlvbnMiLCJjYXNlU2Vuc2l0aXZlIiwicmVnZXgiLCJjb21waWxlUm91dGVSZWdleCIsInJlZGlyZWN0IiwiY2hpbGRNYXRjaEFzIiwiYWxpYXMiLCJhbGlhc2VzIiwiYWxpYXNSb3V0ZSIsIm5vcm1hbGl6ZUxvY2F0aW9uIiwiX25vcm1hbGl6ZWQiLCJhc3NpZ24iLCJyYXdQYXRoIiwicGFyc2VkUGF0aCIsImJhc2VQYXRoIiwiY3JlYXRlTWF0Y2hlciIsImFkZFJvdXRlcyIsImN1cnJlbnRSb3V0ZSIsIl9jcmVhdGVSb3V0ZSIsInBhcmFtTmFtZXMiLCJyZWNvcmQkMSIsIm1hdGNoUm91dGUiLCJvcmlnaW5hbFJlZGlyZWN0IiwidGFyZ2V0UmVjb3JkIiwicmVzb2x2ZVJlY29yZFBhdGgiLCJyZXNvbHZlZFBhdGgiLCJhbGlhc2VkUGF0aCIsImFsaWFzZWRNYXRjaCIsImFsaWFzZWRSZWNvcmQiLCJwb3NpdGlvblN0b3JlIiwic2V0dXBTY3JvbGwiLCJzYXZlU2Nyb2xsUG9zaXRpb24iLCJzZXRTdGF0ZUtleSIsImhhbmRsZVNjcm9sbCIsImlzUG9wIiwiYmVoYXZpb3IiLCJzY3JvbGxCZWhhdmlvciIsInBvc2l0aW9uIiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJzaG91bGRTY3JvbGwiLCJzZWxlY3RvciIsIm5vcm1hbGl6ZU9mZnNldCIsImdldEVsZW1lbnRQb3NpdGlvbiIsImlzVmFsaWRQb3NpdGlvbiIsIm5vcm1hbGl6ZVBvc2l0aW9uIiwic2Nyb2xsVG8iLCJ5IiwiZ2V0U3RhdGVLZXkiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiZG9jRWwiLCJkb2NSZWN0IiwiZWxSZWN0Iiwic3VwcG9ydHNQdXNoU3RhdGUiLCJ1YSIsIlRpbWUiLCJfa2V5IiwiZ2VuS2V5IiwidG9GaXhlZCIsInB1c2hTdGF0ZSIsInJ1blF1ZXVlIiwic3RlcCIsInJlc29sdmVBc3luY0NvbXBvbmVudHMiLCJoYXNBc3luYyIsImZsYXRNYXBDb21wb25lbnRzIiwicmVzb2x2ZWREZWYiLCJmbGF0dGVuIiwiSGlzdG9yeSIsIm5vcm1hbGl6ZUJhc2UiLCJyZWFkeSIsInJlYWR5Q2JzIiwicmVhZHlFcnJvckNicyIsImVycm9yQ2JzIiwibGlzdGVuIiwib25SZWFkeSIsImVycm9yQ2IiLCJvbkVycm9yIiwidHJhbnNpdGlvblRvIiwib25Db21wbGV0ZSIsIm9uQWJvcnQiLCJjb25maXJtVHJhbnNpdGlvbiIsInVwZGF0ZVJvdXRlIiwiZW5zdXJlVVJMIiwicmVzb2x2ZVF1ZXVlIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJleHRyYWN0TGVhdmVHdWFyZHMiLCJiZWZvcmVIb29rcyIsImV4dHJhY3RVcGRhdGVIb29rcyIsIml0ZXJhdG9yIiwicG9zdEVudGVyQ2JzIiwiaXNWYWxpZCIsImVudGVyR3VhcmRzIiwiZXh0cmFjdEVudGVyR3VhcmRzIiwicmVzb2x2ZUhvb2tzIiwicHJldiIsImFmdGVySG9va3MiLCJiYXNlRWwiLCJleHRyYWN0R3VhcmRzIiwicmVjb3JkcyIsInJldmVyc2UiLCJndWFyZHMiLCJndWFyZCIsImV4dHJhY3RHdWFyZCIsImJpbmRHdWFyZCIsImJvdW5kUm91dGVHdWFyZCIsImJpbmRFbnRlckd1YXJkIiwicm91dGVFbnRlckd1YXJkIiwicG9sbCIsIkhUTUw1SGlzdG9yeSIsIkhpc3RvcnkkJDEiLCJleHBlY3RTY3JvbGwiLCJnZXRMb2NhdGlvbiIsImdvIiwiZnJvbVJvdXRlIiwiZ2V0Q3VycmVudExvY2F0aW9uIiwiSGFzaEhpc3RvcnkiLCJjaGVja0ZhbGxiYWNrIiwiZW5zdXJlU2xhc2giLCJzZXR1cExpc3RlbmVycyIsImdldEhhc2giLCJyZXBsYWNlSGFzaCIsInB1c2hIYXNoIiwiQWJzdHJhY3RIaXN0b3J5IiwidGFyZ2V0SW5kZXgiLCJWdWVSb3V0ZXIiLCJhcHBzIiwibWF0Y2hlciIsInNldHVwSGFzaExpc3RlbmVyIiwiYmVmb3JlRWFjaCIsInJlZ2lzdGVySG9vayIsImJlZm9yZVJlc29sdmUiLCJhZnRlckVhY2giLCJiYWNrIiwiZm9yd2FyZCIsImdldE1hdGNoZWRDb21wb25lbnRzIiwiY3JlYXRlSHJlZiIsIm5vcm1hbGl6ZWRUbyIsImxpc3RUb1N0eWxlcyIsInBhcmVudElkIiwibmV3U3R5bGVzIiwibWVkaWEiLCJwYXJ0Il0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1EQUEyQyxjQUFjOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNoRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ3hOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0ksbUZBQW1GO0FBQ3ZOLDZJQUE2SSxtRkFBbUY7QUFDaE87QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDOzs7Ozs7QUNwQkE7O0FBRUE7QUFDQSxxQ0FBd047QUFDeE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9JQUFvSSxtRkFBbUY7QUFDdk4sNklBQTZJLG1GQUFtRjtBQUNoTztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7OztBQ3BCQTs7QUFFQTtBQUNBLHFDQUF3TjtBQUN4TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0lBQW9JLG1GQUFtRjtBQUN2Tiw2SUFBNkksbUZBQW1GO0FBQ2hPO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLEVBQUU7QUFDNUMsQzs7Ozs7O0FDcEJBOztBQUVBO0FBQ0EscUNBQXdOO0FBQ3hOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0ksbUZBQW1GO0FBQ3ZOLDZJQUE2SSxtRkFBbUY7QUFDaE87QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNzIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGIzOTIyMjM2OGE3YmM1ZjZlZmMxIiwiLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIElNUE9SVEFOVDogRG8gTk9UIHVzZSBFUzIwMTUgZmVhdHVyZXMgaW4gdGhpcyBmaWxlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHJhd1NjcmlwdEV4cG9ydHMsXG4gIGNvbXBpbGVkVGVtcGxhdGUsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gICAgb3B0aW9ucy5fY29tcGlsZWQgPSB0cnVlXG4gIH1cblxuICAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChmdW5jdGlvbmFsVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxuICAgIHZhciBleGlzdGluZyA9IGZ1bmN0aW9uYWxcbiAgICAgID8gb3B0aW9ucy5yZW5kZXJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcblxuICAgIGlmICghZnVuY3Rpb25hbCkge1xuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBleGlzdGluZyhoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiAgTW9kaWZpZWQgYnkgRXZhbiBZb3UgQHl5eDk5MDgwM1xuKi9cblxudmFyIGhhc0RvY3VtZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuXG5pZiAodHlwZW9mIERFQlVHICE9PSAndW5kZWZpbmVkJyAmJiBERUJVRykge1xuICBpZiAoIWhhc0RvY3VtZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2dWUtc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuICcgK1xuICAgIFwiVXNlIHsgdGFyZ2V0OiAnbm9kZScgfSBpbiB5b3VyIFdlYnBhY2sgY29uZmlnIHRvIGluZGljYXRlIGEgc2VydmVyLXJlbmRlcmluZyBlbnZpcm9ubWVudC5cIlxuICApIH1cbn1cblxudmFyIGxpc3RUb1N0eWxlcyA9IHJlcXVpcmUoJy4vbGlzdFRvU3R5bGVzJylcblxuLypcbnR5cGUgU3R5bGVPYmplY3QgPSB7XG4gIGlkOiBudW1iZXI7XG4gIHBhcnRzOiBBcnJheTxTdHlsZU9iamVjdFBhcnQ+XG59XG5cbnR5cGUgU3R5bGVPYmplY3RQYXJ0ID0ge1xuICBjc3M6IHN0cmluZztcbiAgbWVkaWE6IHN0cmluZztcbiAgc291cmNlTWFwOiA/c3RyaW5nXG59XG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7LypcbiAgW2lkOiBudW1iZXJdOiB7XG4gICAgaWQ6IG51bWJlcixcbiAgICByZWZzOiBudW1iZXIsXG4gICAgcGFydHM6IEFycmF5PChvYmo/OiBTdHlsZU9iamVjdFBhcnQpID0+IHZvaWQ+XG4gIH1cbiovfVxuXG52YXIgaGVhZCA9IGhhc0RvY3VtZW50ICYmIChkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0pXG52YXIgc2luZ2xldG9uRWxlbWVudCA9IG51bGxcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMFxudmFyIGlzUHJvZHVjdGlvbiA9IGZhbHNlXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9XG5cbi8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxudmFyIGlzT2xkSUUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvbXNpZSBbNi05XVxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBhcmVudElkLCBsaXN0LCBfaXNQcm9kdWN0aW9uKSB7XG4gIGlzUHJvZHVjdGlvbiA9IF9pc1Byb2R1Y3Rpb25cblxuICB2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBsaXN0KVxuICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuICAgIHZhciBtYXlSZW1vdmUgPSBbXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICAgIGRvbVN0eWxlLnJlZnMtLVxuICAgICAgbWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpXG4gICAgfVxuICAgIGlmIChuZXdMaXN0KSB7XG4gICAgICBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIG5ld0xpc3QpXG4gICAgICBhZGRTdHlsZXNUb0RvbShzdHlsZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlcyA9IFtdXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV1cbiAgICAgIGlmIChkb21TdHlsZS5yZWZzID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXSgpXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzIC8qIEFycmF5PFN0eWxlT2JqZWN0PiAqLykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgdmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF1cbiAgICBpZiAoZG9tU3R5bGUpIHtcbiAgICAgIGRvbVN0eWxlLnJlZnMrK1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKVxuICAgICAgfVxuICAgICAgZm9yICg7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBpZiAoZG9tU3R5bGUucGFydHMubGVuZ3RoID4gaXRlbS5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMubGVuZ3RoID0gaXRlbS5wYXJ0cy5sZW5ndGhcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnRzID0gW11cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgc3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7IGlkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHMgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKCkge1xuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKVxuICBzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2NzcydcbiAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpXG4gIHJldHVybiBzdHlsZUVsZW1lbnRcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgdmFyIHVwZGF0ZSwgcmVtb3ZlXG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLXZ1ZS1zc3ItaWR+PVwiJyArIG9iai5pZCArICdcIl0nKVxuXG4gIGlmIChzdHlsZUVsZW1lbnQpIHtcbiAgICBpZiAoaXNQcm9kdWN0aW9uKSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBhbmQgaW4gcHJvZHVjdGlvbiBtb2RlLlxuICAgICAgLy8gc2ltcGx5IGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbm9vcFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYXMgU1NSIHN0eWxlcyBidXQgaW4gZGV2IG1vZGUuXG4gICAgICAvLyBmb3Igc29tZSByZWFzb24gQ2hyb21lIGNhbid0IGhhbmRsZSBzb3VyY2UgbWFwIGluIHNlcnZlci1yZW5kZXJlZFxuICAgICAgLy8gc3R5bGUgdGFncyAtIHNvdXJjZSBtYXBzIGluIDxzdHlsZT4gb25seSB3b3JrcyBpZiB0aGUgc3R5bGUgdGFnIGlzXG4gICAgICAvLyBjcmVhdGVkIGFuZCBpbnNlcnRlZCBkeW5hbWljYWxseS4gU28gd2UgcmVtb3ZlIHRoZSBzZXJ2ZXIgcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlcyBhbmQgaW5qZWN0IG5ldyBvbmVzLlxuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIGlmIChpc09sZElFKSB7XG4gICAgLy8gdXNlIHNpbmdsZXRvbiBtb2RlIGZvciBJRTkuXG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKytcbiAgICBzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KCkpXG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpXG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2UgbXVsdGktc3R5bGUtdGFnIG1vZGUgaW4gYWxsIG90aGVyIGNhc2VzXG4gICAgc3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KClcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KVxuICAgIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICB1cGRhdGUob2JqKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG4gICAgICAgICAgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcbiAgICAgICAgICBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iailcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnRcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKVxuICB9XG59KSgpXG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5jc3NcblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcylcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcylcbiAgICB2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGVFbGVtZW50LCBvYmopIHtcbiAgdmFyIGNzcyA9IG9iai5jc3NcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwXG5cbiAgaWYgKG1lZGlhKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSlcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2RldnRvb2xzL2RvY3MvamF2YXNjcmlwdC1kZWJ1Z2dpbmdcbiAgICAvLyB0aGlzIG1ha2VzIHNvdXJjZSBtYXBzIGluc2lkZSBzdHlsZSB0YWdzIHdvcmsgcHJvcGVybHkgaW4gQ2hyb21lXG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlVVJMPScgKyBzb3VyY2VNYXAuc291cmNlc1swXSArICcgKi8nXG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJ1xuICB9XG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzc1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKVxuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSlcbiAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgIWlzQXJyYXkob2JqKSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi91dGlscy5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2luZGV4LmpzIiwiLyoqXG4gKiB2dWV4IHYyLjMuMFxuICogKGMpIDIwMTcgRXZhbiBZb3VcbiAqIEBsaWNlbnNlIE1JVFxuICovXG52YXIgYXBwbHlNaXhpbiA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgdmFyIHZlcnNpb24gPSBOdW1iZXIoVnVlLnZlcnNpb24uc3BsaXQoJy4nKVswXSk7XG5cbiAgaWYgKHZlcnNpb24gPj0gMikge1xuICAgIHZhciB1c2VzSW5pdCA9IFZ1ZS5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmluZGV4T2YoJ2luaXQnKSA+IC0xO1xuICAgIFZ1ZS5taXhpbih1c2VzSW5pdCA/IHsgaW5pdDogdnVleEluaXQgfSA6IHsgYmVmb3JlQ3JlYXRlOiB2dWV4SW5pdCB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdmVycmlkZSBpbml0IGFuZCBpbmplY3QgdnVleCBpbml0IHByb2NlZHVyZVxuICAgIC8vIGZvciAxLnggYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgdmFyIF9pbml0ID0gVnVlLnByb3RvdHlwZS5faW5pdDtcbiAgICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBvcHRpb25zLmluaXQgPSBvcHRpb25zLmluaXRcbiAgICAgICAgPyBbdnVleEluaXRdLmNvbmNhdChvcHRpb25zLmluaXQpXG4gICAgICAgIDogdnVleEluaXQ7XG4gICAgICBfaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVnVleCBpbml0IGhvb2ssIGluamVjdGVkIGludG8gZWFjaCBpbnN0YW5jZXMgaW5pdCBob29rcyBsaXN0LlxuICAgKi9cblxuICBmdW5jdGlvbiB2dWV4SW5pdCAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIC8vIHN0b3JlIGluamVjdGlvblxuICAgIGlmIChvcHRpb25zLnN0b3JlKSB7XG4gICAgICB0aGlzLiRzdG9yZSA9IG9wdGlvbnMuc3RvcmU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC4kc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5wYXJlbnQuJHN0b3JlO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRldnRvb2xIb29rID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbmZ1bmN0aW9uIGRldnRvb2xQbHVnaW4gKHN0b3JlKSB7XG4gIGlmICghZGV2dG9vbEhvb2spIHsgcmV0dXJuIH1cblxuICBzdG9yZS5fZGV2dG9vbEhvb2sgPSBkZXZ0b29sSG9vaztcblxuICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4OmluaXQnLCBzdG9yZSk7XG5cbiAgZGV2dG9vbEhvb2sub24oJ3Z1ZXg6dHJhdmVsLXRvLXN0YXRlJywgZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgc3RvcmUucmVwbGFjZVN0YXRlKHRhcmdldFN0YXRlKTtcbiAgfSk7XG5cbiAgc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbiwgc3RhdGUpIHtcbiAgICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4Om11dGF0aW9uJywgbXV0YXRpb24sIHN0YXRlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBpdGVtIHRoYXQgcGFzcyB0aGUgdGVzdFxuICogYnkgc2Vjb25kIGFyZ3VtZW50IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHJldHVybiB7Kn1cbiAqL1xuLyoqXG4gKiBEZWVwIGNvcHkgdGhlIGdpdmVuIG9iamVjdCBjb25zaWRlcmluZyBjaXJjdWxhciBzdHJ1Y3R1cmUuXG4gKiBUaGlzIGZ1bmN0aW9uIGNhY2hlcyBhbGwgbmVzdGVkIG9iamVjdHMgYW5kIGl0cyBjb3BpZXMuXG4gKiBJZiBpdCBkZXRlY3RzIGNpcmN1bGFyIHN0cnVjdHVyZSwgdXNlIGNhY2hlZCBjb3B5IHRvIGF2b2lkIGluZmluaXRlIGxvb3AuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY2FjaGVcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuXG4vKipcbiAqIGZvckVhY2ggZm9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBmb3JFYWNoVmFsdWUgKG9iaiwgZm4pIHtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKG9ialtrZXldLCBrZXkpOyB9KTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtc2cpIHtcbiAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKChcIlt2dWV4XSBcIiArIG1zZykpIH1cbn1cblxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZSAocmF3TW9kdWxlLCBydW50aW1lKSB7XG4gIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gIHRoaXMuX2NoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fcmF3TW9kdWxlID0gcmF3TW9kdWxlO1xuICB2YXIgcmF3U3RhdGUgPSByYXdNb2R1bGUuc3RhdGU7XG4gIHRoaXMuc3RhdGUgPSAodHlwZW9mIHJhd1N0YXRlID09PSAnZnVuY3Rpb24nID8gcmF3U3RhdGUoKSA6IHJhd1N0YXRlKSB8fCB7fTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgbmFtZXNwYWNlZDoge30gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEubmFtZXNwYWNlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIXRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKGtleSwgbW9kdWxlKSB7XG4gIHRoaXMuX2NoaWxkcmVuW2tleV0gPSBtb2R1bGU7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGtleSkge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5ba2V5XTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiBnZXRDaGlsZCAoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAocmF3TW9kdWxlKSB7XG4gIHRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkID0gcmF3TW9kdWxlLm5hbWVzcGFjZWQ7XG4gIGlmIChyYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zID0gcmF3TW9kdWxlLmFjdGlvbnM7XG4gIH1cbiAgaWYgKHJhd01vZHVsZS5tdXRhdGlvbnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zID0gcmF3TW9kdWxlLm11dGF0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycyA9IHJhd01vZHVsZS5nZXR0ZXJzO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIGZvckVhY2hDaGlsZCAoZm4pIHtcbiAgZm9yRWFjaFZhbHVlKHRoaXMuX2NoaWxkcmVuLCBmbik7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hHZXR0ZXIgPSBmdW5jdGlvbiBmb3JFYWNoR2V0dGVyIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoQWN0aW9uID0gZnVuY3Rpb24gZm9yRWFjaEFjdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zLCBmbik7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaE11dGF0aW9uID0gZnVuY3Rpb24gZm9yRWFjaE11dGF0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zLCBmbik7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNb2R1bGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG52YXIgTW9kdWxlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIE1vZHVsZUNvbGxlY3Rpb24gKHJhd1Jvb3RNb2R1bGUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gcmVnaXN0ZXIgcm9vdCBtb2R1bGUgKFZ1ZXguU3RvcmUgb3B0aW9ucylcbiAgdGhpcy5yb290ID0gbmV3IE1vZHVsZShyYXdSb290TW9kdWxlLCBmYWxzZSk7XG5cbiAgLy8gcmVnaXN0ZXIgYWxsIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdSb290TW9kdWxlLm1vZHVsZXMpIHtcbiAgICBmb3JFYWNoVmFsdWUocmF3Um9vdE1vZHVsZS5tb2R1bGVzLCBmdW5jdGlvbiAocmF3TW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3Rlcihba2V5XSwgcmF3TW9kdWxlLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKG1vZHVsZSwga2V5KSB7XG4gICAgcmV0dXJuIG1vZHVsZS5nZXRDaGlsZChrZXkpXG4gIH0sIHRoaXMucm9vdClcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldE5hbWVzcGFjZSA9IGZ1bmN0aW9uIGdldE5hbWVzcGFjZSAocGF0aCkge1xuICB2YXIgbW9kdWxlID0gdGhpcy5yb290O1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwga2V5KSB7XG4gICAgbW9kdWxlID0gbW9kdWxlLmdldENoaWxkKGtleSk7XG4gICAgcmV0dXJuIG5hbWVzcGFjZSArIChtb2R1bGUubmFtZXNwYWNlZCA/IGtleSArICcvJyA6ICcnKVxuICB9LCAnJylcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSQxIChyYXdSb290TW9kdWxlKSB7XG4gIHVwZGF0ZSh0aGlzLnJvb3QsIHJhd1Jvb3RNb2R1bGUpO1xufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlciAocGF0aCwgcmF3TW9kdWxlLCBydW50aW1lKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgaWYgKCBydW50aW1lID09PSB2b2lkIDAgKSBydW50aW1lID0gdHJ1ZTtcblxuICB2YXIgcGFyZW50ID0gdGhpcy5nZXQocGF0aC5zbGljZSgwLCAtMSkpO1xuICB2YXIgbmV3TW9kdWxlID0gbmV3IE1vZHVsZShyYXdNb2R1bGUsIHJ1bnRpbWUpO1xuICBwYXJlbnQuYWRkQ2hpbGQocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBuZXdNb2R1bGUpO1xuXG4gIC8vIHJlZ2lzdGVyIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvckVhY2hWYWx1ZShyYXdNb2R1bGUubW9kdWxlcywgZnVuY3Rpb24gKHJhd0NoaWxkTW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3RlcihwYXRoLmNvbmNhdChrZXkpLCByYXdDaGlsZE1vZHVsZSwgcnVudGltZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyIChwYXRoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGlmICghcGFyZW50LmdldENoaWxkKGtleSkucnVudGltZSkgeyByZXR1cm4gfVxuXG4gIHBhcmVudC5yZW1vdmVDaGlsZChrZXkpO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlICh0YXJnZXRNb2R1bGUsIG5ld01vZHVsZSkge1xuICAvLyB1cGRhdGUgdGFyZ2V0IG1vZHVsZVxuICB0YXJnZXRNb2R1bGUudXBkYXRlKG5ld01vZHVsZSk7XG5cbiAgLy8gdXBkYXRlIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChuZXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvciAodmFyIGtleSBpbiBuZXdNb2R1bGUubW9kdWxlcykge1xuICAgICAgaWYgKCF0YXJnZXRNb2R1bGUuZ2V0Q2hpbGQoa2V5KSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJbdnVleF0gdHJ5aW5nIHRvIGFkZCBhIG5ldyBtb2R1bGUgJ1wiICsga2V5ICsgXCInIG9uIGhvdCByZWxvYWRpbmcsIFwiICtcbiAgICAgICAgICAnbWFudWFsIHJlbG9hZCBpcyBuZWVkZWQnXG4gICAgICAgICk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKHRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpLCBuZXdNb2R1bGUubW9kdWxlc1trZXldKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFZ1ZTsgLy8gYmluZCBvbiBpbnN0YWxsXG5cbnZhciBTdG9yZSA9IGZ1bmN0aW9uIFN0b3JlIChvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBhc3NlcnQoVnVlLCBcIm11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLlwiKTtcbiAgYXNzZXJ0KHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJywgXCJ2dWV4IHJlcXVpcmVzIGEgUHJvbWlzZSBwb2x5ZmlsbCBpbiB0aGlzIGJyb3dzZXIuXCIpO1xuXG4gIHZhciBzdGF0ZSA9IG9wdGlvbnMuc3RhdGU7IGlmICggc3RhdGUgPT09IHZvaWQgMCApIHN0YXRlID0ge307XG4gIHZhciBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zOyBpZiAoIHBsdWdpbnMgPT09IHZvaWQgMCApIHBsdWdpbnMgPSBbXTtcbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0OyBpZiAoIHN0cmljdCA9PT0gdm9pZCAwICkgc3RyaWN0ID0gZmFsc2U7XG5cbiAgLy8gc3RvcmUgaW50ZXJuYWwgc3RhdGVcbiAgdGhpcy5fY29tbWl0dGluZyA9IGZhbHNlO1xuICB0aGlzLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fbXV0YXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9tb2R1bGVzID0gbmV3IE1vZHVsZUNvbGxlY3Rpb24ob3B0aW9ucyk7XG4gIHRoaXMuX21vZHVsZXNOYW1lc3BhY2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuICB0aGlzLl93YXRjaGVyVk0gPSBuZXcgVnVlKCk7XG5cbiAgLy8gYmluZCBjb21taXQgYW5kIGRpc3BhdGNoIHRvIHNlbGZcbiAgdmFyIHN0b3JlID0gdGhpcztcbiAgdmFyIHJlZiA9IHRoaXM7XG4gIHZhciBkaXNwYXRjaCA9IHJlZi5kaXNwYXRjaDtcbiAgdmFyIGNvbW1pdCA9IHJlZi5jb21taXQ7XG4gIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiBib3VuZERpc3BhdGNoICh0eXBlLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoLmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQpXG4gIH07XG4gIHRoaXMuY29tbWl0ID0gZnVuY3Rpb24gYm91bmRDb21taXQgKHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29tbWl0LmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpXG4gIH07XG5cbiAgLy8gc3RyaWN0IG1vZGVcbiAgdGhpcy5zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgLy8gaW5pdCByb290IG1vZHVsZS5cbiAgLy8gdGhpcyBhbHNvIHJlY3Vyc2l2ZWx5IHJlZ2lzdGVycyBhbGwgc3ViLW1vZHVsZXNcbiAgLy8gYW5kIGNvbGxlY3RzIGFsbCBtb2R1bGUgZ2V0dGVycyBpbnNpZGUgdGhpcy5fd3JhcHBlZEdldHRlcnNcbiAgaW5zdGFsbE1vZHVsZSh0aGlzLCBzdGF0ZSwgW10sIHRoaXMuX21vZHVsZXMucm9vdCk7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgc3RvcmUgdm0sIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgcmVhY3Rpdml0eVxuICAvLyAoYWxzbyByZWdpc3RlcnMgX3dyYXBwZWRHZXR0ZXJzIGFzIGNvbXB1dGVkIHByb3BlcnRpZXMpXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCBzdGF0ZSk7XG5cbiAgLy8gYXBwbHkgcGx1Z2luc1xuICBwbHVnaW5zLmNvbmNhdChkZXZ0b29sUGx1Z2luKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHsgcmV0dXJuIHBsdWdpbih0aGlzJDEpOyB9KTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IHN0YXRlOiB7fSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc3RhdGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdm0uX2RhdGEuJCRzdGF0ZVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnN0YXRlLnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gIGFzc2VydChmYWxzZSwgXCJVc2Ugc3RvcmUucmVwbGFjZVN0YXRlKCkgdG8gZXhwbGljaXQgcmVwbGFjZSBzdG9yZSBzdGF0ZS5cIik7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gY29tbWl0IChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGNvbW1pdFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG4gICAgdmFyIG9wdGlvbnMgPSByZWYub3B0aW9ucztcblxuICB2YXIgbXV0YXRpb24gPSB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQgfTtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fbXV0YXRpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICBlbnRyeS5mb3JFYWNoKGZ1bmN0aW9uIGNvbW1pdEl0ZXJhdG9yIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKHBheWxvYWQpO1xuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5fc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIobXV0YXRpb24sIHRoaXMkMS5zdGF0ZSk7IH0pO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2lsZW50KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbdnVleF0gbXV0YXRpb24gdHlwZTogXCIgKyB0eXBlICsgXCIuIFNpbGVudCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gXCIgK1xuICAgICAgJ1VzZSB0aGUgZmlsdGVyIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIHZ1ZS1kZXZ0b29scydcbiAgICApO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAoX3R5cGUsIF9wYXlsb2FkKSB7XG4gIC8vIGNoZWNrIG9iamVjdC1zdHlsZSBkaXNwYXRjaFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcblxuICB2YXIgZW50cnkgPSB0aGlzLl9hY3Rpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIGVudHJ5Lmxlbmd0aCA+IDFcbiAgICA/IFByb21pc2UuYWxsKGVudHJ5Lm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlcihwYXlsb2FkKTsgfSkpXG4gICAgOiBlbnRyeVswXShwYXlsb2FkKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZSAoZm4pIHtcbiAgdmFyIHN1YnMgPSB0aGlzLl9zdWJzY3JpYmVycztcbiAgaWYgKHN1YnMuaW5kZXhPZihmbikgPCAwKSB7XG4gICAgc3Vicy5wdXNoKGZuKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gc3Vicy5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICBzdWJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIHdhdGNoIChnZXR0ZXIsIGNiLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgYXNzZXJ0KHR5cGVvZiBnZXR0ZXIgPT09ICdmdW5jdGlvbicsIFwic3RvcmUud2F0Y2ggb25seSBhY2NlcHRzIGEgZnVuY3Rpb24uXCIpO1xuICByZXR1cm4gdGhpcy5fd2F0Y2hlclZNLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBnZXR0ZXIodGhpcyQxLnN0YXRlLCB0aGlzJDEuZ2V0dGVycyk7IH0sIGNiLCBvcHRpb25zKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAoc3RhdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEuX3ZtLl9kYXRhLiQkc3RhdGUgPSBzdGF0ZTtcbiAgfSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiByZWdpc3Rlck1vZHVsZSAocGF0aCwgcmF3TW9kdWxlKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuICBhc3NlcnQoQXJyYXkuaXNBcnJheShwYXRoKSwgXCJtb2R1bGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIEFycmF5LlwiKTtcbiAgdGhpcy5fbW9kdWxlcy5yZWdpc3RlcihwYXRoLCByYXdNb2R1bGUpO1xuICBpbnN0YWxsTW9kdWxlKHRoaXMsIHRoaXMuc3RhdGUsIHBhdGgsIHRoaXMuX21vZHVsZXMuZ2V0KHBhdGgpKTtcbiAgLy8gcmVzZXQgc3RvcmUgdG8gdXBkYXRlIGdldHRlcnMuLi5cbiAgcmVzZXRTdG9yZVZNKHRoaXMsIHRoaXMuc3RhdGUpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLnVucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTW9kdWxlIChwYXRoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdOyB9XG4gIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB0aGlzLl9tb2R1bGVzLnVucmVnaXN0ZXIocGF0aCk7XG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnRTdGF0ZSA9IGdldE5lc3RlZFN0YXRlKHRoaXMkMS5zdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIFZ1ZS5kZWxldGUocGFyZW50U3RhdGUsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSk7XG4gIH0pO1xuICByZXNldFN0b3JlKHRoaXMpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLmhvdFVwZGF0ZSA9IGZ1bmN0aW9uIGhvdFVwZGF0ZSAobmV3T3B0aW9ucykge1xuICB0aGlzLl9tb2R1bGVzLnVwZGF0ZShuZXdPcHRpb25zKTtcbiAgcmVzZXRTdG9yZSh0aGlzLCB0cnVlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5fd2l0aENvbW1pdCA9IGZ1bmN0aW9uIF93aXRoQ29tbWl0IChmbikge1xuICB2YXIgY29tbWl0dGluZyA9IHRoaXMuX2NvbW1pdHRpbmc7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSB0cnVlO1xuICBmbigpO1xuICB0aGlzLl9jb21taXR0aW5nID0gY29tbWl0dGluZztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTdG9yZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiByZXNldFN0b3JlIChzdG9yZSwgaG90KSB7XG4gIHN0b3JlLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHN0YXRlID0gc3RvcmUuc3RhdGU7XG4gIC8vIGluaXQgYWxsIG1vZHVsZXNcbiAgaW5zdGFsbE1vZHVsZShzdG9yZSwgc3RhdGUsIFtdLCBzdG9yZS5fbW9kdWxlcy5yb290LCB0cnVlKTtcbiAgLy8gcmVzZXQgdm1cbiAgcmVzZXRTdG9yZVZNKHN0b3JlLCBzdGF0ZSwgaG90KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTdG9yZVZNIChzdG9yZSwgc3RhdGUsIGhvdCkge1xuICB2YXIgb2xkVm0gPSBzdG9yZS5fdm07XG5cbiAgLy8gYmluZCBzdG9yZSBwdWJsaWMgZ2V0dGVyc1xuICBzdG9yZS5nZXR0ZXJzID0ge307XG4gIHZhciB3cmFwcGVkR2V0dGVycyA9IHN0b3JlLl93cmFwcGVkR2V0dGVycztcbiAgdmFyIGNvbXB1dGVkID0ge307XG4gIGZvckVhY2hWYWx1ZSh3cmFwcGVkR2V0dGVycywgZnVuY3Rpb24gKGZuLCBrZXkpIHtcbiAgICAvLyB1c2UgY29tcHV0ZWQgdG8gbGV2ZXJhZ2UgaXRzIGxhenktY2FjaGluZyBtZWNoYW5pc21cbiAgICBjb21wdXRlZFtrZXldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4oc3RvcmUpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdG9yZS5nZXR0ZXJzLCBrZXksIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuX3ZtW2tleV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlIC8vIGZvciBsb2NhbCBnZXR0ZXJzXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHVzZSBhIFZ1ZSBpbnN0YW5jZSB0byBzdG9yZSB0aGUgc3RhdGUgdHJlZVxuICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBqdXN0IGluIGNhc2UgdGhlIHVzZXIgaGFzIGFkZGVkXG4gIC8vIHNvbWUgZnVua3kgZ2xvYmFsIG1peGluc1xuICB2YXIgc2lsZW50ID0gVnVlLmNvbmZpZy5zaWxlbnQ7XG4gIFZ1ZS5jb25maWcuc2lsZW50ID0gdHJ1ZTtcbiAgc3RvcmUuX3ZtID0gbmV3IFZ1ZSh7XG4gICAgZGF0YToge1xuICAgICAgJCRzdGF0ZTogc3RhdGVcbiAgICB9LFxuICAgIGNvbXB1dGVkOiBjb21wdXRlZFxuICB9KTtcbiAgVnVlLmNvbmZpZy5zaWxlbnQgPSBzaWxlbnQ7XG5cbiAgLy8gZW5hYmxlIHN0cmljdCBtb2RlIGZvciBuZXcgdm1cbiAgaWYgKHN0b3JlLnN0cmljdCkge1xuICAgIGVuYWJsZVN0cmljdE1vZGUoc3RvcmUpO1xuICB9XG5cbiAgaWYgKG9sZFZtKSB7XG4gICAgaWYgKGhvdCkge1xuICAgICAgLy8gZGlzcGF0Y2ggY2hhbmdlcyBpbiBhbGwgc3Vic2NyaWJlZCB3YXRjaGVyc1xuICAgICAgLy8gdG8gZm9yY2UgZ2V0dGVyIHJlLWV2YWx1YXRpb24gZm9yIGhvdCByZWxvYWRpbmcuXG4gICAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9sZFZtLl9kYXRhLiQkc3RhdGUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFZ1ZS5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJldHVybiBvbGRWbS4kZGVzdHJveSgpOyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsTW9kdWxlIChzdG9yZSwgcm9vdFN0YXRlLCBwYXRoLCBtb2R1bGUsIGhvdCkge1xuICB2YXIgaXNSb290ID0gIXBhdGgubGVuZ3RoO1xuICB2YXIgbmFtZXNwYWNlID0gc3RvcmUuX21vZHVsZXMuZ2V0TmFtZXNwYWNlKHBhdGgpO1xuXG4gIC8vIHJlZ2lzdGVyIGluIG5hbWVzcGFjZSBtYXBcbiAgaWYgKG1vZHVsZS5uYW1lc3BhY2VkKSB7XG4gICAgc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSA9IG1vZHVsZTtcbiAgfVxuXG4gIC8vIHNldCBzdGF0ZVxuICBpZiAoIWlzUm9vdCAmJiAhaG90KSB7XG4gICAgdmFyIHBhcmVudFN0YXRlID0gZ2V0TmVzdGVkU3RhdGUocm9vdFN0YXRlLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgdmFyIG1vZHVsZU5hbWUgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgc3RvcmUuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgICAgVnVlLnNldChwYXJlbnRTdGF0ZSwgbW9kdWxlTmFtZSwgbW9kdWxlLnN0YXRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBsb2NhbCA9IG1vZHVsZS5jb250ZXh0ID0gbWFrZUxvY2FsQ29udGV4dChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKTtcblxuICBtb2R1bGUuZm9yRWFjaE11dGF0aW9uKGZ1bmN0aW9uIChtdXRhdGlvbiwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyTXV0YXRpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBtdXRhdGlvbiwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEFjdGlvbihmdW5jdGlvbiAoYWN0aW9uLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJBY3Rpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBhY3Rpb24sIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hHZXR0ZXIoZnVuY3Rpb24gKGdldHRlciwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyR2V0dGVyKHN0b3JlLCBuYW1lc3BhY2VkVHlwZSwgZ2V0dGVyLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkLCBrZXkpIHtcbiAgICBpbnN0YWxsTW9kdWxlKHN0b3JlLCByb290U3RhdGUsIHBhdGguY29uY2F0KGtleSksIGNoaWxkLCBob3QpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBtYWtlIGxvY2FsaXplZCBkaXNwYXRjaCwgY29tbWl0LCBnZXR0ZXJzIGFuZCBzdGF0ZVxuICogaWYgdGhlcmUgaXMgbm8gbmFtZXNwYWNlLCBqdXN0IHVzZSByb290IG9uZXNcbiAqL1xuZnVuY3Rpb24gbWFrZUxvY2FsQ29udGV4dCAoc3RvcmUsIG5hbWVzcGFjZSwgcGF0aCkge1xuICB2YXIgbm9OYW1lc3BhY2UgPSBuYW1lc3BhY2UgPT09ICcnO1xuXG4gIHZhciBsb2NhbCA9IHtcbiAgICBkaXNwYXRjaDogbm9OYW1lc3BhY2UgPyBzdG9yZS5kaXNwYXRjaCA6IGZ1bmN0aW9uIChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucyk7XG4gICAgICB2YXIgcGF5bG9hZCA9IGFyZ3MucGF5bG9hZDtcbiAgICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zO1xuICAgICAgdmFyIHR5cGUgPSBhcmdzLnR5cGU7XG5cbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yb290KSB7XG4gICAgICAgIHR5cGUgPSBuYW1lc3BhY2UgKyB0eXBlO1xuICAgICAgICBpZiAoIXN0b3JlLl9hY3Rpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBhY3Rpb24gdHlwZTogXCIgKyAoYXJncy50eXBlKSArIFwiLCBnbG9iYWwgdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKHR5cGUsIHBheWxvYWQpXG4gICAgfSxcblxuICAgIGNvbW1pdDogbm9OYW1lc3BhY2UgPyBzdG9yZS5jb21taXQgOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKCFzdG9yZS5fbXV0YXRpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBtdXRhdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9yZS5jb21taXQodHlwZSwgcGF5bG9hZCwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGdldHRlcnMgYW5kIHN0YXRlIG9iamVjdCBtdXN0IGJlIGdvdHRlbiBsYXppbHlcbiAgLy8gYmVjYXVzZSB0aGV5IHdpbGwgYmUgY2hhbmdlZCBieSB2bSB1cGRhdGVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobG9jYWwsIHtcbiAgICBnZXR0ZXJzOiB7XG4gICAgICBnZXQ6IG5vTmFtZXNwYWNlXG4gICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyczsgfVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VMb2NhbEdldHRlcnMoc3RvcmUsIG5hbWVzcGFjZSk7IH1cbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldE5lc3RlZFN0YXRlKHN0b3JlLnN0YXRlLCBwYXRoKTsgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGxvY2FsXG59XG5cbmZ1bmN0aW9uIG1ha2VMb2NhbEdldHRlcnMgKHN0b3JlLCBuYW1lc3BhY2UpIHtcbiAgdmFyIGdldHRlcnNQcm94eSA9IHt9O1xuXG4gIHZhciBzcGxpdFBvcyA9IG5hbWVzcGFjZS5sZW5ndGg7XG4gIE9iamVjdC5rZXlzKHN0b3JlLmdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAvLyBza2lwIGlmIHRoZSB0YXJnZXQgZ2V0dGVyIGlzIG5vdCBtYXRjaCB0aGlzIG5hbWVzcGFjZVxuICAgIGlmICh0eXBlLnNsaWNlKDAsIHNwbGl0UG9zKSAhPT0gbmFtZXNwYWNlKSB7IHJldHVybiB9XG5cbiAgICAvLyBleHRyYWN0IGxvY2FsIGdldHRlciB0eXBlXG4gICAgdmFyIGxvY2FsVHlwZSA9IHR5cGUuc2xpY2Uoc3BsaXRQb3MpO1xuXG4gICAgLy8gQWRkIGEgcG9ydCB0byB0aGUgZ2V0dGVycyBwcm94eS5cbiAgICAvLyBEZWZpbmUgYXMgZ2V0dGVyIHByb3BlcnR5IGJlY2F1c2VcbiAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBldmFsdWF0ZSB0aGUgZ2V0dGVycyBpbiB0aGlzIHRpbWUuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldHRlcnNQcm94eSwgbG9jYWxUeXBlLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLmdldHRlcnNbdHlwZV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBnZXR0ZXJzUHJveHlcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gfHwgKHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZE11dGF0aW9uSGFuZGxlciAocGF5bG9hZCkge1xuICAgIGhhbmRsZXIobG9jYWwuc3RhdGUsIHBheWxvYWQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJBY3Rpb24gKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCkge1xuICB2YXIgZW50cnkgPSBzdG9yZS5fYWN0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX2FjdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZEFjdGlvbkhhbmRsZXIgKHBheWxvYWQsIGNiKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIoe1xuICAgICAgZGlzcGF0Y2g6IGxvY2FsLmRpc3BhdGNoLFxuICAgICAgY29tbWl0OiBsb2NhbC5jb21taXQsXG4gICAgICBnZXR0ZXJzOiBsb2NhbC5nZXR0ZXJzLFxuICAgICAgc3RhdGU6IGxvY2FsLnN0YXRlLFxuICAgICAgcm9vdEdldHRlcnM6IHN0b3JlLmdldHRlcnMsXG4gICAgICByb290U3RhdGU6IHN0b3JlLnN0YXRlXG4gICAgfSwgcGF5bG9hZCwgY2IpO1xuICAgIGlmICghaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcyA9IFByb21pc2UucmVzb2x2ZShyZXMpO1xuICAgIH1cbiAgICBpZiAoc3RvcmUuX2RldnRvb2xIb29rKSB7XG4gICAgICByZXR1cm4gcmVzLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc3RvcmUuX2RldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6ZXJyb3InLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckdldHRlciAoc3RvcmUsIHR5cGUsIHJhd0dldHRlciwgbG9jYWwpIHtcbiAgaWYgKHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSkge1xuICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIGR1cGxpY2F0ZSBnZXR0ZXIga2V5OiBcIiArIHR5cGUpKTtcbiAgICByZXR1cm5cbiAgfVxuICBzdG9yZS5fd3JhcHBlZEdldHRlcnNbdHlwZV0gPSBmdW5jdGlvbiB3cmFwcGVkR2V0dGVyIChzdG9yZSkge1xuICAgIHJldHVybiByYXdHZXR0ZXIoXG4gICAgICBsb2NhbC5zdGF0ZSwgLy8gbG9jYWwgc3RhdGVcbiAgICAgIGxvY2FsLmdldHRlcnMsIC8vIGxvY2FsIGdldHRlcnNcbiAgICAgIHN0b3JlLnN0YXRlLCAvLyByb290IHN0YXRlXG4gICAgICBzdG9yZS5nZXR0ZXJzIC8vIHJvb3QgZ2V0dGVyc1xuICAgIClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlU3RyaWN0TW9kZSAoc3RvcmUpIHtcbiAgc3RvcmUuX3ZtLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhLiQkc3RhdGUgfSwgZnVuY3Rpb24gKCkge1xuICAgIGFzc2VydChzdG9yZS5fY29tbWl0dGluZywgXCJEbyBub3QgbXV0YXRlIHZ1ZXggc3RvcmUgc3RhdGUgb3V0c2lkZSBtdXRhdGlvbiBoYW5kbGVycy5cIik7XG4gIH0sIHsgZGVlcDogdHJ1ZSwgc3luYzogdHJ1ZSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TmVzdGVkU3RhdGUgKHN0YXRlLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aFxuICAgID8gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlLCBrZXkpIHsgcmV0dXJuIHN0YXRlW2tleV07IH0sIHN0YXRlKVxuICAgIDogc3RhdGVcbn1cblxuZnVuY3Rpb24gdW5pZnlPYmplY3RTdHlsZSAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICBpZiAoaXNPYmplY3QodHlwZSkgJiYgdHlwZS50eXBlKSB7XG4gICAgb3B0aW9ucyA9IHBheWxvYWQ7XG4gICAgcGF5bG9hZCA9IHR5cGU7XG4gICAgdHlwZSA9IHR5cGUudHlwZTtcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycsIChcIkV4cGVjdHMgc3RyaW5nIGFzIHRoZSB0eXBlLCBidXQgZm91bmQgXCIgKyAodHlwZW9mIHR5cGUpICsgXCIuXCIpKTtcblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkLCBvcHRpb25zOiBvcHRpb25zIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFsbCAoX1Z1ZSkge1xuICBpZiAoVnVlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgICdbdnVleF0gYWxyZWFkeSBpbnN0YWxsZWQuIFZ1ZS51c2UoVnVleCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgVnVlID0gX1Z1ZTtcbiAgYXBwbHlNaXhpbihWdWUpO1xufVxuXG4vLyBhdXRvIGluc3RhbGwgaW4gZGlzdCBtb2RlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICBpbnN0YWxsKHdpbmRvdy5WdWUpO1xufVxuXG52YXIgbWFwU3RhdGUgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgc3RhdGVzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKHN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZFN0YXRlICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHN0b3JlLnN0YXRlO1xuICAgICAgdmFyIGdldHRlcnMgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzO1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBTdGF0ZScsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBtb2R1bGUuY29udGV4dC5zdGF0ZTtcbiAgICAgICAgZ2V0dGVycyA9IG1vZHVsZS5jb250ZXh0LmdldHRlcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5jYWxsKHRoaXMsIHN0YXRlLCBnZXR0ZXJzKVxuICAgICAgICA6IHN0YXRlW3ZhbF1cbiAgICB9O1xuICAgIC8vIG1hcmsgdnVleCBnZXR0ZXIgZm9yIGRldnRvb2xzXG4gICAgcmVzW2tleV0udnVleCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxudmFyIG1hcE11dGF0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBtdXRhdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAobXV0YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHZhbCA9IG5hbWVzcGFjZSArIHZhbDtcbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZE11dGF0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcE11dGF0aW9ucycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuY29tbWl0LmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwR2V0dGVycyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBnZXR0ZXJzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkR2V0dGVyICgpIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwR2V0dGVycycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoISh2YWwgaW4gdGhpcy4kc3RvcmUuZ2V0dGVycykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBnZXR0ZXI6IFwiICsgdmFsKSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnNbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwQWN0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBhY3Rpb25zKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkQWN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcEFjdGlvbnMnLCBuYW1lc3BhY2UpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmRpc3BhdGNoLmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG5mdW5jdGlvbiBub3JtYWxpemVNYXAgKG1hcCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXApXG4gICAgPyBtYXAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IGtleSB9KTsgfSlcbiAgICA6IE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IG1hcFtrZXldIH0pOyB9KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lc3BhY2UgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZXNwYWNlLCBtYXApIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG1hcCA9IG5hbWVzcGFjZTtcbiAgICAgIG5hbWVzcGFjZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlLmNoYXJBdChuYW1lc3BhY2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgbmFtZXNwYWNlICs9ICcvJztcbiAgICB9XG4gICAgcmV0dXJuIGZuKG5hbWVzcGFjZSwgbWFwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZUJ5TmFtZXNwYWNlIChzdG9yZSwgaGVscGVyLCBuYW1lc3BhY2UpIHtcbiAgdmFyIG1vZHVsZSA9IHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV07XG4gIGlmICghbW9kdWxlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gbW9kdWxlIG5hbWVzcGFjZSBub3QgZm91bmQgaW4gXCIgKyBoZWxwZXIgKyBcIigpOiBcIiArIG5hbWVzcGFjZSkpO1xuICB9XG4gIHJldHVybiBtb2R1bGVcbn1cblxudmFyIGluZGV4X2VzbSA9IHtcbiAgU3RvcmU6IFN0b3JlLFxuICBpbnN0YWxsOiBpbnN0YWxsLFxuICB2ZXJzaW9uOiAnMi4zLjAnLFxuICBtYXBTdGF0ZTogbWFwU3RhdGUsXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLFxuICBtYXBHZXR0ZXJzOiBtYXBHZXR0ZXJzLFxuICBtYXBBY3Rpb25zOiBtYXBBY3Rpb25zXG59O1xuXG5leHBvcnQgeyBTdG9yZSwgbWFwU3RhdGUsIG1hcE11dGF0aW9ucywgbWFwR2V0dGVycywgbWFwQWN0aW9ucyB9O2V4cG9ydCBkZWZhdWx0IGluZGV4X2VzbTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdnVleC9kaXN0L3Z1ZXguZXNtLmpzIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3Jvb3QuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNBcnJheS5qcyIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fU3ltYm9sLmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0tleTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL190b0tleS5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNPYmplY3QuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTeW1ib2w7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc1N5bWJvbC5qcyIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fTGlzdENhY2hlLmpzIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2lzSW5kZXguanMiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlQ3JlYXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pZGVudGl0eS5qcyIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCIvKiFcbiAqIFZ1ZS5qcyB2Mi41LjEzXG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUgZS5nLiBbb2JqZWN0IE9iamVjdF1cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuICovXG5mdW5jdGlvbiBiaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuXG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcbiAgICovXG4gIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG4gICAqL1xuICBwZXJmb3JtYW5jZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIFdhcm4gaGFuZGxlciBmb3Igd2F0Y2hlciB3YXJuc1xuICAgKi9cbiAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBbXSxcblxuICAvKipcbiAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm0gfHwge307XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCQxKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSwgZGVlcCkge1xuICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICBjb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIGlmIChkZWVwKSB7XG4gICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICBjbG9uZWQuY2hpbGRyZW4gPSBjbG9uZVZOb2Rlcyh2bm9kZS5jaGlsZHJlbiwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChjb21wb25lbnRPcHRpb25zICYmIGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4pIHtcbiAgICAgIGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4gPSBjbG9uZVZOb2Rlcyhjb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzLCBkZWVwKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSwgZGVlcCk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlXG59O1xuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaGVzIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbi8qKlxuICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb2JzZXJ2ZShpdGVtc1tpXSk7XG4gIH1cbn07XG5cbi8vIGhlbHBlcnNcblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG4gKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuICovXG5mdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG4gIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cbn1cblxuLyoqXG4gKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcbiAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iO1xuICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcbiAgICBvYiA9IHZhbHVlLl9fb2JfXztcbiAgfSBlbHNlIGlmIChcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgIHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgIH1cbiAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCk7XG4gICAgICBkZXAubm90aWZ5KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIEFkZHMgdGhlIG5ldyBwcm9wZXJ0eSBhbmRcbiAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAqIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5mdW5jdGlvbiBtZXJnZURhdGFPckZuIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLFxuICAgICAgICB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWxcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgJ2RlZmluaXRpb25zLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gIH1cblxuICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSlcbn07XG5cbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG59KTtcblxuLyoqXG4gKiBBc3NldHNcbiAqXG4gKiBXaGVuIGEgdm0gaXMgcHJlc2VudCAoaW5zdGFuY2UgY3JlYXRpb24pLCB3ZSBuZWVkIHRvIGRvXG4gKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICBpZiAoY2hpbGRWYWwpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSB7fTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZm9yICh2YXIga2V5JDEgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleSQxXTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgaWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICB9XG4gICAgcmV0W2tleSQxXSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgfVxuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXG4gKi9cbnN0cmF0cy5wcm9wcyA9XG5zdHJhdHMubWV0aG9kcyA9XG5zdHJhdHMuaW5qZWN0ID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIGlmIChjaGlsZFZhbCAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIG9wdGlvbnMucHJvcHMgPSByZXM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gIHZhciBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgaWYgKCFpbmplY3QpIHsgcmV0dXJuIH1cbiAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbmplY3QpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgIDogeyBmcm9tOiB2YWwgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XG4gIH1cblxuICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG4gIHZhciBleHRlbmRzRnJvbSA9IGNoaWxkLmV4dGVuZHM7XG4gIGlmIChleHRlbmRzRnJvbSkge1xuICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgLy8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3RcbiAgaWYgKGhhc093bihhc3NldHMsIGlkKSkgeyByZXR1cm4gYXNzZXRzW2lkXSB9XG4gIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG4gIHZhciBQYXNjYWxDYXNlSWQgPSBjYXBpdGFsaXplKGNhbWVsaXplZElkKTtcbiAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG4gICAgICB2YWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuICB9XG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgLy8gc2tpcCB2YWxpZGF0aW9uIGZvciB3ZWV4IHJlY3ljbGUtbGlzdCBjaGlsZCBjb21wb25lbnQgcHJvcHNcbiAgICAhKGZhbHNlICYmIGlzT2JqZWN0KHZhbHVlKSAmJiAoJ0BiaW5kaW5nJyBpbiB2YWx1ZSkpXG4gICkge1xuICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuICAvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKSArXG4gICAgICBcIiwgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNUeXBlICh0eXBlLCBmbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG4gICAgcmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmICh2bSkge1xuICAgIHZhciBjdXIgPSB2bTtcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKiAgKi9cbi8qIGdsb2JhbHMgTWVzc2FnZUNoYW5uZWwgKi9cblxudmFyIGNhbGxiYWNrcyA9IFtdO1xudmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2hDYWxsYmFja3MgKCkge1xuICBwZW5kaW5nID0gZmFsc2U7XG4gIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuICAgIGNvcGllc1tpXSgpO1xuICB9XG59XG5cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgYm90aCBtaWNybyBhbmQgbWFjcm8gdGFza3MuXG4vLyBJbiA8IDIuNCB3ZSB1c2VkIG1pY3JvIHRhc2tzIGV2ZXJ5d2hlcmUsIGJ1dCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3Mgd2hlcmVcbi8vIG1pY3JvIHRhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZXMgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTApIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZVxuLy8gZXZlbnQgKCM2NTY2KS4gSG93ZXZlciwgdXNpbmcgbWFjcm8gdGFza3MgZXZlcnl3aGVyZSBhbHNvIGhhcyBzdWJ0bGUgcHJvYmxlbXNcbi8vIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludCAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cbi8vIEhlcmUgd2UgdXNlIG1pY3JvIHRhc2sgYnkgZGVmYXVsdCwgYnV0IGV4cG9zZSBhIHdheSB0byBmb3JjZSBtYWNybyB0YXNrIHdoZW5cbi8vIG5lZWRlZCAoZS5nLiBpbiBldmVudCBoYW5kbGVycyBhdHRhY2hlZCBieSB2LW9uKS5cbnZhciBtaWNyb1RpbWVyRnVuYztcbnZhciBtYWNyb1RpbWVyRnVuYztcbnZhciB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcblxuLy8gRGV0ZXJtaW5lIChtYWNybykgVGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8vIFRlY2huaWNhbGx5IHNldEltbWVkaWF0ZSBzaG91bGQgYmUgdGhlIGlkZWFsIGNob2ljZSwgYnV0IGl0J3Mgb25seSBhdmFpbGFibGVcbi8vIGluIElFLiBUaGUgb25seSBwb2x5ZmlsbCB0aGF0IGNvbnNpc3RlbnRseSBxdWV1ZXMgdGhlIGNhbGxiYWNrIGFmdGVyIGFsbCBET01cbi8vIGV2ZW50cyB0cmlnZ2VyZWQgaW4gdGhlIHNhbWUgbG9vcCBpcyBieSB1c2luZyBNZXNzYWdlQ2hhbm5lbC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE1lc3NhZ2VDaGFubmVsKSB8fFxuICAvLyBQaGFudG9tSlNcbiAgTWVzc2FnZUNoYW5uZWwudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTWVzc2FnZUNoYW5uZWxDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaENhbGxiYWNrcztcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZSgxKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xuICB9O1xufVxuXG4vLyBEZXRlcm1pbmUgTWljcm9UYXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBtaWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIGZhbGxiYWNrIHRvIG1hY3JvXG4gIG1pY3JvVGltZXJGdW5jID0gbWFjcm9UaW1lckZ1bmM7XG59XG5cbi8qKlxuICogV3JhcCBhIGZ1bmN0aW9uIHNvIHRoYXQgaWYgYW55IGNvZGUgaW5zaWRlIHRyaWdnZXJzIHN0YXRlIGNoYW5nZSxcbiAqIHRoZSBjaGFuZ2VzIGFyZSBxdWV1ZWQgdXNpbmcgYSBUYXNrIGluc3RlYWQgb2YgYSBNaWNyb1Rhc2suXG4gKi9cbmZ1bmN0aW9uIHdpdGhNYWNyb1Rhc2sgKGZuKSB7XG4gIHJldHVybiBmbi5fd2l0aFRhc2sgfHwgKGZuLl93aXRoVGFzayA9IGZ1bmN0aW9uICgpIHtcbiAgICB1c2VNYWNyb1Rhc2sgPSB0cnVlO1xuICAgIHZhciByZXMgPSBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIHVzZU1hY3JvVGFzayA9IGZhbHNlO1xuICAgIHJldHVybiByZXNcbiAgfSlcbn1cblxuZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgdmFyIF9yZXNvbHZlO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUoY3R4KTtcbiAgICB9XG4gIH0pO1xuICBpZiAoIXBlbmRpbmcpIHtcbiAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICBpZiAodXNlTWFjcm9UYXNrKSB7XG4gICAgICBtYWNyb1RpbWVyRnVuYygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaWNyb1RpbWVyRnVuYygpO1xuICAgIH1cbiAgfVxuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG4gICAgUHJveHkudG9TdHJpbmcoKS5tYXRjaCgvbmF0aXZlIGNvZGUvKTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb25lZFtpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0cyA9IGZhY3RvcnkuY29udGV4dHMgPSBbY29udGV4dF07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XG4gICAgaWYgKHNsb3RzW25hbWUkMV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCh2bS4kb3B0aW9ucy50ZW1wbGF0ZSAmJiB2bS4kb3B0aW9ucy50ZW1wbGF0ZS5jaGFyQXQoMCkgIT09ICcjJykgfHxcbiAgICAgICAgdm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXG4gICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG4gICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG4gIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwgbnVsbCwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBoYXMgc2xvdCBjaGlsZHJlblxuICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuICB2YXIgaGFzQ2hpbGRyZW4gPSAhIShcbiAgICByZW5kZXJDaGlsZHJlbiB8fCAgICAgICAgICAgICAgIC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgIHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcbiAgICB2bS4kc2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0IC8vIGhhcyBvbGQgc2NvcGVkIHNsb3RzXG4gICk7XG5cbiAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIHZtLiR2bm9kZSA9IHBhcmVudFZub2RlOyAvLyB1cGRhdGUgdm0ncyBwbGFjZWhvbGRlciBub2RlIHdpdGhvdXQgcmUtcmVuZGVyXG5cbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgLy8gdGhlc2UgYXJlIGFsc28gcmVhY3RpdmUgc28gdGhleSBtYXkgdHJpZ2dlciBjaGlsZCB1cGRhdGUgaWYgdGhlIGNoaWxkXG4gIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXG4gIHZtLiRhdHRycyA9IChwYXJlbnRWbm9kZS5kYXRhICYmIHBhcmVudFZub2RlLmRhdGEuYXR0cnMpIHx8IGVtcHR5T2JqZWN0O1xuICB2bS4kbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuXG4gIC8vIHVwZGF0ZSBwcm9wc1xuICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cblxuICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuICB9XG4gIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gIGlmIChoYXNDaGlsZHJlbikge1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgdm0uJGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQyID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zLFxuICBpc1JlbmRlcldhdGNoZXJcbikge1xuICB0aGlzLnZtID0gdm07XG4gIGlmIChpc1JlbmRlcldhdGNoZXIpIHtcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gIH1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzICYmIGhhc093bihtZXRob2RzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBkYXRhIHByb3BlcnR5LlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgfVxuICB9XG4gIC8vIG9ic2VydmUgZGF0YVxuICBvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgdGFyZ2V0LFxuICBrZXksXG4gIHVzZXJEZWZcbikge1xuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDogdXNlckRlZjtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGtleU9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGtleU9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0IChpbmplY3QsIHZtKSB7XG4gIGlmIChpbmplY3QpIHtcbiAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluamVjdCwga2V5KS5lbnVtZXJhYmxlXG4gICAgICB9KVxuICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciBwcm92aWRlS2V5ID0gaW5qZWN0W2tleV0uZnJvbTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVEZWZhdWx0ID0gaW5qZWN0W2tleV0uZGVmYXVsdDtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHR5cGVvZiBwcm92aWRlRGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlRGVmYXVsdDtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybigoXCJJbmplY3Rpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICovXG5mdW5jdGlvbiByZW5kZXJMaXN0IChcbiAgdmFsLFxuICByZW5kZXJcbikge1xuICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNEZWYocmV0KSkge1xuICAgIChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuICBuYW1lLFxuICBmYWxsYmFjayxcbiAgcHJvcHMsXG4gIGJpbmRPYmplY3Rcbikge1xuICB2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG4gIHZhciBub2RlcztcbiAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgIHByb3BzID0gcHJvcHMgfHwge307XG4gICAgaWYgKGJpbmRPYmplY3QpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdzbG90IHYtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0JyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwcm9wcyA9IGV4dGVuZChleHRlbmQoe30sIGJpbmRPYmplY3QpLCBwcm9wcyk7XG4gICAgfVxuICAgIG5vZGVzID0gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFjaztcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3ROb2Rlcy5fcmVuZGVyZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIG5vZGVzID0gc2xvdE5vZGVzIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKiBleHBvc2VkIGFzIFZ1ZS5wcm90b3R5cGUuX2tcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICovXG5mdW5jdGlvbiBjaGVja0tleUNvZGVzIChcbiAgZXZlbnRLZXlDb2RlLFxuICBrZXksXG4gIGJ1aWx0SW5BbGlhcyxcbiAgZXZlbnRLZXlOYW1lXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoa2V5Q29kZXMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICAgIHJldHVybiBrZXlDb2Rlcy5pbmRleE9mKGV2ZW50S2V5Q29kZSkgPT09IC0xXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gICAgfVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB2YXIgaGFzaDtcbiAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGFzcycgfHxcbiAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcbiAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGtleSBpbiBoYXNoKSkge1xuICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cbiAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgICAgICAgICAgb25bKFwidXBkYXRlOlwiICsga2V5KV0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSBsb29wKCBrZXkgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyAoXG4gIGluZGV4LFxuICBpc0luRm9yXG4pIHtcbiAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gdGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwoXG4gICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgbnVsbCxcbiAgICB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyAoZGF0YSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9uID0gZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gb25ba2V5XTtcbiAgICAgICAgdmFyIG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gIHRhcmdldC5fbiA9IHRvTnVtYmVyO1xuICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgdGFyZ2V0Ll90ID0gcmVuZGVyU2xvdDtcbiAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICB0YXJnZXQuX20gPSByZW5kZXJTdGF0aWM7XG4gIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gIHRhcmdldC5fYiA9IGJpbmRPYmplY3RQcm9wcztcbiAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICB0YXJnZXQuX3UgPSByZXNvbHZlU2NvcGVkU2xvdHM7XG4gIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCAoXG4gIGRhdGEsXG4gIHByb3BzLFxuICBjaGlsZHJlbixcbiAgcGFyZW50LFxuICBDdG9yXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBkYXRhLm9uIHx8IGVtcHR5T2JqZWN0O1xuICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpOyB9O1xuXG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XG4gIHZhciBuZWVkTm9ybWFsaXphdGlvbiA9ICFpc0NvbXBpbGVkO1xuXG4gIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGlzQ29tcGlsZWQpIHtcbiAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBwcmUtcmVzb2x2ZSBzbG90cyBmb3IgcmVuZGVyU2xvdCgpXG4gICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBkYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICAgIHZhciB2bm9kZSA9IGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICBpZiAodm5vZGUpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZm5Db250ZXh0ID0gY29udGV4dFZtO1xuICAgIHZub2RlLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKGRhdGEuc2xvdCkge1xuICAgICAgKHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cblxuXG5cbi8vIFJlZ2lzdGVyIHRoZSBjb21wb25lbnQgaG9vayB0byB3ZWV4IG5hdGl2ZSByZW5kZXIgZW5naW5lLlxuLy8gVGhlIGhvb2sgd2lsbCBiZSB0cmlnZ2VyZWQgYnkgbmF0aXZlLCBub3QgamF2YXNjcmlwdC5cblxuXG4vLyBVcGRhdGVzIHRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50IHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG5cbi8qICAqL1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vSGFua3MxMDEwMC93ZWV4LW5hdGl2ZS1kaXJlY3RpdmUvdHJlZS9tYXN0ZXIvY29tcG9uZW50XG5cbi8vIGxpc3RlbmluZyBvbiBuYXRpdmUgY2FsbGJhY2tcblxuLyogICovXG5cbi8qICAqL1xuXG4vLyBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfSBlbHNlIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG4gICAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgIH1cbiAgfSxcblxuICBwcmVwYXRjaDogZnVuY3Rpb24gcHJlcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIHVwZGF0ZUNoaWxkQ29tcG9uZW50KFxuICAgICAgY2hpbGQsXG4gICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICApO1xuICB9LFxuXG4gIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dDtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG4gICAgfVxuICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgaWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgLy8gRHVyaW5nIHVwZGF0ZXMsIGEga2VwdC1hbGl2ZSBjb21wb25lbnQncyBjaGlsZCBjb21wb25lbnRzIG1heVxuICAgICAgICAvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3NcbiAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAvLyBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIHdob2xlIHBhdGNoIHByb2Nlc3MgZW5kZWQuXG4gICAgICAgIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgaWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgaG9va3NUb01lcmdlID0gT2JqZWN0LmtleXMoY29tcG9uZW50Vk5vZGVIb29rcyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG4gIEN0b3IsXG4gIGRhdGEsXG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICB0YWdcbikge1xuICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcbiAgLy8gcmVqZWN0LlxuICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FybigoXCJJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiBcIiArIChTdHJpbmcoQ3RvcikpKSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gYXN5bmMgY29tcG9uZW50XG4gIHZhciBhc3luY0ZhY3Rvcnk7XG4gIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgIGFzeW5jRmFjdG9yeSA9IEN0b3I7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yLCBjb250ZXh0KTtcbiAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKFxuICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICB0YWdcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG4gIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgaWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG4gICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgcHJvcHNcbiAgdmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cblxuICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgLy8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcbiAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHZhciBzbG90ID0gZGF0YS5zbG90O1xuICAgIGRhdGEgPSB7fTtcbiAgICBpZiAoc2xvdCkge1xuICAgICAgZGF0YS5zbG90ID0gc2xvdDtcbiAgICB9XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG4gICAgeyBDdG9yOiBDdG9yLCBwcm9wc0RhdGE6IHByb3BzRGF0YSwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMsIHRhZzogdGFnLCBjaGlsZHJlbjogY2hpbGRyZW4gfSxcbiAgICBhc3luY0ZhY3RvcnlcbiAgKTtcblxuICAvLyBXZWV4IHNwZWNpZmljOiBpbnZva2UgcmVjeWNsZS1saXN0IG9wdGltaXplZCBAcmVuZGVyIGZ1bmN0aW9uIGZvclxuICAvLyBleHRyYWN0aW5nIGNlbGwtc2xvdCB0ZW1wbGF0ZS5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhbmtzMTAxMDAvd2VleC1uYXRpdmUtZGlyZWN0aXZlL3RyZWUvbWFzdGVyL2NvbXBvbmVudFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHVzaW5nIG5vbi1wcmltaXRpdmUgdmFsdWUgYXMga2V5LCAnICtcbiAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoaXNVbmRlZihjaGlsZC5ucykgfHwgaXNUcnVlKGZvcmNlKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBpZiB0aGUgcGFyZW50IGRpZG4ndCB1cGRhdGUsIHRoZSBzbG90IG5vZGVzIHdpbGwgYmUgdGhlIG9uZXMgZnJvbVxuICAgICAgLy8gbGFzdCByZW5kZXIuIFRoZXkgbmVlZCB0byBiZSBjbG9uZWQgdG8gZW5zdXJlIFwiZnJlc2huZXNzXCIgZm9yIHRoaXMgcmVuZGVyLlxuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2YXIgc2xvdCA9IHZtLiRzbG90c1trZXldO1xuICAgICAgICAvLyBfcmVuZGVyZWQgaXMgYSBmbGFnIGFkZGVkIGJ5IHJlbmRlclNsb3QsIGJ1dCBtYXkgbm90IGJlIHByZXNlbnRcbiAgICAgICAgLy8gaWYgdGhlIHNsb3QgaXMgcGFzc2VkIGZyb20gbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zXG4gICAgICAgIGlmIChzbG90Ll9yZW5kZXJlZCB8fCAoc2xvdFswXSAmJiBzbG90WzBdLmVsbSkpIHtcbiAgICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHNsb3QsIHRydWUgLyogZGVlcCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQrKztcblxuICAgIHZhciBzdGFydFRhZywgZW5kVGFnO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBpbml0UmVuZGVyKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgaW5pdFN0YXRlKHZtKTtcbiAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICB9XG5cbiAgICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICB2YXIgcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuICBvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG5cbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHBhcmVudFZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XG4gIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcbiAgICAgIGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zIHx8ICh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zID0gW10pKTtcbiAgICBpZiAoaW5zdGFsbGVkUGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPiAtMSkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9XG4gICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgVnVlLm1peGluID0gZnVuY3Rpb24gKG1peGluKSB7XG4gICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuXG4gICAgdmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50IChvcHRpb25zKSB7XG4gICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgIH07XG4gICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgIFN1Yi5jaWQgPSBjaWQrKztcbiAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICBleHRlbmRPcHRpb25zXG4gICAgKTtcbiAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgLy8gdGhlIFZ1ZSBpbnN0YW5jZXMgYXQgZXh0ZW5zaW9uIHRpbWUsIG9uIHRoZSBleHRlbmRlZCBwcm90b3R5cGUuIFRoaXNcbiAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICBpbml0UHJvcHMkMShTdWIpO1xuICAgIH1cbiAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgIGluaXRDb21wdXRlZCQxKFN1Yik7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG4gICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICBTdWIudXNlID0gU3VwZXIudXNlO1xuXG4gICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuXG4gICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cbiAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgIC8vIGJlZW4gdXBkYXRlZC5cbiAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcbiAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG4gIHZhciBjb21wdXRlZCA9IENvbXAub3B0aW9ucy5jb21wdXRlZDtcbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRBc3NldFJlZ2lzdGVycyAoVnVlKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG4gICAqL1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICB2YXIgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICBpZiAoY2FjaGVkJCQxICYmICghY3VycmVudCB8fCBjYWNoZWQkJDEudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZVtrZXldID0gbnVsbDtcbiAgcmVtb3ZlKGtleXMsIGtleSk7XG59XG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZSwga2V5LCB0aGlzJDEua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0sXG4gICAgZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgaW5jbHVkZSA9IHJlZi5pbmNsdWRlO1xuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuNS4xMyc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIHN0cmluZ2lmaWVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG5cblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChyZWYkJDEucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja0R1cGxpY2F0ZUtleXMobmV3Q2gpO1xuICAgIH1cblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgdmFyIHNlZW5LZXlzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHtcbiAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiRHVwbGljYXRlIGtleXMgZGV0ZWN0ZWQ6ICdcIiArIGtleSArIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFxuICAgICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiAhZWwuX19pZXBoXG4gICAgICApIHtcbiAgICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuXG5cblxuXG5cblxuXG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuXG5cblxuXG5cblxuXG5cbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbi8vIGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCBieSBwcm9jZXNzQXR0cnMuXG4vLyBCeSBkZWZhdWx0IGl0IGRvZXMgTk9UIHJlbW92ZSBpdCBmcm9tIHRoZSBtYXAgKGF0dHJzTWFwKSBiZWNhdXNlIHRoZSBtYXAgaXNcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuXG4vKiAgKi9cblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBoYW5kbGVyID0gd2l0aE1hY3JvVGFzayhoYW5kbGVyKTtcbiAgaWYgKG9uY2UkJDEpIHsgaGFuZGxlciA9IGNyZWF0ZU9uY2VIYW5kbGVyKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKTsgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIuX3dpdGhUYXNrIHx8IGhhbmRsZXIsXG4gICAgY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAvLyBpbnB1dHMgd2l0aCBsYXp5IHNob3VsZCBvbmx5IGJlIHVwZGF0ZWQgd2hlbiBub3QgaW4gZm9jdXNcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xuICB2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoXG4gICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSlcbiAgICAgICkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBkaXJlY3RpdmUgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyAjNjkwM1xuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogZGlyZWN0aXZlLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn07XG5cbi8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUkMy5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlJDMuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgaW5Ccm93c2VyID8gcXVlcnkoZWwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbn07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuVnVlJDMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZSQzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi92dWUvZGlzdC92dWUucnVudGltZS5lc20uanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19NYXAuanMiLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX01hcENhY2hlLmpzIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlR2V0LmpzIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fY2FzdFBhdGguanMiLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faXNLZXkuanMiLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2VxLmpzIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0xlbmd0aC5qcyIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2tleXMuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcbnZhciBidG9hID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5idG9hICYmIHdpbmRvdy5idG9hLmJpbmQod2luZG93KSkgfHwgcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J0b2EnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgbG9hZEV2ZW50ID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG4gICAgdmFyIHhEb21haW4gPSBmYWxzZTtcblxuICAgIC8vIEZvciBJRSA4LzkgQ09SUyBzdXBwb3J0XG4gICAgLy8gT25seSBzdXBwb3J0cyBQT1NUIGFuZCBHRVQgY2FsbHMgYW5kIGRvZXNuJ3QgcmV0dXJucyB0aGUgcmVzcG9uc2UgaGVhZGVycy5cbiAgICAvLyBET04nVCBkbyB0aGlzIGZvciB0ZXN0aW5nIGIvYyBYTUxIdHRwUmVxdWVzdCBpcyBtb2NrZWQsIG5vdCBYRG9tYWluUmVxdWVzdC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuICAgICAgICAhaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSB7XG4gICAgICByZXF1ZXN0ID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgbG9hZEV2ZW50ID0gJ29ubG9hZCc7XG4gICAgICB4RG9tYWluID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKCkge307XG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7fTtcbiAgICB9XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkIHx8ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0W2xvYWRFdmVudF0gPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQgJiYgIXhEb21haW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIC8vIElFIHNlbmRzIDEyMjMgaW5zdGVhZCBvZiAyMDQgKGh0dHBzOi8vZ2l0aHViLmNvbS9temFicmlza2llL2F4aW9zL2lzc3Vlcy8yMDEpXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIHZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcblxuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19TdGFjay5qcyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYXJyYXlNYXAuanMiLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbERlZXAnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0J1ZmZlci5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCI8dGVtcGxhdGU+XHJcbjxkaXY+XHJcbiAgPGRpdiB2LWlmPVwiZ2V0VXNlckRhdGEuYWNjb3VudHR5cGUgPT0gMlwiIGNsYXNzPVwiY29sdW1uIGlzLWhhbGYgaXMtb2Zmc2V0LW9uZS1xdWFydGVyXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cclxuICAgICAgPGxhYmVsPkxlYWd1ZSBOYW1lPC9sYWJlbD5cclxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2wgaGFzLWljb25zLWxlZnRcIj5cclxuICAgICAgICA8aW5wdXQgY2xhc3M9XCJpbnB1dFwiIHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJMZWFndWUgTmFtZVwiPlxyXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCI+XHJcbiAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXRyb3BoeVwiPjwvaT5cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cclxuICAgICAgPGxhYmVsPkxlYWd1ZSBQYXNzd29yZDwvbGFiZWw+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCI+XHJcbiAgICAgICAgPGlucHV0IGNsYXNzPVwiaW5wdXRcIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiTGVhZ3VlIFBhc3N3b3JkXCI+XHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIj5cclxuICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtbG9ja1wiPjwvaT5cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cclxuICAgICAgPGxhYmVsPk1heCBQbGF5ZXJzPC9sYWJlbD5cclxuICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2wgaGFzLWljb25zLWxlZnRcIj5cclxuICAgICAgICA8aW5wdXQgY2xhc3M9XCJpbnB1dFwiIHR5cGU9XCJudW1iZXJcIiBwbGFjZWhvbGRlcj1cIk1heCBQbGF5ZXJzXCI+XHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIj5cclxuICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtaGFzaHRhZ1wiPjwvaT5cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cclxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPlN1Ym1pdDwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbiAgPGRpdiB2LWlmPVwiZ2V0VXNlckRhdGEuYWNjb3VudHR5cGUgIT0gMlwiPlxyXG4gICAgPHAgY2xhc3M9XCJib2xkLW1lc3NhZ2VcIj5UaGlzIGZlYXR1cmUgcmVxdWlyZXMgYSBQcmVtaXVtIGFjY291bnQuIFBsZWFzZSB1cGdyYWRlIHlvdXIgYWNjb3VudCBpbiBvcmRlciB0byBhY3RpdmF0ZSB0aGlzIGZlYXR1cmUuPC9wPlxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7IG1hcEdldHRlcnMsIG1hcE11dGF0aW9ucyB9IGZyb20gJ3Z1ZXgnO1xyXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG4gIGV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcblxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgY29tcHV0ZWQ6IG1hcEdldHRlcnMoW1xyXG4gICAgICAnZ2V0VXNlckRhdGEnXHJcbiAgICBdKSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgLi4ubWFwTXV0YXRpb25zKFtcclxuICAgICAgXSksXHJcbiAgICB9XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG4gIC5ib2xkLW1lc3NhZ2Uge1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgZm9udC1zaXplOiAxOHB0O1xyXG4gICAgY29sb3I6ICNmZmZjN2Y7XHJcbiAgICBmb250LXdlaWdodDogODAwO1xyXG4gIH1cclxuPC9zdHlsZT5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGNsaWVudC9jb21wb25lbnRzL0NyZWF0ZUxlYWd1ZS52dWUiLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy1oYWxmIGlzLW9mZnNldC1vbmUtcXVhcnRlclwiPlxyXG4gICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XHJcbiAgICAgICAgPGxhYmVsIGNsYXNzPVwicmFkaW9cIj5BcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHlvdXIgYWNjb3VudD9cclxuICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwicXVlc3Rpb25cIj5cclxuICAgICAgICAgIFllc1xyXG4gICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgPGxhYmVsIGNsYXNzPVwicmFkaW9cIj5cclxuICAgICAgICAgIDxpbnB1dCB0eXBlPVwicmFkaW9cIiBuYW1lPVwicXVlc3Rpb25cIj5cclxuICAgICAgICAgIE5vXHJcbiAgICAgICAgPC9sYWJlbD5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxyXG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uXCI+U3VibWl0PC9idXR0b24+XHJcbiAgICA8L2Rpdj5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7IG1hcEdldHRlcnMsIG1hcE11dGF0aW9ucyB9IGZyb20gJ3Z1ZXgnO1xyXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG4gIGV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcblxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgY29tcHV0ZWQ6IG1hcEdldHRlcnMoW1xyXG4gICAgICAnZ2V0VXNlckRhdGEnXHJcbiAgICBdKSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgLi4ubWFwTXV0YXRpb25zKFtcclxuICAgICAgXSksXHJcbiAgICB9XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG5cclxuPC9zdHlsZT5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGNsaWVudC9jb21wb25lbnRzL2RlbGV0ZWFjY291bnQudnVlIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXY+XHJcbiAgPGRpdiB2LWlmPVwiZ2V0VXNlckRhdGEuYWNjb3VudHR5cGUgPiAwXCIgY2xhc3M9XCJjb2x1bW4gaXMtaGFsZiBpcy1vZmZzZXQtb25lLXF1YXJ0ZXJcIj5cclxuICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxyXG4gICAgICA8bGFiZWw+TGVhZ3VlIE5hbWU8L2xhYmVsPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiPlxyXG4gICAgICAgIDxpbnB1dCBjbGFzcz1cImlucHV0XCIgdHlwZT1cInRleHRcIiBwbGFjZWhvbGRlcj1cIkxlYWd1ZSBJRFwiPlxyXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCI+XHJcbiAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXRyb3BoeVwiPjwvaT5cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cclxuICAgICAgPGxhYmVsPkxlYWd1ZSBQYXNzd29yZDwvbGFiZWw+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCI+XHJcbiAgICAgICAgPGlucHV0IGNsYXNzPVwiaW5wdXRcIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiTGVhZ3VlIFBhc3N3b3JkXCI+XHJcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIj5cclxuICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtbG9ja1wiPjwvaT5cclxuICAgICAgICA8L3NwYW4+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cclxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvblwiPlN1Ym1pdDwvYnV0dG9uPlxyXG4gICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbiAgPGRpdiB2LWlmPVwiZ2V0VXNlckRhdGEuYWNjb3VudHR5cGUgPT0gMFwiPlxyXG4gICAgPHAgY2xhc3M9XCJib2xkLW1lc3NhZ2VcIj5UaGlzIGZlYXR1cmUgcmVxdWlyZXMgYXQgbGVhc3QgYSBCYXNpYyBhY2NvdW50LiBQbGVhc2UgdXBncmFkZSB5b3VyIGFjY291bnQgaW4gb3JkZXIgdG8gYWN0aXZhdGUgdGhpcyBmZWF0dXJlLjwvcD5cclxuICA8L2Rpdj5cclxuPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgeyBtYXBHZXR0ZXJzLCBtYXBNdXRhdGlvbnMgfSBmcm9tICd2dWV4JztcclxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuICBleHBvcnQgZGVmYXVsdCB7XHJcbiAgICBkYXRhKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG5cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXB1dGVkOiBtYXBHZXR0ZXJzKFtcclxuICAgICAgJ2dldFVzZXJEYXRhJ1xyXG4gICAgXSksXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgIC4uLm1hcE11dGF0aW9ucyhbXHJcbiAgICAgIF0pLFxyXG4gICAgfVxyXG4gIH1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZT5cclxuLmJvbGQtbWVzc2FnZSB7XHJcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gIGZvbnQtc2l6ZTogMThwdDtcclxuICBjb2xvcjogI2ZmZmM3ZjtcclxuICBmb250LXdlaWdodDogODAwO1xyXG59XHJcbjwvc3R5bGU+XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjbGllbnQvY29tcG9uZW50cy9qb2lubGVhZ3VlLnZ1ZSIsIjx0ZW1wbGF0ZT5cclxuICA8ZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cImNvbHVtbnMgbGVhZGVyYm9hcmRcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cImNvbHVtbiBpcy1oYWxmIGlzLW9mZnNldC1vbmUtcXVhcnRlclwiPlxyXG4gICAgICAgIDx0YWJsZSBjbGFzcz1cImxlYWRlcmJvYXJkLXRhYmxlXCIgdi1pZj1cImRvbmVMb2FkaW5nXCI+XHJcbiAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgIDx0ciBjbGFzcz1cInRpdGxlXCI+XHJcbiAgICAgICAgICAgICAgPHRoIGNvbHNwYW49XCI0XCI+MjAxOCBGYW50YXN5IFNYOiBNYWluIExlYWd1ZSBTdGFuZGluZ3M8L3RoPlxyXG4gICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgPHRoPlBvc2l0aW9uPC90aD5cclxuICAgICAgICAgICAgICA8dGg+VG90YWwgUG9pbnRzPC90aD5cclxuICAgICAgICAgICAgICA8dGg+VXNlcm5hbWU8L3RoPlxyXG4gICAgICAgICAgICAgIDx0aD5Qb2ludHMgQmFjazwvdGg+XHJcbiAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgPHRmb290PlxyXG4gICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgPHRoPlBvc2l0aW9uPC90aD5cclxuICAgICAgICAgICAgICA8dGg+VG90YWwgUG9pbnRzPC90aD5cclxuICAgICAgICAgICAgICA8dGg+VXNlcm5hbWU8L3RoPlxyXG4gICAgICAgICAgICAgIDx0aD5Qb2ludHMgQmFjazwvdGg+XHJcbiAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICA8L3Rmb290PlxyXG4gICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICA8dHIgdi1mb3I9XCIodXNlciwgaW5kZXgpIGluIHN0YW5kaW5nc1wiIHYtYmluZDpjbGFzcz1cInsgJ01lJzogSXNNZSh1c2VyKSB9XCI+XHJcbiAgICAgICAgICAgICAgPHRkPnt7IGluZGV4ICsgMSB9fS48L3RkPlxyXG4gICAgICAgICAgICAgIDx0ZD57e3VzZXIudG90YWxwb2ludHN9fTwvdGQ+XHJcbiAgICAgICAgICAgICAgPHRkPnt7dXNlci53ZWVrbHl0ZWFtc1swXS51c2VybmFtZX19PC90ZD5cclxuICAgICAgICAgICAgICA8dGQgdi1iaW5kOmNsYXNzPVwieyAncG9pbnRzYmFjayc6IGluZGV4ID4gMCB9XCI+e3sgcG9pbnRzYmVoaW5kKHVzZXIpIH19PC90ZD5cclxuICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgPC90YWJsZT5cclxuICAgICAgICA8ZGl2IHYtaWY9XCIhZG9uZUxvYWRpbmdcIj5cclxuICAgICAgICAgIDxwPlwiVGhpcyBkYXRhIGRvZXNuJ3QgZmV0Y2ggaXRzZWxmLi4gTG9hZGluZyBSYWNlIFRyYWNrZXIuXCI8L3A+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbjwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5pbXBvcnQgeyBtYXBHZXR0ZXJzIH0gZnJvbSAndnVleCc7XHJcbiAgZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgZGF0YSgpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBkb25lTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgcmVzdWx0czogW10sXHJcbiAgICAgICAgbWFpbkxlYWd1ZVVzZXJzOiBbXSxcclxuICAgICAgICB3ZWVrbHl0ZWFtczogW11cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgIHN0YW5kaW5nczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbkxlYWd1ZVVzZXJzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgIHZhciBhUG9pbnRzID0gMDtcclxuICAgICAgICAgIHZhciBiUG9pbnRzID0gMDtcclxuICAgICAgICAgIGEud2Vla2x5dGVhbXMuZm9yRWFjaCh0ZWFtID0+IHsgYVBvaW50cyArPSB0ZWFtLnBsYWNlIH0pXHJcbiAgICAgICAgICBiLndlZWtseXRlYW1zLmZvckVhY2godGVhbSA9PiB7IGJQb2ludHMgKz0gdGVhbS5wbGFjZSB9KVxyXG4gICAgICAgICAgcmV0dXJuIGFQb2ludHMgLSBiUG9pbnRzO1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH0sXHJcbiAgICAgIG5ld3N0YW5kaW5nczogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICB9LFxyXG4gICAgICAuLi5tYXBHZXR0ZXJzKFtcclxuICAgICAgICAnZ2V0VXNlckRhdGEnXHJcbiAgICAgIF0pXHJcbiAgICB9LFxyXG4gICAgY3JlYXRlZCgpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJlbnZpcm9ubWVudFwiLCBwcm9jZXNzLmVudi5OT0RFX0VOVilcclxuICAgICAgYXhpb3MuZ2V0KCcvTWFpbkxlYWd1ZVN0YW5kaW5ncycpXHJcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgIHRoaXMubWFpbkxlYWd1ZVVzZXJzID0gZGF0YS5kYXRhO1xyXG4gICAgICAgIHRoaXMubWFpbkxlYWd1ZVVzZXJzLmZvckVhY2goKHVzZXIpID0+IHtcclxuICAgICAgICAgIHVzZXIudG90YWxwb2ludHMgPSAwXHJcbiAgICAgICAgICB1c2VyLndlZWtseXRlYW1zLmZvckVhY2god3QgPT4geyB1c2VyLnRvdGFscG9pbnRzICs9IHd0LnBsYWNlIH0pXHJcbiAgICAgICAgICB1c2VyLndlZWtseXRlYW1zLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgICAgIHRoaXMuZG9uZUxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICB9KVxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgcG9pbnRzYmVoaW5kOiBmdW5jdGlvbih1c2VyKSB7XHJcbiAgICAgICAgdmFyIG9iakluZGV4ID0gdGhpcy5zdGFuZGluZ3MuaW5kZXhPZih1c2VyKTtcclxuICAgICAgICBpZiAob2JqSW5kZXggIT0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIHVzZXIudG90YWxwb2ludHMgLSB0aGlzLnN0YW5kaW5nc1swXS50b3RhbHBvaW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICctJ1xyXG4gICAgICB9LFxyXG4gICAgICBJc01lOiBmdW5jdGlvbiAodXNlcikge1xyXG4gICAgICAgIGlmICh1c2VyLndlZWtseXRlYW1zWzBdLnVzZXJuYW1lID09IHRoaXMuZ2V0VXNlckRhdGEudXNlcm5hbWUpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwidXNlcm5hbWVcIiwgdGhpcy5nZXRVc2VyRGF0YS51c2VybmFtZSlcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbmJvZHkge1xyXG4gIGZvbnQtZmFtaWx5OiBcIk9wZW4gU2FucyBDb25kZW5zZWRcIjtcclxuICBoZWlnaHQ6IDEwMCU7XHJcbiAgbWluLWhlaWdodDogMTAwdmg7XHJcbiAgYmFja2dyb3VuZDpcclxuICAgIGxpbmVhci1ncmFkaWVudCh0byBib3R0b20gcmlnaHQsIHJnYmEoMjUxLCAxMDksIDgsIC44KTAlLCByZ2JhKDIwNCwgNjYsIDAsIDEpMTAwJSksXHJcbiAgICB1cmwoJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzM3NTI3L3Nwb3J0cy1nYW1lcy1mdW4taG9saWRheS0zNzUyNy5qcGVnP3c9MTI2MCZoPTc1MCZhdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJyk7XHJcbiAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcclxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOmNlbnRlcjtcclxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xyXG59XHJcbi5sZWFkZXJib2FyZC10YWJsZSAudGl0bGUgPiB0aCB7XHJcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNmNWY1YTI7XHJcbiAgZm9udC1zaXplOiAxNnB0O1xyXG4gIHBhZGRpbmc6IC41cmVtO1xyXG59XHJcbi5sZWFkZXJib2FyZC10YWJsZSB7XHJcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuOCk7XHJcbiAgY29sb3I6ICM3YjdiN2I7XHJcbiAgYm94LXNoYWRvdzogMXB4IDFweCAxMHB4ICMyMjI7XHJcbn1cclxuLmxlYWRlcmJvYXJkLXRhYmxlIHRoZWFkIHRoLCB0Zm9vdCB0aCB7XHJcbiAgY29sb3I6ICNmZmY7XHJcbiAgZm9udC1zaXplOiAxMnB0O1xyXG59XHJcbi5sZWFkZXJib2FyZC10YWJsZSB0aGVhZCwgdGZvb3Qge1xyXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChyZ2JhKDI1NSwgMTA2LCAwLCAxKTAlLCByZ2JhKDE1NiwgNTIsIDAsIDEpMTAwJSk7XHJcbn1cclxuLmxlYWRlcmJvYXJkLXRhYmxlIHRkIHtcclxuICBib3JkZXI6IG5vbmU7XHJcbn1cclxuLmxlYWRlcmJvYXJkLXRhYmxlIHRyOmhvdmVyIHtcclxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjMzLCAxMjAsIC4yKTtcclxufVxyXG4gIC5wb2ludHNiYWNrIHtcclxuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XHJcbiAgICBjb2xvcjogI2ZmMzg2MDtcclxuICB9XHJcbiAgLmxlYWRlcmJvYXJkIHtcclxuICAgIG1hcmdpbi10b3A6IDUwcHg7XHJcbiAgfVxyXG4gIHRhYmxlIHRkLCB0aCB7XHJcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXIgIWltcG9ydGFudDtcclxuICB9XHJcbiAgLmxlYWRlcmJvYXJkLW1haW4ge1xyXG4gICAgbWFyZ2luLXRvcDogMjVweDtcclxuICB9XHJcbiAgLk1lIHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyMzMsIDEyMCwgLjcpO1xyXG4gICAgY29sb3I6ICNkMjRhMDA7XHJcbiAgICBmb250LXdlaWdodDogNjAwO1xyXG4gIH1cclxuPC9zdHlsZT5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGNsaWVudC9jb21wb25lbnRzL2xlYWRlcmJvYXJkLnZ1ZSIsIjx0ZW1wbGF0ZT5cclxuICA8ZGl2IGNsYXNzPVwibW9kYWxcIiB2LWJpbmQ6Y2xhc3M9XCJ7J2lzLWFjdGl2ZSc6IHNob3d9XCIgaWQ9XCJsb2dpbk1vZGFsXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYmFja2dyb3VuZFwiPjwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNhcmRcIj5cclxuICAgICAgPGhlYWRlciBjbGFzcz1cIm1vZGFsLWNhcmQtaGVhZFwiPlxyXG4gICAgICAgIDxwIGNsYXNzPVwibW9kYWwtY2FyZC10aXRsZVwiPlVzZXIgTG9naW48L3A+XHJcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImRlbGV0ZVwiIEBjbGljaz1cInNldExvZ2luTW9kYWwoeyBzaG93OiAhU2hvd0xvZ2luTW9kYWwgfSlcIj48L2J1dHRvbj5cclxuICAgICAgPC9oZWFkZXI+XHJcbiAgICAgIDxzZWN0aW9uIGNsYXNzPVwibW9kYWwtY2FyZC1ib2R5XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwicmVnLXVzZXJuYW1lXCIgY2xhc3M9XCJsYWJlbFwiPlVzZXJuYW1lOiA8L2xhYmVsPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxyXG4gICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiaW5wdXRcIiB2LW1vZGVsPVwidXNlcm5hbWVcIi8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cclxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cInJlZy1wYXNzd29yZFwiIGNsYXNzPVwibGFiZWxcIj5QYXNzd29yZDogPC9sYWJlbD5cclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2xcIj5cclxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgY2xhc3M9XCJpbnB1dFwiIGlkPVwicmVnLXBhc3N3b3JkXCIgdi1tb2RlbD1cInBhc3N3b3JkXCIvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgaWQ9XCJsb2dpbi1yZWNhcHRjaGFcIj48L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXJyb3JNZXNzYWdlXCIgdi1pZj1cImVycm9yTWVzc2FnZSAhPSAnJ1wiPlxyXG4gICAgICAgICAge3sgZXJyb3JNZXNzYWdlIH19XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvc2VjdGlvbj5cclxuICAgICAgPGZvb3RlciBjbGFzcz1cIm1vZGFsLWNhcmQtZm9vdFwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBpcy1wcmltYXJ5XCIgdi1iaW5kOmNsYXNzPVwieyAnaXMtbG9hZGluZyc6IGlzTG9hZGluZyB9XCIgdi1vbjpjbGljaz1cInN1Ym1pdFwiIHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cIkxvZ2luXCIgaWQ9XCJzdWJtaXQtbG9naW5cIj5Mb2dpbjwvYnV0dG9uPlxyXG4gICAgICAgICAgPGEgY2xhc3M9XCJidXR0b25cIiBAY2xpY2s9XCJzZXRMb2dpbk1vZGFsKHsgc2hvdzogIVNob3dMb2dpbk1vZGFsIH0pXCI+Q2FuY2VsPC9hPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Zvb3Rlcj5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L2Rpdj5cclxuICA8L3RlbXBsYXRlPlxyXG4gIDxzY3JpcHQ+XHJcbiAgaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuICBpbXBvcnQgeyBtYXBNdXRhdGlvbnMsIG1hcEdldHRlcnMgfSBmcm9tICd2dWV4JztcclxuICBleHBvcnQgZGVmYXVsdCB7XHJcbiAgICAgIGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHVzZXJuYW1lOiAnJyxcclxuICAgICAgICAgIHBhc3N3b3JkOiAnJyxcclxuICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgICBlcnJvck1lc3NhZ2U6ICcnXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBjb21wdXRlZDogbWFwR2V0dGVycyhbXHJcbiAgICAgICAgJ1Nob3dMb2dpbk1vZGFsJ1xyXG4gICAgICBdKSxcclxuICAgICAgcHJvcHM6IHtcclxuICAgICAgICBzaG93OiB7XHJcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgLi4ubWFwTXV0YXRpb25zKFtcclxuICAgICAgICAgICdzZXRMb2dpbk1vZGFsJyxcclxuICAgICAgICAgICdzZXRVc2VyRGF0YScsXHJcbiAgICAgICAgICAnc2V0TG9nZ2VkSW4nXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgc3VibWl0OiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICBheGlvcy5wb3N0KCcvbG9naW4nLCB7XHJcbiAgICAgICAgICAgIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lLFxyXG4gICAgICAgICAgICBwYXNzd29yZDogdGhpcy5wYXNzd29yZCxcclxuICAgICAgICAgICAgY2FwdGNoYTogZ3JlY2FwdGNoYS5nZXRSZXNwb25zZSgpXHJcbiAgICAgICAgICB9KS50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBncmVjYXB0Y2hhLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMudXNlcm5hbWUgPSAnJztcclxuICAgICAgICAgICAgdGhpcy5wYXNzd29yZCA9ICcnO1xyXG4gICAgICAgICAgICB0aGlzLnNldFVzZXJEYXRhKHsgdXNlckRhdGE6IGRhdGEuZGF0YSB9KVxyXG4gICAgICAgICAgICB0aGlzLnNldExvZ2dlZEluKHsgbG9nZ2VkSW46IHRydWUgfSlcclxuICAgICAgICAgICAgdGhpcy5zZXRMb2dpbk1vZGFsKHsgc2hvdzogZmFsc2UgfSlcclxuICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGdyZWNhcHRjaGEucmVzZXQoKTtcclxuICAgICAgICAgICAgdGhpcy51c2VybmFtZSA9ICcnO1xyXG4gICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gZXJyLnJlc3BvbnNlLmRhdGEuZXJyb3I7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gIH1cclxuPC9zY3JpcHQ+XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBjbGllbnQvY29tcG9uZW50cy9sb2dpbi52dWUiLCI8dGVtcGxhdGU+XHJcbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIG15YWNjb3VudC1jb250YWluZXJcIj5cclxuICAgICAgPHVsIGNsYXNzPVwidWxcIj5cclxuICAgICAgICA8bGk+PHJvdXRlci1saW5rIHRvPVwiL215YWNjb3VudC9jcmVhdGVsZWFndWVcIj5DcmVhdGUgTGVhZ3VlPC9yb3V0ZXItbGluaz48L2xpPlxyXG4gICAgICAgIDxsaT48cm91dGVyLWxpbmsgdG89XCIvbXlhY2NvdW50L2pvaW5sZWFndWVcIj5Kb2luIExlYWd1ZTwvcm91dGVyLWxpbms+PC9saT5cclxuICAgICAgICA8bGk+PHJvdXRlci1saW5rIHRvPVwiL215YWNjb3VudC9kZWxldGVhY2NvdW50XCI+RGVsZXRlIEFjY291bnQ8L3JvdXRlci1saW5rPjwvbGk+XHJcbiAgICAgICAgPGxpPjxyb3V0ZXItbGluayB0bz1cIi9teWFjY291bnQvdXBncmFkZWFjY291bnRcIj5VcGdyYWRlIEFjY291bnQ8L3JvdXRlci1saW5rPjwvbGk+XHJcbiAgICAgIDwvdWw+XHJcbiAgICAgIDxyb3V0ZXItdmlldz48L3JvdXRlci12aWV3PlxyXG4gICAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG4gIGV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcblxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG4gIC5teWFjY291bnQtY29udGFpbmVyIHtcclxuICAgIGRpc3BsYXk6ZmxleDtcclxuICAgIGZsZXgtZGlyZWN0aW9uOmNvbHVtbjtcclxuICAgIHdpZHRoOiA0NSU7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbiAgICBtYXJnaW4tdG9wOiAycmVtO1xyXG4gIH1cclxuICAudWwge1xyXG4gICAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xyXG4gICAgbWFyZ2luLWJvdHRvbTogMnJlbTtcclxuICB9XHJcbiAgLnVsID4gbGkge1xyXG4gICAgZGlzcGxheTogaW5saW5lO1xyXG4gIH1cclxuICBsYWJlbCB7XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbiAgICBmb250LXNpemU6IDFyZW07XHJcbiAgICBmb250LXdlaWdodDogNjAwO1xyXG4gIH1cclxuICBpbnB1dFt0eXBlPSdyYWRpbyddIHtcclxuICAgIG1hcmdpbi1sZWZ0OiAycmVtO1xyXG4gIH1cclxuPC9zdHlsZT5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGNsaWVudC9jb21wb25lbnRzL215YWNjb3VudC52dWUiLCI8dGVtcGxhdGU+XHJcbiAgPGRpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1jb250YWluZXJcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLWJsb2NrXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImxoLTRyXCI+V2VlazogPHNwYW4gY2xhc3M9XCJib2xkZXN0LWhlYWRlciByaWdodFwiPnt7Y3VycmVudHdlZWt9fTwvc3Bhbj48L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwibGgtNHJcIj5CYWxhbmNlIFJlbWFpbmluZzo8c3BhbiBjbGFzcz1cImJvbGRlc3QtaGVhZGVyIHJpZ2h0XCI+ICR7e2RvbGxhcnN9fTwvc3Bhbj48L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cclxuICAgICAgPHRyYW5zaXRpb24gbmFtZT1cImZhZGVcIiBtb2RlPVwib3V0LWluXCI+XHJcbiAgICAgICAgPHAgdi1pZj1cInNob3dTYXZlTWVzc2FnZVwiIGNsYXNzPVwic3VjY2Vzc2Z1bC1zYXZlXCI+WW91ciB0ZWFtIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBzYXZlZCE8L3A+XHJcbiAgICAgICAgPHAgdi1pZj1cInNob3dGYWlsTWVzc2FnZVwiIGNsYXNzPVwiZmFpbHVyZS1zYXZlXCI+T29wcyEgU29tZXRoaW5nIFdlbnQgV3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuPC9wPlxyXG4gICAgICA8L3RyYW5zaXRpb24+XHJcbiAgICAgIDx0YWJsZSBjbGFzcz1cIm15dGVhbS10YWJsZVwiPlxyXG4gICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgPHRoPkFjdGlvbjwvdGg+XHJcbiAgICAgICAgICAgIDx0aCBAY2xpY2s9XCJzb3J0QnlQcmljZVwiPlByaWNlXHJcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCI+XHJcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLWNhcmV0LXVwXCIgdi1pZj1cIkNvc3RTb3J0QnlBc2NcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XHJcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLWNhcmV0LWRvd25cIiB2LWVsc2UgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxyXG4gICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgPC90aD5cclxuICAgICAgICAgICAgPHRoPlJhY2VyIE5hbWU8L3RoPlxyXG4gICAgICAgICAgICA8dGg+UmFjZXIgTnVtYmVyPC90aD5cclxuICAgICAgICAgICAgPHRoPkhpZ2hlc3QgRmluaXNoPC90aD5cclxuICAgICAgICAgICAgPHRoPkxvd2VzdCBGaW5pc2g8L3RoPlxyXG4gICAgICAgICAgICA8dGg+QXZlcmFnZSBGaW5pc2g8L3RoPlxyXG4gICAgICAgICAgPC90cj5cclxuICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgIDx0Zm9vdD5cclxuICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgPHRoPkFjdGlvbjwvdGg+XHJcbiAgICAgICAgICAgIDx0aD5QcmljZTwvdGg+XHJcbiAgICAgICAgICAgIDx0aD5SYWNlciBOYW1lPC90aD5cclxuICAgICAgICAgICAgPHRoPlJhY2VyIE51bWJlcjwvdGg+XHJcbiAgICAgICAgICAgIDx0aD5IaWdoZXN0IEZpbmlzaDwvdGg+XHJcbiAgICAgICAgICAgIDx0aD5Mb3dlc3QgRmluaXNoPC90aD5cclxuICAgICAgICAgICAgPHRoPkF2ZXJhZ2UgRmluaXNoPC90aD5cclxuICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgPC90Zm9vdD5cclxuICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICA8dHIgdi1mb3I9XCIocmFjZXIsIGluZGV4KSBpbiBzZWxlY3RlZHJpZGVyc1wiPlxyXG4gICAgICAgICAgICA8dGQ+XHJcbiAgICAgICAgICAgICAgPGEgaHJlZj1cIiMhXCIgdi1pZj1cInJhY2VyLm5hbWUgIT0gJ09QRU4gU0xPVCdcIiBAY2xpY2s9XCJyZW1vdmVSYWNlcihyYWNlcilcIj5cclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBtaW51cy1pY29uXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtbWludXNcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XHJcbiAgICAgICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICA8dGQ+JHt7cmFjZXIuY29zdH19PC90ZD5cclxuICAgICAgICAgICAgPHRkPnt7cmFjZXIubmFtZX19PC90ZD5cclxuICAgICAgICAgICAgPHRkPnt7cmFjZXIucmlkZXJfbnVtYmVyfX08L3RkPlxyXG4gICAgICAgICAgICA8dGQ+e3tyYWNlci5oaWdoZXN0RmluaXNofX08L3RkPlxyXG4gICAgICAgICAgICA8dGQ+e3tyYWNlci5sb3dlc3RGaW5pc2h9fTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZD57e3JhY2VyLmF2ZXJhZ2VGaW5pc2h9fTwvdGQ+XHJcbiAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgPHRyIGNsYXNzPVwibGFzdFJvd1wiPlxyXG4gICAgICAgICAgICA8dGQgY29sc3Bhbj1cIjVcIj48L3RkPlxyXG4gICAgICAgICAgICA8dGQgY29sc3Bhbj1cIjFcIj5cclxuICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGlzLWRhbmdlclwiIEBjbGljaz1cIlJlbW92ZUFsbFwiIDpkaXNhYmxlZD1cIiFzaG93UmVtb3ZlQWxsXCI+UmVtb3ZlIEFsbDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgICA8dGQgY29sc3Bhbj1cIjFcIj5cclxuICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGlzLXN1Y2Nlc3NcIiBAY2xpY2s9XCJTYXZlVGVhbVwiIDpkaXNhYmxlZD1cImhhc09wZW5TbG90c1wiIHYtYmluZDpjbGFzcz1cInsnaXMtbG9hZGluZyc6aXNMb2FkaW5nfVwiPlNhdmUgVGVhbTwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgICAgPC90cj5cclxuICAgICAgICAgIDx0ciB2LWZvcj1cInJpZGVyIGluIHBhZ2luYXRlZFJpZGVyc1wiPlxyXG4gICAgICAgICAgICA8dGQ+XHJcbiAgICAgICAgICAgICAgPGEgaHJlZj1cIiMhXCIgdi1pZj1cInNob3dTZWxlY3QgJiYgcmlkZXIuY29zdCA8PSBkb2xsYXJzXCIgQGNsaWNrPVwiYWRkUmFjZXIocmlkZXIpXCI+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb24gcGx1cy1pY29uXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtcGx1c1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cclxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICA8L2E+XHJcbiAgICAgICAgICAgIDwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZD4ke3tyaWRlci5jb3N0fX08L3RkPlxyXG4gICAgICAgICAgICA8dGQ+e3tyaWRlci5uYW1lfX08L3RkPlxyXG4gICAgICAgICAgICA8dGQ+e3tyaWRlci5yaWRlcl9udW1iZXJ9fTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZD57e3JpZGVyLmhpZ2hlc3RGaW5pc2h9fTwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZD57e3JpZGVyLmxvd2VzdEZpbmlzaH19PC90ZD5cclxuICAgICAgICAgICAgPHRkPnt7cmlkZXIuYXZlcmFnZUZpbmlzaH19PC90ZD5cclxuICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgPC90Ym9keT5cclxuICAgICAgPC90YWJsZT5cclxuICAgICAgPGRpdiBjbGFzcz1cImN1c3RvbS1wYWdpbmF0aW9uXCI+XHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgICAgIDxhIGNsYXNzPVwicGFnaW5hdGlvbi1wcmV2aW91c1wiIEBjbGljaz1cInBhZ2UtLVwiIHYtYmluZDpjbGFzcz1cInsgJ2hpZGUtcGFnaW5hdGlvbi1idXR0b24nIDogaGlkZVByZXZpb3VzIH1cIj5QcmV2aW91czwvYT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgPGEgY2xhc3M9XCJwYWdpbmF0aW9uLW51bWJlclwiPnt7cGFnZX19L3t7cGFnaW5hdGlvblBhZ2VzfX08L2E+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgICAgIDxhIGNsYXNzPVwicGFnaW5hdGlvbi1uZXh0XCIgQGNsaWNrPVwicGFnZSsrXCIgdi1iaW5kOmNsYXNzPVwieyAnaGlkZS1wYWdpbmF0aW9uLWJ1dHRvbicgOiBoaWRlTmV4dCB9XCI+TmV4dCBwYWdlPC9hPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuaW1wb3J0IHsgbWFwR2V0dGVycyB9IGZyb20gJ3Z1ZXgnO1xyXG5pbXBvcnQgX2ZpbmRJbmRleCBmcm9tICdsb2Rhc2gvZmluZEluZGV4JztcclxuaW1wb3J0IF9zb3J0QnkgZnJvbSAnbG9kYXNoL3NvcnRCeSc7XHJcbmltcG9ydCBfcmVtb3ZlIGZyb20gJ2xvZGFzaC9yZW1vdmUnO1xyXG4gIGV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGRhdGEoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgY3VycmVudHdlZWs6IDAsXHJcbiAgICAgICAgc2VsZWN0ZWRyaWRlcnM6IFtdLFxyXG4gICAgICAgIGF2YWlsYWJsZVJpZGVyczogW10sXHJcbiAgICAgICAgQ29zdFNvcnRCeUFzYzogdHJ1ZSxcclxuICAgICAgICBwYWdlOiAxLFxyXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXHJcbiAgICAgICAgc2hvd1NhdmVNZXNzYWdlOiBmYWxzZSxcclxuICAgICAgICBzaG93RmFpbE1lc3NhZ2U6IGZhbHNlXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICAuLi5tYXBHZXR0ZXJzKFtcclxuICAgICAgICAnZ2V0VXNlckRhdGEnXHJcbiAgICAgIF0pLFxyXG4gICAgICBkb2xsYXJzKCkge1xyXG4gICAgICAgIHZhciB0b3RhbCA9IDEwMDAwO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRyaWRlcnMuZm9yRWFjaChyaWRlciA9PiB7XHJcbiAgICAgICAgICB0b3RhbCAtPSByaWRlci5jb3N0O1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xyXG4gICAgICB9LFxyXG4gICAgICBoaWRlUHJldmlvdXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZSA8PSAxO1xyXG4gICAgICB9LFxyXG4gICAgICBoaWRlTmV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYWdlID49IHRoaXMucGFnaW5hdGlvblBhZ2VzO1xyXG4gICAgICB9LFxyXG4gICAgICBwYWdpbmF0ZWRSaWRlcnMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGFnZSA9PSAxKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcImVudGlyZSBhcnJheVwiLCB0aGlzLmF2YWlsYWJsZVJpZGVycylcclxuICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYXZhaWxhYmxlUmlkZXJzLnNsaWNlKDAsIDEwKSk7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdmFpbGFibGVSaWRlcnMuc2xpY2UoMCwgMTApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgYmVnaW5TbGljZSA9IHRoaXMucGFnZSAqIDEwIC0gOTtcclxuICAgICAgICAgIHZhciBlbmRTbGljZSA9IGJlZ2luU2xpY2UgKyAxMDtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYXZhaWxhYmxlUmlkZXJzKVxyXG4gICAgICAgICAgY29uc29sZS5sb2codGhpcy5hdmFpbGFibGVSaWRlcnMuc2xpY2UoYmVnaW5TbGljZSwgZW5kU2xpY2UpKVxyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlUmlkZXJzLnNsaWNlKGJlZ2luU2xpY2UsIGVuZFNsaWNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHBhZ2luYXRpb25QYWdlcygpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYXZhaWxhYmxlUmlkZXJzLmxlbmd0aCAvIDEwKTtcclxuICAgICAgfSxcclxuICAgICAgaGFzT3BlblNsb3RzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkcmlkZXJzLnNvbWUocmlkZXIgPT4geyByZXR1cm4gcmlkZXIubmFtZSA9PSBcIk9QRU4gU0xPVFwiIH0pXHJcbiAgICAgIH0sXHJcbiAgICAgIHNob3dSZW1vdmVBbGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRyaWRlcnMuc29tZShyaWRlciA9PiB7IHJldHVybiByaWRlci5uYW1lICE9IFwiT1BFTiBTTE9UXCIgfSlcclxuICAgICAgfSxcclxuICAgICAgc2hvd1NlbGVjdCgpIHtcclxuICAgICAgICB2YXIgb3BlblNsb3RzID0gdGhpcy5zZWxlY3RlZHJpZGVycy5zb21lKChyaWRlcikgPT4ge3JldHVybiByaWRlci5uYW1lID09IFwiT1BFTiBTTE9UXCJ9KTtcclxuICAgICAgICB2YXIgbG93ZXN0Q29zdEF2YWlsYWJsZSA9IF9zb3J0QnkodGhpcy5hdmFpbGFibGVSaWRlcnMsIG8gPT4geyByZXR1cm4gby5jb3N0IH0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwic2hvd1NlbGVjdFwiLCBsb3dlc3RDb3N0QXZhaWxhYmxlWzBdKVxyXG4gICAgICAgIGlmICgodGhpcy5kb2xsYXJzID49IGxvd2VzdENvc3RBdmFpbGFibGVbMF0uY29zdCkgJiYgb3BlblNsb3RzKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICByZW1vdmVSYWNlcihyYWNlcikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwicmVtb3ZlZCByYWNlcnNcIiwgcmFjZXIpO1xyXG4gICAgICAgIHZhciBzZWxlY3RlZFJhY2VySW5kZXggPSBfZmluZEluZGV4KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIG8gPT4geyByZXR1cm4gby5yaWRlcmlkID09PSByYWNlci5yaWRlcmlkIH0pO1xyXG4gICAgICAgIHZhciBvcGVuU3BhY2UgPSB7XHJcbiAgICAgICAgICBpZDogdGhpcy5zZWxlY3RlZHJpZGVyc1tzZWxlY3RlZFJhY2VySW5kZXhdLmlkLFxyXG4gICAgICAgICAgYXZhdGFyX3VybDogJ2h0dHA6Ly93d3cuc2hvcGFhcmR2YXJrLmNvbS9tZWRpYS9jYXRhbG9nL3Byb2R1Y3QvVy9TL1dTLTE4NjU1LmpwZycsXHJcbiAgICAgICAgICBjb3N0OiAwLFxyXG4gICAgICAgICAgaGlnaGVzdEZpbmlzaDogJy0nLFxyXG4gICAgICAgICAgbG93ZXN0RmluaXNoOiAnLScsXHJcbiAgICAgICAgICBuYW1lOiAnT1BFTiBTTE9UJyxcclxuICAgICAgICAgIHJpZGVyX251bWJlcjogMCxcclxuICAgICAgICAgIHJpZGVyaWQ6IDAsXHJcbiAgICAgICAgICBsZWFndWVpZDogMSxcclxuICAgICAgICAgIHNlYXNvbl93ZWVrc2lkOiB0aGlzLmN1cnJlbnR3ZWVrXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXZhaWxhYmxlUmlkZXJzLnB1c2gocmFjZXIpXHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIHNlbGVjdGVkUmFjZXJJbmRleCwgb3BlblNwYWNlKVxyXG4gICAgICAgIHRoaXMuc29ydEJ5UHJpY2UoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIk15IG5ldyB0ZWFtXCIsIHRoaXMuc2VsZWN0ZWRyaWRlcnMpXHJcbiAgICAgIH0sXHJcbiAgICAgIGFkZFJhY2VyKHJhY2VyKSB7XHJcbiAgICAgICAgdmFyIG9wZW5TbG90SW5kZXggPSBfZmluZEluZGV4KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIG8gPT4geyByZXR1cm4gby5uYW1lID09IFwiT1BFTiBTTE9UXCIgfSk7XHJcbiAgICAgICAgX3JlbW92ZSh0aGlzLnBhZ2luYXRlZFJpZGVycywgbyA9PiB7IHJldHVybiBvLnJpZGVyaWQgPT0gcmFjZXIucmlkZXJpZCB9KVxyXG4gICAgICAgIF9yZW1vdmUodGhpcy5hdmFpbGFibGVSaWRlcnMsIG8gPT4geyByZXR1cm4gby5yaWRlcmlkID09IHJhY2VyLnJpZGVyaWQgfSlcclxuICAgICAgICByYWNlci5pZCA9IHRoaXMuc2VsZWN0ZWRyaWRlcnNbb3BlblNsb3RJbmRleF0uaWQ7XHJcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIG9wZW5TbG90SW5kZXgsIHJhY2VyKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlJhY2VycyB0byBBZGRcIiwgdGhpcy5zZWxlY3RlZHJpZGVycylcclxuICAgICAgfSxcclxuICAgICAgc29ydEJ5UHJpY2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuQ29zdFNvcnRCeUFzYykge1xyXG4gICAgICAgICAgdGhpcy5Db3N0U29ydEJ5QXNjID0gZmFsc2U7XHJcbiAgICAgICAgICB0aGlzLmF2YWlsYWJsZVJpZGVycyA9IHRoaXMuYXZhaWxhYmxlUmlkZXJzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGEuY29zdCA+IGIuY29zdCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiAtMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhLmNvc3QgPCBiLmNvc3QpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAwXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLkNvc3RTb3J0QnlBc2MgPSB0cnVlO1xyXG4gICAgICAgICAgdGhpcy5hdmFpbGFibGVSaWRlcnMgPSB0aGlzLmF2YWlsYWJsZVJpZGVycy5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChhLmNvc3QgPiBiLmNvc3QpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhLmNvc3QgPCBiLmNvc3QpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gLTFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gMFxyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFNhdmVUZWFtKCkge1xyXG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICBheGlvcy5wb3N0KFwiL1NhdmVUZWFtXCIsIHRoaXMuc2VsZWN0ZWRyaWRlcnMpXHJcbiAgICAgICAgLnRoZW4oZGF0YSA9PiB7XHJcbiAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgdGhpcy5TYXZlTWVzc2FnZSgpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgIHRoaXMuRmFpbE1lc3NhZ2UoKTtcclxuICAgICAgICB9KVxyXG4gICAgICB9LFxyXG4gICAgICBTYXZlTWVzc2FnZSgpIHtcclxuICAgICAgICB0aGlzLnNob3dTYXZlTWVzc2FnZSA9IHRydWU7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuc2hvd1NhdmVNZXNzYWdlID0gZmFsc2UgfSwgNTAwMClcclxuICAgICAgfSxcclxuICAgICAgRmFpbE1lc3NhZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5zaG93RmFpbE1lc3NhZ2UgPSB0cnVlO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLnNob3dGYWlsTWVzc2FnZSA9IGZhbHNlIH0sIDUwMDApXHJcbiAgICAgIH0sXHJcbiAgICAgIFJlbW92ZUFsbCgpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdGVkcmlkZXJzLmZvckVhY2gocmFjZXIgPT4ge1xyXG4gICAgICAgICAgaWYgKHJhY2VyLm5hbWUgIT0gXCJPUEVOIFNMT1RcIikge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVJhY2VyKHJhY2VyKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBiZWZvcmVDcmVhdGUoKSB7XHJcbiAgICAgIGF4aW9zLmdldCgnL0N1cnJlbnRNeVRlYW1Nb2RlbCcpXHJcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiZGF0YVwiLCBkYXRhLmRhdGEpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudHdlZWsgPSBkYXRhLmRhdGEuQ3VycmVudFdlZWs7XHJcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5jdXJyZW50d2Vlayk7XHJcbiAgICAgICAgdGhpcy5hdmFpbGFibGVSaWRlcnMgPSBfc29ydEJ5KGRhdGEuZGF0YS5BdmFpbGFibGVSaWRlcnMsIG8gPT4geyByZXR1cm4gby5jb3N0IH0pO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRyaWRlcnMgPSBkYXRhLmRhdGEuQ3VycmVudFRlYW07XHJcbiAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgbW91bnRlZCgpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJtb3VudGVkXCIsIHRoaXMuZ2V0VXNlckRhdGEpXHJcbiAgICB9XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG4uc3VjY2Vzc2Z1bC1zYXZlIHtcclxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgY29sb3I6ICMwMGQxYjI7XHJcbn1cclxuLm15dGVhbS10YWJsZSB0YWJsZSB0ZCB7XHJcbiAgYm9yZGVyOiBub25lO1xyXG4gIGZvbnQtZmFtaWx5OiAnQ291cmllcic7XHJcbn1cclxuLm15dGVhbS10YWJsZSB7XHJcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAxKTtcclxuICBjb2xvcjogYmxhY2s7XHJcbiAgYm94LXNoYWRvdzogMXB4IDFweCAxMHB4ICMyMjI7XHJcbn1cclxuLm15dGVhbS10YWJsZSB0aGVhZCwgdGZvb3Qge1xyXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChyZ2JhKDI1NSwgMTA2LCAwLCAxKTAlLCByZ2JhKDE1NiwgNTIsIDAsIDEpMTAwJSk7XHJcbn1cclxuLm15dGVhbS10aXRsZSB7XHJcbiAgY29sb3I6ICM4Njg2ODY7XHJcbiAgZm9udC1zaXplOiAxNnB0O1xyXG59XHJcbi5teXRlYW0tdGFibGUgdGhlYWQgdGgsIHRmb290IHRoIHtcclxuICBjb2xvcjogI2ZmZjtcclxuICBmb250LXNpemU6IDEycHQ7XHJcbn1cclxuLm15dGVhbS10YWJsZSB0cjpob3ZlciB7XHJcbiAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDIzMywgMTIwLCAuMik7XHJcbn1cclxuLmZhaWx1cmUtc2F2ZSB7XHJcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gIGNvbG9yOiAjZmYyYjU2O1xyXG59XHJcbi5mYWRlLWVudGVyLWFjdGl2ZSwgLmZhZGUtbGVhdmUtYWN0aXZlIHtcclxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDFzO1xyXG59XHJcbi5mYWRlLWVudGVyLCAuZmFkZS1sZWF2ZS10byB7XHJcbiAgb3BhY2l0eTogMDtcclxufVxyXG4ucGFnZS1oZWFkZXItY29udGFpbmVyIHtcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG59XHJcbmJ1dHRvbiB7XHJcbiAgbWFyZ2luLWJvdHRvbTogMC4yNXJlbTtcclxufVxyXG4ucGFnZS1oZWFkZXItYmxvY2sge1xyXG4gIHdpZHRoOiAxNSU7XHJcbiAgbWluLXdpZHRoOiAyNjBweDtcclxufVxyXG4gIC5yaWRlcnMtY29udGFpbmVyIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBmbGV4LXdyYXA6IHdyYXA7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICB9XHJcbiAgLnJpZGVyLWJsb2NrIHtcclxuICAgIG1pbi13aWR0aDogMTVyZW07XHJcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZGVkZWRlO1xyXG4gICAgbWFyZ2luOiAxcmVtO1xyXG4gICAgYm94LXNoYWRvdzogMXB4IDFweCAxcHggI2NlY2VjZTtcclxuICAgIHBhZGRpbmc6IDFyZW07XHJcbiAgICBtYXgtd2lkdGg6IDE1cmVtO1xyXG4gIH1cclxuICAucGFnZS10aXRsZSB7XHJcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcclxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XHJcbiAgfVxyXG4gIC5wYWdlLXRpdGxlIHtcclxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xyXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcclxuICB9XHJcbiAgLnBhZ2Utc3ViaGVhZGVyIHtcclxuICAgIHRleHQtYWxpZ246Y2VudGVyO1xyXG4gIH1cclxuICAuY2FyZC1mb290ZXIge1xyXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XHJcbiAgfVxyXG4gIC5jYXJkLWNvbnRlbnQge1xyXG4gICAgbWluLWhlaWdodDogMTFyZW07XHJcbiAgICBtYXgtaGVpZ2h0OiAxMXJlbTtcclxuICAgIG92ZXJmbG93OiBoaWRkZW47XHJcbiAgICBtYXJnaW4tYm90dG9tOiAxcmVtO1xyXG4gIH1cclxuICAuY2FyZC1mb290ZXIgZGl2Om50aC1jaGlsZChldmVuKSB7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xyXG4gIH1cclxuICAuZm9vdGVyLXJvdyB7XHJcbiAgICBkaXNwbGF5OmZsZXg7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcbiAgfVxyXG4gIHAuY2FyZC1oZWFkZXItdGl0bGUge1xyXG4gICAgZGlzcGxheTpmbGV4O1xyXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XHJcbiAgfVxyXG4gIHAgc3Bhbi5pY29uIHtcclxuICAgIGNvbG9yOiAjZmYzODYwO1xyXG4gIH1cclxuICB0aDpob3ZlciB7XHJcbiAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgfVxyXG4gIC5oaWRlLXBhZ2luYXRpb24tYnV0dG9uIHtcclxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcclxuICB9XHJcbiAgLmN1c3RvbS1wYWdpbmF0aW9uIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XHJcbiAgfVxyXG4gIC5sYXN0Um93IHtcclxuICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCByZ2IoMjA4LCA4MywgMSk7XHJcbiAgfVxyXG4gIC5taW51cy1pY29uIHtcclxuICAgIGNvbG9yOiAjZmYzODYwO1xyXG4gIH1cclxuICAucGx1cy1pY29uIHtcclxuICAgIGNvbG9yOiAjMjNkMTYwO1xyXG4gIH1cclxuICAuYm9sZGVzdC1oZWFkZXIge1xyXG4gICAgY29sb3I6ICNmZmZjN2Y7XHJcbiAgICBmb250LXdlaWdodDogNzAwO1xyXG4gICAgZm9udC1zaXplOiB4eC1sYXJnZTtcclxuICB9XHJcbiAgLnJpZ2h0IHtcclxuICAgIGZsb2F0OiByaWdodDtcclxuICB9XHJcbiAgLmxoLTRyIHtcclxuICAgIGhlaWdodDogNHJlbTtcclxuICAgIGxpbmUtaGVpZ2h0OiA0cmVtO1xyXG4gICAgZm9udC1zaXplOiAxLjc1cmVtO1xyXG4gICAgY29sb3I6d2hpdGU7XHJcbiAgfVxyXG4gIC5saC00cjpmaXJzdC1vZi10eXBlIHtcclxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZmZlOTc4O1xyXG4gIH1cclxuICAubGgtNHI6bGFzdC1vZi10eXBlIHtcclxuICAgIG1hcmdpbi1ib3R0b206IDJyZW07XHJcbiAgfVxyXG48L3N0eWxlPlxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gY2xpZW50L2NvbXBvbmVudHMvbXl0ZWFtLnZ1ZSIsIlxyXG4gIDx0ZW1wbGF0ZT5cclxuICAgIDxuYXYgY2xhc3M9XCJuYXZiYXJcIj5cclxuICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItYnJhbmRcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWl0ZW1cIj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWJ1cmdlciBidXJnZXJcIiBkYXRhLXRhcmdldD1cIm5hdk1lbnVcIj5cclxuICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cclxuICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cclxuICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItbWVudVwiIGlkPVwibmF2TWVudVwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItc3RhcnRcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbVwiPlxyXG4gICAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XCIvaG9tZVwiIGV4YWN0PkhvbWU8L3JvdXRlci1saW5rPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWl0ZW1cIiB2LWlmPVwiR2V0QXV0aFN0YXR1c1wiPlxyXG4gICAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XCIvbXl0ZWFtXCI+TXkgVGVhbTwvcm91dGVyLWxpbms+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbVwiIHYtaWY9XCJHZXRBdXRoU3RhdHVzXCI+XHJcbiAgICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cIi9saXZlXCI+U3RhdCBUcmFja2VyPC9yb3V0ZXItbGluaz5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1pdGVtXCI+XHJcbiAgICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cIi9ydWxlc1wiPkluZm88L3JvdXRlci1saW5rPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWl0ZW1cIj5cclxuICAgICAgICAgICAgPHJvdXRlci1saW5rIHRvPVwiL3N1Z2dlc3Rpb25zXCI+U3VnZ2VzdGlvbnM8L3JvdXRlci1saW5rPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1lbmRcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbVwiIHYtaWY9XCIhR2V0QXV0aFN0YXR1c1wiIEBjbGljaz1cInNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiAhU2hvd1JlZ2lzdGVyTW9kYWwgfSlcIj5cclxuICAgICAgICAgICAgPGEgaHJlZj1cIiMhXCI+UmVnaXN0ZXI8L2E+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbVwiIHYtaWY9XCIhR2V0QXV0aFN0YXR1c1wiIEBjbGljaz1cInNldExvZ2luTW9kYWwoeyBzaG93OiAhU2hvd0xvZ2luTW9kYWwgfSlcIj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCI+XHJcbiAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1zaWduLWluXCI+PC9pPlxyXG4gICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICAgIDxhIGhyZWY9XCIjIVwiPkxvZ2luPC9hPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWl0ZW1cIiB2LWlmPVwiR2V0QXV0aFN0YXR1c1wiPlxyXG4gICAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XCIvbXlhY2NvdW50XCI+V2VsY29tZSwge3sgZ2V0VXNlckRhdGEudXNlcm5hbWUgfX0hPC9yb3V0ZXItbGluaz5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1pdGVtXCIgdi1pZj1cIkdldEF1dGhTdGF0dXNcIiBAY2xpY2s9XCJzZXRMb2dnZWRJbih7IGlzTG9nZ2VkSW46ICFHZXRBdXRoU3RhdHVzIH0pXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiIHYtaWY9XCJHZXRBdXRoU3RhdHVzXCI+XHJcbiAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1zaWduLW91dFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICA8YSBocmVmPVwiIyFcIiBAY2xpY2s9XCJsb2dvdXRcIj5Mb2dvdXQ8L2E+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxyZWdpc3RlciA6c2hvdz1cIlNob3dSZWdpc3Rlck1vZGFsXCI+PC9yZWdpc3Rlcj5cclxuICAgICAgPGxvZ2luIHYtYmluZDpzaG93PVwiU2hvd0xvZ2luTW9kYWxcIj48L2xvZ2luPlxyXG4gICAgPC9uYXY+XHJcbiAgPC90ZW1wbGF0ZT5cclxuICA8c2NyaXB0PlxyXG4gICAgaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuICAgIGltcG9ydCB7IG1hcEdldHRlcnMsIG1hcE11dGF0aW9ucyB9IGZyb20gJ3Z1ZXgnO1xyXG4gICAgaW1wb3J0IHJlZ2lzdGVyIGZyb20gJy4vcmVnaXN0ZXIudnVlJztcclxuICAgIGltcG9ydCBsb2dpbiBmcm9tICcuL2xvZ2luLnZ1ZSc7XHJcbiAgICBpbXBvcnQgTGVhZ3VlRHJvcGRvd24gZnJvbSAnLi9uYXZiYXJEcm9wZG93bi52dWUnO1xyXG4gICAgZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiAge1xyXG4gICAgICAgICAgdXNlcm5hbWU6ICcnLFxyXG4gICAgICAgICAgcGFzc3dvcmQ6ICcnLFxyXG4gICAgICAgICAgc2hvd1JlZ2lzdGVyTW9kYWw6IGZhbHNlLFxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgY29tcHV0ZWQ6IG1hcEdldHRlcnMoW1xyXG4gICAgICAgICdTaG93TG9naW5Nb2RhbCcsXHJcbiAgICAgICAgJ1Nob3dSZWdpc3Rlck1vZGFsJyxcclxuICAgICAgICAnZ2V0VXNlckRhdGEnLFxyXG4gICAgICAgICdHZXRBdXRoU3RhdHVzJ1xyXG4gICAgICBdKSxcclxuICAgICAgbW91bnRlZCgpIHtcclxuICAgICAgICAvLyBHZXQgYWxsIFwibmF2YmFyLWJ1cmdlclwiIGVsZW1lbnRzXHJcbiAgICAgICAgdmFyICRuYXZiYXJCdXJnZXJzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm5hdmJhci1idXJnZXInKSwgMCk7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSBuYXYgYnVyZ2Vyc1xyXG4gICAgICAgIGlmICgkbmF2YmFyQnVyZ2Vycy5sZW5ndGggPiAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIGEgY2xpY2sgZXZlbnQgb24gZWFjaCBvZiB0aGVtXHJcbiAgICAgICAgICAkbmF2YmFyQnVyZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICgkZWwpIHtcclxuICAgICAgICAgICAgJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRhcmdldCBmcm9tIHRoZSBcImRhdGEtdGFyZ2V0XCIgYXR0cmlidXRlXHJcbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9ICRlbC5kYXRhc2V0LnRhcmdldDtcclxuICAgICAgICAgICAgICB2YXIgJHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFRvZ2dsZSB0aGUgY2xhc3Mgb24gYm90aCB0aGUgXCJuYXZiYXItYnVyZ2VyXCIgYW5kIHRoZSBcIm5hdmJhci1tZW51XCJcclxuICAgICAgICAgICAgICAkZWwuY2xhc3NMaXN0LnRvZ2dsZSgnaXMtYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgJHRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKCdpcy1hY3RpdmUnKTtcclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBjcmVhdGVkKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwic3JjXCIsIHRoaXMubG9nb3NyYylcclxuICAgICAgICBheGlvcy5nZXQoJy9sb2dpbnJlZnJlc2gnKS50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAgY29uc29sZS5sb2coZGF0YS5kYXRhKVxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmRhdGEudXNlcm5hbWUgIT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVc2VyIElzIEF1dGhlbnRpY2F0ZWRcIilcclxuICAgICAgICAgICAgdGhpcy5zZXRVc2VyRGF0YSh7IHVzZXJEYXRhOiBkYXRhLmRhdGEgfSlcclxuICAgICAgICAgICAgdGhpcy5zZXRMb2dnZWRJbih7IGxvZ2dlZEluOiB0cnVlIH0pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwibG9naW4gcmVmcmVzaCBlcnJvclwiLCBlcnIpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH0sXHJcbiAgICAgIG1ldGhvZHM6IHtcclxuICAgICAgICAuLi5tYXBNdXRhdGlvbnMoW1xyXG4gICAgICAgICAgJ3NldFJlZ2lzdGVyTW9kYWwnLFxyXG4gICAgICAgICAgJ3NldExvZ2luTW9kYWwnLFxyXG4gICAgICAgICAgJ3NldExvZ2dlZEluJyxcclxuICAgICAgICAgICdzZXRVc2VyRGF0YScsXHJcbiAgICAgICAgICAnbG9nb3V0JyxcclxuICAgICAgICAgICdzZXRNYW5hZ2VkTGVhZ3VlJyxcclxuICAgICAgICAgICdzZXRMZWFndWVzJ1xyXG4gICAgICAgIF0pLFxyXG4gICAgICAgIGxvZ291dCgpIHtcclxuICAgICAgICAgIGF4aW9zLmdldCgnbG9nb3V0JykudGhlbihkYXRhID0+IHtcclxuICAgICAgICAgICAgdGhpcy4kcm91dGVyLnB1c2goXCIvXCIpO1xyXG4gICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbXBvbmVudHM6IHtcclxuICAgICAgICAncmVnaXN0ZXInOiByZWdpc3RlcixcclxuICAgICAgICAnbG9naW4nOiBsb2dpbixcclxuICAgICAgICAnTGVhZ3VlRHJvcGRvd24nOiBMZWFndWVEcm9wZG93blxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgPC9zY3JpcHQ+XHJcbiAgPHN0eWxlPlxyXG4gICAgLm5hdmJhci1tZW51IHtcclxuICAgICAgcGFkZGluZzogMCAxMDBweCAwIDUwcHg7XHJcbiAgICB9XHJcbiAgICAubmF2YmFyIHtcclxuICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XHJcbiAgICB9XHJcbiAgICBhIHtcclxuICAgICAgY29sb3I6IHdoaXRlO1xyXG4gICAgICBmb250LXNpemU6IDE2cHQ7XHJcbiAgICB9XHJcbiAgICAucm91dGVyLWxpbmstYWN0aXZlIHtcclxuICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNmZmZjN2Y7XHJcbiAgICB9XHJcbiAgPC9zdHlsZT5cclxufSlcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGNsaWVudC9jb21wb25lbnRzL25hdmJhci52dWUiLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cImRyb3Bkb3duXCIgQGNsaWNrPVwiaXNBY3RpdmUgPSAhaXNBY3RpdmVcIiB2LWJpbmQ6Y2xhc3M9XCJ7ICdpcy1hY3RpdmUnOiBpc0FjdGl2ZSB9XCI+XHJcbiAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLXRyaWdnZXJcIj5cclxuICAgIDxoMyBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtY29udHJvbHM9XCJkcm9wZG93bi1tZW51XCI+XHJcbiAgICAgIDxzcGFuPkN1cnJlbnRseSBNYW5hZ2luZzoge3sgTWFuYWdlZExlYWd1ZS5uYW1lIH19PC9zcGFuPlxyXG4gICAgICA8c3BhbiBjbGFzcz1cImljb24gaXMtc21hbGxcIj5cclxuICAgICAgICA8aSBjbGFzcz1cImZhIGZhLWFuZ2xlLWRvd25cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XHJcbiAgICAgIDwvc3Bhbj5cclxuICAgIDwvaDM+XHJcbiAgPC9kaXY+XHJcbiAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIiBpZD1cImRyb3Bkb3duLW1lbnVcIiByb2xlPVwibWVudVwiPlxyXG4gICAgPGRpdiBjbGFzcz1cImRyb3Bkb3duLWNvbnRlbnRcIiB2LWZvcj1cImxlYWd1ZSBpbiBMZWFndWVMaXN0XCI+XHJcbiAgICAgIDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCIgQGNsaWNrPVwiY2hhbmdlTGVhZ3VlKGxlYWd1ZSlcIj5cclxuICAgICAgICB7e2xlYWd1ZS5uYW1lfX1cclxuICAgICAgPC9hPlxyXG4gICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbjwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG48c2NyaXB0PlxyXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5pbXBvcnQgeyBtYXBNdXRhdGlvbnMsIG1hcEdldHRlcnMgfSBmcm9tICd2dWV4JztcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgZGF0YSgpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpc0FjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgTWFuYWdlZExlYWd1ZTogJycsXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wdXRlZDoge1xyXG4gICAgICBMZWFndWVMaXN0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFsbExlYWd1ZXMuZmlsdGVyKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIGl0ZW0ubGVhZ3VlaWQgIT0gdGhpcy5NYW5hZ2VkTGVhZ3VlLmxlYWd1ZWlkO1xyXG4gICAgICAgIH0pXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjcmVhdGVkKCkge1xyXG4gICAgICB0aGlzLk1hbmFnZWRMZWFndWUgPSB0aGlzLmN1cnJlbnRMZWFndWU7XHJcbiAgICB9LFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgY3VycmVudExlYWd1ZToge1xyXG4gICAgICAgIHR5cGU6IE9iamVjdCxcclxuICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICBhbGxMZWFndWVzOiB7XHJcbiAgICAgICAgdHlwZTogQXJyYXksXHJcbiAgICAgICAgcmVxdWlyZWQ6IHRydWVcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgLi4ubWFwTXV0YXRpb25zKFtcclxuICAgICAgICAnc2V0TWFuYWdlZExlYWd1ZSdcclxuICAgICAgXSksXHJcbiAgICAgIGNoYW5nZUxlYWd1ZShsZWFndWUpIHtcclxuICAgICAgICB0aGlzLnNldE1hbmFnZWRMZWFndWUobGVhZ3VlKVxyXG4gICAgICAgIHRoaXMuTWFuYWdlZExlYWd1ZSA9IGxlYWd1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG48c3R5bGU+XHJcbiAgaDMge1xyXG4gICAgZm9udC1zaXplOiAxNnB0O1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG4gIH1cclxuICBkaXYuZHJvcGRvd24ubmF2YmFyLWl0ZW06aG92ZXIge1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gIH1cclxuPC9zdHlsZT5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGNsaWVudC9jb21wb25lbnRzL25hdmJhckRyb3Bkb3duLnZ1ZSIsIjx0ZW1wbGF0ZT5cclxuICA8ZGl2IGNsYXNzPVwibW9kYWxcIiB2LWJpbmQ6Y2xhc3M9XCJ7J2lzLWFjdGl2ZSc6IFNob3dSZWdpc3Rlck1vZGFsfVwiIGlkPVwicmVnaXN0ZXJNb2RhbFwiPlxyXG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJhY2tncm91bmRcIj48L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jYXJkXCI+XHJcbiAgICAgIDxoZWFkZXIgY2xhc3M9XCJtb2RhbC1jYXJkLWhlYWRcIj5cclxuICAgICAgICA8cCBjbGFzcz1cIm1vZGFsLWNhcmQtdGl0bGVcIj5OZXcgVXNlciBSZWdpc3RyYXRpb248L3A+XHJcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImRlbGV0ZVwiIEBjbGljaz1cInNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiAhU2hvd1JlZ2lzdGVyTW9kYWx9KVwiPjwvYnV0dG9uPlxyXG4gICAgICA8L2hlYWRlcj5cclxuICAgICAgPHNlY3Rpb24gY2xhc3M9XCJtb2RhbC1jYXJkLWJvZHlcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cclxuICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJsYWJlbFwiPlVzZXJuYW1lOiA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCI+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImlucHV0XCIgdi1iaW5kOmNsYXNzPVwieyAnaXMtZGFuZ2VyJzogaW52YWxpZFVzZXJuYW1lIH1cIiBpZD1cInJlZy11c2VybmFtZVwiIHYtbW9kZWw9XCJ1c2VybmFtZVwiIHBsYWNlaG9sZGVyPVwiVXNlcm5hbWVcIiByZXF1aXJlZD5cclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCI+XHJcbiAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtdXNlclwiPjwvaT5cclxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImxhYmVsXCI+RW1haWw6IDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2wgaGFzLWljb25zLWxlZnRcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImVtYWlsXCIgY2xhc3M9XCJpbnB1dFwiIHYtYmluZDpjbGFzcz1cInsgJ2lzLWRhbmdlcic6IGludmFsaWRFbWFpbCB9XCIgIGlkPVwicmVnLWVtYWlsXCIgdi1tb2RlbD1cImVtYWlsXCIgcGxhY2Vob2xkZXI9XCJFbWFpbFwiIHJlcXVpcmVkPlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIj5cclxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1lbnZlbG9wZVwiPjwvaT5cclxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImxhYmVsXCI+UGFzc3dvcmQ6IDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2wgaGFzLWljb25zLWxlZnRcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInBhc3N3b3JkXCIgY2xhc3M9XCJpbnB1dFwiIHYtYmluZDpjbGFzcz1cInsgJ2lzLWRhbmdlcic6IGJsYW5rUGFzc3dvcmQgfVwiIHYtbW9kZWw9XCJwYXNzd29yZFwiIHBsYWNlaG9sZGVyPVwiUGFzc3dvcmRcIiByZXF1aXJlZD5cclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCI+XHJcbiAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtbG9ja1wiPjwvaT5cclxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgICAgIDxkaXYgaWQ9XCJyZWdpc3Rlci1yZWNhcHRjaGFcIj48L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlcnJvck1lc3NhZ2VcIiB2LWZvcj1cImVycm9yIGluIGVycm9yTWVzc2FnZVwiIHYtaWY9XCJlcnJvck1lc3NhZ2UgIT0gJydcIj5cclxuICAgICAgICAgICAgICB7eyBlcnJvciB9fVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9zZWN0aW9uPlxyXG4gICAgICA8Zm9vdGVyIGNsYXNzPVwibW9kYWwtY2FyZC1mb290XCI+XHJcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBpcy1zdWNjZXNzXCIgQGNsaWNrPVwiUmVnaXN0ZXJcIiB2LWJpbmQ6Y2xhc3M9XCJ7ICdpcy1sb2FkaW5nJzogaXNMb2FkaW5nIH1cIj5SZWdpc3RlcjwvYnV0dG9uPlxyXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b25cIiBAY2xpY2s9XCJzZXRSZWdpc3Rlck1vZGFsKHsgc2hvdzogIVNob3dSZWdpc3Rlck1vZGFsIH0pXCI+Q2FuY2VsPC9idXR0b24+XHJcbiAgICAgIDwvZm9vdGVyPlxyXG4gICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgeyBtYXBHZXR0ZXJzLCBtYXBNdXRhdGlvbnMgfSBmcm9tICd2dWV4JztcclxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuICBleHBvcnQgZGVmYXVsdCB7XHJcbiAgICBkYXRhKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZXJuYW1lOiAnJyxcclxuICAgICAgICBlbWFpbDogJycsXHJcbiAgICAgICAgcGFzc3dvcmQ6ICcnLFxyXG4gICAgICAgIGVycm9yTWVzc2FnZTogW10sXHJcbiAgICAgICAgaW52YWxpZFVzZXJuYW1lOiBmYWxzZSxcclxuICAgICAgICBpbnZhbGlkRW1haWw6IGZhbHNlLFxyXG4gICAgICAgIGJsYW5rUGFzc3dvcmQ6IGZhbHNlLFxyXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2VcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXB1dGVkOiBtYXBHZXR0ZXJzKFtcclxuICAgICAgJ1Nob3dSZWdpc3Rlck1vZGFsJyxcclxuICAgICAgJ2dldFVzZXJEYXRhJ1xyXG4gICAgXSksXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgIC4uLm1hcE11dGF0aW9ucyhbXHJcbiAgICAgICAgJ3NldFJlZ2lzdGVyTW9kYWwnLFxyXG4gICAgICAgICdzZXRVc2VyRGF0YScsXHJcbiAgICAgICAgJ3NldExvZ2dlZEluJ1xyXG4gICAgICBdKSxcclxuICAgICAgUmVnaXN0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gW107XHJcbiAgICAgICAgdGhpcy5pbnZhbGlkRW1haWwgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmJsYW5rUGFzc3dvcmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmludmFsaWRVc2VybmFtZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLlJlZ2lzdHJhdGlvbklzVmFsaWQoKSkge1xyXG4gICAgICAgICAgYXhpb3MucG9zdCgnL3JlZ2lzdGVyJywge1xyXG4gICAgICAgICAgICB1c2VybmFtZTogdGhpcy51c2VybmFtZSxcclxuICAgICAgICAgICAgZW1haWw6IHRoaXMuZW1haWwsXHJcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLnBhc3N3b3JkLFxyXG4gICAgICAgICAgICBjYXB0Y2hhOiBncmVjYXB0Y2hhLmdldFJlc3BvbnNlKDEpXHJcbiAgICAgICAgICB9KS50aGVuKGRhdGEgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGlzRmFsc2UgPSAhZGF0YS5kYXRhLkVycm9yTWVzc2FnZTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpc0ZhbHNlXCIsIGlzRmFsc2UpXHJcbiAgICAgICAgICAgIGlmICghZGF0YS5kYXRhLkVycm9yTWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuc2V0VXNlckRhdGEoeyB1c2VyRGF0YTogZGF0YS5kYXRhIH0pXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJnZXRVc2VyRGF0YVwiLCB0aGlzLmdldFVzZXJEYXRhKVxyXG4gICAgICAgICAgICAgIHRoaXMuc2V0UmVnaXN0ZXJNb2RhbCh7IHNob3c6IGZhbHNlIH0pXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy4kc3RvcmUuc3RhdGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlLnB1c2goZGF0YS5kYXRhLkVycm9yTWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UuZm9yRWFjaChtc2cgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1zZy5pbmRleE9mKFwiVXNlcm5hbWVcIikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRVc2VybmFtZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobXNnLmluZGV4T2YoXCJFbWFpbFwiKSA+LTEpIHtcclxuICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkRW1haWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgZ3JlY2FwdGNoYS5yZXNldCgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnVzZXJuYW1lID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMuZW1haWwgPSAnJztcclxuICAgICAgICAgICAgdGhpcy5wYXNzd29yZCA9ICcnXHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLmNhdGNoKGUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZS5wdXNoKGUucmVzcG9uc2UuZGF0YS5lcnJvcik7XHJcbiAgICAgICAgICAgIGdyZWNhcHRjaGEucmVzZXQoMSk7XHJcbiAgICAgICAgICAgIHRoaXMudXNlcm5hbWUgPSAnJztcclxuICAgICAgICAgICAgdGhpcy5lbWFpbCA9ICcnO1xyXG4gICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gJydcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgUmVnaXN0cmF0aW9uSXNWYWxpZCgpIHtcclxuICAgICAgICB2YXIgZW1haWxWYWxpZGF0aW9uID0gdGhpcy5lbWFpbC5tYXRjaChuZXcgUmVnRXhwKC9eKChbXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKFxcLltePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfV0pfCgoW2EtekEtWlxcLTAtOV0rXFwuKStbYS16QS1aXXsyLH0pKSQvKSwgXCJpXCIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGVtYWlsVmFsaWRhdGlvbik7XHJcbiAgICAgICAgaWYgKHRoaXMuZW1haWwgPT0gXCJcIikge1xyXG4gICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UucHVzaChcIlVzZXJuYW1lIGNhbm5vdCBiZSBsZWZ0IGVtcHR5LlwiKVxyXG4gICAgICAgICAgdGhpcy5pbnZhbGlkVXNlcm5hbWUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW1haWxWYWxpZGF0aW9uID09IG51bGwpIHtcclxuICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlLnB1c2goXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbC5cIilcclxuICAgICAgICAgIHRoaXMuaW52YWxpZEVtYWlsID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFzc3dvcmQgPT0gJycgfHwgdGhpcy5wYXNzd29yZC5sZW5ndGggPCA2KSB7XHJcbiAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZS5wdXNoKFwiUGFzc3dvcmQgY2Fubm90IGJlIGxlZnQgZW1wdHkgYW5kIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzLlwiKVxyXG4gICAgICAgICAgdGhpcy5ibGFua1Bhc3N3b3JkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JNZXNzYWdlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG4gIC5lcnJvck1lc3NhZ2Uge1xyXG4gICAgY29sb3I6ICNmZjM4NjA7XHJcbiAgfVxyXG48L3N0eWxlPlxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiZmxleC1jZW50ZXIgZmwgbGl2ZS1oZWFkZXJcIiB2LWlmPVwiIWlzTG9hZGluZ1wiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwibGl2ZS1oZWFkZXItYm94XCI+XHJcbiAgICAgICAgPGRpdj5TZXNzaW9uIEV2ZW50OiA8c3BhbiBjbGFzcz1cInRleHQtaGlnaGxpZ2h0IGZsLXJpZ2h0XCI+e3tyYWNlRGF0YS5yYWNlRGF0YS5TfX08L3NwYW4+PC9kaXY+XHJcbiAgICAgICAgPGRpdj5TZWFzb24gRXZlbnQ6PHNwYW4gY2xhc3M9XCJ0ZXh0LWhpZ2hsaWdodCBmbC1yaWdodFwiPiB7e3JhY2VEYXRhLnJhY2VEYXRhLkV9fTwvc3Bhbj48L2Rpdj5cclxuICAgICAgICA8ZGl2PlNlc3Npb24gU3RhdHVzOjxzcGFuIGNsYXNzPVwidGV4dC1oaWdobGlnaHQgZmwtcmlnaHRcIj4ge3tyYWNlRGF0YS5yYWNlRGV0YWlscy5CfX08L3NwYW4+PC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiY29sdW1ucyBsZWFkZXJib2FyZFwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uIGlzLWhhbGYgaXMtb2Zmc2V0LW9uZS1xdWFydGVyXCI+XHJcbiAgICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGUtbGl2ZVwiIHYtaWY9XCIhaXNMb2FkaW5nXCI+XHJcbiAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICA8dGg+UG9zaXRpb248L3RoPlxyXG4gICAgICAgICAgICAgIDx0aD5Ub3RhbCBQb2ludHM8L3RoPlxyXG4gICAgICAgICAgICAgIDx0aD5Vc2VybmFtZTwvdGg+XHJcbiAgICAgICAgICAgICAgPHRoPlBvaW50cyBCYWNrPC90aD5cclxuICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICA8dGZvb3Q+XHJcbiAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICA8dGg+UG9zaXRpb248L3RoPlxyXG4gICAgICAgICAgICAgIDx0aD5Ub3RhbCBQb2ludHM8L3RoPlxyXG4gICAgICAgICAgICAgIDx0aD5Vc2VybmFtZTwvdGg+XHJcbiAgICAgICAgICAgICAgPHRoPlBvaW50cyBCYWNrPC90aD5cclxuICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgIDwvdGZvb3Q+XHJcbiAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgIDx0ciB2LWZvcj1cIih1c2VyLCBpbmRleCkgaW4gc3RhbmRpbmdzXCIgdi1iaW5kOmNsYXNzPVwiWyB1c2VyLnVzZXJuYW1lID09IGdldFVzZXJEYXRhLnVzZXJuYW1lID8gJ215Um93JyA6ICcnXVwiPlxyXG4gICAgICAgICAgICAgIDx0ZD57eyBpbmRleCArIDEgfX0uPC90ZD5cclxuICAgICAgICAgICAgICA8dGQ+e3t1c2VyLnRvdGFsfX08L3RkPlxyXG4gICAgICAgICAgICAgIDx0ZD57e3VzZXIudXNlcm5hbWV9fTwvdGQ+XHJcbiAgICAgICAgICAgICAgPHRkIGNsYXNzPVwicG9pbnRzYmFja1wiPnt7IHBvaW50c2JlaGluZCh1c2VyKSB9fTwvdGQ+XHJcbiAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgIDwvdGFibGU+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcbjxzY3JpcHQ+XHJcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XHJcbmltcG9ydCB7IG1hcEdldHRlcnMgfSBmcm9tICd2dWV4JztcclxuICBleHBvcnQgZGVmYXVsdCB7XHJcbiAgICBkYXRhKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlYWd1ZURhdGE6IFtdLFxyXG4gICAgICAgIHJhY2VEYXRhOiBbXSxcclxuICAgICAgICBpc0xvYWRpbmc6IHRydWUsXHJcbiAgICAgICAgd3M6IG51bGxcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgIC4uLm1hcEdldHRlcnMoW1xyXG4gICAgICAgICdnZXRVc2VyRGF0YSdcclxuICAgICAgXSksXHJcbiAgICAgIHN0YW5kaW5nczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVhZ3VlRGF0YS5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgICAgICByZXR1cm4gYS50b3RhbCAtIGIudG90YWw7XHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNyZWF0ZWQoKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKHByb2Nlc3MuZW52Lk5PREVfRU5WKVxyXG4gICAgICB0aGlzLndzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT0gJ3Byb2R1Y3Rpb24nXHJcbiAgICAgICAgPyBuZXcgV2ViU29ja2V0KFwid3NzOi8vZmFudGFzeXN4Lmhlcm9rdWFwcC5jb20vdHJhY2tlclwiKVxyXG4gICAgICAgIDogbmV3IFdlYlNvY2tldChcIndzczovL2ZhbnRhc3lzeC5oZXJva3VhcHAuY29tL3RyYWNrZXJcIik7XHJcblxyXG4gICAgICB2YXIgdiA9IHRoaXM7XHJcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoZS5kYXRhKTtcclxuICAgICAgICB2LmlzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHYubGVhZ3VlRGF0YSA9IGRhdGEuTGVhZ3VlRGF0YTtcclxuICAgICAgICB2LnJhY2VEYXRhID0gZGF0YS5SYWNlRGF0YTtcclxuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvclwiLCBlKVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczogIHtcclxuICAgICAgcG9pbnRzYmVoaW5kOiBmdW5jdGlvbih1c2VyKSB7XHJcbiAgICAgICAgdmFyIG9iakluZGV4ID0gdGhpcy5sZWFndWVEYXRhLmluZGV4T2YodXNlcik7XHJcbiAgICAgICAgaWYgKG9iakluZGV4ICE9IDApIHtcclxuICAgICAgICAgIHJldHVybiB1c2VyLnRvdGFsIC0gdGhpcy5sZWFndWVEYXRhWzBdLnRvdGFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJy0nXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgICB0aGlzLndzLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG48L3NjcmlwdD5cclxuPHN0eWxlPlxyXG4uZmxleC1jZW50ZXIge1xyXG4gIGRpc3BsYXk6ZmxleDtcclxuICBqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO1xyXG59XHJcbi5saXZlLWhlYWRlci1ib3gge1xyXG4gIG1pbi13aWR0aDogMzYwcHg7XHJcbn1cclxuLmxpdmUtaGVhZGVyIHtcclxuICBjb2xvcjogd2hpdGU7XHJcbiAgZm9udC1zaXplOiAxMnB0O1xyXG4gIG1hcmdpbi10b3A6IDNyZW07XHJcbiAgZm9udC13ZWlnaHQ6IDcwMDtcclxufVxyXG4udGV4dC1oaWdobGlnaHQge1xyXG4gICAgZm9udC1zaXplOiAxMnB0O1xyXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcclxuICAgIGNvbG9yOiAjZmZmYzdmO1xyXG59XHJcbi5mbC1yaWdodCB7XHJcbiAgZmxvYXQ6IHJpZ2h0O1xyXG59XHJcbiAgLm15Um93IHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsIDIzMywgMTIwLCAuNykgIWltcG9ydGFudDtcclxuICAgIGNvbG9yOiAjZDI0YTAwO1xyXG4gICAgZm9udC13ZWlnaHQ6IDYwMDtcclxuICB9XHJcbiAgLnRhYmxlLWxpdmUgdGFibGUgdGQge1xyXG4gICAgYm9yZGVyOiBub25lO1xyXG4gIH1cclxuICAudGFibGUtbGl2ZSB7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC44KTtcclxuICAgIGNvbG9yOiAjN2I3YjdiO1xyXG4gICAgYm94LXNoYWRvdzogMXB4IDFweCAxMHB4ICMyMjI7XHJcbiAgfVxyXG4gIC50YWJsZS1saXZlIHRoZWFkLCB0Zm9vdCB7XHJcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQocmdiYSgyNTUsIDEwNiwgMCwgMSkwJSwgcmdiYSgxNTYsIDUyLCAwLCAxKTEwMCUpO1xyXG4gIH1cclxuICAudGFibGUtbGl2ZSB0aGVhZCB0aCwgdGZvb3QgdGgge1xyXG4gICAgY29sb3I6ICNmZmY7XHJcbiAgICBmb250LXNpemU6IDEycHQ7XHJcbiAgfVxyXG4gIC50YWJsZS1saXZlIHRyOmhvdmVyIHtcclxuICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyMzMsIDEyMCwgLjIpO1xyXG4gIH1cclxuPC9zdHlsZT5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGNsaWVudC9jb21wb25lbnRzL3N0YXR0cmFja2VyLnZ1ZSIsIjx0ZW1wbGF0ZT5cclxuICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyIHN1Z2dlc3Rpb25zLWNvbnRhaW5lclwiPlxyXG4gICAgICA8c2VjdGlvbj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XHJcbiAgICAgICAgICAgIDxsYWJlbD5BcmUgeW91IGEgcmVnaXN0ZXJlZCB1c2VyPzwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cInJhZGlvXCI+XHJcbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCJSZWdpc3RlcmVkXCIgdmFsdWU9XCJ0cnVlXCIgdi1tb2RlbD1cIlJlZ2lzdGVyZWRcIj5cclxuICAgICAgICAgICAgICBZZXNcclxuICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwicmFkaW9cIj5cclxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cIlJlZ2lzdGVyZWRcIiB2YWx1ZT1cImZhbHNlXCIgdi1tb2RlbD1cIlJlZ2lzdGVyZWRcIj5cclxuICAgICAgICAgICAgICBOb1xyXG4gICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxyXG4gICAgICAgICAgICA8bGFiZWw+SXMgdGhpcyBmZWVkYmFjayBvciBhIGJ1ZyByZXBvcnQ/PC9sYWJlbD5cclxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwicmFkaW9cIj5cclxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImZlZWRiYWNrXCIgdi1tb2RlbD1cIlJlcG9ydFR5cGVcIiB2YWx1ZT1cImZlZWRiYWNrXCI+XHJcbiAgICAgICAgICAgICAgRmVlZGJhY2tcclxuICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwicmFkaW9cIj5cclxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cImZlZWRiYWNrXCIgdi1tb2RlbD1cIlJlcG9ydFR5cGVcIiB2YWx1ZT1cImJ1Z1wiPlxyXG4gICAgICAgICAgICAgIEJ1ZyBSZXBvcnRcclxuICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxyXG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwibGFiZWxcIj5Vc2VybmFtZTwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XHJcbiAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiaW5wdXRcIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiVXNlcm5hbWVcIiB2LW1vZGVsPVwiVXNlcm5hbWVcIj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCIgdi1pZj1cIlJlcG9ydFR5cGUgPT0gJ2ZlZWRiYWNrJ1wiPlxyXG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwibGFiZWxcIj5TdWdnZXN0IEZlYXR1cmVzPC9sYWJlbD5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWxlY3RcIj5cclxuICAgICAgICAgICAgICA8c2VsZWN0IHYtbW9kZWw9XCJmZWF0dXJlXCI+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uIGRpc2FibGVkIHZhbHVlPVwiXCI+U0VMRUNUIENBVEVHT1JZPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uPlVzZXIgSW50ZXJmYWNlPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uPk5hdmlnYXRpb24gQ29udGVudDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbj5NeSBUZWFtPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uPlNjb3Jpbmc8L29wdGlvbj5cclxuICAgICAgICAgICAgICAgIDxvcHRpb24+TmV3IEZlYXR1cmVzPC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICA8b3B0aW9uPlN0YXQgVHJhY2tlcjwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbj5BY2NvdW50PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCIgdi1pZj1cIlJlcG9ydFR5cGUgPT0gJ2ZlZWRiYWNrJ1wiPlxyXG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwibGFiZWxcIj5GZWVkYmFjazwvbGFiZWw+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxyXG4gICAgICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJ0ZXh0YXJlYVwiIHYtbW9kZWw9XCJmZWVkYmFja1wiIHBsYWNlaG9sZGVyPVwiRGVzY3JpYmUgeW91ciBzdWdnZXN0aW9ucyBoZXJlLlwiPjwvdGV4dGFyZWE+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIiB2LWlmPVwiUmVwb3J0VHlwZSA9PSAnYnVnJ1wiPlxyXG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwibGFiZWxcIj5SZXBvcnQgQnVnPC9sYWJlbD5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCI+XHJcbiAgICAgICAgICAgIDx0ZXh0YXJlYSBjbGFzcz1cInRleHRhcmVhXCIgdi1tb2RlbD1cImJ1Z3JlcG9ydFwiIHBsYWNlaG9sZGVyPVwiRGVzY3JpYmUgdGhlIGFjdGlvbnMgeW91IHRvb2ssIHlvdXIgZGVzaXJlZCBvdXRjb21lIGFuZCB0aGUgYWN0dWFsIG91dGNvbWUgb2YgdGhvc2UgYWN0aW9ucy4gV2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVwbGljYXRlIHRoZSBidWcgYmFzZWQgb2ZmIHRoZSBzdGVwcyB5b3UgcHJvdmlkZSBoZXJlLlwiPjwvdGV4dGFyZWE+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cclxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gaXMtcHJpbWFyeVwiIHYtb246Y2xpY2s9XCJzdWJtaXRcIiB0eXBlPVwiYnV0dG9uXCI+U3VibWl0PC9idXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvc2VjdGlvbj5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuPHNjcmlwdD5cclxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcclxuICBleHBvcnQgZGVmYXVsdCB7XHJcbiAgICBkYXRhKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIFVzZXJuYW1lOiAnJyxcclxuICAgICAgICBSZXBvcnRUeXBlOiAnJyxcclxuICAgICAgICBSZWdpc3RlcmVkOiBmYWxzZSxcclxuICAgICAgICBmZWF0dXJlOiAnJyxcclxuICAgICAgICBidWdyZXBvcnQ6ICcnLFxyXG4gICAgICAgIGZlZWRiYWNrOiAnJ1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICBzdWJtaXQoKSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICBVc2VybmFtZTogdGhpcy5Vc2VybmFtZSxcclxuICAgICAgICAgIFJlcG9ydFR5cGU6IHRoaXMuUmVwb3J0VHlwZSxcclxuICAgICAgICAgIFJlZ2lzdGVyZWQ6IHRoaXMuUmVnaXN0ZXJlZCxcclxuICAgICAgICAgIEZlYXR1cmU6IHRoaXMuZmVhdHVyZSxcclxuICAgICAgICAgIEJ1Z1JlcG9ydDogdGhpcy5idWdyZXBvcnQsXHJcbiAgICAgICAgICBGZWVkYmFjazogdGhpcy5mZWVkYmFja1xyXG4gICAgICAgIH1cclxuICAgICAgICBheGlvcy5wb3N0KCcvZmVlZGJhY2snLCBkYXRhKVxyXG4gICAgICAgIC50aGVuKHJlcyA9PiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhyZXMpXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuPC9zY3JpcHQ+XHJcbjxzdHlsZT5cclxuICAuc3VnZ2VzdGlvbnMtY29udGFpbmVyIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgIG1hcmdpbi10b3A6IDNyZW07XHJcbiAgICBjb2xvcjogd2hpdGU7XHJcbiAgfVxyXG48L3N0eWxlPlxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gY2xpZW50L2NvbXBvbmVudHMvc3VnZ2VzdGlvbnMudnVlIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXYgaWQ9XCJhcHBcIj5cclxuICAgIDxuYXZpZ2F0aW9uPjwvbmF2aWdhdGlvbj5cclxuICAgIDxyb3V0ZXItdmlldz48L3JvdXRlci12aWV3PlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHN0eWxlPlxyXG48L3N0eWxlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IG5hdmJhciBmcm9tICcuL2NsaWVudC9jb21wb25lbnRzL25hdmJhci52dWUnO1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIHVzZXJuYW1lOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLnN0YXRlLnVzZXJuYW1lXHJcbiAgICB9LFxyXG4gICAgaXNMb2dnZWRJbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5zdGF0ZS5pc0xvZ2dlZEluXHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wb25lbnRzOiB7XHJcbiAgICAnbmF2aWdhdGlvbic6IG5hdmJhclxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGluZGV4LnZ1ZSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xyXG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxyXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTdiOGExOWI0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9yZWdpc3Rlci52dWVcIilcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9yZWdpc3Rlci52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3JlZ2lzdGVyLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IF9fdnVlX3RlbXBsYXRlX18gZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtN2I4YTE5YjRcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9yZWdpc3Rlci52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiY2xpZW50XFxcXGNvbXBvbmVudHNcXFxccmVnaXN0ZXIudnVlXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTdiOGExOWI0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtN2I4YTE5YjRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWVcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBWdWUgZnJvbSAndnVlJztcclxuaW1wb3J0IFJvdXRlciBmcm9tICd2dWUtcm91dGVyJztcclxuaW1wb3J0IGhvbWUgZnJvbSAnLi9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWUnO1xyXG5pbXBvcnQgcmVnaXN0ZXIgZnJvbSAnLi9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWUnO1xyXG5pbXBvcnQgbXl0ZWFtIGZyb20gJy4vY2xpZW50L2NvbXBvbmVudHMvbXl0ZWFtLnZ1ZSc7XHJcbmltcG9ydCBydWxlcyBmcm9tICcuL2NsaWVudC9jb21wb25lbnRzL3J1bGVzLnZ1ZSc7XHJcbmltcG9ydCBzdGF0dHJhY2tlciBmcm9tICcuL2NsaWVudC9jb21wb25lbnRzL3N0YXR0cmFja2VyLnZ1ZSc7XHJcbmltcG9ydCBzdWdnZXN0aW9ucyBmcm9tICcuL2NsaWVudC9jb21wb25lbnRzL3N1Z2dlc3Rpb25zLnZ1ZSc7XHJcbmltcG9ydCBteWFjY291bnQgZnJvbSAnLi9jbGllbnQvY29tcG9uZW50cy9teWFjY291bnQudnVlJztcclxuaW1wb3J0IGNyZWF0ZWxlYWd1ZSBmcm9tICcuL2NsaWVudC9jb21wb25lbnRzL0NyZWF0ZUxlYWd1ZS52dWUnO1xyXG5pbXBvcnQgam9pbmxlYWd1ZSBmcm9tICcuL2NsaWVudC9jb21wb25lbnRzL2pvaW5sZWFndWUudnVlJztcclxuaW1wb3J0IGRlbGV0ZWFjY291bnQgZnJvbSAnLi9jbGllbnQvY29tcG9uZW50cy9kZWxldGVhY2NvdW50LnZ1ZSc7XHJcblxyXG5WdWUudXNlKFJvdXRlcilcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3V0ZXIgKCkge1xyXG4gIHJldHVybiBuZXcgUm91dGVyKHtcclxuICAgIG1vZGU6ICdoaXN0b3J5JyxcclxuICAgIHJvdXRlczogW1xyXG4gICAgICB7IHBhdGg6IFwiL1wiLCBjb21wb25lbnQ6IGhvbWUgfSxcclxuICAgICAgeyBwYXRoOiBcIi9yZWdpc3RlclwiLCBjb21wb25lbnQ6IHJlZ2lzdGVyIH0sXHJcbiAgICAgIHsgcGF0aDogXCIvbXl0ZWFtXCIsIGNvbXBvbmVudDogbXl0ZWFtIH0sXHJcbiAgICAgIHsgcGF0aDogXCIvcnVsZXNcIiwgY29tcG9uZW50OiBydWxlcyB9LFxyXG4gICAgICB7IHBhdGg6IFwiL2xpdmVcIiwgY29tcG9uZW50OiBzdGF0dHJhY2tlciB9LFxyXG4gICAgICB7IHBhdGg6IFwiL3N1Z2dlc3Rpb25zXCIsIGNvbXBvbmVudDogc3VnZ2VzdGlvbnMgfSxcclxuICAgICAgeyBwYXRoOiBcIi9ob21lXCIsIGNvbXBvbmVudDogaG9tZSB9LFxyXG4gICAgICB7IHBhdGg6IFwiL215YWNjb3VudFwiLCBjb21wb25lbnQ6IG15YWNjb3VudCxcclxuICAgICAgICBjaGlsZHJlbjogW1xyXG4gICAgICAgICAgeyBwYXRoOiAnY3JlYXRlbGVhZ3VlJywgY29tcG9uZW50OiBjcmVhdGVsZWFndWUgfSxcclxuICAgICAgICAgIHsgcGF0aDogJ2pvaW5sZWFndWUnLCBjb21wb25lbnQ6IGpvaW5sZWFndWUgfSxcclxuICAgICAgICAgIHsgcGF0aDogJ2RlbGV0ZWFjY291bnQnLCBjb21wb25lbnQ6IGRlbGV0ZWFjY291bnQgfVxyXG4gICAgICAgIF19XHJcbiAgICBdXHJcbiAgfSlcclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yb3V0ZXIuanMiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcclxuaW1wb3J0IFZ1ZXggZnJvbSAndnVleCdcclxuXHJcblZ1ZS51c2UoVnVleClcclxuXHJcbmNvbnN0IHN0YXRlID0ge1xyXG4gIHVzZXI6IHtcclxuICAgIHVzZXJuYW1lOiAnJ1xyXG4gIH0sXHJcbiAgaXNMb2dnZWRJbjogZmFsc2UsXHJcbiAgbW9kYWxDb250cm9sOiB7XHJcbiAgICBzaG93TG9naW5Nb2RhbDogZmFsc2UsXHJcbiAgICBzaG93UmVnaXN0ZXJNb2RhbDogZmFsc2VcclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IGdldHRlcnMgPSB7XHJcbiAgZ2V0VXNlckRhdGE6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBzdGF0ZS51c2VyXHJcbiAgfSxcclxuICBTaG93TG9naW5Nb2RhbDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHN0YXRlLm1vZGFsQ29udHJvbC5zaG93TG9naW5Nb2RhbFxyXG4gIH0sXHJcbiAgU2hvd1JlZ2lzdGVyTW9kYWw6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBzdGF0ZS5tb2RhbENvbnRyb2wuc2hvd1JlZ2lzdGVyTW9kYWxcclxuICB9LFxyXG4gIEdldEF1dGhTdGF0dXM6IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBzdGF0ZS5pc0xvZ2dlZEluO1xyXG4gIH1cclxufVxyXG5cclxuY29uc3QgbXV0YXRpb25zID0ge1xyXG4gIGNoYW5nZVRlYW0gKHN0YXRlLCByaWRlckFycmF5KSB7XHJcbiAgICBzdGF0ZS51c2VyLnJpZGVycyA9IHJpZGVyQXJyYXlcclxuICB9LFxyXG4gIHNldExvZ2luTW9kYWwgKHN0YXRlLCB7IHNob3cgfSkge1xyXG4gICAgc3RhdGUubW9kYWxDb250cm9sLnNob3dMb2dpbk1vZGFsID0gc2hvdztcclxuICB9LFxyXG4gIHNldFJlZ2lzdGVyTW9kYWwoc3RhdGUsIHsgc2hvdyB9KSB7XHJcbiAgICBzdGF0ZS5tb2RhbENvbnRyb2wuc2hvd1JlZ2lzdGVyTW9kYWwgPSBzaG93XHJcbiAgfSxcclxuICBzZXRVc2VyRGF0YShzdGF0ZSwgeyB1c2VyRGF0YSB9KSB7XHJcbiAgICBzdGF0ZS51c2VyID0gdXNlckRhdGE7XHJcbiAgfSxcclxuICBzZXRMb2dnZWRJbihzdGF0ZSwgeyBsb2dnZWRJbiB9KSB7XHJcbiAgICBzdGF0ZS5pc0xvZ2dlZEluID0gbG9nZ2VkSW47XHJcbiAgfSxcclxuICBsb2dvdXQoc3RhdGUpIHtcclxuICAgIHN0YXRlLnVzZXIucmlkZXJzID0gW107XHJcbiAgICBzdGF0ZS51c2VyID0ge307XHJcbiAgICBzdGF0ZS5pc0xvZ2dlZEluID0gZmFsc2U7XHJcbiAgfSxcclxuICBzZXRNYW5hZ2VkTGVhZ3VlKHN0YXRlLCB7IGxlYWd1ZSB9KSB7XHJcbiAgICBzdGF0ZS51c2VyLmN1cnJlbnRMZWFndWUgPSBsZWFndWVcclxuICB9LFxyXG4gIHNldExlYWd1ZXMoc3RhdGUsIHsgbGVhZ3VlcyB9KSB7XHJcbiAgICBzdGF0ZS51c2VyLmxlYWd1ZXMgPSBsZWFndWVzO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IFZ1ZXguU3RvcmUoe1xyXG4gIHN0YXRlLFxyXG4gIGdldHRlcnMsXHJcbiAgbXV0YXRpb25zXHJcbn0pO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zdG9yZS9zdG9yZS5qcyIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi02ZGU1YWIzNFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9pbmRleC52dWVcIilcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbmV4cG9ydCAqIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vaW5kZXgudnVlXCJcbmltcG9ydCBfX3Z1ZV9zY3JpcHRfXyBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2luZGV4LnZ1ZVwiXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IF9fdnVlX3RlbXBsYXRlX18gZnJvbSBcIiEhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi02ZGU1YWIzNFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vaW5kZXgudnVlXCJcbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcImluZGV4LnZ1ZVwiXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi02ZGU1YWIzNFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTZkZTVhYjM0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vaW5kZXgudnVlXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XHJcbmltcG9ydCBBcHAgZnJvbSAnLi9pbmRleC52dWUnO1xyXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXIgfSBmcm9tICcuL3JvdXRlcic7XHJcbmltcG9ydCBzdG9yZSBmcm9tICcuL3N0b3JlL3N0b3JlJztcclxuXHJcbnZhciByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoKTtcclxuY29uc3QgYXBwID0gbmV3IFZ1ZSh7XHJcbiAgZWw6IFwiI2FwcFwiLFxyXG4gIHJvdXRlcixcclxuICBzdG9yZSxcclxuICByZW5kZXI6IGggPT4gaChBcHApXHJcbn0pLiRtb3VudChcIiNhcHBcIilcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UodXRpbHMubWVyZ2UoZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2F4aW9zLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwnKTtcbnZhciBjb21iaW5lVVJMcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gdXRpbHMubWVyZ2Uoe1xuICAgICAgdXJsOiBhcmd1bWVudHNbMF1cbiAgICB9LCBhcmd1bWVudHNbMV0pO1xuICB9XG5cbiAgY29uZmlnID0gdXRpbHMubWVyZ2UoZGVmYXVsdHMsIHRoaXMuZGVmYXVsdHMsIHsgbWV0aG9kOiAnZ2V0JyB9LCBjb25maWcpO1xuICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIFN1cHBvcnQgYmFzZVVSTCBjb25maWdcbiAgaWYgKGNvbmZpZy5iYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKGNvbmZpZy51cmwpKSB7XG4gICAgY29uZmlnLnVybCA9IGNvbWJpbmVVUkxzKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgfVxuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmxcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgcmV0dXJuIGVycm9yO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCIndXNlIHN0cmljdCc7XG5cbi8vIGJ0b2EgcG9seWZpbGwgZm9yIElFPDEwIGNvdXJ0ZXN5IGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZGNoYW1iZXJzL0Jhc2U2NC5qc1xuXG52YXIgY2hhcnMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG5mdW5jdGlvbiBFKCkge1xuICB0aGlzLm1lc3NhZ2UgPSAnU3RyaW5nIGNvbnRhaW5zIGFuIGludmFsaWQgY2hhcmFjdGVyJztcbn1cbkUucHJvdG90eXBlID0gbmV3IEVycm9yO1xuRS5wcm90b3R5cGUuY29kZSA9IDU7XG5FLnByb3RvdHlwZS5uYW1lID0gJ0ludmFsaWRDaGFyYWN0ZXJFcnJvcic7XG5cbmZ1bmN0aW9uIGJ0b2EoaW5wdXQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhpbnB1dCk7XG4gIHZhciBvdXRwdXQgPSAnJztcbiAgZm9yIChcbiAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlclxuICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzO1xuICAgIC8vIGlmIHRoZSBuZXh0IHN0ciBpbmRleCBkb2VzIG5vdCBleGlzdDpcbiAgICAvLyAgIGNoYW5nZSB0aGUgbWFwcGluZyB0YWJsZSB0byBcIj1cIlxuICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICBzdHIuY2hhckF0KGlkeCB8IDApIHx8IChtYXAgPSAnPScsIGlkeCAlIDEpO1xuICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG4gICAgb3V0cHV0ICs9IG1hcC5jaGFyQXQoNjMgJiBibG9jayA+PiA4IC0gaWR4ICUgMSAqIDgpXG4gICkge1xuICAgIGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaWR4ICs9IDMgLyA0KTtcbiAgICBpZiAoY2hhckNvZGUgPiAweEZGKSB7XG4gICAgICB0aHJvdyBuZXcgRSgpO1xuICAgIH1cbiAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ0b2E7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2J0b2EuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTQwL2dpLCAnQCcpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgfSxcblxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICB9LFxuXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiB7XG4gICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH0pKClcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgdmFyIG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICB9XG5cbiAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKClcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2lzLWJ1ZmZlci9pbmRleC5qcyIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19IYXNoLmpzIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19Qcm9taXNlLmpzIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19TZXQuanMiLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpLFxuICAgIHNldENhY2hlQWRkID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVBZGQnKSxcbiAgICBzZXRDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX3NldENhY2hlSGFzJyk7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxubW9kdWxlLmV4cG9ydHMgPSBTZXRDYWNoZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19TZXRDYWNoZS5qcyIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fVWludDhBcnJheS5qcyIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fV2Vha01hcC5qcyIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19hcHBseS5qcyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19hcnJheUZpbHRlci5qcyIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYXJyYXlTb21lLmpzIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlRWFjaC5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlRm9yLmpzIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlRm9yT3duLmpzIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIGVxdWFsQnlUYWcgPSByZXF1aXJlKCcuL19lcXVhbEJ5VGFnJyksXG4gICAgZXF1YWxPYmplY3RzID0gcmVxdWlyZSgnLi9fZXF1YWxPYmplY3RzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanMiLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUlzTWF0Y2guanMiLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTWFza2VkID0gcmVxdWlyZSgnLi9faXNNYXNrZWQnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmF0aXZlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc05hdGl2ZS5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNUeXBlZEFycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlS2V5cy5qcyIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlTWFwLmpzIiwidmFyIGJhc2VJc01hdGNoID0gcmVxdWlyZSgnLi9fYmFzZUlzTWF0Y2gnKSxcbiAgICBnZXRNYXRjaERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXRjaERhdGEnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXRjaGVzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwidmFyIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKSxcbiAgICBnZXQgPSByZXF1aXJlKCcuL2dldCcpLFxuICAgIGhhc0luID0gcmVxdWlyZSgnLi9oYXNJbicpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBpc1N0cmljdENvbXBhcmFibGUgPSByZXF1aXJlKCcuL19pc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXNQcm9wZXJ0eTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlTWF0Y2hlc1Byb3BlcnR5LmpzIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlTWFwID0gcmVxdWlyZSgnLi9fYmFzZU1hcCcpLFxuICAgIGJhc2VTb3J0QnkgPSByZXF1aXJlKCcuL19iYXNlU29ydEJ5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgY29tcGFyZU11bHRpcGxlID0gcmVxdWlyZSgnLi9fY29tcGFyZU11bHRpcGxlJyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoID8gaXRlcmF0ZWVzIDogW2lkZW50aXR5XSwgYmFzZVVuYXJ5KGJhc2VJdGVyYXRlZSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcblxuICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VPcmRlckJ5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VPcmRlckJ5LmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVByb3BlcnR5LmpzIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eURlZXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsInZhciBiYXNlVW5zZXQgPSByZXF1aXJlKCcuL19iYXNlVW5zZXQnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIGluZGV4ZXMgb3IgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtudW1iZXJbXX0gaW5kZXhlcyBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcykge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgIHZhciBwcmV2aW91cyA9IGluZGV4O1xuICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQdWxsQXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVB1bGxBdC5qcyIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlUmVzdC5qcyIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gIH1cbiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5ndGg7XG4gIH1cbiAgbGVuZ3RoID0gc3RhcnQgPiBlbmQgPyAwIDogKChlbmQgLSBzdGFydCkgPj4+IDApO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNsaWNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VTbGljZS5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICogdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNvcnRCeTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlU29ydEJ5LmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgbGFzdCA9IHJlcXVpcmUoJy4vbGFzdCcpLFxuICAgIHBhcmVudCA9IHJlcXVpcmUoJy4vX3BhcmVudCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcHJvcGVydHkgcGF0aCB0byB1bnNldC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvcGVydHkgaXMgZGVsZXRlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsIHx8IGRlbGV0ZSBvYmplY3RbdG9LZXkobGFzdChwYXRoKSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbnNldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlVW5zZXQuanMiLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19jYWNoZUhhcy5qcyIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqXG4gKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYHZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgaWYgKHZhbHVlICE9PSBvdGhlcikge1xuICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICB2YWxJc051bGwgPSB2YWx1ZSA9PT0gbnVsbCxcbiAgICAgICAgdmFsSXNSZWZsZXhpdmUgPSB2YWx1ZSA9PT0gdmFsdWUsXG4gICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgdmFyIG90aElzRGVmaW5lZCA9IG90aGVyICE9PSB1bmRlZmluZWQsXG4gICAgICAgIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLFxuICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG5cbiAgICBpZiAoKCFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sICYmICF2YWxJc1N5bWJvbCAmJiB2YWx1ZSA+IG90aGVyKSB8fFxuICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAodmFsSXNOdWxsICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCF2YWxJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgIChvdGhJc1N5bWJvbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgJiYgIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wpIHx8XG4gICAgICAgIChvdGhJc051bGwgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIW90aElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVBc2NlbmRpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fY29tcGFyZUFzY2VuZGluZy5qcyIsInZhciBjb21wYXJlQXNjZW5kaW5nID0gcmVxdWlyZSgnLi9fY29tcGFyZUFzY2VuZGluZycpO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8ub3JkZXJCeWAgdG8gY29tcGFyZSBtdWx0aXBsZSBwcm9wZXJ0aWVzIG9mIGEgdmFsdWUgdG8gYW5vdGhlclxuICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gKlxuICogSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXMgYXJlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSxcbiAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAqIG9mIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgb2JqQ3JpdGVyaWEgPSBvYmplY3QuY3JpdGVyaWEsXG4gICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgbGVuZ3RoID0gb2JqQ3JpdGVyaWEubGVuZ3RoLFxuICAgICAgb3JkZXJzTGVuZ3RoID0gb3JkZXJzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlQXNjZW5kaW5nKG9iakNyaXRlcmlhW2luZGV4XSwgb3RoQ3JpdGVyaWFbaW5kZXhdKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgcmV0dXJuIHJlc3VsdCAqIChvcmRlciA9PSAnZGVzYycgPyAtMSA6IDEpO1xuICAgIH1cbiAgfVxuICAvLyBGaXhlcyBhbiBgQXJyYXkjc29ydGAgYnVnIGluIHRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgY2F1c2VzIGl0LCB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXMsIHRvIHByb3ZpZGUgdGhlIHNhbWUgdmFsdWUgZm9yXG4gIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAvL1xuICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTAgZm9yIG1vcmUgZGV0YWlscy5cbiAgcmV0dXJuIG9iamVjdC5pbmRleCAtIG90aGVyLmluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBhcmVNdWx0aXBsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19jb21wYXJlTXVsdGlwbGUuanMiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUVhY2g7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCIvKipcbiAqIENyZWF0ZXMgYSBiYXNlIGZ1bmN0aW9uIGZvciBtZXRob2RzIGxpa2UgYF8uZm9ySW5gIGFuZCBgXy5mb3JPd25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VGb3IoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzRnVuYykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChvYmplY3QpLFxuICAgICAgICBwcm9wcyA9IGtleXNGdW5jKG9iamVjdCksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRm9yO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2NyZWF0ZUJhc2VGb3IuanMiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIFVpbnQ4QXJyYXkgPSByZXF1aXJlKCcuL19VaW50OEFycmF5JyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIG1hcFRvQXJyYXkgPSByZXF1aXJlKCcuL19tYXBUb0FycmF5JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEJ5VGFnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2dldE1hdGNoRGF0YS5qcyIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZ2V0VGFnLmpzIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19oYXNQYXRoLmpzIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faGFzaENsZWFyLmpzIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2hhc2hHZXQuanMiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faGFzaFNldC5qcyIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXlhYmxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2lzTWFza2VkLmpzIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlR2V0LmpzIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVIYXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19tYXBUb0FycmF5LmpzIiwidmFyIG1lbW9pemUgPSByZXF1aXJlKCcuL21lbW9pemUnKTtcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1lbW9pemVDYXBwZWQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19ub2RlVXRpbC5qcyIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19vdmVyQXJnLmpzIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19vdmVyUmVzdC5qcyIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VTbGljZSA9IHJlcXVpcmUoJy4vX2Jhc2VTbGljZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3BhcmVudC5qcyIsIi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlQWRkO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3NldENhY2hlQWRkLmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldENhY2hlSGFzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3NldENhY2hlSGFzLmpzIiwiLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb0FycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3NldFRvQXJyYXkuanMiLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrQ2xlYXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19zdGFja0RlbGV0ZS5qcyIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19zdGFja0dldC5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fc3RhY2tIYXMuanMiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19zdGFja1NldC5qcyIsInZhciBtZW1vaXplQ2FwcGVkID0gcmVxdWlyZSgnLi9fbWVtb2l6ZUNhcHBlZCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVMZWFkaW5nRG90ID0gL15cXC4vLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChyZUxlYWRpbmdEb3QudGVzdChzdHJpbmcpKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5nVG9QYXRoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvY29uc3RhbnQuanMiLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRJbmRleDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2ZpbmRJbmRleC5qcyIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvZ2V0LmpzIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2hhc0luLmpzIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGFzdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2xhc3QuanMiLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL21lbW9pemUuanMiLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5JyksXG4gICAgYmFzZVByb3BlcnR5RGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eURlZXAnKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9wcm9wZXJ0eS5qcyIsInZhciBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlUHVsbEF0ID0gcmVxdWlyZSgnLi9fYmFzZVB1bGxBdCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHJlbW92ZWQgZWxlbWVudHMuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC4gVXNlIGBfLnB1bGxgXG4gKiB0byBwdWxsIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgdmFsdWUuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5ID0gWzEsIDIsIDMsIDRdO1xuICogdmFyIGV2ZW5zID0gXy5yZW1vdmUoYXJyYXksIGZ1bmN0aW9uKG4pIHtcbiAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gKiB9KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gKiAvLyA9PiBbMSwgM11cbiAqXG4gKiBjb25zb2xlLmxvZyhldmVucyk7XG4gKiAvLyA9PiBbMiwgNF1cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICB9XG4gIH1cbiAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVtb3ZlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvcmVtb3ZlLmpzIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlT3JkZXJCeSA9IHJlcXVpcmUoJy4vX2Jhc2VPcmRlckJ5JyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICogcGVyZm9ybXMgYSBzdGFibGUgc29ydCwgdGhhdCBpcywgaXQgcHJlc2VydmVzIHRoZSBvcmlnaW5hbCBzb3J0IG9yZGVyIG9mXG4gKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gKiBdO1xuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNl0sIFsnYmFybmV5JywgMzRdLCBbJ2ZyZWQnLCA0OF0sIFsnZnJlZCcsIDQwXV1cbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM0XSwgWydiYXJuZXknLCAzNl0sIFsnZnJlZCcsIDQwXSwgWydmcmVkJywgNDhdXVxuICovXG52YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGl0ZXJhdGVlcy5sZW5ndGg7XG4gIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtdO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA+IDIgJiYgaXNJdGVyYXRlZUNhbGwoaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0sIGl0ZXJhdGVlc1syXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgfVxuICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgYmFzZUZsYXR0ZW4oaXRlcmF0ZWVzLCAxKSwgW10pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydEJ5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvc29ydEJ5LmpzIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9zdHViQXJyYXkuanMiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvc3R1YkZhbHNlLmpzIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL3RvRmluaXRlLmpzIiwidmFyIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvSW50ZWdlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL3RvSW50ZWdlci5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvTnVtYmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvdG9OdW1iZXIuanMiLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL3RvU3RyaW5nLmpzIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCIvKipcbiAgKiB2dWUtcm91dGVyIHYyLjcuMFxuICAqIChjKSAyMDE3IEV2YW4gWW91XG4gICogQGxpY2Vuc2UgTUlUXG4gICovXG4vKiAgKi9cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybiAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjb25kaXRpb24pIHtcbiAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Vycm9yIChlcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpLmluZGV4T2YoJ0Vycm9yJykgPiAtMVxufVxuXG52YXIgVmlldyA9IHtcbiAgbmFtZTogJ3JvdXRlci12aWV3JyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGVmYXVsdCdcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChfLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG5cbiAgICBkYXRhLnJvdXRlclZpZXcgPSB0cnVlO1xuXG4gICAgLy8gZGlyZWN0bHkgdXNlIHBhcmVudCBjb250ZXh0J3MgY3JlYXRlRWxlbWVudCgpIGZ1bmN0aW9uXG4gICAgLy8gc28gdGhhdCBjb21wb25lbnRzIHJlbmRlcmVkIGJ5IHJvdXRlci12aWV3IGNhbiByZXNvbHZlIG5hbWVkIHNsb3RzXG4gICAgdmFyIGggPSBwYXJlbnQuJGNyZWF0ZUVsZW1lbnQ7XG4gICAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICAgIHZhciByb3V0ZSA9IHBhcmVudC4kcm91dGU7XG4gICAgdmFyIGNhY2hlID0gcGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgfHwgKHBhcmVudC5fcm91dGVyVmlld0NhY2hlID0ge30pO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGN1cnJlbnQgdmlldyBkZXB0aCwgYWxzbyBjaGVjayB0byBzZWUgaWYgdGhlIHRyZWVcbiAgICAvLyBoYXMgYmVlbiB0b2dnbGVkIGluYWN0aXZlIGJ1dCBrZXB0LWFsaXZlLlxuICAgIHZhciBkZXB0aCA9IDA7XG4gICAgdmFyIGluYWN0aXZlID0gZmFsc2U7XG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuX3JvdXRlclJvb3QgIT09IHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC4kdm5vZGUgJiYgcGFyZW50LiR2bm9kZS5kYXRhLnJvdXRlclZpZXcpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQuX2luYWN0aXZlKSB7XG4gICAgICAgIGluYWN0aXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBkYXRhLnJvdXRlclZpZXdEZXB0aCA9IGRlcHRoO1xuXG4gICAgLy8gcmVuZGVyIHByZXZpb3VzIHZpZXcgaWYgdGhlIHRyZWUgaXMgaW5hY3RpdmUgYW5kIGtlcHQtYWxpdmVcbiAgICBpZiAoaW5hY3RpdmUpIHtcbiAgICAgIHJldHVybiBoKGNhY2hlW25hbWVdLCBkYXRhLCBjaGlsZHJlbilcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZCA9IHJvdXRlLm1hdGNoZWRbZGVwdGhdO1xuICAgIC8vIHJlbmRlciBlbXB0eSBub2RlIGlmIG5vIG1hdGNoZWQgcm91dGVcbiAgICBpZiAoIW1hdGNoZWQpIHtcbiAgICAgIGNhY2hlW25hbWVdID0gbnVsbDtcbiAgICAgIHJldHVybiBoKClcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50ID0gY2FjaGVbbmFtZV0gPSBtYXRjaGVkLmNvbXBvbmVudHNbbmFtZV07XG5cbiAgICAvLyBhdHRhY2ggaW5zdGFuY2UgcmVnaXN0cmF0aW9uIGhvb2tcbiAgICAvLyB0aGlzIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBpbnN0YW5jZSdzIGluamVjdGVkIGxpZmVjeWNsZSBob29rc1xuICAgIGRhdGEucmVnaXN0ZXJSb3V0ZUluc3RhbmNlID0gZnVuY3Rpb24gKHZtLCB2YWwpIHtcbiAgICAgIC8vIHZhbCBjb3VsZCBiZSB1bmRlZmluZWQgZm9yIHVucmVnaXN0cmF0aW9uXG4gICAgICB2YXIgY3VycmVudCA9IG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICAodmFsICYmIGN1cnJlbnQgIT09IHZtKSB8fFxuICAgICAgICAoIXZhbCAmJiBjdXJyZW50ID09PSB2bSlcbiAgICAgICkge1xuICAgICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbHNvIHJlZ2lzZXRlciBpbnN0YW5jZSBpbiBwcmVwYXRjaCBob29rXG4gICAgLy8gaW4gY2FzZSB0aGUgc2FtZSBjb21wb25lbnQgaW5zdGFuY2UgaXMgcmV1c2VkIGFjcm9zcyBkaWZmZXJlbnQgcm91dGVzXG4gICAgOyhkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KSkucHJlcGF0Y2ggPSBmdW5jdGlvbiAoXywgdm5vZGUpIHtcbiAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgfTtcblxuICAgIC8vIHJlc29sdmUgcHJvcHNcbiAgICBkYXRhLnByb3BzID0gcmVzb2x2ZVByb3BzKHJvdXRlLCBtYXRjaGVkLnByb3BzICYmIG1hdGNoZWQucHJvcHNbbmFtZV0pO1xuXG4gICAgcmV0dXJuIGgoY29tcG9uZW50LCBkYXRhLCBjaGlsZHJlbilcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVByb3BzIChyb3V0ZSwgY29uZmlnKSB7XG4gIHN3aXRjaCAodHlwZW9mIGNvbmZpZykge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiBjb25maWcocm91dGUpXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY29uZmlnID8gcm91dGUucGFyYW1zIDogdW5kZWZpbmVkXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJwcm9wcyBpbiBcXFwiXCIgKyAocm91dGUucGF0aCkgKyBcIlxcXCIgaXMgYSBcIiArICh0eXBlb2YgY29uZmlnKSArIFwiLCBcIiArXG4gICAgICAgICAgXCJleHBlY3RpbmcgYW4gb2JqZWN0LCBmdW5jdGlvbiBvciBib29sZWFuLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBlbmNvZGVSZXNlcnZlUkUgPSAvWyEnKCkqXS9nO1xudmFyIGVuY29kZVJlc2VydmVSZXBsYWNlciA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpOyB9O1xudmFyIGNvbW1hUkUgPSAvJTJDL2c7XG5cbi8vIGZpeGVkIGVuY29kZVVSSUNvbXBvbmVudCB3aGljaCBpcyBtb3JlIGNvbmZvcm1hbnQgdG8gUkZDMzk4Njpcbi8vIC0gZXNjYXBlcyBbIScoKSpdXG4vLyAtIHByZXNlcnZlIGNvbW1hc1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIC5yZXBsYWNlKGVuY29kZVJlc2VydmVSRSwgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyKVxuICAucmVwbGFjZShjb21tYVJFLCAnLCcpOyB9O1xuXG52YXIgZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50O1xuXG5mdW5jdGlvbiByZXNvbHZlUXVlcnkgKFxuICBxdWVyeSxcbiAgZXh0cmFRdWVyeSxcbiAgX3BhcnNlUXVlcnlcbikge1xuICBpZiAoIGV4dHJhUXVlcnkgPT09IHZvaWQgMCApIGV4dHJhUXVlcnkgPSB7fTtcblxuICB2YXIgcGFyc2UgPSBfcGFyc2VRdWVyeSB8fCBwYXJzZVF1ZXJ5O1xuICB2YXIgcGFyc2VkUXVlcnk7XG4gIHRyeSB7XG4gICAgcGFyc2VkUXVlcnkgPSBwYXJzZShxdWVyeSB8fCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oZmFsc2UsIGUubWVzc2FnZSk7XG4gICAgcGFyc2VkUXVlcnkgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gZXh0cmFRdWVyeSkge1xuICAgIHZhciB2YWwgPSBleHRyYVF1ZXJ5W2tleV07XG4gICAgcGFyc2VkUXVlcnlba2V5XSA9IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbC5zbGljZSgpIDogdmFsO1xuICB9XG4gIHJldHVybiBwYXJzZWRRdWVyeVxufVxuXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5IChxdWVyeSkge1xuICB2YXIgcmVzID0ge307XG5cbiAgcXVlcnkgPSBxdWVyeS50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0cy5zaGlmdCgpKTtcbiAgICB2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMFxuICAgICAgPyBkZWNvZGUocGFydHMuam9pbignPScpKVxuICAgICAgOiBudWxsO1xuXG4gICAgaWYgKHJlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc1trZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXNba2V5XSkpIHtcbiAgICAgIHJlc1trZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2tleV0gPSBbcmVzW2tleV0sIHZhbF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5IChvYmopIHtcbiAgdmFyIHJlcyA9IG9iaiA/IE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoa2V5KVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG4gICAgICAgIGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsMiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwyKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsKVxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfSkuam9pbignJicpIDogbnVsbDtcbiAgcmV0dXJuIHJlcyA/IChcIj9cIiArIHJlcykgOiAnJ1xufVxuXG4vKiAgKi9cblxuXG52YXIgdHJhaWxpbmdTbGFzaFJFID0gL1xcLz8kLztcblxuZnVuY3Rpb24gY3JlYXRlUm91dGUgKFxuICByZWNvcmQsXG4gIGxvY2F0aW9uLFxuICByZWRpcmVjdGVkRnJvbSxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIHN0cmluZ2lmeVF1ZXJ5JCQxID0gcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnN0cmluZ2lmeVF1ZXJ5O1xuICB2YXIgcm91dGUgPSB7XG4gICAgbmFtZTogbG9jYXRpb24ubmFtZSB8fCAocmVjb3JkICYmIHJlY29yZC5uYW1lKSxcbiAgICBtZXRhOiAocmVjb3JkICYmIHJlY29yZC5tZXRhKSB8fCB7fSxcbiAgICBwYXRoOiBsb2NhdGlvbi5wYXRoIHx8ICcvJyxcbiAgICBoYXNoOiBsb2NhdGlvbi5oYXNoIHx8ICcnLFxuICAgIHF1ZXJ5OiBsb2NhdGlvbi5xdWVyeSB8fCB7fSxcbiAgICBwYXJhbXM6IGxvY2F0aW9uLnBhcmFtcyB8fCB7fSxcbiAgICBmdWxsUGF0aDogZ2V0RnVsbFBhdGgobG9jYXRpb24sIHN0cmluZ2lmeVF1ZXJ5JCQxKSxcbiAgICBtYXRjaGVkOiByZWNvcmQgPyBmb3JtYXRNYXRjaChyZWNvcmQpIDogW11cbiAgfTtcbiAgaWYgKHJlZGlyZWN0ZWRGcm9tKSB7XG4gICAgcm91dGUucmVkaXJlY3RlZEZyb20gPSBnZXRGdWxsUGF0aChyZWRpcmVjdGVkRnJvbSwgc3RyaW5naWZ5UXVlcnkkJDEpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHJvdXRlKVxufVxuXG4vLyB0aGUgc3RhcnRpbmcgcm91dGUgdGhhdCByZXByZXNlbnRzIHRoZSBpbml0aWFsIHN0YXRlXG52YXIgU1RBUlQgPSBjcmVhdGVSb3V0ZShudWxsLCB7XG4gIHBhdGg6ICcvJ1xufSk7XG5cbmZ1bmN0aW9uIGZvcm1hdE1hdGNoIChyZWNvcmQpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB3aGlsZSAocmVjb3JkKSB7XG4gICAgcmVzLnVuc2hpZnQocmVjb3JkKTtcbiAgICByZWNvcmQgPSByZWNvcmQucGFyZW50O1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0RnVsbFBhdGggKFxuICByZWYsXG4gIF9zdHJpbmdpZnlRdWVyeVxuKSB7XG4gIHZhciBwYXRoID0gcmVmLnBhdGg7XG4gIHZhciBxdWVyeSA9IHJlZi5xdWVyeTsgaWYgKCBxdWVyeSA9PT0gdm9pZCAwICkgcXVlcnkgPSB7fTtcbiAgdmFyIGhhc2ggPSByZWYuaGFzaDsgaWYgKCBoYXNoID09PSB2b2lkIDAgKSBoYXNoID0gJyc7XG5cbiAgdmFyIHN0cmluZ2lmeSA9IF9zdHJpbmdpZnlRdWVyeSB8fCBzdHJpbmdpZnlRdWVyeTtcbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyBzdHJpbmdpZnkocXVlcnkpICsgaGFzaFxufVxuXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZSAoYSwgYikge1xuICBpZiAoYiA9PT0gU1RBUlQpIHtcbiAgICByZXR1cm4gYSA9PT0gYlxuICB9IGVsc2UgaWYgKCFiKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoYS5wYXRoICYmIGIucGF0aCkge1xuICAgIHJldHVybiAoXG4gICAgICBhLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSA9PT0gYi5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpXG4gICAgKVxuICB9IGVsc2UgaWYgKGEubmFtZSAmJiBiLm5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5uYW1lID09PSBiLm5hbWUgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucGFyYW1zLCBiLnBhcmFtcylcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFcXVhbCAoYSwgYikge1xuICBpZiAoIGEgPT09IHZvaWQgMCApIGEgPSB7fTtcbiAgaWYgKCBiID09PSB2b2lkIDAgKSBiID0ge307XG5cbiAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBhVmFsID0gYVtrZXldO1xuICAgIHZhciBiVmFsID0gYltrZXldO1xuICAgIC8vIGNoZWNrIG5lc3RlZCBlcXVhbGl0eVxuICAgIGlmICh0eXBlb2YgYVZhbCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGJWYWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RFcXVhbChhVmFsLCBiVmFsKVxuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nKGFWYWwpID09PSBTdHJpbmcoYlZhbClcbiAgfSlcbn1cblxuZnVuY3Rpb24gaXNJbmNsdWRlZFJvdXRlIChjdXJyZW50LCB0YXJnZXQpIHtcbiAgcmV0dXJuIChcbiAgICBjdXJyZW50LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJykuaW5kZXhPZihcbiAgICAgIHRhcmdldC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpXG4gICAgKSA9PT0gMCAmJlxuICAgICghdGFyZ2V0Lmhhc2ggfHwgY3VycmVudC5oYXNoID09PSB0YXJnZXQuaGFzaCkgJiZcbiAgICBxdWVyeUluY2x1ZGVzKGN1cnJlbnQucXVlcnksIHRhcmdldC5xdWVyeSlcbiAgKVxufVxuXG5mdW5jdGlvbiBxdWVyeUluY2x1ZGVzIChjdXJyZW50LCB0YXJnZXQpIHtcbiAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgIGlmICghKGtleSBpbiBjdXJyZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qICAqL1xuXG4vLyB3b3JrIGFyb3VuZCB3ZWlyZCBmbG93IGJ1Z1xudmFyIHRvVHlwZXMgPSBbU3RyaW5nLCBPYmplY3RdO1xudmFyIGV2ZW50VHlwZXMgPSBbU3RyaW5nLCBBcnJheV07XG5cbnZhciBMaW5rID0ge1xuICBuYW1lOiAncm91dGVyLWxpbmsnLFxuICBwcm9wczoge1xuICAgIHRvOiB7XG4gICAgICB0eXBlOiB0b1R5cGVzLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHRhZzoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2EnXG4gICAgfSxcbiAgICBleGFjdDogQm9vbGVhbixcbiAgICBhcHBlbmQ6IEJvb2xlYW4sXG4gICAgcmVwbGFjZTogQm9vbGVhbixcbiAgICBhY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV4YWN0QWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogZXZlbnRUeXBlcyxcbiAgICAgIGRlZmF1bHQ6ICdjbGljaydcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy4kcm91dGVyO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy4kcm91dGU7XG4gICAgdmFyIHJlZiA9IHJvdXRlci5yZXNvbHZlKHRoaXMudG8sIGN1cnJlbnQsIHRoaXMuYXBwZW5kKTtcbiAgICB2YXIgbG9jYXRpb24gPSByZWYubG9jYXRpb247XG4gICAgdmFyIHJvdXRlID0gcmVmLnJvdXRlO1xuICAgIHZhciBocmVmID0gcmVmLmhyZWY7XG5cbiAgICB2YXIgY2xhc3NlcyA9IHt9O1xuICAgIHZhciBnbG9iYWxBY3RpdmVDbGFzcyA9IHJvdXRlci5vcHRpb25zLmxpbmtBY3RpdmVDbGFzcztcbiAgICB2YXIgZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyA9IHJvdXRlci5vcHRpb25zLmxpbmtFeGFjdEFjdGl2ZUNsYXNzO1xuICAgIC8vIFN1cHBvcnQgZ2xvYmFsIGVtcHR5IGFjdGl2ZSBjbGFzc1xuICAgIHZhciBhY3RpdmVDbGFzc0ZhbGxiYWNrID0gZ2xvYmFsQWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyAncm91dGVyLWxpbmstYWN0aXZlJ1xuICAgICAgICAgICAgOiBnbG9iYWxBY3RpdmVDbGFzcztcbiAgICB2YXIgZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrID0gZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/ICdyb3V0ZXItbGluay1leGFjdC1hY3RpdmUnXG4gICAgICAgICAgICA6IGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3M7XG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gdGhpcy5hY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/IGFjdGl2ZUNsYXNzRmFsbGJhY2tcbiAgICAgICAgICAgIDogdGhpcy5hY3RpdmVDbGFzcztcbiAgICB2YXIgZXhhY3RBY3RpdmVDbGFzcyA9IHRoaXMuZXhhY3RBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/IGV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFja1xuICAgICAgICAgICAgOiB0aGlzLmV4YWN0QWN0aXZlQ2xhc3M7XG4gICAgdmFyIGNvbXBhcmVUYXJnZXQgPSBsb2NhdGlvbi5wYXRoXG4gICAgICA/IGNyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uLCBudWxsLCByb3V0ZXIpXG4gICAgICA6IHJvdXRlO1xuXG4gICAgY2xhc3Nlc1tleGFjdEFjdGl2ZUNsYXNzXSA9IGlzU2FtZVJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuICAgIGNsYXNzZXNbYWN0aXZlQ2xhc3NdID0gdGhpcy5leGFjdFxuICAgICAgPyBjbGFzc2VzW2V4YWN0QWN0aXZlQ2xhc3NdXG4gICAgICA6IGlzSW5jbHVkZWRSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KTtcblxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChndWFyZEV2ZW50KGUpKSB7XG4gICAgICAgIGlmICh0aGlzJDEucmVwbGFjZSkge1xuICAgICAgICAgIHJvdXRlci5yZXBsYWNlKGxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZXIucHVzaChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9uID0geyBjbGljazogZ3VhcmRFdmVudCB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZXZlbnQpKSB7XG4gICAgICB0aGlzLmV2ZW50LmZvckVhY2goZnVuY3Rpb24gKGUpIHsgb25bZV0gPSBoYW5kbGVyOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb25bdGhpcy5ldmVudF0gPSBoYW5kbGVyO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgY2xhc3M6IGNsYXNzZXNcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMudGFnID09PSAnYScpIHtcbiAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIGRhdGEuYXR0cnMgPSB7IGhyZWY6IGhyZWYgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmluZCB0aGUgZmlyc3QgPGE+IGNoaWxkIGFuZCBhcHBseSBsaXN0ZW5lciBhbmQgaHJlZlxuICAgICAgdmFyIGEgPSBmaW5kQW5jaG9yKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgPGE+IGlzIGEgc3RhdGljIG5vZGVcbiAgICAgICAgYS5pc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXh0ZW5kID0gX1Z1ZS51dGlsLmV4dGVuZDtcbiAgICAgICAgdmFyIGFEYXRhID0gYS5kYXRhID0gZXh0ZW5kKHt9LCBhLmRhdGEpO1xuICAgICAgICBhRGF0YS5vbiA9IG9uO1xuICAgICAgICB2YXIgYUF0dHJzID0gYS5kYXRhLmF0dHJzID0gZXh0ZW5kKHt9LCBhLmRhdGEuYXR0cnMpO1xuICAgICAgICBhQXR0cnMuaHJlZiA9IGhyZWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb2Vzbid0IGhhdmUgPGE+IGNoaWxkLCBhcHBseSBsaXN0ZW5lciB0byBzZWxmXG4gICAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaCh0aGlzLnRhZywgZGF0YSwgdGhpcy4kc2xvdHMuZGVmYXVsdClcbiAgfVxufTtcblxuZnVuY3Rpb24gZ3VhcmRFdmVudCAoZSkge1xuICAvLyBkb24ndCByZWRpcmVjdCB3aXRoIGNvbnRyb2wga2V5c1xuICBpZiAoZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcbiAgaWYgKGUuYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b24gIT09IDApIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3QgaWYgYHRhcmdldD1cIl9ibGFua1wiYFxuICBpZiAoZS5jdXJyZW50VGFyZ2V0ICYmIGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgaWYgKC9cXGJfYmxhbmtcXGIvaS50ZXN0KHRhcmdldCkpIHsgcmV0dXJuIH1cbiAgfVxuICAvLyB0aGlzIG1heSBiZSBhIFdlZXggZXZlbnQgd2hpY2ggZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kXG4gIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbmRBbmNob3IgKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIHZhciBjaGlsZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ2EnKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuICYmIChjaGlsZCA9IGZpbmRBbmNob3IoY2hpbGQuY2hpbGRyZW4pKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIF9WdWU7XG5cbmZ1bmN0aW9uIGluc3RhbGwgKFZ1ZSkge1xuICBpZiAoaW5zdGFsbC5pbnN0YWxsZWQpIHsgcmV0dXJuIH1cbiAgaW5zdGFsbC5pbnN0YWxsZWQgPSB0cnVlO1xuXG4gIF9WdWUgPSBWdWU7XG5cbiAgdmFyIGlzRGVmID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDsgfTtcblxuICB2YXIgcmVnaXN0ZXJJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgY2FsbFZhbCkge1xuICAgIHZhciBpID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIGlmIChpc0RlZihpKSAmJiBpc0RlZihpID0gaS5kYXRhKSAmJiBpc0RlZihpID0gaS5yZWdpc3RlclJvdXRlSW5zdGFuY2UpKSB7XG4gICAgICBpKHZtLCBjYWxsVmFsKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLm1peGluKHtcbiAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIGJlZm9yZUNyZWF0ZSAoKSB7XG4gICAgICBpZiAoaXNEZWYodGhpcy4kb3B0aW9ucy5yb3V0ZXIpKSB7XG4gICAgICAgIHRoaXMuX3JvdXRlclJvb3QgPSB0aGlzO1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSB0aGlzLiRvcHRpb25zLnJvdXRlcjtcbiAgICAgICAgdGhpcy5fcm91dGVyLmluaXQodGhpcyk7XG4gICAgICAgIFZ1ZS51dGlsLmRlZmluZVJlYWN0aXZlKHRoaXMsICdfcm91dGUnLCB0aGlzLl9yb3V0ZXIuaGlzdG9yeS5jdXJyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JvdXRlclJvb3QgPSAodGhpcy4kcGFyZW50ICYmIHRoaXMuJHBhcmVudC5fcm91dGVyUm9vdCkgfHwgdGhpcztcbiAgICAgIH1cbiAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgdGhpcyk7XG4gICAgfSxcbiAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGVyJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclJvb3QuX3JvdXRlciB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlJywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3JvdXRlclJvb3QuX3JvdXRlIH1cbiAgfSk7XG5cbiAgVnVlLmNvbXBvbmVudCgncm91dGVyLXZpZXcnLCBWaWV3KTtcbiAgVnVlLmNvbXBvbmVudCgncm91dGVyLWxpbmsnLCBMaW5rKTtcblxuICB2YXIgc3RyYXRzID0gVnVlLmNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG4gIC8vIHVzZSB0aGUgc2FtZSBob29rIG1lcmdpbmcgc3RyYXRlZ3kgZm9yIHJvdXRlIGhvb2tzXG4gIHN0cmF0cy5iZWZvcmVSb3V0ZUVudGVyID0gc3RyYXRzLmJlZm9yZVJvdXRlTGVhdmUgPSBzdHJhdHMuYmVmb3JlUm91dGVVcGRhdGUgPSBzdHJhdHMuY3JlYXRlZDtcbn1cblxuLyogICovXG5cbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVQYXRoIChcbiAgcmVsYXRpdmUsXG4gIGJhc2UsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBmaXJzdENoYXIgPSByZWxhdGl2ZS5jaGFyQXQoMCk7XG4gIGlmIChmaXJzdENoYXIgPT09ICcvJykge1xuICAgIHJldHVybiByZWxhdGl2ZVxuICB9XG5cbiAgaWYgKGZpcnN0Q2hhciA9PT0gJz8nIHx8IGZpcnN0Q2hhciA9PT0gJyMnKSB7XG4gICAgcmV0dXJuIGJhc2UgKyByZWxhdGl2ZVxuICB9XG5cbiAgdmFyIHN0YWNrID0gYmFzZS5zcGxpdCgnLycpO1xuXG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzZWdtZW50IGlmOlxuICAvLyAtIG5vdCBhcHBlbmRpbmdcbiAgLy8gLSBhcHBlbmRpbmcgdG8gdHJhaWxpbmcgc2xhc2ggKGxhc3Qgc2VnbWVudCBpcyBlbXB0eSlcbiAgaWYgKCFhcHBlbmQgfHwgIXN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgc3RhY2sucG9wKCk7XG4gIH1cblxuICAvLyByZXNvbHZlIHJlbGF0aXZlIHBhdGhcbiAgdmFyIHNlZ21lbnRzID0gcmVsYXRpdmUucmVwbGFjZSgvXlxcLy8sICcnKS5zcGxpdCgnLycpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBpZiAoc2VnbWVudCA9PT0gJy4uJykge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSAnLicpIHtcbiAgICAgIHN0YWNrLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZW5zdXJlIGxlYWRpbmcgc2xhc2hcbiAgaWYgKHN0YWNrWzBdICE9PSAnJykge1xuICAgIHN0YWNrLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgcmV0dXJuIHN0YWNrLmpvaW4oJy8nKVxufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgdmFyIGhhc2ggPSAnJztcbiAgdmFyIHF1ZXJ5ID0gJyc7XG5cbiAgdmFyIGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ID49IDApIHtcbiAgICBoYXNoID0gcGF0aC5zbGljZShoYXNoSW5kZXgpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuICBpZiAocXVlcnlJbmRleCA+PSAwKSB7XG4gICAgcXVlcnkgPSBwYXRoLnNsaWNlKHF1ZXJ5SW5kZXggKyAxKTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBxdWVyeUluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aDogcGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgaGFzaDogaGFzaFxuICB9XG59XG5cbmZ1bmN0aW9uIGNsZWFuUGF0aCAocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC9cXC8vZywgJy8nKVxufVxuXG52YXIgaW5kZXgkMSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG52YXIgaW5kZXggPSBwYXRoVG9SZWdleHA7XG52YXIgcGFyc2VfMSA9IHBhcnNlO1xudmFyIGNvbXBpbGVfMSA9IGNvbXBpbGU7XG52YXIgdG9rZW5zVG9GdW5jdGlvbl8xID0gdG9rZW5zVG9GdW5jdGlvbjtcbnZhciB0b2tlbnNUb1JlZ0V4cF8xID0gdG9rZW5zVG9SZWdFeHA7XG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJyk7XG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIGtleSA9IDA7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBwYXRoID0gJyc7XG4gIHZhciBkZWZhdWx0RGVsaW1pdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlciB8fCAnLyc7XG4gIHZhciByZXM7XG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXTtcbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXTtcbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4O1xuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpO1xuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGg7XG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdO1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF07XG4gICAgdmFyIHByZWZpeCA9IHJlc1syXTtcbiAgICB2YXIgbmFtZSA9IHJlc1szXTtcbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XTtcbiAgICB2YXIgZ3JvdXAgPSByZXNbNV07XG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdO1xuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XTtcblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpO1xuICAgICAgcGF0aCA9ICcnO1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeDtcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonO1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXI7XG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwO1xuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleCk7XG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBleGlzdHMsIHB1c2ggaXQgb250byB0aGUgZW5kLlxuICBpZiAocGF0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGgpO1xuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpO1xuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAob2JqLCBvcHRzKSB7XG4gICAgdmFyIHBhdGggPSAnJztcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fTtcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge307XG4gICAgdmFyIGVuY29kZSA9IG9wdGlvbnMucHJldHR5ID8gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IDogZW5jb2RlVVJJQ29tcG9uZW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlbjtcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBkYXRhW3Rva2VuLm5hbWVdO1xuICAgICAgdmFyIHNlZ21lbnQ7XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gYmUgZGVmaW5lZCcpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4JDEodmFsdWUpKSB7XG4gICAgICAgIGlmICghdG9rZW4ucmVwZWF0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgcmVwZWF0LCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnYCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCBiZSBlbXB0eScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0pO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSk7XG5cbiAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIFwiJyArIHNlZ21lbnQgKyAnXCInKVxuICAgICAgfVxuXG4gICAgICBwYXRoICs9IHRva2VuLnByZWZpeCArIHNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXM7XG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKTtcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBhc3RlcmlzazogZmFsc2UsXG4gICAgICAgIHBhdHRlcm46IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKTtcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaW5kZXgkMShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZTtcbiAgdmFyIHJvdXRlID0gJyc7XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpO1xuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSc7XG5cbiAgICAgIGtleXMucHVzaCh0b2tlbik7XG5cbiAgICAgIGlmICh0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/JztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpO1xuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlcjtcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/JztcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCc7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJztcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWluZGV4JDEoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGluZGV4JDEocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG5cbmluZGV4LnBhcnNlID0gcGFyc2VfMTtcbmluZGV4LmNvbXBpbGUgPSBjb21waWxlXzE7XG5pbmRleC50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvbl8xO1xuaW5kZXgudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cF8xO1xuXG4vKiAgKi9cblxudmFyIHJlZ2V4cENvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIGZpbGxQYXJhbXMgKFxuICBwYXRoLFxuICBwYXJhbXMsXG4gIHJvdXRlTXNnXG4pIHtcbiAgdHJ5IHtcbiAgICB2YXIgZmlsbGVyID1cbiAgICAgIHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSB8fFxuICAgICAgKHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSA9IGluZGV4LmNvbXBpbGUocGF0aCkpO1xuICAgIHJldHVybiBmaWxsZXIocGFyYW1zIHx8IHt9LCB7IHByZXR0eTogdHJ1ZSB9KVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oZmFsc2UsIChcIm1pc3NpbmcgcGFyYW0gZm9yIFwiICsgcm91dGVNc2cgKyBcIjogXCIgKyAoZS5tZXNzYWdlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVNYXAgKFxuICByb3V0ZXMsXG4gIG9sZFBhdGhMaXN0LFxuICBvbGRQYXRoTWFwLFxuICBvbGROYW1lTWFwXG4pIHtcbiAgLy8gdGhlIHBhdGggbGlzdCBpcyB1c2VkIHRvIGNvbnRyb2wgcGF0aCBtYXRjaGluZyBwcmlvcml0eVxuICB2YXIgcGF0aExpc3QgPSBvbGRQYXRoTGlzdCB8fCBbXTtcbiAgdmFyIHBhdGhNYXAgPSBvbGRQYXRoTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBuYW1lTWFwID0gb2xkTmFtZU1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCByb3V0ZSk7XG4gIH0pO1xuXG4gIC8vIGVuc3VyZSB3aWxkY2FyZCByb3V0ZXMgYXJlIGFsd2F5cyBhdCB0aGUgZW5kXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aExpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHBhdGhMaXN0W2ldID09PSAnKicpIHtcbiAgICAgIHBhdGhMaXN0LnB1c2gocGF0aExpc3Quc3BsaWNlKGksIDEpWzBdKTtcbiAgICAgIGwtLTtcbiAgICAgIGktLTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhMaXN0OiBwYXRoTGlzdCxcbiAgICBwYXRoTWFwOiBwYXRoTWFwLFxuICAgIG5hbWVNYXA6IG5hbWVNYXBcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb3V0ZVJlY29yZCAoXG4gIHBhdGhMaXN0LFxuICBwYXRoTWFwLFxuICBuYW1lTWFwLFxuICByb3V0ZSxcbiAgcGFyZW50LFxuICBtYXRjaEFzXG4pIHtcbiAgdmFyIHBhdGggPSByb3V0ZS5wYXRoO1xuICB2YXIgbmFtZSA9IHJvdXRlLm5hbWU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHBhdGggIT0gbnVsbCwgXCJcXFwicGF0aFxcXCIgaXMgcmVxdWlyZWQgaW4gYSByb3V0ZSBjb25maWd1cmF0aW9uLlwiKTtcbiAgICBhc3NlcnQoXG4gICAgICB0eXBlb2Ygcm91dGUuY29tcG9uZW50ICE9PSAnc3RyaW5nJyxcbiAgICAgIFwicm91dGUgY29uZmlnIFxcXCJjb21wb25lbnRcXFwiIGZvciBwYXRoOiBcIiArIChTdHJpbmcocGF0aCB8fCBuYW1lKSkgKyBcIiBjYW5ub3QgYmUgYSBcIiArXG4gICAgICBcInN0cmluZyBpZC4gVXNlIGFuIGFjdHVhbCBjb21wb25lbnQgaW5zdGVhZC5cIlxuICAgICk7XG4gIH1cblxuICB2YXIgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgsIHBhcmVudCk7XG4gIHZhciBwYXRoVG9SZWdleHBPcHRpb25zID0gcm91dGUucGF0aFRvUmVnZXhwT3B0aW9ucyB8fCB7fTtcblxuICBpZiAodHlwZW9mIHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09ICdib29sZWFuJykge1xuICAgIHBhdGhUb1JlZ2V4cE9wdGlvbnMuc2Vuc2l0aXZlID0gcm91dGUuY2FzZVNlbnNpdGl2ZTtcbiAgfVxuXG4gIHZhciByZWNvcmQgPSB7XG4gICAgcGF0aDogbm9ybWFsaXplZFBhdGgsXG4gICAgcmVnZXg6IGNvbXBpbGVSb3V0ZVJlZ2V4KG5vcm1hbGl6ZWRQYXRoLCBwYXRoVG9SZWdleHBPcHRpb25zKSxcbiAgICBjb21wb25lbnRzOiByb3V0ZS5jb21wb25lbnRzIHx8IHsgZGVmYXVsdDogcm91dGUuY29tcG9uZW50IH0sXG4gICAgaW5zdGFuY2VzOiB7fSxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIG1hdGNoQXM6IG1hdGNoQXMsXG4gICAgcmVkaXJlY3Q6IHJvdXRlLnJlZGlyZWN0LFxuICAgIGJlZm9yZUVudGVyOiByb3V0ZS5iZWZvcmVFbnRlcixcbiAgICBtZXRhOiByb3V0ZS5tZXRhIHx8IHt9LFxuICAgIHByb3BzOiByb3V0ZS5wcm9wcyA9PSBudWxsXG4gICAgICA/IHt9XG4gICAgICA6IHJvdXRlLmNvbXBvbmVudHNcbiAgICAgICAgPyByb3V0ZS5wcm9wc1xuICAgICAgICA6IHsgZGVmYXVsdDogcm91dGUucHJvcHMgfVxuICB9O1xuXG4gIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgIC8vIFdhcm4gaWYgcm91dGUgaXMgbmFtZWQsIGRvZXMgbm90IHJlZGlyZWN0IGFuZCBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLlxuICAgIC8vIElmIHVzZXJzIG5hdmlnYXRlIHRvIHRoaXMgcm91dGUgYnkgbmFtZSwgdGhlIGRlZmF1bHQgY2hpbGQgd2lsbFxuICAgIC8vIG5vdCBiZSByZW5kZXJlZCAoR0ggSXNzdWUgIzYyOSlcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHJvdXRlLm5hbWUgJiYgIXJvdXRlLnJlZGlyZWN0ICYmIHJvdXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAvXlxcLz8kLy50ZXN0KGNoaWxkLnBhdGgpOyB9KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiTmFtZWQgUm91dGUgJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuIFwiICtcbiAgICAgICAgICBcIldoZW4gbmF2aWdhdGluZyB0byB0aGlzIG5hbWVkIHJvdXRlICg6dG89XFxcIntuYW1lOiAnXCIgKyAocm91dGUubmFtZSkgKyBcIidcXFwiKSwgXCIgK1xuICAgICAgICAgIFwidGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgd2lsbCBub3QgYmUgcmVuZGVyZWQuIFJlbW92ZSB0aGUgbmFtZSBmcm9tIFwiICtcbiAgICAgICAgICBcInRoaXMgcm91dGUgYW5kIHVzZSB0aGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSBmb3IgbmFtZWQgXCIgK1xuICAgICAgICAgIFwibGlua3MgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTWF0Y2hBcyA9IG1hdGNoQXNcbiAgICAgICAgPyBjbGVhblBhdGgoKG1hdGNoQXMgKyBcIi9cIiArIChjaGlsZC5wYXRoKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIGNoaWxkLCByZWNvcmQsIGNoaWxkTWF0Y2hBcyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocm91dGUuYWxpYXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBhbGlhc2VzID0gQXJyYXkuaXNBcnJheShyb3V0ZS5hbGlhcylcbiAgICAgID8gcm91dGUuYWxpYXNcbiAgICAgIDogW3JvdXRlLmFsaWFzXTtcblxuICAgIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgIHZhciBhbGlhc1JvdXRlID0ge1xuICAgICAgICBwYXRoOiBhbGlhcyxcbiAgICAgICAgY2hpbGRyZW46IHJvdXRlLmNoaWxkcmVuXG4gICAgICB9O1xuICAgICAgYWRkUm91dGVSZWNvcmQoXG4gICAgICAgIHBhdGhMaXN0LFxuICAgICAgICBwYXRoTWFwLFxuICAgICAgICBuYW1lTWFwLFxuICAgICAgICBhbGlhc1JvdXRlLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIHJlY29yZC5wYXRoIHx8ICcvJyAvLyBtYXRjaEFzXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFwYXRoTWFwW3JlY29yZC5wYXRoXSkge1xuICAgIHBhdGhMaXN0LnB1c2gocmVjb3JkLnBhdGgpO1xuICAgIHBhdGhNYXBbcmVjb3JkLnBhdGhdID0gcmVjb3JkO1xuICB9XG5cbiAgaWYgKG5hbWUpIHtcbiAgICBpZiAoIW5hbWVNYXBbbmFtZV0pIHtcbiAgICAgIG5hbWVNYXBbbmFtZV0gPSByZWNvcmQ7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFtYXRjaEFzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgXCJEdXBsaWNhdGUgbmFtZWQgcm91dGVzIGRlZmluaXRpb246IFwiICtcbiAgICAgICAgXCJ7IG5hbWU6IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIHBhdGg6IFxcXCJcIiArIChyZWNvcmQucGF0aCkgKyBcIlxcXCIgfVwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21waWxlUm91dGVSZWdleCAocGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucykge1xuICB2YXIgcmVnZXggPSBpbmRleChwYXRoLCBbXSwgcGF0aFRvUmVnZXhwT3B0aW9ucyk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGtleXMgPSB7fTtcbiAgICByZWdleC5rZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgd2Fybigha2V5c1trZXkubmFtZV0sIChcIkR1cGxpY2F0ZSBwYXJhbSBrZXlzIGluIHJvdXRlIHdpdGggcGF0aDogXFxcIlwiICsgcGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICBrZXlzW2tleS5uYW1lXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZ2V4XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGggKHBhdGgsIHBhcmVudCkge1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICBpZiAocGF0aFswXSA9PT0gJy8nKSB7IHJldHVybiBwYXRoIH1cbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7IHJldHVybiBwYXRoIH1cbiAgcmV0dXJuIGNsZWFuUGF0aCgoKHBhcmVudC5wYXRoKSArIFwiL1wiICsgcGF0aCkpXG59XG5cbi8qICAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICBhcHBlbmQsXG4gIHJvdXRlclxuKSB7XG4gIHZhciBuZXh0ID0gdHlwZW9mIHJhdyA9PT0gJ3N0cmluZycgPyB7IHBhdGg6IHJhdyB9IDogcmF3O1xuICAvLyBuYW1lZCB0YXJnZXRcbiAgaWYgKG5leHQubmFtZSB8fCBuZXh0Ll9ub3JtYWxpemVkKSB7XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIC8vIHJlbGF0aXZlIHBhcmFtc1xuICBpZiAoIW5leHQucGF0aCAmJiBuZXh0LnBhcmFtcyAmJiBjdXJyZW50KSB7XG4gICAgbmV4dCA9IGFzc2lnbih7fSwgbmV4dCk7XG4gICAgbmV4dC5fbm9ybWFsaXplZCA9IHRydWU7XG4gICAgdmFyIHBhcmFtcyA9IGFzc2lnbihhc3NpZ24oe30sIGN1cnJlbnQucGFyYW1zKSwgbmV4dC5wYXJhbXMpO1xuICAgIGlmIChjdXJyZW50Lm5hbWUpIHtcbiAgICAgIG5leHQubmFtZSA9IGN1cnJlbnQubmFtZTtcbiAgICAgIG5leHQucGFyYW1zID0gcGFyYW1zO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5tYXRjaGVkLmxlbmd0aCkge1xuICAgICAgdmFyIHJhd1BhdGggPSBjdXJyZW50Lm1hdGNoZWRbY3VycmVudC5tYXRjaGVkLmxlbmd0aCAtIDFdLnBhdGg7XG4gICAgICBuZXh0LnBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicGF0aCBcIiArIChjdXJyZW50LnBhdGgpKSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCBcInJlbGF0aXZlIHBhcmFtcyBuYXZpZ2F0aW9uIHJlcXVpcmVzIGEgY3VycmVudCByb3V0ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICB2YXIgcGFyc2VkUGF0aCA9IHBhcnNlUGF0aChuZXh0LnBhdGggfHwgJycpO1xuICB2YXIgYmFzZVBhdGggPSAoY3VycmVudCAmJiBjdXJyZW50LnBhdGgpIHx8ICcvJztcbiAgdmFyIHBhdGggPSBwYXJzZWRQYXRoLnBhdGhcbiAgICA/IHJlc29sdmVQYXRoKHBhcnNlZFBhdGgucGF0aCwgYmFzZVBhdGgsIGFwcGVuZCB8fCBuZXh0LmFwcGVuZClcbiAgICA6IGJhc2VQYXRoO1xuXG4gIHZhciBxdWVyeSA9IHJlc29sdmVRdWVyeShcbiAgICBwYXJzZWRQYXRoLnF1ZXJ5LFxuICAgIG5leHQucXVlcnksXG4gICAgcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnBhcnNlUXVlcnlcbiAgKTtcblxuICB2YXIgaGFzaCA9IG5leHQuaGFzaCB8fCBwYXJzZWRQYXRoLmhhc2g7XG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHtcbiAgICBoYXNoID0gXCIjXCIgKyBoYXNoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduIChhLCBiKSB7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgYVtrZXldID0gYltrZXldO1xuICB9XG4gIHJldHVybiBhXG59XG5cbi8qICAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIgKFxuICByb3V0ZXMsXG4gIHJvdXRlclxuKSB7XG4gIHZhciByZWYgPSBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMpO1xuICB2YXIgcGF0aExpc3QgPSByZWYucGF0aExpc3Q7XG4gIHZhciBwYXRoTWFwID0gcmVmLnBhdGhNYXA7XG4gIHZhciBuYW1lTWFwID0gcmVmLm5hbWVNYXA7XG5cbiAgZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcbiAgICBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMsIHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoIChcbiAgICByYXcsXG4gICAgY3VycmVudFJvdXRlLFxuICAgIHJlZGlyZWN0ZWRGcm9tXG4gICkge1xuICAgIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKHJhdywgY3VycmVudFJvdXRlLCBmYWxzZSwgcm91dGVyKTtcbiAgICB2YXIgbmFtZSA9IGxvY2F0aW9uLm5hbWU7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgdmFyIHJlY29yZCA9IG5hbWVNYXBbbmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKHJlY29yZCwgKFwiUm91dGUgd2l0aCBuYW1lICdcIiArIG5hbWUgKyBcIicgZG9lcyBub3QgZXhpc3RcIikpO1xuICAgICAgfVxuICAgICAgaWYgKCFyZWNvcmQpIHsgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbikgfVxuICAgICAgdmFyIHBhcmFtTmFtZXMgPSByZWNvcmQucmVnZXgua2V5c1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFrZXkub3B0aW9uYWw7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5Lm5hbWU7IH0pO1xuXG4gICAgICBpZiAodHlwZW9mIGxvY2F0aW9uLnBhcmFtcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50Um91dGUgJiYgdHlwZW9mIGN1cnJlbnRSb3V0ZS5wYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBjdXJyZW50Um91dGUucGFyYW1zKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGxvY2F0aW9uLnBhcmFtcykgJiYgcGFyYW1OYW1lcy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgbG9jYXRpb24ucGFyYW1zW2tleV0gPSBjdXJyZW50Um91dGUucGFyYW1zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQpIHtcbiAgICAgICAgbG9jYXRpb24ucGF0aCA9IGZpbGxQYXJhbXMocmVjb3JkLnBhdGgsIGxvY2F0aW9uLnBhcmFtcywgKFwibmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSk7XG4gICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRoKSB7XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoTGlzdFtpXTtcbiAgICAgICAgdmFyIHJlY29yZCQxID0gcGF0aE1hcFtwYXRoXTtcbiAgICAgICAgaWYgKG1hdGNoUm91dGUocmVjb3JkJDEucmVnZXgsIGxvY2F0aW9uLnBhdGgsIGxvY2F0aW9uLnBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCQxLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm8gbWF0Y2hcbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkaXJlY3QgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvblxuICApIHtcbiAgICB2YXIgb3JpZ2luYWxSZWRpcmVjdCA9IHJlY29yZC5yZWRpcmVjdDtcbiAgICB2YXIgcmVkaXJlY3QgPSB0eXBlb2Ygb3JpZ2luYWxSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9yaWdpbmFsUmVkaXJlY3QoY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKSlcbiAgICAgICAgOiBvcmlnaW5hbFJlZGlyZWN0O1xuXG4gICAgaWYgKHR5cGVvZiByZWRpcmVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJlZGlyZWN0ID0geyBwYXRoOiByZWRpcmVjdCB9O1xuICAgIH1cblxuICAgIGlmICghcmVkaXJlY3QgfHwgdHlwZW9mIHJlZGlyZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICAgIH1cblxuICAgIHZhciByZSA9IHJlZGlyZWN0O1xuICAgIHZhciBuYW1lID0gcmUubmFtZTtcbiAgICB2YXIgcGF0aCA9IHJlLnBhdGg7XG4gICAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnk7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBwYXJhbXMgPSBsb2NhdGlvbi5wYXJhbXM7XG4gICAgcXVlcnkgPSByZS5oYXNPd25Qcm9wZXJ0eSgncXVlcnknKSA/IHJlLnF1ZXJ5IDogcXVlcnk7XG4gICAgaGFzaCA9IHJlLmhhc093blByb3BlcnR5KCdoYXNoJykgPyByZS5oYXNoIDogaGFzaDtcbiAgICBwYXJhbXMgPSByZS5oYXNPd25Qcm9wZXJ0eSgncGFyYW1zJykgPyByZS5wYXJhbXMgOiBwYXJhbXM7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgLy8gcmVzb2x2ZWQgbmFtZWQgZGlyZWN0XG4gICAgICB2YXIgdGFyZ2V0UmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydCh0YXJnZXRSZWNvcmQsIChcInJlZGlyZWN0IGZhaWxlZDogbmFtZWQgcm91dGUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBub3QgZm91bmQuXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgIHBhcmFtczogcGFyYW1zXG4gICAgICB9LCB1bmRlZmluZWQsIGxvY2F0aW9uKVxuICAgIH0gZWxzZSBpZiAocGF0aCkge1xuICAgICAgLy8gMS4gcmVzb2x2ZSByZWxhdGl2ZSByZWRpcmVjdFxuICAgICAgdmFyIHJhd1BhdGggPSByZXNvbHZlUmVjb3JkUGF0aChwYXRoLCByZWNvcmQpO1xuICAgICAgLy8gMi4gcmVzb2x2ZSBwYXJhbXNcbiAgICAgIHZhciByZXNvbHZlZFBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicmVkaXJlY3Qgcm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIHJhd1BhdGggKyBcIlxcXCJcIikpO1xuICAgICAgLy8gMy4gcmVtYXRjaCB3aXRoIGV4aXN0aW5nIHF1ZXJ5IGFuZCBoYXNoXG4gICAgICByZXR1cm4gbWF0Y2goe1xuICAgICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgICAgcGF0aDogcmVzb2x2ZWRQYXRoLFxuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIGhhc2g6IGhhc2hcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oZmFsc2UsIChcImludmFsaWQgcmVkaXJlY3Qgb3B0aW9uOiBcIiArIChKU09OLnN0cmluZ2lmeShyZWRpcmVjdCkpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsaWFzIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgbWF0Y2hBc1xuICApIHtcbiAgICB2YXIgYWxpYXNlZFBhdGggPSBmaWxsUGFyYW1zKG1hdGNoQXMsIGxvY2F0aW9uLnBhcmFtcywgKFwiYWxpYXNlZCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgbWF0Y2hBcyArIFwiXFxcIlwiKSk7XG4gICAgdmFyIGFsaWFzZWRNYXRjaCA9IG1hdGNoKHtcbiAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgcGF0aDogYWxpYXNlZFBhdGhcbiAgICB9KTtcbiAgICBpZiAoYWxpYXNlZE1hdGNoKSB7XG4gICAgICB2YXIgbWF0Y2hlZCA9IGFsaWFzZWRNYXRjaC5tYXRjaGVkO1xuICAgICAgdmFyIGFsaWFzZWRSZWNvcmQgPSBtYXRjaGVkW21hdGNoZWQubGVuZ3RoIC0gMV07XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSBhbGlhc2VkTWF0Y2gucGFyYW1zO1xuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShhbGlhc2VkUmVjb3JkLCBsb2NhdGlvbilcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVSb3V0ZSAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uLFxuICAgIHJlZGlyZWN0ZWRGcm9tXG4gICkge1xuICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLnJlZGlyZWN0KSB7XG4gICAgICByZXR1cm4gcmVkaXJlY3QocmVjb3JkLCByZWRpcmVjdGVkRnJvbSB8fCBsb2NhdGlvbilcbiAgICB9XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQubWF0Y2hBcykge1xuICAgICAgcmV0dXJuIGFsaWFzKHJlY29yZCwgbG9jYXRpb24sIHJlY29yZC5tYXRjaEFzKVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20sIHJvdXRlcilcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIGFkZFJvdXRlczogYWRkUm91dGVzXG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZSAoXG4gIHJlZ2V4LFxuICBwYXRoLFxuICBwYXJhbXNcbikge1xuICB2YXIgbSA9IHBhdGgubWF0Y2gocmVnZXgpO1xuXG4gIGlmICghbSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IG0ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIga2V5ID0gcmVnZXgua2V5c1tpIC0gMV07XG4gICAgdmFyIHZhbCA9IHR5cGVvZiBtW2ldID09PSAnc3RyaW5nJyA/IGRlY29kZVVSSUNvbXBvbmVudChtW2ldKSA6IG1baV07XG4gICAgaWYgKGtleSkge1xuICAgICAgcGFyYW1zW2tleS5uYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUmVjb3JkUGF0aCAocGF0aCwgcmVjb3JkKSB7XG4gIHJldHVybiByZXNvbHZlUGF0aChwYXRoLCByZWNvcmQucGFyZW50ID8gcmVjb3JkLnBhcmVudC5wYXRoIDogJy8nLCB0cnVlKVxufVxuXG4vKiAgKi9cblxuXG52YXIgcG9zaXRpb25TdG9yZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIHNldHVwU2Nyb2xsICgpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICBpZiAoZS5zdGF0ZSAmJiBlLnN0YXRlLmtleSkge1xuICAgICAgc2V0U3RhdGVLZXkoZS5zdGF0ZS5rZXkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNjcm9sbCAoXG4gIHJvdXRlcixcbiAgdG8sXG4gIGZyb20sXG4gIGlzUG9wXG4pIHtcbiAgaWYgKCFyb3V0ZXIuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmVoYXZpb3IgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcbiAgaWYgKCFiZWhhdmlvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJlaGF2aW9yID09PSAnZnVuY3Rpb24nLCBcInNjcm9sbEJlaGF2aW9yIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIC8vIHdhaXQgdW50aWwgcmUtcmVuZGVyIGZpbmlzaGVzIGJlZm9yZSBzY3JvbGxpbmdcbiAgcm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgdmFyIHNob3VsZFNjcm9sbCA9IGJlaGF2aW9yKHRvLCBmcm9tLCBpc1BvcCA/IHBvc2l0aW9uIDogbnVsbCk7XG4gICAgaWYgKCFzaG91bGRTY3JvbGwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgaXNPYmplY3QgPSB0eXBlb2Ygc2hvdWxkU2Nyb2xsID09PSAnb2JqZWN0JztcbiAgICBpZiAoaXNPYmplY3QgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5zZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2hvdWxkU2Nyb2xsLnNlbGVjdG9yKTtcbiAgICAgIGlmIChlbCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gc2hvdWxkU2Nyb2xsLm9mZnNldCAmJiB0eXBlb2Ygc2hvdWxkU2Nyb2xsLm9mZnNldCA9PT0gJ29iamVjdCcgPyBzaG91bGRTY3JvbGwub2Zmc2V0IDoge307XG4gICAgICAgIG9mZnNldCA9IG5vcm1hbGl6ZU9mZnNldChvZmZzZXQpO1xuICAgICAgICBwb3NpdGlvbiA9IGdldEVsZW1lbnRQb3NpdGlvbihlbCwgb2Zmc2V0KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICAgICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QgJiYgaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHBvc2l0aW9uU3RvcmVba2V5XSA9IHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHJldHVybiBwb3NpdGlvblN0b3JlW2tleV1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50UG9zaXRpb24gKGVsLCBvZmZzZXQpIHtcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgZG9jUmVjdCA9IGRvY0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQgLSBvZmZzZXQueCxcbiAgICB5OiBlbFJlY3QudG9wIC0gZG9jUmVjdC50b3AgLSBvZmZzZXQueVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiBpc051bWJlcihvYmoueCkgfHwgaXNOdW1iZXIob2JqLnkpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9mZnNldCAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgeDogaXNOdW1iZXIob2JqLngpID8gb2JqLnggOiAwLFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogMFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcidcbn1cblxuLyogICovXG5cbnZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IGluQnJvd3NlciAmJiAoZnVuY3Rpb24gKCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoXG4gICAgKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmXG4gICAgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTFcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnlcbn0pKCk7XG5cbi8vIHVzZSBVc2VyIFRpbWluZyBhcGkgKGlmIHByZXNlbnQpIGZvciBtb3JlIGFjY3VyYXRlIGtleSBwcmVjaXNpb25cbnZhciBUaW1lID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93XG4gID8gd2luZG93LnBlcmZvcm1hbmNlXG4gIDogRGF0ZTtcblxudmFyIF9rZXkgPSBnZW5LZXkoKTtcblxuZnVuY3Rpb24gZ2VuS2V5ICgpIHtcbiAgcmV0dXJuIFRpbWUubm93KCkudG9GaXhlZCgzKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUtleSAoKSB7XG4gIHJldHVybiBfa2V5XG59XG5cbmZ1bmN0aW9uIHNldFN0YXRlS2V5IChrZXkpIHtcbiAgX2tleSA9IGtleTtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXRlICh1cmwsIHJlcGxhY2UpIHtcbiAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gIC8vIHRyeS4uLmNhdGNoIHRoZSBwdXNoU3RhdGUgY2FsbCB0byBnZXQgYXJvdW5kIFNhZmFyaVxuICAvLyBET00gRXhjZXB0aW9uIDE4IHdoZXJlIGl0IGxpbWl0cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzXG4gIHZhciBoaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfa2V5ID0gZ2VuS2V5KCk7XG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB3aW5kb3cubG9jYXRpb25bcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdhc3NpZ24nXSh1cmwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAodXJsKSB7XG4gIHB1c2hTdGF0ZSh1cmwsIHRydWUpO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcnVuUXVldWUgKHF1ZXVlLCBmbiwgY2IpIHtcbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gcXVldWUubGVuZ3RoKSB7XG4gICAgICBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocXVldWVbaW5kZXhdKSB7XG4gICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGVwKDApO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyAobWF0Y2hlZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgdmFyIGhhc0FzeW5jID0gZmFsc2U7XG4gICAgdmFyIHBlbmRpbmcgPSAwO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG5cbiAgICBmbGF0TWFwQ29tcG9uZW50cyhtYXRjaGVkLCBmdW5jdGlvbiAoZGVmLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgICAvLyBpZiBpdCdzIGEgZnVuY3Rpb24gYW5kIGRvZXNuJ3QgaGF2ZSBjaWQgYXR0YWNoZWQsXG4gICAgICAvLyBhc3N1bWUgaXQncyBhbiBhc3luYyBjb21wb25lbnQgcmVzb2x2ZSBmdW5jdGlvbi5cbiAgICAgIC8vIHdlIGFyZSBub3QgdXNpbmcgVnVlJ3MgZGVmYXVsdCBhc3luYyByZXNvbHZpbmcgbWVjaGFuaXNtIGJlY2F1c2VcbiAgICAgIC8vIHdlIHdhbnQgdG8gaGFsdCB0aGUgbmF2aWdhdGlvbiB1bnRpbCB0aGUgaW5jb21pbmcgY29tcG9uZW50IGhhcyBiZWVuXG4gICAgICAvLyByZXNvbHZlZC5cbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGRlZi5jaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoYXNBc3luYyA9IHRydWU7XG4gICAgICAgIHBlbmRpbmcrKztcblxuICAgICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlc29sdmVkRGVmKSB7XG4gICAgICAgICAgaWYgKHJlc29sdmVkRGVmLl9fZXNNb2R1bGUgJiYgcmVzb2x2ZWREZWYuZGVmYXVsdCkge1xuICAgICAgICAgICAgcmVzb2x2ZWREZWYgPSByZXNvbHZlZERlZi5kZWZhdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzYXZlIHJlc29sdmVkIG9uIGFzeW5jIGZhY3RvcnkgaW4gY2FzZSBpdCdzIHVzZWQgZWxzZXdoZXJlXG4gICAgICAgICAgZGVmLnJlc29sdmVkID0gdHlwZW9mIHJlc29sdmVkRGVmID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHJlc29sdmVkRGVmXG4gICAgICAgICAgICA6IF9WdWUuZXh0ZW5kKHJlc29sdmVkRGVmKTtcbiAgICAgICAgICBtYXRjaC5jb21wb25lbnRzW2tleV0gPSByZXNvbHZlZERlZjtcbiAgICAgICAgICBwZW5kaW5nLS07XG4gICAgICAgICAgaWYgKHBlbmRpbmcgPD0gMCkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHZhciBtc2cgPSBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudCBcIiArIGtleSArIFwiOiBcIiArIHJlYXNvbjtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oZmFsc2UsIG1zZyk7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBpc0Vycm9yKHJlYXNvbilcbiAgICAgICAgICAgICAgPyByZWFzb25cbiAgICAgICAgICAgICAgOiBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIG5leHQoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBkZWYocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbmV3IHN5bnRheCBpbiBWdWUgMi4zXG4gICAgICAgICAgICB2YXIgY29tcCA9IHJlcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAoY29tcCAmJiB0eXBlb2YgY29tcC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNvbXAudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFoYXNBc3luYykgeyBuZXh0KCk7IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0TWFwQ29tcG9uZW50cyAoXG4gIG1hdGNoZWQsXG4gIGZuXG4pIHtcbiAgcmV0dXJuIGZsYXR0ZW4obWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4oXG4gICAgICBtLmNvbXBvbmVudHNba2V5XSxcbiAgICAgIG0uaW5zdGFuY2VzW2tleV0sXG4gICAgICBtLCBrZXlcbiAgICApOyB9KVxuICB9KSlcbn1cblxuZnVuY3Rpb24gZmxhdHRlbiAoYXJyKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpXG59XG5cbi8vIGluIFdlYnBhY2sgMiwgcmVxdWlyZS5lbnN1cmUgbm93IGFsc28gcmV0dXJucyBhIFByb21pc2Vcbi8vIHNvIHRoZSByZXNvbHZlL3JlamVjdCBmdW5jdGlvbnMgbWF5IGdldCBjYWxsZWQgYW4gZXh0cmEgdGltZVxuLy8gaWYgdGhlIHVzZXIgdXNlcyBhbiBhcnJvdyBmdW5jdGlvbiBzaG9ydGhhbmQgdGhhdCBoYXBwZW5zIHRvXG4vLyByZXR1cm4gdGhhdCBQcm9taXNlLlxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIGlmIChjYWxsZWQpIHsgcmV0dXJuIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgSGlzdG9yeSA9IGZ1bmN0aW9uIEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgdGhpcy5iYXNlID0gbm9ybWFsaXplQmFzZShiYXNlKTtcbiAgLy8gc3RhcnQgd2l0aCBhIHJvdXRlIG9iamVjdCB0aGF0IHN0YW5kcyBmb3IgXCJub3doZXJlXCJcbiAgdGhpcy5jdXJyZW50ID0gU1RBUlQ7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7XG4gIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgdGhpcy5yZWFkeUNicyA9IFtdO1xuICB0aGlzLnJlYWR5RXJyb3JDYnMgPSBbXTtcbiAgdGhpcy5lcnJvckNicyA9IFtdO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuIChjYikge1xuICB0aGlzLmNiID0gY2I7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gb25SZWFkeSAoY2IsIGVycm9yQ2IpIHtcbiAgaWYgKHRoaXMucmVhZHkpIHtcbiAgICBjYigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVhZHlDYnMucHVzaChjYik7XG4gICAgaWYgKGVycm9yQ2IpIHtcbiAgICAgIHRoaXMucmVhZHlFcnJvckNicy5wdXNoKGVycm9yQ2IpO1xuICAgIH1cbiAgfVxufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5lcnJvckNicy5wdXNoKGVycm9yQ2IpO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gdHJhbnNpdGlvblRvIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciByb3V0ZSA9IHRoaXMucm91dGVyLm1hdGNoKGxvY2F0aW9uLCB0aGlzLmN1cnJlbnQpO1xuICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIHRoaXMkMS5lbnN1cmVVUkwoKTtcblxuICAgIC8vIGZpcmUgcmVhZHkgY2JzIG9uY2VcbiAgICBpZiAoIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihyb3V0ZSk7IH0pO1xuICAgIH1cbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChvbkFib3J0KSB7XG4gICAgICBvbkFib3J0KGVycik7XG4gICAgfVxuICAgIGlmIChlcnIgJiYgIXRoaXMkMS5yZWFkeSkge1xuICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5yZWFkeUVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5jb25maXJtVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uIChyb3V0ZSwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGlzRXJyb3IoZXJyKSkge1xuICAgICAgaWYgKHRoaXMkMS5lcnJvckNicy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcyQxLmVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKGVycik7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihmYWxzZSwgJ3VuY2F1Z2h0IGVycm9yIGR1cmluZyByb3V0ZSBuYXZpZ2F0aW9uOicpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIG9uQWJvcnQgJiYgb25BYm9ydChlcnIpO1xuICB9O1xuICBpZiAoXG4gICAgaXNTYW1lUm91dGUocm91dGUsIGN1cnJlbnQpICYmXG4gICAgLy8gaW4gdGhlIGNhc2UgdGhlIHJvdXRlIG1hcCBoYXMgYmVlbiBkeW5hbWljYWxseSBhcHBlbmRlZCB0b1xuICAgIHJvdXRlLm1hdGNoZWQubGVuZ3RoID09PSBjdXJyZW50Lm1hdGNoZWQubGVuZ3RoXG4gICkge1xuICAgIHRoaXMuZW5zdXJlVVJMKCk7XG4gICAgcmV0dXJuIGFib3J0KClcbiAgfVxuXG4gIHZhciByZWYgPSByZXNvbHZlUXVldWUodGhpcy5jdXJyZW50Lm1hdGNoZWQsIHJvdXRlLm1hdGNoZWQpO1xuICAgIHZhciB1cGRhdGVkID0gcmVmLnVwZGF0ZWQ7XG4gICAgdmFyIGRlYWN0aXZhdGVkID0gcmVmLmRlYWN0aXZhdGVkO1xuICAgIHZhciBhY3RpdmF0ZWQgPSByZWYuYWN0aXZhdGVkO1xuXG4gIHZhciBxdWV1ZSA9IFtdLmNvbmNhdChcbiAgICAvLyBpbi1jb21wb25lbnQgbGVhdmUgZ3VhcmRzXG4gICAgZXh0cmFjdExlYXZlR3VhcmRzKGRlYWN0aXZhdGVkKSxcbiAgICAvLyBnbG9iYWwgYmVmb3JlIGhvb2tzXG4gICAgdGhpcy5yb3V0ZXIuYmVmb3JlSG9va3MsXG4gICAgLy8gaW4tY29tcG9uZW50IHVwZGF0ZSBob29rc1xuICAgIGV4dHJhY3RVcGRhdGVIb29rcyh1cGRhdGVkKSxcbiAgICAvLyBpbi1jb25maWcgZW50ZXIgZ3VhcmRzXG4gICAgYWN0aXZhdGVkLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbS5iZWZvcmVFbnRlcjsgfSksXG4gICAgLy8gYXN5bmMgY29tcG9uZW50c1xuICAgIHJlc29sdmVBc3luY0NvbXBvbmVudHMoYWN0aXZhdGVkKVxuICApO1xuXG4gIHRoaXMucGVuZGluZyA9IHJvdXRlO1xuICB2YXIgaXRlcmF0b3IgPSBmdW5jdGlvbiAoaG9vaywgbmV4dCkge1xuICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgIHJldHVybiBhYm9ydCgpXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBob29rKHJvdXRlLCBjdXJyZW50LCBmdW5jdGlvbiAodG8pIHtcbiAgICAgICAgaWYgKHRvID09PSBmYWxzZSB8fCBpc0Vycm9yKHRvKSkge1xuICAgICAgICAgIC8vIG5leHQoZmFsc2UpIC0+IGFib3J0IG5hdmlnYXRpb24sIGVuc3VyZSBjdXJyZW50IFVSTFxuICAgICAgICAgIHRoaXMkMS5lbnN1cmVVUkwodHJ1ZSk7XG4gICAgICAgICAgYWJvcnQodG8pO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiAoXG4gICAgICAgICAgICB0eXBlb2YgdG8ucGF0aCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHR5cGVvZiB0by5uYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICkpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5leHQoJy8nKSBvciBuZXh0KHsgcGF0aDogJy8nIH0pIC0+IHJlZGlyZWN0XG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiB0by5yZXBsYWNlKSB7XG4gICAgICAgICAgICB0aGlzJDEucmVwbGFjZSh0byk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMkMS5wdXNoKHRvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uZmlybSB0cmFuc2l0aW9uIGFuZCBwYXNzIG9uIHRoZSB2YWx1ZVxuICAgICAgICAgIG5leHQodG8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydChlKTtcbiAgICB9XG4gIH07XG5cbiAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc3RFbnRlckNicyA9IFtdO1xuICAgIHZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmN1cnJlbnQgPT09IHJvdXRlOyB9O1xuICAgIC8vIHdhaXQgdW50aWwgYXN5bmMgY29tcG9uZW50cyBhcmUgcmVzb2x2ZWQgYmVmb3JlXG4gICAgLy8gZXh0cmFjdGluZyBpbi1jb21wb25lbnQgZW50ZXIgZ3VhcmRzXG4gICAgdmFyIGVudGVyR3VhcmRzID0gZXh0cmFjdEVudGVyR3VhcmRzKGFjdGl2YXRlZCwgcG9zdEVudGVyQ2JzLCBpc1ZhbGlkKTtcbiAgICB2YXIgcXVldWUgPSBlbnRlckd1YXJkcy5jb25jYXQodGhpcyQxLnJvdXRlci5yZXNvbHZlSG9va3MpO1xuICAgIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gYWJvcnQoKVxuICAgICAgfVxuICAgICAgdGhpcyQxLnBlbmRpbmcgPSBudWxsO1xuICAgICAgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgICBpZiAodGhpcyQxLnJvdXRlci5hcHApIHtcbiAgICAgICAgdGhpcyQxLnJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwb3N0RW50ZXJDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoKTsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnVwZGF0ZVJvdXRlID0gZnVuY3Rpb24gdXBkYXRlUm91dGUgKHJvdXRlKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5jdXJyZW50O1xuICB0aGlzLmN1cnJlbnQgPSByb3V0ZTtcbiAgdGhpcy5jYiAmJiB0aGlzLmNiKHJvdXRlKTtcbiAgdGhpcy5yb3V0ZXIuYWZ0ZXJIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgaG9vayAmJiBob29rKHJvdXRlLCBwcmV2KTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBub3JtYWxpemVCYXNlIChiYXNlKSB7XG4gIGlmICghYmFzZSkge1xuICAgIGlmIChpbkJyb3dzZXIpIHtcbiAgICAgIC8vIHJlc3BlY3QgPGJhc2U+IHRhZ1xuICAgICAgdmFyIGJhc2VFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2Jhc2UnKTtcbiAgICAgIGJhc2UgPSAoYmFzZUVsICYmIGJhc2VFbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgfHwgJy8nO1xuICAgICAgLy8gc3RyaXAgZnVsbCBVUkwgb3JpZ2luXG4gICAgICBiYXNlID0gYmFzZS5yZXBsYWNlKC9eaHR0cHM/OlxcL1xcL1teXFwvXSsvLCAnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UgPSAnLyc7XG4gICAgfVxuICB9XG4gIC8vIG1ha2Ugc3VyZSB0aGVyZSdzIHRoZSBzdGFydGluZyBzbGFzaFxuICBpZiAoYmFzZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGJhc2UgPSAnLycgKyBiYXNlO1xuICB9XG4gIC8vIHJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICByZXR1cm4gYmFzZS5yZXBsYWNlKC9cXC8kLywgJycpXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVRdWV1ZSAoXG4gIGN1cnJlbnQsXG4gIG5leHRcbikge1xuICB2YXIgaTtcbiAgdmFyIG1heCA9IE1hdGgubWF4KGN1cnJlbnQubGVuZ3RoLCBuZXh0Lmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIGlmIChjdXJyZW50W2ldICE9PSBuZXh0W2ldKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZWQ6IG5leHQuc2xpY2UoMCwgaSksXG4gICAgYWN0aXZhdGVkOiBuZXh0LnNsaWNlKGkpLFxuICAgIGRlYWN0aXZhdGVkOiBjdXJyZW50LnNsaWNlKGkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkcyAoXG4gIHJlY29yZHMsXG4gIG5hbWUsXG4gIGJpbmQsXG4gIHJldmVyc2Vcbikge1xuICB2YXIgZ3VhcmRzID0gZmxhdE1hcENvbXBvbmVudHMocmVjb3JkcywgZnVuY3Rpb24gKGRlZiwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpIHtcbiAgICB2YXIgZ3VhcmQgPSBleHRyYWN0R3VhcmQoZGVmLCBuYW1lKTtcbiAgICBpZiAoZ3VhcmQpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGd1YXJkKVxuICAgICAgICA/IGd1YXJkLm1hcChmdW5jdGlvbiAoZ3VhcmQpIHsgcmV0dXJuIGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KTsgfSlcbiAgICAgICAgOiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSlcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZmxhdHRlbihyZXZlcnNlID8gZ3VhcmRzLnJldmVyc2UoKSA6IGd1YXJkcylcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEd1YXJkIChcbiAgZGVmLFxuICBrZXlcbikge1xuICBpZiAodHlwZW9mIGRlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIGV4dGVuZCBub3cgc28gdGhhdCBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkLlxuICAgIGRlZiA9IF9WdWUuZXh0ZW5kKGRlZik7XG4gIH1cbiAgcmV0dXJuIGRlZi5vcHRpb25zW2tleV1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdExlYXZlR3VhcmRzIChkZWFjdGl2YXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhkZWFjdGl2YXRlZCwgJ2JlZm9yZVJvdXRlTGVhdmUnLCBiaW5kR3VhcmQsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RVcGRhdGVIb29rcyAodXBkYXRlZCkge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyh1cGRhdGVkLCAnYmVmb3JlUm91dGVVcGRhdGUnLCBiaW5kR3VhcmQpXG59XG5cbmZ1bmN0aW9uIGJpbmRHdWFyZCAoZ3VhcmQsIGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBib3VuZFJvdXRlR3VhcmQgKCkge1xuICAgICAgcmV0dXJuIGd1YXJkLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFbnRlckd1YXJkcyAoXG4gIGFjdGl2YXRlZCxcbiAgY2JzLFxuICBpc1ZhbGlkXG4pIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVFbnRlcicsIGZ1bmN0aW9uIChndWFyZCwgXywgbWF0Y2gsIGtleSkge1xuICAgIHJldHVybiBiaW5kRW50ZXJHdWFyZChndWFyZCwgbWF0Y2gsIGtleSwgY2JzLCBpc1ZhbGlkKVxuICB9KVxufVxuXG5mdW5jdGlvbiBiaW5kRW50ZXJHdWFyZCAoXG4gIGd1YXJkLFxuICBtYXRjaCxcbiAga2V5LFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZnVuY3Rpb24gcm91dGVFbnRlckd1YXJkICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHJldHVybiBndWFyZCh0bywgZnJvbSwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICBuZXh0KGNiKTtcbiAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2JzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vICM3NTBcbiAgICAgICAgICAvLyBpZiBhIHJvdXRlci12aWV3IGlzIHdyYXBwZWQgd2l0aCBhbiBvdXQtaW4gdHJhbnNpdGlvbixcbiAgICAgICAgICAvLyB0aGUgaW5zdGFuY2UgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCBhdCB0aGlzIHRpbWUuXG4gICAgICAgICAgLy8gd2Ugd2lsbCBuZWVkIHRvIHBvbGwgZm9yIHJlZ2lzdHJhdGlvbiB1bnRpbCBjdXJyZW50IHJvdXRlXG4gICAgICAgICAgLy8gaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgICAgICAgIHBvbGwoY2IsIG1hdGNoLmluc3RhbmNlcywga2V5LCBpc1ZhbGlkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2xsIChcbiAgY2IsIC8vIHNvbWVob3cgZmxvdyBjYW5ub3QgaW5mZXIgdGhpcyBpcyBhIGZ1bmN0aW9uXG4gIGluc3RhbmNlcyxcbiAga2V5LFxuICBpc1ZhbGlkXG4pIHtcbiAgaWYgKGluc3RhbmNlc1trZXldKSB7XG4gICAgY2IoaW5zdGFuY2VzW2tleV0pO1xuICB9IGVsc2UgaWYgKGlzVmFsaWQoKSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgcG9sbChjYiwgaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgIH0sIDE2KTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG52YXIgSFRNTDVIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhUTUw1SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcblxuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcblxuICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgIHNldHVwU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcyQxLmN1cnJlbnQ7XG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGdldExvY2F0aW9uKHRoaXMkMS5iYXNlKSwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgICAgICBoYW5kbGVTY3JvbGwocm91dGVyLCByb3V0ZSwgY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSFRNTDVIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MNUhpc3Rvcnk7XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZVN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIGlmIChnZXRMb2NhdGlvbih0aGlzLmJhc2UpICE9PSB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gY2xlYW5QYXRoKHRoaXMuYmFzZSArIHRoaXMuY3VycmVudC5mdWxsUGF0aCk7XG4gICAgICBwdXNoID8gcHVzaFN0YXRlKGN1cnJlbnQpIDogcmVwbGFjZVN0YXRlKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldExvY2F0aW9uKHRoaXMuYmFzZSlcbiAgfTtcblxuICByZXR1cm4gSFRNTDVIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGdldExvY2F0aW9uIChiYXNlKSB7XG4gIHZhciBwYXRoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICBpZiAoYmFzZSAmJiBwYXRoLmluZGV4T2YoYmFzZSkgPT09IDApIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZShiYXNlLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2hcbn1cblxuLyogICovXG5cblxudmFyIEhhc2hIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhhc2hIaXN0b3J5IChyb3V0ZXIsIGJhc2UsIGZhbGxiYWNrKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgLy8gY2hlY2sgaGlzdG9yeSBmYWxsYmFjayBkZWVwbGlua2luZ1xuICAgIGlmIChmYWxsYmFjayAmJiBjaGVja0ZhbGxiYWNrKHRoaXMuYmFzZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbnN1cmVTbGFzaCgpO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSGFzaEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIYXNoSGlzdG9yeTtcblxuICAvLyB0aGlzIGlzIGRlbGF5ZWQgdW50aWwgdGhlIGFwcCBtb3VudHNcbiAgLy8gdG8gYXZvaWQgdGhlIGhhc2hjaGFuZ2UgbGlzdGVuZXIgYmVpbmcgZmlyZWQgdG9vIGVhcmx5XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zZXR1cExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFlbnN1cmVTbGFzaCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcyQxLnRyYW5zaXRpb25UbyhnZXRIYXNoKCksIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaEhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudC5mdWxsUGF0aDtcbiAgICBpZiAoZ2V0SGFzaCgpICE9PSBjdXJyZW50KSB7XG4gICAgICBwdXNoID8gcHVzaEhhc2goY3VycmVudCkgOiByZXBsYWNlSGFzaChjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEhhc2goKVxuICB9O1xuXG4gIHJldHVybiBIYXNoSGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBjaGVja0ZhbGxiYWNrIChiYXNlKSB7XG4gIHZhciBsb2NhdGlvbiA9IGdldExvY2F0aW9uKGJhc2UpO1xuICBpZiAoIS9eXFwvIy8udGVzdChsb2NhdGlvbikpIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShcbiAgICAgIGNsZWFuUGF0aChiYXNlICsgJy8jJyArIGxvY2F0aW9uKVxuICAgICk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVTbGFzaCAoKSB7XG4gIHZhciBwYXRoID0gZ2V0SGFzaCgpO1xuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmVwbGFjZUhhc2goJy8nICsgcGF0aCk7XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZXRIYXNoICgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zbGljZShpbmRleCArIDEpXG59XG5cbmZ1bmN0aW9uIHB1c2hIYXNoIChwYXRoKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhhc2ggKHBhdGgpIHtcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGkgPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgdmFyIGJhc2UgPSBpID49IDAgPyBocmVmLnNsaWNlKDAsIGkpIDogaHJlZjtcbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoKGJhc2UgKyBcIiNcIiArIHBhdGgpKTtcbn1cblxuLyogICovXG5cblxudmFyIEFic3RyYWN0SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBBYnN0cmFjdEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLmluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBBYnN0cmFjdEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFic3RyYWN0SGlzdG9yeTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCArIDEpLmNvbmNhdChyb3V0ZSk7XG4gICAgICB0aGlzJDEuaW5kZXgrKztcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXgpLmNvbmNhdChyb3V0ZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHRhcmdldEluZGV4ID0gdGhpcy5pbmRleCArIG47XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciByb3V0ZSA9IHRoaXMuc3RhY2tbdGFyZ2V0SW5kZXhdO1xuICAgIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5pbmRleCA9IHRhcmdldEluZGV4O1xuICAgICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGN1cnJlbnQgPyBjdXJyZW50LmZ1bGxQYXRoIDogJy8nXG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKCkge1xuICAgIC8vIG5vb3BcbiAgfTtcblxuICByZXR1cm4gQWJzdHJhY3RIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbi8qICAqL1xuXG52YXIgVnVlUm91dGVyID0gZnVuY3Rpb24gVnVlUm91dGVyIChvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIHRoaXMuYXBwID0gbnVsbDtcbiAgdGhpcy5hcHBzID0gW107XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuYmVmb3JlSG9va3MgPSBbXTtcbiAgdGhpcy5yZXNvbHZlSG9va3MgPSBbXTtcbiAgdGhpcy5hZnRlckhvb2tzID0gW107XG4gIHRoaXMubWF0Y2hlciA9IGNyZWF0ZU1hdGNoZXIob3B0aW9ucy5yb3V0ZXMgfHwgW10sIHRoaXMpO1xuXG4gIHZhciBtb2RlID0gb3B0aW9ucy5tb2RlIHx8ICdoYXNoJztcbiAgdGhpcy5mYWxsYmFjayA9IG1vZGUgPT09ICdoaXN0b3J5JyAmJiAhc3VwcG9ydHNQdXNoU3RhdGUgJiYgb3B0aW9ucy5mYWxsYmFjayAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgbW9kZSA9ICdoYXNoJztcbiAgfVxuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIG1vZGUgPSAnYWJzdHJhY3QnO1xuICB9XG4gIHRoaXMubW9kZSA9IG1vZGU7XG5cbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSAnaGlzdG9yeSc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSFRNTDVIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhhc2hIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSwgdGhpcy5mYWxsYmFjayk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Fic3RyYWN0JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBBYnN0cmFjdEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgKFwiaW52YWxpZCBtb2RlOiBcIiArIG1vZGUpKTtcbiAgICAgIH1cbiAgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY3VycmVudFJvdXRlOiB7fSB9O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2ggKFxuICByYXcsXG4gIGN1cnJlbnQsXG4gIHJlZGlyZWN0ZWRGcm9tXG4pIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2hlci5tYXRjaChyYXcsIGN1cnJlbnQsIHJlZGlyZWN0ZWRGcm9tKVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmN1cnJlbnRSb3V0ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LmN1cnJlbnRcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKGFwcCAvKiBWdWUgY29tcG9uZW50IGluc3RhbmNlICovKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnQoXG4gICAgaW5zdGFsbC5pbnN0YWxsZWQsXG4gICAgXCJub3QgaW5zdGFsbGVkLiBNYWtlIHN1cmUgdG8gY2FsbCBgVnVlLnVzZShWdWVSb3V0ZXIpYCBcIiArXG4gICAgXCJiZWZvcmUgY3JlYXRpbmcgcm9vdCBpbnN0YW5jZS5cIlxuICApO1xuXG4gIHRoaXMuYXBwcy5wdXNoKGFwcCk7XG5cbiAgLy8gbWFpbiBhcHAgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgaWYgKHRoaXMuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmFwcCA9IGFwcDtcblxuICB2YXIgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcblxuICBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhUTUw1SGlzdG9yeSkge1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9IGVsc2UgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIYXNoSGlzdG9yeSkge1xuICAgIHZhciBzZXR1cEhhc2hMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhpc3Rvcnkuc2V0dXBMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKFxuICAgICAgaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSxcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXJcbiAgICApO1xuICB9XG5cbiAgaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgdGhpcyQxLmFwcHMuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7XG4gICAgICBhcHAuX3JvdXRlID0gcm91dGU7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmJlZm9yZUhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlUmVzb2x2ZSA9IGZ1bmN0aW9uIGJlZm9yZVJlc29sdmUgKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5yZXNvbHZlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiBhZnRlckVhY2ggKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5hZnRlckhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiLCBlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uRXJyb3IoZXJyb3JDYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucHVzaChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgdGhpcy5oaXN0b3J5LmdvKG4pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gYmFjayAoKSB7XG4gIHRoaXMuZ28oLTEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gZm9yd2FyZCAoKSB7XG4gIHRoaXMuZ28oMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdldE1hdGNoZWRDb21wb25lbnRzID0gZnVuY3Rpb24gZ2V0TWF0Y2hlZENvbXBvbmVudHMgKHRvKSB7XG4gIHZhciByb3V0ZSA9IHRvXG4gICAgPyB0by5tYXRjaGVkXG4gICAgICA/IHRvXG4gICAgICA6IHRoaXMucmVzb2x2ZSh0bykucm91dGVcbiAgICA6IHRoaXMuY3VycmVudFJvdXRlO1xuICBpZiAoIXJvdXRlKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgcm91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG0uY29tcG9uZW50c1trZXldXG4gICAgfSlcbiAgfSkpXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChcbiAgdG8sXG4gIGN1cnJlbnQsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKFxuICAgIHRvLFxuICAgIGN1cnJlbnQgfHwgdGhpcy5oaXN0b3J5LmN1cnJlbnQsXG4gICAgYXBwZW5kLFxuICAgIHRoaXNcbiAgKTtcbiAgdmFyIHJvdXRlID0gdGhpcy5tYXRjaChsb2NhdGlvbiwgY3VycmVudCk7XG4gIHZhciBmdWxsUGF0aCA9IHJvdXRlLnJlZGlyZWN0ZWRGcm9tIHx8IHJvdXRlLmZ1bGxQYXRoO1xuICB2YXIgYmFzZSA9IHRoaXMuaGlzdG9yeS5iYXNlO1xuICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYoYmFzZSwgZnVsbFBhdGgsIHRoaXMubW9kZSk7XG4gIHJldHVybiB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHJvdXRlOiByb3V0ZSxcbiAgICBocmVmOiBocmVmLFxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgbm9ybWFsaXplZFRvOiBsb2NhdGlvbixcbiAgICByZXNvbHZlZDogcm91dGVcbiAgfVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZGRSb3V0ZXMgPSBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICB0aGlzLm1hdGNoZXIuYWRkUm91dGVzKHJvdXRlcyk7XG4gIGlmICh0aGlzLmhpc3RvcnkuY3VycmVudCAhPT0gU1RBUlQpIHtcbiAgICB0aGlzLmhpc3RvcnkudHJhbnNpdGlvblRvKHRoaXMuaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWdWVSb3V0ZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJIb29rIChsaXN0LCBmbikge1xuICBsaXN0LnB1c2goZm4pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gbGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7IGxpc3Quc3BsaWNlKGksIDEpOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSHJlZiAoYmFzZSwgZnVsbFBhdGgsIG1vZGUpIHtcbiAgdmFyIHBhdGggPSBtb2RlID09PSAnaGFzaCcgPyAnIycgKyBmdWxsUGF0aCA6IGZ1bGxQYXRoO1xuICByZXR1cm4gYmFzZSA/IGNsZWFuUGF0aChiYXNlICsgJy8nICsgcGF0aCkgOiBwYXRoXG59XG5cblZ1ZVJvdXRlci5pbnN0YWxsID0gaW5zdGFsbDtcblZ1ZVJvdXRlci52ZXJzaW9uID0gJzIuNy4wJztcblxuaWYgKGluQnJvd3NlciAmJiB3aW5kb3cuVnVlKSB7XG4gIHdpbmRvdy5WdWUudXNlKFZ1ZVJvdXRlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZVJvdXRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuZXNtLmpzIiwiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnN1Y2Nlc3NmdWwtc2F2ZSB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICBjb2xvcjogIzAwZDFiMjtcXG59XFxuLm15dGVhbS10YWJsZSB0YWJsZSB0ZCB7XFxyXFxuICBib3JkZXI6IG5vbmU7XFxyXFxuICBmb250LWZhbWlseTogJ0NvdXJpZXInO1xcbn1cXG4ubXl0ZWFtLXRhYmxlIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMSk7XFxyXFxuICBjb2xvcjogYmxhY2s7XFxyXFxuICBib3gtc2hhZG93OiAxcHggMXB4IDEwcHggIzIyMjtcXG59XFxuLm15dGVhbS10YWJsZSB0aGVhZCwgdGZvb3Qge1xcclxcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHJnYmEoMjU1LCAxMDYsIDAsIDEpMCUsIHJnYmEoMTU2LCA1MiwgMCwgMSkxMDAlKTtcXG59XFxuLm15dGVhbS10aXRsZSB7XFxyXFxuICBjb2xvcjogIzg2ODY4NjtcXHJcXG4gIGZvbnQtc2l6ZTogMTZwdDtcXG59XFxuLm15dGVhbS10YWJsZSB0aGVhZCB0aCwgdGZvb3QgdGgge1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICBmb250LXNpemU6IDEycHQ7XFxufVxcbi5teXRlYW0tdGFibGUgdHI6aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZDogcmdiYSgyNTUsIDIzMywgMTIwLCAuMik7XFxufVxcbi5mYWlsdXJlLXNhdmUge1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgY29sb3I6ICNmZjJiNTY7XFxufVxcbi5mYWRlLWVudGVyLWFjdGl2ZSwgLmZhZGUtbGVhdmUtYWN0aXZlIHtcXHJcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgMXM7XFxufVxcbi5mYWRlLWVudGVyLCAuZmFkZS1sZWF2ZS10byB7XFxyXFxuICBvcGFjaXR5OiAwO1xcbn1cXG4ucGFnZS1oZWFkZXItY29udGFpbmVyIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuYnV0dG9uIHtcXHJcXG4gIG1hcmdpbi1ib3R0b206IDAuMjVyZW07XFxufVxcbi5wYWdlLWhlYWRlci1ibG9jayB7XFxyXFxuICB3aWR0aDogMTUlO1xcclxcbiAgbWluLXdpZHRoOiAyNjBweDtcXG59XFxuLnJpZGVycy1jb250YWluZXIge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBmbGV4LXdyYXA6IHdyYXA7XFxyXFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG4ucmlkZXItYmxvY2sge1xcclxcbiAgICBtaW4td2lkdGg6IDE1cmVtO1xcclxcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZGVkZWRlO1xcclxcbiAgICBtYXJnaW46IDFyZW07XFxyXFxuICAgIGJveC1zaGFkb3c6IDFweCAxcHggMXB4ICNjZWNlY2U7XFxyXFxuICAgIHBhZGRpbmc6IDFyZW07XFxyXFxuICAgIG1heC13aWR0aDogMTVyZW07XFxufVxcbi5wYWdlLXRpdGxlIHtcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXG59XFxuLnBhZ2UtdGl0bGUge1xcclxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcclxcbiAgICBmb250LXdlaWdodDogNzAwO1xcbn1cXG4ucGFnZS1zdWJoZWFkZXIge1xcclxcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcXG59XFxuLmNhcmQtZm9vdGVyIHtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2VlZTtcXG59XFxuLmNhcmQtY29udGVudCB7XFxyXFxuICAgIG1pbi1oZWlnaHQ6IDExcmVtO1xcclxcbiAgICBtYXgtaGVpZ2h0OiAxMXJlbTtcXHJcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG59XFxuLmNhcmQtZm9vdGVyIGRpdjpudGgtY2hpbGQoZXZlbikge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbn1cXG4uZm9vdGVyLXJvdyB7XFxyXFxuICAgIGRpc3BsYXk6ZmxleDtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbn1cXG5wLmNhcmQtaGVhZGVyLXRpdGxlIHtcXHJcXG4gICAgZGlzcGxheTpmbGV4O1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcXG59XFxucCBzcGFuLmljb24ge1xcclxcbiAgICBjb2xvcjogI2ZmMzg2MDtcXG59XFxudGg6aG92ZXIge1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5oaWRlLXBhZ2luYXRpb24tYnV0dG9uIHtcXHJcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbn1cXG4uY3VzdG9tLXBhZ2luYXRpb24ge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcbi5sYXN0Um93IHtcXHJcXG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHJnYigyMDgsIDgzLCAxKTtcXG59XFxuLm1pbnVzLWljb24ge1xcclxcbiAgICBjb2xvcjogI2ZmMzg2MDtcXG59XFxuLnBsdXMtaWNvbiB7XFxyXFxuICAgIGNvbG9yOiAjMjNkMTYwO1xcbn1cXG4uYm9sZGVzdC1oZWFkZXIge1xcclxcbiAgICBjb2xvcjogI2ZmZmM3ZjtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gICAgZm9udC1zaXplOiB4eC1sYXJnZTtcXG59XFxuLnJpZ2h0IHtcXHJcXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbn1cXG4ubGgtNHIge1xcclxcbiAgICBoZWlnaHQ6IDRyZW07XFxyXFxuICAgIGxpbmUtaGVpZ2h0OiA0cmVtO1xcclxcbiAgICBmb250LXNpemU6IDEuNzVyZW07XFxyXFxuICAgIGNvbG9yOndoaXRlO1xcbn1cXG4ubGgtNHI6Zmlyc3Qtb2YtdHlwZSB7XFxyXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZmZlOTc4O1xcbn1cXG4ubGgtNHI6bGFzdC1vZi10eXBlIHtcXHJcXG4gICAgbWFyZ2luLWJvdHRvbTogMnJlbTtcXG59XFxyXFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkM6L1VzZXJzL3Nkb3JyaXMvZmFudGFzeW14L2NsaWVudC9jb21wb25lbnRzL2NsaWVudC9jb21wb25lbnRzL215dGVhbS52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXlRQTtFQUNBLG1CQUFBO0VBQ0EsZUFBQTtDQUNBO0FBQ0E7RUFDQSxhQUFBO0VBQ0EsdUJBQUE7Q0FDQTtBQUNBO0VBQ0EseUNBQUE7RUFDQSxhQUFBO0VBQ0EsOEJBQUE7Q0FDQTtBQUNBO0VBQ0EsNkVBQUE7Q0FDQTtBQUNBO0VBQ0EsZUFBQTtFQUNBLGdCQUFBO0NBQ0E7QUFDQTtFQUNBLFlBQUE7RUFDQSxnQkFBQTtDQUNBO0FBQ0E7RUFDQSxvQ0FBQTtDQUNBO0FBQ0E7RUFDQSxtQkFBQTtFQUNBLGVBQUE7Q0FDQTtBQUNBO0VBQ0EsdUJBQUE7Q0FDQTtBQUNBO0VBQ0EsV0FBQTtDQUNBO0FBQ0E7RUFDQSxjQUFBO0VBQ0Esd0JBQUE7Q0FDQTtBQUNBO0VBQ0EsdUJBQUE7Q0FDQTtBQUNBO0VBQ0EsV0FBQTtFQUNBLGlCQUFBO0NBQ0E7QUFDQTtJQUNBLGNBQUE7SUFDQSxnQkFBQTtJQUNBLHdCQUFBO0NBQ0E7QUFDQTtJQUNBLGlCQUFBO0lBQ0EsMEJBQUE7SUFDQSxhQUFBO0lBQ0EsZ0NBQUE7SUFDQSxjQUFBO0lBQ0EsaUJBQUE7Q0FDQTtBQUNBO0lBQ0EsbUJBQUE7SUFDQSwyQkFBQTtJQUNBLGlCQUFBO0NBQ0E7QUFDQTtJQUNBLG1CQUFBO0lBQ0EsMkJBQUE7SUFDQSxpQkFBQTtDQUNBO0FBQ0E7SUFDQSxrQkFBQTtDQUNBO0FBQ0E7SUFDQSx1QkFBQTtJQUNBLHVCQUFBO0NBQ0E7QUFDQTtJQUNBLGtCQUFBO0lBQ0Esa0JBQUE7SUFDQSxpQkFBQTtJQUNBLG9CQUFBO0NBQ0E7QUFDQTtJQUNBLHVCQUFBO0NBQ0E7QUFDQTtJQUNBLGFBQUE7SUFDQSwrQkFBQTtDQUNBO0FBQ0E7SUFDQSxhQUFBO0lBQ0EsOEJBQUE7Q0FDQTtBQUNBO0lBQ0EsZUFBQTtDQUNBO0FBQ0E7SUFDQSxnQkFBQTtDQUNBO0FBQ0E7SUFDQSxtQkFBQTtDQUNBO0FBQ0E7SUFDQSxjQUFBO0lBQ0EsK0JBQUE7Q0FDQTtBQUNBO0lBQ0EseUNBQUE7Q0FDQTtBQUNBO0lBQ0EsZUFBQTtDQUNBO0FBQ0E7SUFDQSxlQUFBO0NBQ0E7QUFDQTtJQUNBLGVBQUE7SUFDQSxpQkFBQTtJQUNBLG9CQUFBO0NBQ0E7QUFDQTtJQUNBLGFBQUE7Q0FDQTtBQUNBO0lBQ0EsYUFBQTtJQUNBLGtCQUFBO0lBQ0EsbUJBQUE7SUFDQSxZQUFBO0NBQ0E7QUFDQTtJQUNBLGlDQUFBO0NBQ0E7QUFDQTtJQUNBLG9CQUFBO0NBQ0FcIixcImZpbGVcIjpcIm15dGVhbS52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbiAgPGRpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwicGFnZS1oZWFkZXItY29udGFpbmVyXFxcIj5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJwYWdlLWhlYWRlci1ibG9ja1xcXCI+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaC00clxcXCI+V2VlazogPHNwYW4gY2xhc3M9XFxcImJvbGRlc3QtaGVhZGVyIHJpZ2h0XFxcIj57e2N1cnJlbnR3ZWVrfX08L3NwYW4+PC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsaC00clxcXCI+QmFsYW5jZSBSZW1haW5pbmc6PHNwYW4gY2xhc3M9XFxcImJvbGRlc3QtaGVhZGVyIHJpZ2h0XFxcIj4gJHt7ZG9sbGFyc319PC9zcGFuPjwvZGl2PlxcclxcbiAgICAgIDwvZGl2PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIj5cXHJcXG4gICAgICA8dHJhbnNpdGlvbiBuYW1lPVxcXCJmYWRlXFxcIiBtb2RlPVxcXCJvdXQtaW5cXFwiPlxcclxcbiAgICAgICAgPHAgdi1pZj1cXFwic2hvd1NhdmVNZXNzYWdlXFxcIiBjbGFzcz1cXFwic3VjY2Vzc2Z1bC1zYXZlXFxcIj5Zb3VyIHRlYW0gaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHNhdmVkITwvcD5cXHJcXG4gICAgICAgIDxwIHYtaWY9XFxcInNob3dGYWlsTWVzc2FnZVxcXCIgY2xhc3M9XFxcImZhaWx1cmUtc2F2ZVxcXCI+T29wcyEgU29tZXRoaW5nIFdlbnQgV3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuPC9wPlxcclxcbiAgICAgIDwvdHJhbnNpdGlvbj5cXHJcXG4gICAgICA8dGFibGUgY2xhc3M9XFxcIm15dGVhbS10YWJsZVxcXCI+XFxyXFxuICAgICAgICA8dGhlYWQ+XFxyXFxuICAgICAgICAgIDx0cj5cXHJcXG4gICAgICAgICAgICA8dGg+QWN0aW9uPC90aD5cXHJcXG4gICAgICAgICAgICA8dGggQGNsaWNrPVxcXCJzb3J0QnlQcmljZVxcXCI+UHJpY2VcXHJcXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNhcmV0LXVwXFxcIiB2LWlmPVxcXCJDb3N0U29ydEJ5QXNjXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9pPlxcclxcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtY2FyZXQtZG93blxcXCIgdi1lbHNlIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L2k+XFxyXFxuICAgICAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgICAgICAgPC90aD5cXHJcXG4gICAgICAgICAgICA8dGg+UmFjZXIgTmFtZTwvdGg+XFxyXFxuICAgICAgICAgICAgPHRoPlJhY2VyIE51bWJlcjwvdGg+XFxyXFxuICAgICAgICAgICAgPHRoPkhpZ2hlc3QgRmluaXNoPC90aD5cXHJcXG4gICAgICAgICAgICA8dGg+TG93ZXN0IEZpbmlzaDwvdGg+XFxyXFxuICAgICAgICAgICAgPHRoPkF2ZXJhZ2UgRmluaXNoPC90aD5cXHJcXG4gICAgICAgICAgPC90cj5cXHJcXG4gICAgICAgIDwvdGhlYWQ+XFxyXFxuICAgICAgICA8dGZvb3Q+XFxyXFxuICAgICAgICAgIDx0cj5cXHJcXG4gICAgICAgICAgICA8dGg+QWN0aW9uPC90aD5cXHJcXG4gICAgICAgICAgICA8dGg+UHJpY2U8L3RoPlxcclxcbiAgICAgICAgICAgIDx0aD5SYWNlciBOYW1lPC90aD5cXHJcXG4gICAgICAgICAgICA8dGg+UmFjZXIgTnVtYmVyPC90aD5cXHJcXG4gICAgICAgICAgICA8dGg+SGlnaGVzdCBGaW5pc2g8L3RoPlxcclxcbiAgICAgICAgICAgIDx0aD5Mb3dlc3QgRmluaXNoPC90aD5cXHJcXG4gICAgICAgICAgICA8dGg+QXZlcmFnZSBGaW5pc2g8L3RoPlxcclxcbiAgICAgICAgICA8L3RyPlxcclxcbiAgICAgICAgPC90Zm9vdD5cXHJcXG4gICAgICAgIDx0Ym9keT5cXHJcXG4gICAgICAgICAgPHRyIHYtZm9yPVxcXCIocmFjZXIsIGluZGV4KSBpbiBzZWxlY3RlZHJpZGVyc1xcXCI+XFxyXFxuICAgICAgICAgICAgPHRkPlxcclxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiIyFcXFwiIHYtaWY9XFxcInJhY2VyLm5hbWUgIT0gJ09QRU4gU0xPVCdcXFwiIEBjbGljaz1cXFwicmVtb3ZlUmFjZXIocmFjZXIpXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24gbWludXMtaWNvblxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLW1pbnVzXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9pPlxcclxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgICAgICAgICA8L2E+XFxyXFxuICAgICAgICAgICAgPC90ZD5cXHJcXG4gICAgICAgICAgICA8dGQ+JHt7cmFjZXIuY29zdH19PC90ZD5cXHJcXG4gICAgICAgICAgICA8dGQ+e3tyYWNlci5uYW1lfX08L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZD57e3JhY2VyLnJpZGVyX251bWJlcn19PC90ZD5cXHJcXG4gICAgICAgICAgICA8dGQ+e3tyYWNlci5oaWdoZXN0RmluaXNofX08L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZD57e3JhY2VyLmxvd2VzdEZpbmlzaH19PC90ZD5cXHJcXG4gICAgICAgICAgICA8dGQ+e3tyYWNlci5hdmVyYWdlRmluaXNofX08L3RkPlxcclxcbiAgICAgICAgICA8L3RyPlxcclxcbiAgICAgICAgICA8dHIgY2xhc3M9XFxcImxhc3RSb3dcXFwiPlxcclxcbiAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCI1XFxcIj48L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZCBjb2xzcGFuPVxcXCIxXFxcIj5cXHJcXG4gICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBpcy1kYW5nZXJcXFwiIEBjbGljaz1cXFwiUmVtb3ZlQWxsXFxcIiA6ZGlzYWJsZWQ9XFxcIiFzaG93UmVtb3ZlQWxsXFxcIj5SZW1vdmUgQWxsPC9idXR0b24+XFxyXFxuICAgICAgICAgICAgPC90ZD5cXHJcXG4gICAgICAgICAgICA8dGQgY29sc3Bhbj1cXFwiMVxcXCI+XFxyXFxuICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gaXMtc3VjY2Vzc1xcXCIgQGNsaWNrPVxcXCJTYXZlVGVhbVxcXCIgOmRpc2FibGVkPVxcXCJoYXNPcGVuU2xvdHNcXFwiIHYtYmluZDpjbGFzcz1cXFwieydpcy1sb2FkaW5nJzppc0xvYWRpbmd9XFxcIj5TYXZlIFRlYW08L2J1dHRvbj5cXHJcXG4gICAgICAgICAgICA8L3RkPlxcclxcbiAgICAgICAgICA8L3RyPlxcclxcbiAgICAgICAgICA8dHIgdi1mb3I9XFxcInJpZGVyIGluIHBhZ2luYXRlZFJpZGVyc1xcXCI+XFxyXFxuICAgICAgICAgICAgPHRkPlxcclxcbiAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiIyFcXFwiIHYtaWY9XFxcInNob3dTZWxlY3QgJiYgcmlkZXIuY29zdCA8PSBkb2xsYXJzXFxcIiBAY2xpY2s9XFxcImFkZFJhY2VyKHJpZGVyKVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uIHBsdXMtaWNvblxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXBsdXNcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L2k+XFxyXFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICAgICAgICAgIDwvYT5cXHJcXG4gICAgICAgICAgICA8L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZD4ke3tyaWRlci5jb3N0fX08L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZD57e3JpZGVyLm5hbWV9fTwvdGQ+XFxyXFxuICAgICAgICAgICAgPHRkPnt7cmlkZXIucmlkZXJfbnVtYmVyfX08L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZD57e3JpZGVyLmhpZ2hlc3RGaW5pc2h9fTwvdGQ+XFxyXFxuICAgICAgICAgICAgPHRkPnt7cmlkZXIubG93ZXN0RmluaXNofX08L3RkPlxcclxcbiAgICAgICAgICAgIDx0ZD57e3JpZGVyLmF2ZXJhZ2VGaW5pc2h9fTwvdGQ+XFxyXFxuICAgICAgICAgIDwvdHI+XFxyXFxuICAgICAgICA8L3Rib2R5PlxcclxcbiAgICAgIDwvdGFibGU+XFxyXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY3VzdG9tLXBhZ2luYXRpb25cXFwiPlxcclxcbiAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgPGEgY2xhc3M9XFxcInBhZ2luYXRpb24tcHJldmlvdXNcXFwiIEBjbGljaz1cXFwicGFnZS0tXFxcIiB2LWJpbmQ6Y2xhc3M9XFxcInsgJ2hpZGUtcGFnaW5hdGlvbi1idXR0b24nIDogaGlkZVByZXZpb3VzIH1cXFwiPlByZXZpb3VzPC9hPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICA8YSBjbGFzcz1cXFwicGFnaW5hdGlvbi1udW1iZXJcXFwiPnt7cGFnZX19L3t7cGFnaW5hdGlvblBhZ2VzfX08L2E+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgIDxhIGNsYXNzPVxcXCJwYWdpbmF0aW9uLW5leHRcXFwiIEBjbGljaz1cXFwicGFnZSsrXFxcIiB2LWJpbmQ6Y2xhc3M9XFxcInsgJ2hpZGUtcGFnaW5hdGlvbi1idXR0b24nIDogaGlkZU5leHQgfVxcXCI+TmV4dCBwYWdlPC9hPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgPC9kaXY+XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG5cXHJcXG48c2NyaXB0PlxcclxcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XFxyXFxuaW1wb3J0IHsgbWFwR2V0dGVycyB9IGZyb20gJ3Z1ZXgnO1xcclxcbmltcG9ydCBfZmluZEluZGV4IGZyb20gJ2xvZGFzaC9maW5kSW5kZXgnO1xcclxcbmltcG9ydCBfc29ydEJ5IGZyb20gJ2xvZGFzaC9zb3J0QnknO1xcclxcbmltcG9ydCBfcmVtb3ZlIGZyb20gJ2xvZGFzaC9yZW1vdmUnO1xcclxcbiAgZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICBkYXRhKCkge1xcclxcbiAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICBjdXJyZW50d2VlazogMCxcXHJcXG4gICAgICAgIHNlbGVjdGVkcmlkZXJzOiBbXSxcXHJcXG4gICAgICAgIGF2YWlsYWJsZVJpZGVyczogW10sXFxyXFxuICAgICAgICBDb3N0U29ydEJ5QXNjOiB0cnVlLFxcclxcbiAgICAgICAgcGFnZTogMSxcXHJcXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXFxyXFxuICAgICAgICBzaG93U2F2ZU1lc3NhZ2U6IGZhbHNlLFxcclxcbiAgICAgICAgc2hvd0ZhaWxNZXNzYWdlOiBmYWxzZVxcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAuLi5tYXBHZXR0ZXJzKFtcXHJcXG4gICAgICAgICdnZXRVc2VyRGF0YSdcXHJcXG4gICAgICBdKSxcXHJcXG4gICAgICBkb2xsYXJzKCkge1xcclxcbiAgICAgICAgdmFyIHRvdGFsID0gMTAwMDA7XFxyXFxuICAgICAgICB0aGlzLnNlbGVjdGVkcmlkZXJzLmZvckVhY2gocmlkZXIgPT4ge1xcclxcbiAgICAgICAgICB0b3RhbCAtPSByaWRlci5jb3N0O1xcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIHJldHVybiB0b3RhbDtcXHJcXG4gICAgICB9LFxcclxcbiAgICAgIGhpZGVQcmV2aW91cygpIHtcXHJcXG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2UgPD0gMTtcXHJcXG4gICAgICB9LFxcclxcbiAgICAgIGhpZGVOZXh0KCkge1xcclxcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZSA+PSB0aGlzLnBhZ2luYXRpb25QYWdlcztcXHJcXG4gICAgICB9LFxcclxcbiAgICAgIHBhZ2luYXRlZFJpZGVycygpIHtcXHJcXG4gICAgICAgIGlmICh0aGlzLnBhZ2UgPT0gMSkge1xcclxcbiAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiZW50aXJlIGFycmF5XFxcIiwgdGhpcy5hdmFpbGFibGVSaWRlcnMpXFxyXFxuICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYXZhaWxhYmxlUmlkZXJzLnNsaWNlKDAsIDEwKSk7XFxyXFxuICAgICAgICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZVJpZGVycy5zbGljZSgwLCAxMCk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICB2YXIgYmVnaW5TbGljZSA9IHRoaXMucGFnZSAqIDEwIC0gOTtcXHJcXG4gICAgICAgICAgdmFyIGVuZFNsaWNlID0gYmVnaW5TbGljZSArIDEwO1xcclxcbiAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmF2YWlsYWJsZVJpZGVycylcXHJcXG4gICAgICAgICAgY29uc29sZS5sb2codGhpcy5hdmFpbGFibGVSaWRlcnMuc2xpY2UoYmVnaW5TbGljZSwgZW5kU2xpY2UpKVxcclxcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdmFpbGFibGVSaWRlcnMuc2xpY2UoYmVnaW5TbGljZSwgZW5kU2xpY2UpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0sXFxyXFxuICAgICAgcGFnaW5hdGlvblBhZ2VzKCkge1xcclxcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmF2YWlsYWJsZVJpZGVycy5sZW5ndGggLyAxMCk7XFxyXFxuICAgICAgfSxcXHJcXG4gICAgICBoYXNPcGVuU2xvdHMoKSB7XFxyXFxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZHJpZGVycy5zb21lKHJpZGVyID0+IHsgcmV0dXJuIHJpZGVyLm5hbWUgPT0gXFxcIk9QRU4gU0xPVFxcXCIgfSlcXHJcXG4gICAgICB9LFxcclxcbiAgICAgIHNob3dSZW1vdmVBbGwoKSB7XFxyXFxuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZHJpZGVycy5zb21lKHJpZGVyID0+IHsgcmV0dXJuIHJpZGVyLm5hbWUgIT0gXFxcIk9QRU4gU0xPVFxcXCIgfSlcXHJcXG4gICAgICB9LFxcclxcbiAgICAgIHNob3dTZWxlY3QoKSB7XFxyXFxuICAgICAgICB2YXIgb3BlblNsb3RzID0gdGhpcy5zZWxlY3RlZHJpZGVycy5zb21lKChyaWRlcikgPT4ge3JldHVybiByaWRlci5uYW1lID09IFxcXCJPUEVOIFNMT1RcXFwifSk7XFxyXFxuICAgICAgICB2YXIgbG93ZXN0Q29zdEF2YWlsYWJsZSA9IF9zb3J0QnkodGhpcy5hdmFpbGFibGVSaWRlcnMsIG8gPT4geyByZXR1cm4gby5jb3N0IH0pO1xcclxcbiAgICAgICAgY29uc29sZS5sb2coXFxcInNob3dTZWxlY3RcXFwiLCBsb3dlc3RDb3N0QXZhaWxhYmxlWzBdKVxcclxcbiAgICAgICAgaWYgKCh0aGlzLmRvbGxhcnMgPj0gbG93ZXN0Q29zdEF2YWlsYWJsZVswXS5jb3N0KSAmJiBvcGVuU2xvdHMpIHtcXHJcXG4gICAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBtZXRob2RzOiB7XFxyXFxuICAgICAgcmVtb3ZlUmFjZXIocmFjZXIpIHtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKFxcXCJyZW1vdmVkIHJhY2Vyc1xcXCIsIHJhY2VyKTtcXHJcXG4gICAgICAgIHZhciBzZWxlY3RlZFJhY2VySW5kZXggPSBfZmluZEluZGV4KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIG8gPT4geyByZXR1cm4gby5yaWRlcmlkID09PSByYWNlci5yaWRlcmlkIH0pO1xcclxcbiAgICAgICAgdmFyIG9wZW5TcGFjZSA9IHtcXHJcXG4gICAgICAgICAgaWQ6IHRoaXMuc2VsZWN0ZWRyaWRlcnNbc2VsZWN0ZWRSYWNlckluZGV4XS5pZCxcXHJcXG4gICAgICAgICAgYXZhdGFyX3VybDogJ2h0dHA6Ly93d3cuc2hvcGFhcmR2YXJrLmNvbS9tZWRpYS9jYXRhbG9nL3Byb2R1Y3QvVy9TL1dTLTE4NjU1LmpwZycsXFxyXFxuICAgICAgICAgIGNvc3Q6IDAsXFxyXFxuICAgICAgICAgIGhpZ2hlc3RGaW5pc2g6ICctJyxcXHJcXG4gICAgICAgICAgbG93ZXN0RmluaXNoOiAnLScsXFxyXFxuICAgICAgICAgIG5hbWU6ICdPUEVOIFNMT1QnLFxcclxcbiAgICAgICAgICByaWRlcl9udW1iZXI6IDAsXFxyXFxuICAgICAgICAgIHJpZGVyaWQ6IDAsXFxyXFxuICAgICAgICAgIGxlYWd1ZWlkOiAxLFxcclxcbiAgICAgICAgICBzZWFzb25fd2Vla3NpZDogdGhpcy5jdXJyZW50d2Vla1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdGhpcy5hdmFpbGFibGVSaWRlcnMucHVzaChyYWNlcilcXHJcXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnNlbGVjdGVkcmlkZXJzLCBzZWxlY3RlZFJhY2VySW5kZXgsIG9wZW5TcGFjZSlcXHJcXG4gICAgICAgIHRoaXMuc29ydEJ5UHJpY2UoKTtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKFxcXCJNeSBuZXcgdGVhbVxcXCIsIHRoaXMuc2VsZWN0ZWRyaWRlcnMpXFxyXFxuICAgICAgfSxcXHJcXG4gICAgICBhZGRSYWNlcihyYWNlcikge1xcclxcbiAgICAgICAgdmFyIG9wZW5TbG90SW5kZXggPSBfZmluZEluZGV4KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIG8gPT4geyByZXR1cm4gby5uYW1lID09IFxcXCJPUEVOIFNMT1RcXFwiIH0pO1xcclxcbiAgICAgICAgX3JlbW92ZSh0aGlzLnBhZ2luYXRlZFJpZGVycywgbyA9PiB7IHJldHVybiBvLnJpZGVyaWQgPT0gcmFjZXIucmlkZXJpZCB9KVxcclxcbiAgICAgICAgX3JlbW92ZSh0aGlzLmF2YWlsYWJsZVJpZGVycywgbyA9PiB7IHJldHVybiBvLnJpZGVyaWQgPT0gcmFjZXIucmlkZXJpZCB9KVxcclxcbiAgICAgICAgcmFjZXIuaWQgPSB0aGlzLnNlbGVjdGVkcmlkZXJzW29wZW5TbG90SW5kZXhdLmlkO1xcclxcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIG9wZW5TbG90SW5kZXgsIHJhY2VyKTtcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKFxcXCJSYWNlcnMgdG8gQWRkXFxcIiwgdGhpcy5zZWxlY3RlZHJpZGVycylcXHJcXG4gICAgICB9LFxcclxcbiAgICAgIHNvcnRCeVByaWNlKCkge1xcclxcbiAgICAgICAgaWYgKHRoaXMuQ29zdFNvcnRCeUFzYykge1xcclxcbiAgICAgICAgICB0aGlzLkNvc3RTb3J0QnlBc2MgPSBmYWxzZTtcXHJcXG4gICAgICAgICAgdGhpcy5hdmFpbGFibGVSaWRlcnMgPSB0aGlzLmF2YWlsYWJsZVJpZGVycy5zb3J0KChhLCBiKSA9PiB7XFxyXFxuICAgICAgICAgICAgaWYgKGEuY29zdCA+IGIuY29zdCkge1xcclxcbiAgICAgICAgICAgICAgcmV0dXJuIC0xXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIGlmIChhLmNvc3QgPCBiLmNvc3QpIHtcXHJcXG4gICAgICAgICAgICAgIHJldHVybiAxXFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHJldHVybiAwXFxyXFxuICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICB0aGlzLkNvc3RTb3J0QnlBc2MgPSB0cnVlO1xcclxcbiAgICAgICAgICB0aGlzLmF2YWlsYWJsZVJpZGVycyA9IHRoaXMuYXZhaWxhYmxlUmlkZXJzLnNvcnQoKGEsIGIpID0+IHtcXHJcXG4gICAgICAgICAgICBpZiAoYS5jb3N0ID4gYi5jb3N0KSB7XFxyXFxuICAgICAgICAgICAgICByZXR1cm4gMVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICBpZiAoYS5jb3N0IDwgYi5jb3N0KSB7XFxyXFxuICAgICAgICAgICAgICByZXR1cm4gLTFcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgcmV0dXJuIDBcXHJcXG4gICAgICAgICAgfSlcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9LFxcclxcbiAgICAgIFNhdmVUZWFtKCkge1xcclxcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xcclxcbiAgICAgICAgYXhpb3MucG9zdChcXFwiL1NhdmVUZWFtXFxcIiwgdGhpcy5zZWxlY3RlZHJpZGVycylcXHJcXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xcclxcbiAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xcclxcbiAgICAgICAgICB0aGlzLlNhdmVNZXNzYWdlKCk7XFxyXFxuICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIC5jYXRjaChlcnJvciA9PiB7XFxyXFxuICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcXHJcXG4gICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcXHJcXG4gICAgICAgICAgdGhpcy5GYWlsTWVzc2FnZSgpO1xcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICB9LFxcclxcbiAgICAgIFNhdmVNZXNzYWdlKCkge1xcclxcbiAgICAgICAgdGhpcy5zaG93U2F2ZU1lc3NhZ2UgPSB0cnVlO1xcclxcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuc2hvd1NhdmVNZXNzYWdlID0gZmFsc2UgfSwgNTAwMClcXHJcXG4gICAgICB9LFxcclxcbiAgICAgIEZhaWxNZXNzYWdlKCkge1xcclxcbiAgICAgICAgdGhpcy5zaG93RmFpbE1lc3NhZ2UgPSB0cnVlO1xcclxcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuc2hvd0ZhaWxNZXNzYWdlID0gZmFsc2UgfSwgNTAwMClcXHJcXG4gICAgICB9LFxcclxcbiAgICAgIFJlbW92ZUFsbCgpIHtcXHJcXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRyaWRlcnMuZm9yRWFjaChyYWNlciA9PiB7XFxyXFxuICAgICAgICAgIGlmIChyYWNlci5uYW1lICE9IFxcXCJPUEVOIFNMT1RcXFwiKSB7XFxyXFxuICAgICAgICAgICAgdGhpcy5yZW1vdmVSYWNlcihyYWNlcilcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIGJlZm9yZUNyZWF0ZSgpIHtcXHJcXG4gICAgICBheGlvcy5nZXQoJy9DdXJyZW50TXlUZWFtTW9kZWwnKVxcclxcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xcclxcbiAgICAgICAgY29uc29sZS5sb2coXFxcImRhdGFcXFwiLCBkYXRhLmRhdGEpO1xcclxcbiAgICAgICAgdGhpcy5jdXJyZW50d2VlayA9IGRhdGEuZGF0YS5DdXJyZW50V2VlaztcXHJcXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuY3VycmVudHdlZWspO1xcclxcbiAgICAgICAgdGhpcy5hdmFpbGFibGVSaWRlcnMgPSBfc29ydEJ5KGRhdGEuZGF0YS5BdmFpbGFibGVSaWRlcnMsIG8gPT4geyByZXR1cm4gby5jb3N0IH0pO1xcclxcbiAgICAgICAgdGhpcy5zZWxlY3RlZHJpZGVycyA9IGRhdGEuZGF0YS5DdXJyZW50VGVhbTtcXHJcXG4gICAgICB9KVxcclxcbiAgICB9LFxcclxcbiAgICBtb3VudGVkKCkge1xcclxcbiAgICAgIGNvbnNvbGUubG9nKFxcXCJtb3VudGVkXFxcIiwgdGhpcy5nZXRVc2VyRGF0YSlcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbjwvc2NyaXB0PlxcclxcbjxzdHlsZT5cXHJcXG4uc3VjY2Vzc2Z1bC1zYXZlIHtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIGNvbG9yOiAjMDBkMWIyO1xcclxcbn1cXHJcXG4ubXl0ZWFtLXRhYmxlIHRhYmxlIHRkIHtcXHJcXG4gIGJvcmRlcjogbm9uZTtcXHJcXG4gIGZvbnQtZmFtaWx5OiAnQ291cmllcic7XFxyXFxufVxcclxcbi5teXRlYW0tdGFibGUge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAxKTtcXHJcXG4gIGNvbG9yOiBibGFjaztcXHJcXG4gIGJveC1zaGFkb3c6IDFweCAxcHggMTBweCAjMjIyO1xcclxcbn1cXHJcXG4ubXl0ZWFtLXRhYmxlIHRoZWFkLCB0Zm9vdCB7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQocmdiYSgyNTUsIDEwNiwgMCwgMSkwJSwgcmdiYSgxNTYsIDUyLCAwLCAxKTEwMCUpO1xcclxcbn1cXHJcXG4ubXl0ZWFtLXRpdGxlIHtcXHJcXG4gIGNvbG9yOiAjODY4Njg2O1xcclxcbiAgZm9udC1zaXplOiAxNnB0O1xcclxcbn1cXHJcXG4ubXl0ZWFtLXRhYmxlIHRoZWFkIHRoLCB0Zm9vdCB0aCB7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGZvbnQtc2l6ZTogMTJwdDtcXHJcXG59XFxyXFxuLm15dGVhbS10YWJsZSB0cjpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjMzLCAxMjAsIC4yKTtcXHJcXG59XFxyXFxuLmZhaWx1cmUtc2F2ZSB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICBjb2xvcjogI2ZmMmI1NjtcXHJcXG59XFxyXFxuLmZhZGUtZW50ZXItYWN0aXZlLCAuZmFkZS1sZWF2ZS1hY3RpdmUge1xcclxcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSAxcztcXHJcXG59XFxyXFxuLmZhZGUtZW50ZXIsIC5mYWRlLWxlYXZlLXRvIHtcXHJcXG4gIG9wYWNpdHk6IDA7XFxyXFxufVxcclxcbi5wYWdlLWhlYWRlci1jb250YWluZXIge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcclxcbn1cXHJcXG5idXR0b24ge1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMC4yNXJlbTtcXHJcXG59XFxyXFxuLnBhZ2UtaGVhZGVyLWJsb2NrIHtcXHJcXG4gIHdpZHRoOiAxNSU7XFxyXFxuICBtaW4td2lkdGg6IDI2MHB4O1xcclxcbn1cXHJcXG4gIC5yaWRlcnMtY29udGFpbmVyIHtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAgZmxleC13cmFwOiB3cmFwO1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gIH1cXHJcXG4gIC5yaWRlci1ibG9jayB7XFxyXFxuICAgIG1pbi13aWR0aDogMTVyZW07XFxyXFxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNkZWRlZGU7XFxyXFxuICAgIG1hcmdpbjogMXJlbTtcXHJcXG4gICAgYm94LXNoYWRvdzogMXB4IDFweCAxcHggI2NlY2VjZTtcXHJcXG4gICAgcGFkZGluZzogMXJlbTtcXHJcXG4gICAgbWF4LXdpZHRoOiAxNXJlbTtcXHJcXG4gIH1cXHJcXG4gIC5wYWdlLXRpdGxlIHtcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gIH1cXHJcXG4gIC5wYWdlLXRpdGxlIHtcXHJcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gIH1cXHJcXG4gIC5wYWdlLXN1YmhlYWRlciB7XFxyXFxuICAgIHRleHQtYWxpZ246Y2VudGVyO1xcclxcbiAgfVxcclxcbiAgLmNhcmQtZm9vdGVyIHtcXHJcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2VlZTtcXHJcXG4gIH1cXHJcXG4gIC5jYXJkLWNvbnRlbnQge1xcclxcbiAgICBtaW4taGVpZ2h0OiAxMXJlbTtcXHJcXG4gICAgbWF4LWhlaWdodDogMTFyZW07XFxyXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxyXFxuICB9XFxyXFxuICAuY2FyZC1mb290ZXIgZGl2Om50aC1jaGlsZChldmVuKSB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XFxyXFxuICB9XFxyXFxuICAuZm9vdGVyLXJvdyB7XFxyXFxuICAgIGRpc3BsYXk6ZmxleDtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbiAgfVxcclxcbiAgcC5jYXJkLWhlYWRlci10aXRsZSB7XFxyXFxuICAgIGRpc3BsYXk6ZmxleDtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxyXFxuICB9XFxyXFxuICBwIHNwYW4uaWNvbiB7XFxyXFxuICAgIGNvbG9yOiAjZmYzODYwO1xcclxcbiAgfVxcclxcbiAgdGg6aG92ZXIge1xcclxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICB9XFxyXFxuICAuaGlkZS1wYWdpbmF0aW9uLWJ1dHRvbiB7XFxyXFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXHJcXG4gIH1cXHJcXG4gIC5jdXN0b20tcGFnaW5hdGlvbiB7XFxyXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXHJcXG4gIH1cXHJcXG4gIC5sYXN0Um93IHtcXHJcXG4gICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHJnYigyMDgsIDgzLCAxKTtcXHJcXG4gIH1cXHJcXG4gIC5taW51cy1pY29uIHtcXHJcXG4gICAgY29sb3I6ICNmZjM4NjA7XFxyXFxuICB9XFxyXFxuICAucGx1cy1pY29uIHtcXHJcXG4gICAgY29sb3I6ICMyM2QxNjA7XFxyXFxuICB9XFxyXFxuICAuYm9sZGVzdC1oZWFkZXIge1xcclxcbiAgICBjb2xvcjogI2ZmZmM3ZjtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gICAgZm9udC1zaXplOiB4eC1sYXJnZTtcXHJcXG4gIH1cXHJcXG4gIC5yaWdodCB7XFxyXFxuICAgIGZsb2F0OiByaWdodDtcXHJcXG4gIH1cXHJcXG4gIC5saC00ciB7XFxyXFxuICAgIGhlaWdodDogNHJlbTtcXHJcXG4gICAgbGluZS1oZWlnaHQ6IDRyZW07XFxyXFxuICAgIGZvbnQtc2l6ZTogMS43NXJlbTtcXHJcXG4gICAgY29sb3I6d2hpdGU7XFxyXFxuICB9XFxyXFxuICAubGgtNHI6Zmlyc3Qtb2YtdHlwZSB7XFxyXFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZmZlOTc4O1xcclxcbiAgfVxcclxcbiAgLmxoLTRyOmxhc3Qtb2YtdHlwZSB7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IDJyZW07XFxyXFxuICB9XFxyXFxuPC9zdHlsZT5cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0xMTc3Y2I2OFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9teXRlYW0udnVlXG4vLyBtb2R1bGUgaWQgPSAyMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiXCIsXCJmaWxlXCI6XCJkZWxldGVhY2NvdW50LnZ1ZVwiLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtMTUxNjdmMmZcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvZGVsZXRlYWNjb3VudC52dWVcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmJvbGQtbWVzc2FnZSB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBmb250LXNpemU6IDE4cHQ7XFxuICBjb2xvcjogI2ZmZmM3ZjtcXG4gIGZvbnQtd2VpZ2h0OiA4MDA7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9zZG9ycmlzL2ZhbnRhc3lteC9jbGllbnQvY29tcG9uZW50cy9jbGllbnQvY29tcG9uZW50cy9DcmVhdGVMZWFndWUudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUEwREE7RUFDQSxtQkFBQTtFQUNBLGdCQUFBO0VBQ0EsZUFBQTtFQUNBLGlCQUFBO0NBQ0FcIixcImZpbGVcIjpcIkNyZWF0ZUxlYWd1ZS52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbjxkaXY+XFxyXFxuICA8ZGl2IHYtaWY9XFxcImdldFVzZXJEYXRhLmFjY291bnR0eXBlID09IDJcXFwiIGNsYXNzPVxcXCJjb2x1bW4gaXMtaGFsZiBpcy1vZmZzZXQtb25lLXF1YXJ0ZXJcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxyXFxuICAgICAgPGxhYmVsPkxlYWd1ZSBOYW1lPC9sYWJlbD5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XFxcIj5cXHJcXG4gICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiaW5wdXRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJMZWFndWUgTmFtZVxcXCI+XFxyXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XFxcIj5cXHJcXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXRyb3BoeVxcXCI+PC9pPlxcclxcbiAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgIDwvZGl2PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcclxcbiAgICAgIDxsYWJlbD5MZWFndWUgUGFzc3dvcmQ8L2xhYmVsPlxcclxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wgaGFzLWljb25zLWxlZnRcXFwiPlxcclxcbiAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJpbnB1dFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgcGxhY2Vob2xkZXI9XFxcIkxlYWd1ZSBQYXNzd29yZFxcXCI+XFxyXFxuICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XFxcIj5cXHJcXG4gICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWxvY2tcXFwiPjwvaT5cXHJcXG4gICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXHJcXG4gICAgICA8bGFiZWw+TWF4IFBsYXllcnM8L2xhYmVsPlxcclxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wgaGFzLWljb25zLWxlZnRcXFwiPlxcclxcbiAgICAgICAgPGlucHV0IGNsYXNzPVxcXCJpbnB1dFxcXCIgdHlwZT1cXFwibnVtYmVyXFxcIiBwbGFjZWhvbGRlcj1cXFwiTWF4IFBsYXllcnNcXFwiPlxcclxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24gaXMtc21hbGwgaXMtbGVmdFxcXCI+XFxyXFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1oYXNodGFnXFxcIj48L2k+XFxyXFxuICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxyXFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uXFxcIj5TdWJtaXQ8L2J1dHRvbj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG4gIDxkaXYgdi1pZj1cXFwiZ2V0VXNlckRhdGEuYWNjb3VudHR5cGUgIT0gMlxcXCI+XFxyXFxuICAgIDxwIGNsYXNzPVxcXCJib2xkLW1lc3NhZ2VcXFwiPlRoaXMgZmVhdHVyZSByZXF1aXJlcyBhIFByZW1pdW0gYWNjb3VudC4gUGxlYXNlIHVwZ3JhZGUgeW91ciBhY2NvdW50IGluIG9yZGVyIHRvIGFjdGl2YXRlIHRoaXMgZmVhdHVyZS48L3A+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG48L3RlbXBsYXRlPlxcclxcblxcclxcbjxzY3JpcHQ+XFxyXFxuaW1wb3J0IHsgbWFwR2V0dGVycywgbWFwTXV0YXRpb25zIH0gZnJvbSAndnVleCc7XFxyXFxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcXHJcXG4gIGV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgZGF0YSgpIHtcXHJcXG4gICAgICByZXR1cm4ge1xcclxcblxcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgY29tcHV0ZWQ6IG1hcEdldHRlcnMoW1xcclxcbiAgICAgICdnZXRVc2VyRGF0YSdcXHJcXG4gICAgXSksXFxyXFxuICAgIG1ldGhvZHM6IHtcXHJcXG4gICAgICAuLi5tYXBNdXRhdGlvbnMoW1xcclxcbiAgICAgIF0pLFxcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuPC9zY3JpcHQ+XFxyXFxuPHN0eWxlPlxcclxcbiAgLmJvbGQtbWVzc2FnZSB7XFxyXFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gICAgZm9udC1zaXplOiAxOHB0O1xcclxcbiAgICBjb2xvcjogI2ZmZmM3ZjtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDgwMDtcXHJcXG4gIH1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTJiNzcwZDI0XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL0NyZWF0ZUxlYWd1ZS52dWVcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLm5hdmJhci1tZW51IHtcXG4gIHBhZGRpbmc6IDAgMTAwcHggMCA1MHB4O1xcbn1cXG4ubmF2YmFyIHtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbn1cXG5hIHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGZvbnQtc2l6ZTogMTZwdDtcXG59XFxuLnJvdXRlci1saW5rLWFjdGl2ZSB7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2ZmZmM3ZjtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkM6L1VzZXJzL3Nkb3JyaXMvZmFudGFzeW14L2NsaWVudC9jb21wb25lbnRzL2NsaWVudC9jb21wb25lbnRzL25hdmJhci52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXNJQTtFQUNBLHdCQUFBO0NBQ0E7QUFDQTtFQUNBLHdCQUFBO0NBQ0E7QUFDQTtFQUNBLGFBQUE7RUFDQSxnQkFBQTtDQUNBO0FBQ0E7RUFDQSxpQ0FBQTtDQUNBXCIsXCJmaWxlXCI6XCJuYXZiYXIudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIlxcclxcbiAgPHRlbXBsYXRlPlxcclxcbiAgICA8bmF2IGNsYXNzPVxcXCJuYXZiYXJcXFwiPlxcclxcbiAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItYnJhbmRcXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWl0ZW1cXFwiPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1idXJnZXIgYnVyZ2VyXFxcIiBkYXRhLXRhcmdldD1cXFwibmF2TWVudVxcXCI+XFxyXFxuICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cXHJcXG4gICAgICAgICAgPHNwYW4+PC9zcGFuPlxcclxcbiAgICAgICAgICA8c3Bhbj48L3NwYW4+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICA8L2Rpdj5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItbWVudVxcXCIgaWQ9XFxcIm5hdk1lbnVcXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLXN0YXJ0XFxcIj5cXHJcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWl0ZW1cXFwiPlxcclxcbiAgICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cXFwiL2hvbWVcXFwiIGV4YWN0PkhvbWU8L3JvdXRlci1saW5rPlxcclxcbiAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWl0ZW1cXFwiIHYtaWY9XFxcIkdldEF1dGhTdGF0dXNcXFwiPlxcclxcbiAgICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cXFwiL215dGVhbVxcXCI+TXkgVGVhbTwvcm91dGVyLWxpbms+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaXRlbVxcXCIgdi1pZj1cXFwiR2V0QXV0aFN0YXR1c1xcXCI+XFxyXFxuICAgICAgICAgICAgPHJvdXRlci1saW5rIHRvPVxcXCIvbGl2ZVxcXCI+U3RhdCBUcmFja2VyPC9yb3V0ZXItbGluaz5cXHJcXG4gICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1pdGVtXFxcIj5cXHJcXG4gICAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XFxcIi9ydWxlc1xcXCI+SW5mbzwvcm91dGVyLWxpbms+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaXRlbVxcXCI+XFxyXFxuICAgICAgICAgICAgPHJvdXRlci1saW5rIHRvPVxcXCIvc3VnZ2VzdGlvbnNcXFwiPlN1Z2dlc3Rpb25zPC9yb3V0ZXItbGluaz5cXHJcXG4gICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1lbmRcXFwiPlxcclxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaXRlbVxcXCIgdi1pZj1cXFwiIUdldEF1dGhTdGF0dXNcXFwiIEBjbGljaz1cXFwic2V0UmVnaXN0ZXJNb2RhbCh7IHNob3c6ICFTaG93UmVnaXN0ZXJNb2RhbCB9KVxcXCI+XFxyXFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiIyFcXFwiPlJlZ2lzdGVyPC9hPlxcclxcbiAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWl0ZW1cXFwiIHYtaWY9XFxcIiFHZXRBdXRoU3RhdHVzXFxcIiBAY2xpY2s9XFxcInNldExvZ2luTW9kYWwoeyBzaG93OiAhU2hvd0xvZ2luTW9kYWwgfSlcXFwiPlxcclxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj5cXHJcXG4gICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1zaWduLWluXFxcIj48L2k+XFxyXFxuICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcIiMhXFxcIj5Mb2dpbjwvYT5cXHJcXG4gICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1pdGVtXFxcIiB2LWlmPVxcXCJHZXRBdXRoU3RhdHVzXFxcIj5cXHJcXG4gICAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XFxcIi9teWFjY291bnRcXFwiPldlbGNvbWUsIHt7IGdldFVzZXJEYXRhLnVzZXJuYW1lIH19ITwvcm91dGVyLWxpbms+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaXRlbVxcXCIgdi1pZj1cXFwiR2V0QXV0aFN0YXR1c1xcXCIgQGNsaWNrPVxcXCJzZXRMb2dnZWRJbih7IGlzTG9nZ2VkSW46ICFHZXRBdXRoU3RhdHVzIH0pXFxcIj5cXHJcXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvblxcXCIgdi1pZj1cXFwiR2V0QXV0aFN0YXR1c1xcXCI+XFxyXFxuICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtc2lnbi1vdXRcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L2k+XFxyXFxuICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcIiMhXFxcIiBAY2xpY2s9XFxcImxvZ291dFxcXCI+TG9nb3V0PC9hPlxcclxcbiAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgIDwvZGl2PlxcclxcbiAgICAgIDxyZWdpc3RlciA6c2hvdz1cXFwiU2hvd1JlZ2lzdGVyTW9kYWxcXFwiPjwvcmVnaXN0ZXI+XFxyXFxuICAgICAgPGxvZ2luIHYtYmluZDpzaG93PVxcXCJTaG93TG9naW5Nb2RhbFxcXCI+PC9sb2dpbj5cXHJcXG4gICAgPC9uYXY+XFxyXFxuICA8L3RlbXBsYXRlPlxcclxcbiAgPHNjcmlwdD5cXHJcXG4gICAgaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcXHJcXG4gICAgaW1wb3J0IHsgbWFwR2V0dGVycywgbWFwTXV0YXRpb25zIH0gZnJvbSAndnVleCc7XFxyXFxuICAgIGltcG9ydCByZWdpc3RlciBmcm9tICcuL3JlZ2lzdGVyLnZ1ZSc7XFxyXFxuICAgIGltcG9ydCBsb2dpbiBmcm9tICcuL2xvZ2luLnZ1ZSc7XFxyXFxuICAgIGltcG9ydCBMZWFndWVEcm9wZG93biBmcm9tICcuL25hdmJhckRyb3Bkb3duLnZ1ZSc7XFxyXFxuICAgIGV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgICBkYXRhKCkge1xcclxcbiAgICAgICAgcmV0dXJuICB7XFxyXFxuICAgICAgICAgIHVzZXJuYW1lOiAnJyxcXHJcXG4gICAgICAgICAgcGFzc3dvcmQ6ICcnLFxcclxcbiAgICAgICAgICBzaG93UmVnaXN0ZXJNb2RhbDogZmFsc2UsXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSxcXHJcXG4gICAgICBjb21wdXRlZDogbWFwR2V0dGVycyhbXFxyXFxuICAgICAgICAnU2hvd0xvZ2luTW9kYWwnLFxcclxcbiAgICAgICAgJ1Nob3dSZWdpc3Rlck1vZGFsJyxcXHJcXG4gICAgICAgICdnZXRVc2VyRGF0YScsXFxyXFxuICAgICAgICAnR2V0QXV0aFN0YXR1cydcXHJcXG4gICAgICBdKSxcXHJcXG4gICAgICBtb3VudGVkKCkge1xcclxcbiAgICAgICAgLy8gR2V0IGFsbCBcXFwibmF2YmFyLWJ1cmdlclxcXCIgZWxlbWVudHNcXHJcXG4gICAgICAgIHZhciAkbmF2YmFyQnVyZ2VycyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5uYXZiYXItYnVyZ2VyJyksIDApO1xcclxcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSBuYXYgYnVyZ2Vyc1xcclxcbiAgICAgICAgaWYgKCRuYXZiYXJCdXJnZXJzLmxlbmd0aCA+IDApIHtcXHJcXG5cXHJcXG4gICAgICAgICAgLy8gQWRkIGEgY2xpY2sgZXZlbnQgb24gZWFjaCBvZiB0aGVtXFxyXFxuICAgICAgICAgICRuYXZiYXJCdXJnZXJzLmZvckVhY2goZnVuY3Rpb24gKCRlbCkge1xcclxcbiAgICAgICAgICAgICRlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgdGFyZ2V0IGZyb20gdGhlIFxcXCJkYXRhLXRhcmdldFxcXCIgYXR0cmlidXRlXFxyXFxuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gJGVsLmRhdGFzZXQudGFyZ2V0O1xcclxcbiAgICAgICAgICAgICAgdmFyICR0YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YXJnZXQpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgLy8gVG9nZ2xlIHRoZSBjbGFzcyBvbiBib3RoIHRoZSBcXFwibmF2YmFyLWJ1cmdlclxcXCIgYW5kIHRoZSBcXFwibmF2YmFyLW1lbnVcXFwiXFxyXFxuICAgICAgICAgICAgICAkZWwuY2xhc3NMaXN0LnRvZ2dsZSgnaXMtYWN0aXZlJyk7XFxyXFxuICAgICAgICAgICAgICAkdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ2lzLWFjdGl2ZScpO1xcclxcblxcclxcbiAgICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgICB9KTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9LFxcclxcbiAgICAgIGNyZWF0ZWQoKSB7XFxyXFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwic3JjXFxcIiwgdGhpcy5sb2dvc3JjKVxcclxcbiAgICAgICAgYXhpb3MuZ2V0KCcvbG9naW5yZWZyZXNoJykudGhlbihkYXRhID0+IHtcXHJcXG4gICAgICAgICAgY29uc29sZS5sb2coZGF0YS5kYXRhKVxcclxcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEuZGF0YS51c2VybmFtZSAhPSAndW5kZWZpbmVkJykge1xcclxcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJVc2VyIElzIEF1dGhlbnRpY2F0ZWRcXFwiKVxcclxcbiAgICAgICAgICAgIHRoaXMuc2V0VXNlckRhdGEoeyB1c2VyRGF0YTogZGF0YS5kYXRhIH0pXFxyXFxuICAgICAgICAgICAgdGhpcy5zZXRMb2dnZWRJbih7IGxvZ2dlZEluOiB0cnVlIH0pXFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XFxyXFxuICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJsb2dpbiByZWZyZXNoIGVycm9yXFxcIiwgZXJyKTtcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgICAgfSxcXHJcXG4gICAgICBtZXRob2RzOiB7XFxyXFxuICAgICAgICAuLi5tYXBNdXRhdGlvbnMoW1xcclxcbiAgICAgICAgICAnc2V0UmVnaXN0ZXJNb2RhbCcsXFxyXFxuICAgICAgICAgICdzZXRMb2dpbk1vZGFsJyxcXHJcXG4gICAgICAgICAgJ3NldExvZ2dlZEluJyxcXHJcXG4gICAgICAgICAgJ3NldFVzZXJEYXRhJyxcXHJcXG4gICAgICAgICAgJ2xvZ291dCcsXFxyXFxuICAgICAgICAgICdzZXRNYW5hZ2VkTGVhZ3VlJyxcXHJcXG4gICAgICAgICAgJ3NldExlYWd1ZXMnXFxyXFxuICAgICAgICBdKSxcXHJcXG4gICAgICAgIGxvZ291dCgpIHtcXHJcXG4gICAgICAgICAgYXhpb3MuZ2V0KCdsb2dvdXQnKS50aGVuKGRhdGEgPT4ge1xcclxcbiAgICAgICAgICAgIHRoaXMuJHJvdXRlci5wdXNoKFxcXCIvXFxcIik7XFxyXFxuICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSxcXHJcXG4gICAgICBjb21wb25lbnRzOiB7XFxyXFxuICAgICAgICAncmVnaXN0ZXInOiByZWdpc3RlcixcXHJcXG4gICAgICAgICdsb2dpbic6IGxvZ2luLFxcclxcbiAgICAgICAgJ0xlYWd1ZURyb3Bkb3duJzogTGVhZ3VlRHJvcGRvd25cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIDwvc2NyaXB0PlxcclxcbiAgPHN0eWxlPlxcclxcbiAgICAubmF2YmFyLW1lbnUge1xcclxcbiAgICAgIHBhZGRpbmc6IDAgMTAwcHggMCA1MHB4O1xcclxcbiAgICB9XFxyXFxuICAgIC5uYXZiYXIge1xcclxcbiAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbiAgICB9XFxyXFxuICAgIGEge1xcclxcbiAgICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgICBmb250LXNpemU6IDE2cHQ7XFxyXFxuICAgIH1cXHJcXG4gICAgLnJvdXRlci1saW5rLWFjdGl2ZSB7XFxyXFxuICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNmZmZjN2Y7XFxyXFxuICAgIH1cXHJcXG4gIDwvc3R5bGU+XFxyXFxufSlcXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0zNjc5NDBkM1wiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5teWFjY291bnQtY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6ZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOmNvbHVtbjtcXG4gIHdpZHRoOiA0NSU7XFxuICBjb2xvcjogd2hpdGU7XFxuICBtYXJnaW4tdG9wOiAycmVtO1xcbn1cXG4udWwge1xcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcbiAgbWFyZ2luLWJvdHRvbTogMnJlbTtcXG59XFxuLnVsID4gbGkge1xcbiAgZGlzcGxheTogaW5saW5lO1xcbn1cXG5sYWJlbCB7XFxuICBjb2xvcjogd2hpdGU7XFxuICBmb250LXNpemU6IDFyZW07XFxuICBmb250LXdlaWdodDogNjAwO1xcbn1cXG5pbnB1dFt0eXBlPSdyYWRpbyddIHtcXG4gIG1hcmdpbi1sZWZ0OiAycmVtO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiQzovVXNlcnMvc2RvcnJpcy9mYW50YXN5bXgvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50L2NvbXBvbmVudHMvbXlhY2NvdW50LnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBcUJBO0VBQ0EsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsV0FBQTtFQUNBLGFBQUE7RUFDQSxpQkFBQTtDQUNBO0FBQ0E7RUFDQSxzQkFBQTtFQUNBLGNBQUE7RUFDQSw4QkFBQTtFQUNBLG9CQUFBO0NBQ0E7QUFDQTtFQUNBLGdCQUFBO0NBQ0E7QUFDQTtFQUNBLGFBQUE7RUFDQSxnQkFBQTtFQUNBLGlCQUFBO0NBQ0E7QUFDQTtFQUNBLGtCQUFBO0NBQ0FcIixcImZpbGVcIjpcIm15YWNjb3VudC52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXIgbXlhY2NvdW50LWNvbnRhaW5lclxcXCI+XFxyXFxuICAgICAgPHVsIGNsYXNzPVxcXCJ1bFxcXCI+XFxyXFxuICAgICAgICA8bGk+PHJvdXRlci1saW5rIHRvPVxcXCIvbXlhY2NvdW50L2NyZWF0ZWxlYWd1ZVxcXCI+Q3JlYXRlIExlYWd1ZTwvcm91dGVyLWxpbms+PC9saT5cXHJcXG4gICAgICAgIDxsaT48cm91dGVyLWxpbmsgdG89XFxcIi9teWFjY291bnQvam9pbmxlYWd1ZVxcXCI+Sm9pbiBMZWFndWU8L3JvdXRlci1saW5rPjwvbGk+XFxyXFxuICAgICAgICA8bGk+PHJvdXRlci1saW5rIHRvPVxcXCIvbXlhY2NvdW50L2RlbGV0ZWFjY291bnRcXFwiPkRlbGV0ZSBBY2NvdW50PC9yb3V0ZXItbGluaz48L2xpPlxcclxcbiAgICAgICAgPGxpPjxyb3V0ZXItbGluayB0bz1cXFwiL215YWNjb3VudC91cGdyYWRlYWNjb3VudFxcXCI+VXBncmFkZSBBY2NvdW50PC9yb3V0ZXItbGluaz48L2xpPlxcclxcbiAgICAgIDwvdWw+XFxyXFxuICAgICAgPHJvdXRlci12aWV3Pjwvcm91dGVyLXZpZXc+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvdGVtcGxhdGU+XFxyXFxuXFxyXFxuPHNjcmlwdD5cXHJcXG4gIGV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgZGF0YSgpIHtcXHJcXG4gICAgICByZXR1cm4ge1xcclxcblxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbjwvc2NyaXB0PlxcclxcbjxzdHlsZT5cXHJcXG4gIC5teWFjY291bnQtY29udGFpbmVyIHtcXHJcXG4gICAgZGlzcGxheTpmbGV4O1xcclxcbiAgICBmbGV4LWRpcmVjdGlvbjpjb2x1bW47XFxyXFxuICAgIHdpZHRoOiA0NSU7XFxyXFxuICAgIGNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgbWFyZ2luLXRvcDogMnJlbTtcXHJcXG4gIH1cXHJcXG4gIC51bCB7XFxyXFxuICAgIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcXHJcXG4gICAgZGlzcGxheTogZmxleDtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxyXFxuICAgIG1hcmdpbi1ib3R0b206IDJyZW07XFxyXFxuICB9XFxyXFxuICAudWwgPiBsaSB7XFxyXFxuICAgIGRpc3BsYXk6IGlubGluZTtcXHJcXG4gIH1cXHJcXG4gIGxhYmVsIHtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbiAgICBmb250LXNpemU6IDFyZW07XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxuICB9XFxyXFxuICBpbnB1dFt0eXBlPSdyYWRpbyddIHtcXHJcXG4gICAgbWFyZ2luLWxlZnQ6IDJyZW07XFxyXFxuICB9XFxyXFxuPC9zdHlsZT5cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0zZWZkOWYwZVwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9teWFjY291bnQudnVlXG4vLyBtb2R1bGUgaWQgPSAyMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5mbGV4LWNlbnRlciB7XFxyXFxuICBkaXNwbGF5OmZsZXg7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO1xcbn1cXG4ubGl2ZS1oZWFkZXItYm94IHtcXHJcXG4gIG1pbi13aWR0aDogMzYwcHg7XFxufVxcbi5saXZlLWhlYWRlciB7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICBmb250LXNpemU6IDEycHQ7XFxyXFxuICBtYXJnaW4tdG9wOiAzcmVtO1xcclxcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG59XFxuLnRleHQtaGlnaGxpZ2h0IHtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB0O1xcclxcbiAgICBmb250LXdlaWdodDogNzAwO1xcclxcbiAgICBjb2xvcjogI2ZmZmM3ZjtcXG59XFxuLmZsLXJpZ2h0IHtcXHJcXG4gIGZsb2F0OiByaWdodDtcXG59XFxuLm15Um93IHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjpyZ2JhKDI1NSwgMjMzLCAxMjAsIC43KSAhaW1wb3J0YW50O1xcclxcbiAgICBjb2xvcjogI2QyNGEwMDtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDYwMDtcXG59XFxuLnRhYmxlLWxpdmUgdGFibGUgdGQge1xcclxcbiAgICBib3JkZXI6IG5vbmU7XFxufVxcbi50YWJsZS1saXZlIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuOCk7XFxyXFxuICAgIGNvbG9yOiAjN2I3YjdiO1xcclxcbiAgICBib3gtc2hhZG93OiAxcHggMXB4IDEwcHggIzIyMjtcXG59XFxuLnRhYmxlLWxpdmUgdGhlYWQsIHRmb290IHtcXHJcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHJnYmEoMjU1LCAxMDYsIDAsIDEpMCUsIHJnYmEoMTU2LCA1MiwgMCwgMSkxMDAlKTtcXG59XFxuLnRhYmxlLWxpdmUgdGhlYWQgdGgsIHRmb290IHRoIHtcXHJcXG4gICAgY29sb3I6ICNmZmY7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTJwdDtcXG59XFxuLnRhYmxlLWxpdmUgdHI6aG92ZXIge1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjMzLCAxMjAsIC4yKTtcXG59XFxyXFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkM6L1VzZXJzL3Nkb3JyaXMvZmFudGFzeW14L2NsaWVudC9jb21wb25lbnRzL2NsaWVudC9jb21wb25lbnRzL3N0YXR0cmFja2VyLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBK0ZBO0VBQ0EsYUFBQTtFQUNBLHVCQUFBO0NBQ0E7QUFDQTtFQUNBLGlCQUFBO0NBQ0E7QUFDQTtFQUNBLGFBQUE7RUFDQSxnQkFBQTtFQUNBLGlCQUFBO0VBQ0EsaUJBQUE7Q0FDQTtBQUNBO0lBQ0EsZ0JBQUE7SUFDQSxpQkFBQTtJQUNBLGVBQUE7Q0FDQTtBQUNBO0VBQ0EsYUFBQTtDQUNBO0FBQ0E7SUFDQSxvREFBQTtJQUNBLGVBQUE7SUFDQSxpQkFBQTtDQUNBO0FBQ0E7SUFDQSxhQUFBO0NBQ0E7QUFDQTtJQUNBLDBDQUFBO0lBQ0EsZUFBQTtJQUNBLDhCQUFBO0NBQ0E7QUFDQTtJQUNBLDZFQUFBO0NBQ0E7QUFDQTtJQUNBLFlBQUE7SUFDQSxnQkFBQTtDQUNBO0FBQ0E7SUFDQSxvQ0FBQTtDQUNBXCIsXCJmaWxlXCI6XCJzdGF0dHJhY2tlci52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbiAgPGRpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZmxleC1jZW50ZXIgZmwgbGl2ZS1oZWFkZXJcXFwiIHYtaWY9XFxcIiFpc0xvYWRpbmdcXFwiPlxcclxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImxpdmUtaGVhZGVyLWJveFxcXCI+XFxyXFxuICAgICAgICA8ZGl2PlNlc3Npb24gRXZlbnQ6IDxzcGFuIGNsYXNzPVxcXCJ0ZXh0LWhpZ2hsaWdodCBmbC1yaWdodFxcXCI+e3tyYWNlRGF0YS5yYWNlRGF0YS5TfX08L3NwYW4+PC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlNlYXNvbiBFdmVudDo8c3BhbiBjbGFzcz1cXFwidGV4dC1oaWdobGlnaHQgZmwtcmlnaHRcXFwiPiB7e3JhY2VEYXRhLnJhY2VEYXRhLkV9fTwvc3Bhbj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXY+U2Vzc2lvbiBTdGF0dXM6PHNwYW4gY2xhc3M9XFxcInRleHQtaGlnaGxpZ2h0IGZsLXJpZ2h0XFxcIj4ge3tyYWNlRGF0YS5yYWNlRGV0YWlscy5CfX08L3NwYW4+PC9kaXY+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb2x1bW5zIGxlYWRlcmJvYXJkXFxcIj5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb2x1bW4gaXMtaGFsZiBpcy1vZmZzZXQtb25lLXF1YXJ0ZXJcXFwiPlxcclxcbiAgICAgICAgPHRhYmxlIGNsYXNzPVxcXCJ0YWJsZS1saXZlXFxcIiB2LWlmPVxcXCIhaXNMb2FkaW5nXFxcIj5cXHJcXG4gICAgICAgICAgPHRoZWFkPlxcclxcbiAgICAgICAgICAgIDx0cj5cXHJcXG4gICAgICAgICAgICAgIDx0aD5Qb3NpdGlvbjwvdGg+XFxyXFxuICAgICAgICAgICAgICA8dGg+VG90YWwgUG9pbnRzPC90aD5cXHJcXG4gICAgICAgICAgICAgIDx0aD5Vc2VybmFtZTwvdGg+XFxyXFxuICAgICAgICAgICAgICA8dGg+UG9pbnRzIEJhY2s8L3RoPlxcclxcbiAgICAgICAgICAgIDwvdHI+XFxyXFxuICAgICAgICAgIDwvdGhlYWQ+XFxyXFxuICAgICAgICAgIDx0Zm9vdD5cXHJcXG4gICAgICAgICAgICA8dHI+XFxyXFxuICAgICAgICAgICAgICA8dGg+UG9zaXRpb248L3RoPlxcclxcbiAgICAgICAgICAgICAgPHRoPlRvdGFsIFBvaW50czwvdGg+XFxyXFxuICAgICAgICAgICAgICA8dGg+VXNlcm5hbWU8L3RoPlxcclxcbiAgICAgICAgICAgICAgPHRoPlBvaW50cyBCYWNrPC90aD5cXHJcXG4gICAgICAgICAgICA8L3RyPlxcclxcbiAgICAgICAgICA8L3Rmb290PlxcclxcbiAgICAgICAgICA8dGJvZHk+XFxyXFxuICAgICAgICAgICAgPHRyIHYtZm9yPVxcXCIodXNlciwgaW5kZXgpIGluIHN0YW5kaW5nc1xcXCIgdi1iaW5kOmNsYXNzPVxcXCJbIHVzZXIudXNlcm5hbWUgPT0gZ2V0VXNlckRhdGEudXNlcm5hbWUgPyAnbXlSb3cnIDogJyddXFxcIj5cXHJcXG4gICAgICAgICAgICAgIDx0ZD57eyBpbmRleCArIDEgfX0uPC90ZD5cXHJcXG4gICAgICAgICAgICAgIDx0ZD57e3VzZXIudG90YWx9fTwvdGQ+XFxyXFxuICAgICAgICAgICAgICA8dGQ+e3t1c2VyLnVzZXJuYW1lfX08L3RkPlxcclxcbiAgICAgICAgICAgICAgPHRkIGNsYXNzPVxcXCJwb2ludHNiYWNrXFxcIj57eyBwb2ludHNiZWhpbmQodXNlcikgfX08L3RkPlxcclxcbiAgICAgICAgICAgIDwvdHI+XFxyXFxuICAgICAgICAgIDwvdGJvZHk+XFxyXFxuICAgICAgICA8L3RhYmxlPlxcclxcbiAgICAgIDwvZGl2PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gIDwvZGl2PlxcclxcbjwvdGVtcGxhdGU+XFxyXFxuPHNjcmlwdD5cXHJcXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xcclxcbmltcG9ydCB7IG1hcEdldHRlcnMgfSBmcm9tICd2dWV4JztcXHJcXG4gIGV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgZGF0YSgpIHtcXHJcXG4gICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgbGVhZ3VlRGF0YTogW10sXFxyXFxuICAgICAgICByYWNlRGF0YTogW10sXFxyXFxuICAgICAgICBpc0xvYWRpbmc6IHRydWUsXFxyXFxuICAgICAgICB3czogbnVsbFxcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICAuLi5tYXBHZXR0ZXJzKFtcXHJcXG4gICAgICAgICdnZXRVc2VyRGF0YSdcXHJcXG4gICAgICBdKSxcXHJcXG4gICAgICBzdGFuZGluZ3M6IGZ1bmN0aW9uKCkge1xcclxcbiAgICAgICAgcmV0dXJuIHRoaXMubGVhZ3VlRGF0YS5zb3J0KChhLCBiKSA9PiB7XFxyXFxuICAgICAgICAgIHJldHVybiBhLnRvdGFsIC0gYi50b3RhbDtcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBjcmVhdGVkKCkge1xcclxcbiAgICAgIGNvbnNvbGUubG9nKHByb2Nlc3MuZW52Lk5PREVfRU5WKVxcclxcbiAgICAgIHRoaXMud3MgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PSAncHJvZHVjdGlvbidcXHJcXG4gICAgICAgID8gbmV3IFdlYlNvY2tldChcXFwid3NzOi8vZmFudGFzeXN4Lmhlcm9rdWFwcC5jb20vdHJhY2tlclxcXCIpXFxyXFxuICAgICAgICA6IG5ldyBXZWJTb2NrZXQoXFxcIndzczovL2ZhbnRhc3lzeC5oZXJva3VhcHAuY29tL3RyYWNrZXJcXFwiKTtcXHJcXG5cXHJcXG4gICAgICB2YXIgdiA9IHRoaXM7XFxyXFxuICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKGUuZGF0YSk7XFxyXFxuICAgICAgICB2LmlzTG9hZGluZyA9IGZhbHNlO1xcclxcbiAgICAgICAgdi5sZWFndWVEYXRhID0gZGF0YS5MZWFndWVEYXRhO1xcclxcbiAgICAgICAgdi5yYWNlRGF0YSA9IGRhdGEuUmFjZURhdGE7XFxyXFxuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKVxcclxcbiAgICAgIH1cXHJcXG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgY29uc29sZS5sb2coXFxcIkVycm9yXFxcIiwgZSlcXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIG1ldGhvZHM6ICB7XFxyXFxuICAgICAgcG9pbnRzYmVoaW5kOiBmdW5jdGlvbih1c2VyKSB7XFxyXFxuICAgICAgICB2YXIgb2JqSW5kZXggPSB0aGlzLmxlYWd1ZURhdGEuaW5kZXhPZih1c2VyKTtcXHJcXG4gICAgICAgIGlmIChvYmpJbmRleCAhPSAwKSB7XFxyXFxuICAgICAgICAgIHJldHVybiB1c2VyLnRvdGFsIC0gdGhpcy5sZWFndWVEYXRhWzBdLnRvdGFsO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuICctJ1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgYmVmb3JlRGVzdHJveSgpIHtcXHJcXG4gICAgICB0aGlzLndzLmNsb3NlKCk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuLmZsZXgtY2VudGVyIHtcXHJcXG4gIGRpc3BsYXk6ZmxleDtcXHJcXG4gIGp1c3RpZnktY29udGVudDpjZW50ZXI7XFxyXFxufVxcclxcbi5saXZlLWhlYWRlci1ib3gge1xcclxcbiAgbWluLXdpZHRoOiAzNjBweDtcXHJcXG59XFxyXFxuLmxpdmUtaGVhZGVyIHtcXHJcXG4gIGNvbG9yOiB3aGl0ZTtcXHJcXG4gIGZvbnQtc2l6ZTogMTJwdDtcXHJcXG4gIG1hcmdpbi10b3A6IDNyZW07XFxyXFxuICBmb250LXdlaWdodDogNzAwO1xcclxcbn1cXHJcXG4udGV4dC1oaWdobGlnaHQge1xcclxcbiAgICBmb250LXNpemU6IDEycHQ7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxyXFxuICAgIGNvbG9yOiAjZmZmYzdmO1xcclxcbn1cXHJcXG4uZmwtcmlnaHQge1xcclxcbiAgZmxvYXQ6IHJpZ2h0O1xcclxcbn1cXHJcXG4gIC5teVJvdyB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6cmdiYSgyNTUsIDIzMywgMTIwLCAuNykgIWltcG9ydGFudDtcXHJcXG4gICAgY29sb3I6ICNkMjRhMDA7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxuICB9XFxyXFxuICAudGFibGUtbGl2ZSB0YWJsZSB0ZCB7XFxyXFxuICAgIGJvcmRlcjogbm9uZTtcXHJcXG4gIH1cXHJcXG4gIC50YWJsZS1saXZlIHtcXHJcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAuOCk7XFxyXFxuICAgIGNvbG9yOiAjN2I3YjdiO1xcclxcbiAgICBib3gtc2hhZG93OiAxcHggMXB4IDEwcHggIzIyMjtcXHJcXG4gIH1cXHJcXG4gIC50YWJsZS1saXZlIHRoZWFkLCB0Zm9vdCB7XFxyXFxuICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChyZ2JhKDI1NSwgMTA2LCAwLCAxKTAlLCByZ2JhKDE1NiwgNTIsIDAsIDEpMTAwJSk7XFxyXFxuICB9XFxyXFxuICAudGFibGUtbGl2ZSB0aGVhZCB0aCwgdGZvb3QgdGgge1xcclxcbiAgICBjb2xvcjogI2ZmZjtcXHJcXG4gICAgZm9udC1zaXplOiAxMnB0O1xcclxcbiAgfVxcclxcbiAgLnRhYmxlLWxpdmUgdHI6aG92ZXIge1xcclxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjMzLCAxMjAsIC4yKTtcXHJcXG4gIH1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTNmYzM1ODllXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL3N0YXR0cmFja2VyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5oMyB7XFxuICBmb250LXNpemU6IDE2cHQ7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcbmRpdi5kcm9wZG93bi5uYXZiYXItaXRlbTpob3ZlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9zZG9ycmlzL2ZhbnRhc3lteC9jbGllbnQvY29tcG9uZW50cy9jbGllbnQvY29tcG9uZW50cy9uYXZiYXJEcm9wZG93bi52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQTREQTtFQUNBLGdCQUFBO0VBQ0EsYUFBQTtDQUNBO0FBQ0E7RUFDQSxnQkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJuYXZiYXJEcm9wZG93bi52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiZHJvcGRvd25cXFwiIEBjbGljaz1cXFwiaXNBY3RpdmUgPSAhaXNBY3RpdmVcXFwiIHYtYmluZDpjbGFzcz1cXFwieyAnaXMtYWN0aXZlJzogaXNBY3RpdmUgfVxcXCI+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJkcm9wZG93bi10cmlnZ2VyXFxcIj5cXHJcXG4gICAgPGgzIGFyaWEtaGFzcG9wdXA9XFxcInRydWVcXFwiIGFyaWEtY29udHJvbHM9XFxcImRyb3Bkb3duLW1lbnVcXFwiPlxcclxcbiAgICAgIDxzcGFuPkN1cnJlbnRseSBNYW5hZ2luZzoge3sgTWFuYWdlZExlYWd1ZS5uYW1lIH19PC9zcGFuPlxcclxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uIGlzLXNtYWxsXFxcIj5cXHJcXG4gICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1hbmdsZS1kb3duXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9pPlxcclxcbiAgICAgIDwvc3Bhbj5cXHJcXG4gICAgPC9oMz5cXHJcXG4gIDwvZGl2PlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiZHJvcGRvd24tbWVudVxcXCIgaWQ9XFxcImRyb3Bkb3duLW1lbnVcXFwiIHJvbGU9XFxcIm1lbnVcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJkcm9wZG93bi1jb250ZW50XFxcIiB2LWZvcj1cXFwibGVhZ3VlIGluIExlYWd1ZUxpc3RcXFwiPlxcclxcbiAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJkcm9wZG93bi1pdGVtXFxcIiBAY2xpY2s9XFxcImNoYW5nZUxlYWd1ZShsZWFndWUpXFxcIj5cXHJcXG4gICAgICAgIHt7bGVhZ3VlLm5hbWV9fVxcclxcbiAgICAgIDwvYT5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcXHJcXG5pbXBvcnQgeyBtYXBNdXRhdGlvbnMsIG1hcEdldHRlcnMgfSBmcm9tICd2dWV4JztcXHJcXG5leHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIGRhdGEoKSB7XFxyXFxuICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgIGlzQWN0aXZlOiBmYWxzZSxcXHJcXG4gICAgICAgIE1hbmFnZWRMZWFndWU6ICcnLFxcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgY29tcHV0ZWQ6IHtcXHJcXG4gICAgICBMZWFndWVMaXN0KCkge1xcclxcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsTGVhZ3Vlcy5maWx0ZXIoaXRlbSA9PiB7XFxyXFxuICAgICAgICAgIHJldHVybiBpdGVtLmxlYWd1ZWlkICE9IHRoaXMuTWFuYWdlZExlYWd1ZS5sZWFndWVpZDtcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgICAgfVxcclxcbiAgICB9LFxcclxcbiAgICBjcmVhdGVkKCkge1xcclxcbiAgICAgIHRoaXMuTWFuYWdlZExlYWd1ZSA9IHRoaXMuY3VycmVudExlYWd1ZTtcXHJcXG4gICAgfSxcXHJcXG4gICAgcHJvcHM6IHtcXHJcXG4gICAgICBjdXJyZW50TGVhZ3VlOiB7XFxyXFxuICAgICAgICB0eXBlOiBPYmplY3QsXFxyXFxuICAgICAgICByZXF1aXJlZDogdHJ1ZVxcclxcbiAgICAgIH0sXFxyXFxuICAgICAgYWxsTGVhZ3Vlczoge1xcclxcbiAgICAgICAgdHlwZTogQXJyYXksXFxyXFxuICAgICAgICByZXF1aXJlZDogdHJ1ZVxcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgbWV0aG9kczoge1xcclxcbiAgICAgIC4uLm1hcE11dGF0aW9ucyhbXFxyXFxuICAgICAgICAnc2V0TWFuYWdlZExlYWd1ZSdcXHJcXG4gICAgICBdKSxcXHJcXG4gICAgICBjaGFuZ2VMZWFndWUobGVhZ3VlKSB7XFxyXFxuICAgICAgICB0aGlzLnNldE1hbmFnZWRMZWFndWUobGVhZ3VlKVxcclxcbiAgICAgICAgdGhpcy5NYW5hZ2VkTGVhZ3VlID0gbGVhZ3VlO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbn1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuICBoMyB7XFxyXFxuICAgIGZvbnQtc2l6ZTogMTZwdDtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbiAgfVxcclxcbiAgZGl2LmRyb3Bkb3duLm5hdmJhci1pdGVtOmhvdmVyIHtcXHJcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgfVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNGQ4OGZkODRcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyRHJvcGRvd24udnVlXG4vLyBtb2R1bGUgaWQgPSAyMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJcIixcImZpbGVcIjpcImluZGV4LnZ1ZVwiLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNmRlNWFiMzRcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vaW5kZXgudnVlXG4vLyBtb2R1bGUgaWQgPSAyMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbmJvZHkge1xcclxcbiAgZm9udC1mYW1pbHk6IFxcXCJPcGVuIFNhbnMgQ29uZGVuc2VkXFxcIjtcXHJcXG4gIGhlaWdodDogMTAwJTtcXHJcXG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xcclxcbiAgYmFja2dyb3VuZDpcXHJcXG4gICAgbGluZWFyLWdyYWRpZW50KHRvIGJvdHRvbSByaWdodCwgcmdiYSgyNTEsIDEwOSwgOCwgLjgpMCUsIHJnYmEoMjA0LCA2NiwgMCwgMSkxMDAlKSxcXHJcXG4gICAgdXJsKCdodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8zNzUyNy9zcG9ydHMtZ2FtZXMtZnVuLWhvbGlkYXktMzc1MjcuanBlZz93PTEyNjAmaD03NTAmYXV0bz1jb21wcmVzcyZjcz10aW55c3JnYicpO1xcclxcbiAgYmFja2dyb3VuZC1zaXplOiBjb3ZlcjtcXHJcXG4gIGJhY2tncm91bmQtcG9zaXRpb246Y2VudGVyO1xcclxcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcXG59XFxuLmxlYWRlcmJvYXJkLXRhYmxlIC50aXRsZSA+IHRoIHtcXHJcXG4gIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjZjVmNWEyO1xcclxcbiAgZm9udC1zaXplOiAxNnB0O1xcclxcbiAgcGFkZGluZzogLjVyZW07XFxufVxcbi5sZWFkZXJib2FyZC10YWJsZSB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIC44KTtcXHJcXG4gIGNvbG9yOiAjN2I3YjdiO1xcclxcbiAgYm94LXNoYWRvdzogMXB4IDFweCAxMHB4ICMyMjI7XFxufVxcbi5sZWFkZXJib2FyZC10YWJsZSB0aGVhZCB0aCwgdGZvb3QgdGgge1xcclxcbiAgY29sb3I6ICNmZmY7XFxyXFxuICBmb250LXNpemU6IDEycHQ7XFxufVxcbi5sZWFkZXJib2FyZC10YWJsZSB0aGVhZCwgdGZvb3Qge1xcclxcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHJnYmEoMjU1LCAxMDYsIDAsIDEpMCUsIHJnYmEoMTU2LCA1MiwgMCwgMSkxMDAlKTtcXG59XFxuLmxlYWRlcmJvYXJkLXRhYmxlIHRkIHtcXHJcXG4gIGJvcmRlcjogbm9uZTtcXG59XFxuLmxlYWRlcmJvYXJkLXRhYmxlIHRyOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyMzMsIDEyMCwgLjIpO1xcbn1cXG4ucG9pbnRzYmFjayB7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxyXFxuICAgIGNvbG9yOiAjZmYzODYwO1xcbn1cXG4ubGVhZGVyYm9hcmQge1xcclxcbiAgICBtYXJnaW4tdG9wOiA1MHB4O1xcbn1cXG50YWJsZSB0ZCwgdGgge1xcclxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXIgIWltcG9ydGFudDtcXG59XFxuLmxlYWRlcmJvYXJkLW1haW4ge1xcclxcbiAgICBtYXJnaW4tdG9wOiAyNXB4O1xcbn1cXG4uTWUge1xcclxcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjMzLCAxMjAsIC43KTtcXHJcXG4gICAgY29sb3I6ICNkMjRhMDA7XFxyXFxuICAgIGZvbnQtd2VpZ2h0OiA2MDA7XFxufVxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9zZG9ycmlzL2ZhbnRhc3lteC9jbGllbnQvY29tcG9uZW50cy9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXNHQTtFQUNBLG1DQUFBO0VBQ0EsYUFBQTtFQUNBLGtCQUFBO0VBQ0E7OzZIQUVBO0VBQ0EsdUJBQUE7RUFDQSwyQkFBQTtFQUNBLDZCQUFBO0NBQ0E7QUFDQTtFQUNBLGlDQUFBO0VBQ0EsZ0JBQUE7RUFDQSxlQUFBO0NBQ0E7QUFDQTtFQUNBLDBDQUFBO0VBQ0EsZUFBQTtFQUNBLDhCQUFBO0NBQ0E7QUFDQTtFQUNBLFlBQUE7RUFDQSxnQkFBQTtDQUNBO0FBQ0E7RUFDQSw2RUFBQTtDQUNBO0FBQ0E7RUFDQSxhQUFBO0NBQ0E7QUFDQTtFQUNBLDBDQUFBO0NBQ0E7QUFDQTtJQUNBLG9CQUFBO0lBQ0EsZUFBQTtDQUNBO0FBQ0E7SUFDQSxpQkFBQTtDQUNBO0FBQ0E7SUFDQSw4QkFBQTtDQUNBO0FBQ0E7SUFDQSxpQkFBQTtDQUNBO0FBQ0E7SUFDQSwwQ0FBQTtJQUNBLGVBQUE7SUFDQSxpQkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJsZWFkZXJib2FyZC52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbiAgPGRpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sdW1ucyBsZWFkZXJib2FyZFxcXCI+XFxyXFxuICAgICAgPGRpdiBjbGFzcz1cXFwiY29sdW1uIGlzLWhhbGYgaXMtb2Zmc2V0LW9uZS1xdWFydGVyXFxcIj5cXHJcXG4gICAgICAgIDx0YWJsZSBjbGFzcz1cXFwibGVhZGVyYm9hcmQtdGFibGVcXFwiIHYtaWY9XFxcImRvbmVMb2FkaW5nXFxcIj5cXHJcXG4gICAgICAgICAgPHRoZWFkPlxcclxcbiAgICAgICAgICAgIDx0ciBjbGFzcz1cXFwidGl0bGVcXFwiPlxcclxcbiAgICAgICAgICAgICAgPHRoIGNvbHNwYW49XFxcIjRcXFwiPjIwMTggRmFudGFzeSBTWDogTWFpbiBMZWFndWUgU3RhbmRpbmdzPC90aD5cXHJcXG4gICAgICAgICAgICA8L3RyPlxcclxcbiAgICAgICAgICAgIDx0cj5cXHJcXG4gICAgICAgICAgICAgIDx0aD5Qb3NpdGlvbjwvdGg+XFxyXFxuICAgICAgICAgICAgICA8dGg+VG90YWwgUG9pbnRzPC90aD5cXHJcXG4gICAgICAgICAgICAgIDx0aD5Vc2VybmFtZTwvdGg+XFxyXFxuICAgICAgICAgICAgICA8dGg+UG9pbnRzIEJhY2s8L3RoPlxcclxcbiAgICAgICAgICAgIDwvdHI+XFxyXFxuICAgICAgICAgIDwvdGhlYWQ+XFxyXFxuICAgICAgICAgIDx0Zm9vdD5cXHJcXG4gICAgICAgICAgICA8dHI+XFxyXFxuICAgICAgICAgICAgICA8dGg+UG9zaXRpb248L3RoPlxcclxcbiAgICAgICAgICAgICAgPHRoPlRvdGFsIFBvaW50czwvdGg+XFxyXFxuICAgICAgICAgICAgICA8dGg+VXNlcm5hbWU8L3RoPlxcclxcbiAgICAgICAgICAgICAgPHRoPlBvaW50cyBCYWNrPC90aD5cXHJcXG4gICAgICAgICAgICA8L3RyPlxcclxcbiAgICAgICAgICA8L3Rmb290PlxcclxcbiAgICAgICAgICA8dGJvZHk+XFxyXFxuICAgICAgICAgICAgPHRyIHYtZm9yPVxcXCIodXNlciwgaW5kZXgpIGluIHN0YW5kaW5nc1xcXCIgdi1iaW5kOmNsYXNzPVxcXCJ7ICdNZSc6IElzTWUodXNlcikgfVxcXCI+XFxyXFxuICAgICAgICAgICAgICA8dGQ+e3sgaW5kZXggKyAxIH19LjwvdGQ+XFxyXFxuICAgICAgICAgICAgICA8dGQ+e3t1c2VyLnRvdGFscG9pbnRzfX08L3RkPlxcclxcbiAgICAgICAgICAgICAgPHRkPnt7dXNlci53ZWVrbHl0ZWFtc1swXS51c2VybmFtZX19PC90ZD5cXHJcXG4gICAgICAgICAgICAgIDx0ZCB2LWJpbmQ6Y2xhc3M9XFxcInsgJ3BvaW50c2JhY2snOiBpbmRleCA+IDAgfVxcXCI+e3sgcG9pbnRzYmVoaW5kKHVzZXIpIH19PC90ZD5cXHJcXG4gICAgICAgICAgICA8L3RyPlxcclxcbiAgICAgICAgICA8L3Rib2R5PlxcclxcbiAgICAgICAgPC90YWJsZT5cXHJcXG4gICAgICAgIDxkaXYgdi1pZj1cXFwiIWRvbmVMb2FkaW5nXFxcIj5cXHJcXG4gICAgICAgICAgPHA+XFxcIlRoaXMgZGF0YSBkb2Vzbid0IGZldGNoIGl0c2VsZi4uIExvYWRpbmcgUmFjZSBUcmFja2VyLlxcXCI8L3A+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG48c2NyaXB0PlxcclxcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XFxyXFxuaW1wb3J0IHsgbWFwR2V0dGVycyB9IGZyb20gJ3Z1ZXgnO1xcclxcbiAgZXhwb3J0IGRlZmF1bHQge1xcclxcbiAgICBkYXRhKCkge1xcclxcbiAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICBkb25lTG9hZGluZzogZmFsc2UsXFxyXFxuICAgICAgICByZXN1bHRzOiBbXSxcXHJcXG4gICAgICAgIG1haW5MZWFndWVVc2VyczogW10sXFxyXFxuICAgICAgICB3ZWVrbHl0ZWFtczogW11cXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIGNvbXB1dGVkOiB7XFxyXFxuICAgICAgc3RhbmRpbmdzOiBmdW5jdGlvbigpIHtcXHJcXG4gICAgICAgIHJldHVybiB0aGlzLm1haW5MZWFndWVVc2Vycy5zb3J0KChhLCBiKSA9PiB7XFxyXFxuICAgICAgICAgIHZhciBhUG9pbnRzID0gMDtcXHJcXG4gICAgICAgICAgdmFyIGJQb2ludHMgPSAwO1xcclxcbiAgICAgICAgICBhLndlZWtseXRlYW1zLmZvckVhY2godGVhbSA9PiB7IGFQb2ludHMgKz0gdGVhbS5wbGFjZSB9KVxcclxcbiAgICAgICAgICBiLndlZWtseXRlYW1zLmZvckVhY2godGVhbSA9PiB7IGJQb2ludHMgKz0gdGVhbS5wbGFjZSB9KVxcclxcbiAgICAgICAgICByZXR1cm4gYVBvaW50cyAtIGJQb2ludHM7XFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgIH0sXFxyXFxuICAgICAgbmV3c3RhbmRpbmdzOiBmdW5jdGlvbigpIHtcXHJcXG5cXHJcXG4gICAgICB9LFxcclxcbiAgICAgIC4uLm1hcEdldHRlcnMoW1xcclxcbiAgICAgICAgJ2dldFVzZXJEYXRhJ1xcclxcbiAgICAgIF0pXFxyXFxuICAgIH0sXFxyXFxuICAgIGNyZWF0ZWQoKSB7XFxyXFxuICAgICAgY29uc29sZS5sb2coXFxcImVudmlyb25tZW50XFxcIiwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYpXFxyXFxuICAgICAgYXhpb3MuZ2V0KCcvTWFpbkxlYWd1ZVN0YW5kaW5ncycpXFxyXFxuICAgICAgLnRoZW4oZGF0YSA9PiB7XFxyXFxuICAgICAgICB0aGlzLm1haW5MZWFndWVVc2VycyA9IGRhdGEuZGF0YTtcXHJcXG4gICAgICAgIHRoaXMubWFpbkxlYWd1ZVVzZXJzLmZvckVhY2goKHVzZXIpID0+IHtcXHJcXG4gICAgICAgICAgdXNlci50b3RhbHBvaW50cyA9IDBcXHJcXG4gICAgICAgICAgdXNlci53ZWVrbHl0ZWFtcy5mb3JFYWNoKHd0ID0+IHsgdXNlci50b3RhbHBvaW50cyArPSB3dC5wbGFjZSB9KVxcclxcbiAgICAgICAgICB1c2VyLndlZWtseXRlYW1zLnNvcnQoKGEsIGIpID0+IHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XFxyXFxuICAgICAgICAgIH0pXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgdGhpcy5kb25lTG9hZGluZyA9IHRydWU7XFxyXFxuICAgICAgfSlcXHJcXG4gICAgfSxcXHJcXG4gICAgbWV0aG9kczoge1xcclxcbiAgICAgIHBvaW50c2JlaGluZDogZnVuY3Rpb24odXNlcikge1xcclxcbiAgICAgICAgdmFyIG9iakluZGV4ID0gdGhpcy5zdGFuZGluZ3MuaW5kZXhPZih1c2VyKTtcXHJcXG4gICAgICAgIGlmIChvYmpJbmRleCAhPSAwKSB7XFxyXFxuICAgICAgICAgIHJldHVybiB1c2VyLnRvdGFscG9pbnRzIC0gdGhpcy5zdGFuZGluZ3NbMF0udG90YWxwb2ludHM7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gJy0nXFxyXFxuICAgICAgfSxcXHJcXG4gICAgICBJc01lOiBmdW5jdGlvbiAodXNlcikge1xcclxcbiAgICAgICAgaWYgKHVzZXIud2Vla2x5dGVhbXNbMF0udXNlcm5hbWUgPT0gdGhpcy5nZXRVc2VyRGF0YS51c2VybmFtZSkge1xcclxcbiAgICAgICAgICBjb25zb2xlLmxvZyhcXFwidXNlcm5hbWVcXFwiLCB0aGlzLmdldFVzZXJEYXRhLnVzZXJuYW1lKVxcclxcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuYm9keSB7XFxyXFxuICBmb250LWZhbWlseTogXFxcIk9wZW4gU2FucyBDb25kZW5zZWRcXFwiO1xcclxcbiAgaGVpZ2h0OiAxMDAlO1xcclxcbiAgbWluLWhlaWdodDogMTAwdmg7XFxyXFxuICBiYWNrZ3JvdW5kOlxcclxcbiAgICBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tIHJpZ2h0LCByZ2JhKDI1MSwgMTA5LCA4LCAuOCkwJSwgcmdiYSgyMDQsIDY2LCAwLCAxKTEwMCUpLFxcclxcbiAgICB1cmwoJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzM3NTI3L3Nwb3J0cy1nYW1lcy1mdW4taG9saWRheS0zNzUyNy5qcGVnP3c9MTI2MCZoPTc1MCZhdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJyk7XFxyXFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvdmVyO1xcclxcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjpjZW50ZXI7XFxyXFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcclxcbn1cXHJcXG4ubGVhZGVyYm9hcmQtdGFibGUgLnRpdGxlID4gdGgge1xcclxcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNmNWY1YTI7XFxyXFxuICBmb250LXNpemU6IDE2cHQ7XFxyXFxuICBwYWRkaW5nOiAuNXJlbTtcXHJcXG59XFxyXFxuLmxlYWRlcmJvYXJkLXRhYmxlIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgLjgpO1xcclxcbiAgY29sb3I6ICM3YjdiN2I7XFxyXFxuICBib3gtc2hhZG93OiAxcHggMXB4IDEwcHggIzIyMjtcXHJcXG59XFxyXFxuLmxlYWRlcmJvYXJkLXRhYmxlIHRoZWFkIHRoLCB0Zm9vdCB0aCB7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIGZvbnQtc2l6ZTogMTJwdDtcXHJcXG59XFxyXFxuLmxlYWRlcmJvYXJkLXRhYmxlIHRoZWFkLCB0Zm9vdCB7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQocmdiYSgyNTUsIDEwNiwgMCwgMSkwJSwgcmdiYSgxNTYsIDUyLCAwLCAxKTEwMCUpO1xcclxcbn1cXHJcXG4ubGVhZGVyYm9hcmQtdGFibGUgdGQge1xcclxcbiAgYm9yZGVyOiBub25lO1xcclxcbn1cXHJcXG4ubGVhZGVyYm9hcmQtdGFibGUgdHI6aG92ZXIge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDIzMywgMTIwLCAuMik7XFxyXFxufVxcclxcbiAgLnBvaW50c2JhY2sge1xcclxcbiAgICBmb250LXdlaWdodDogYm9sZGVyO1xcclxcbiAgICBjb2xvcjogI2ZmMzg2MDtcXHJcXG4gIH1cXHJcXG4gIC5sZWFkZXJib2FyZCB7XFxyXFxuICAgIG1hcmdpbi10b3A6IDUwcHg7XFxyXFxuICB9XFxyXFxuICB0YWJsZSB0ZCwgdGgge1xcclxcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXIgIWltcG9ydGFudDtcXHJcXG4gIH1cXHJcXG4gIC5sZWFkZXJib2FyZC1tYWluIHtcXHJcXG4gICAgbWFyZ2luLXRvcDogMjVweDtcXHJcXG4gIH1cXHJcXG4gIC5NZSB7XFxyXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyMzMsIDEyMCwgLjcpO1xcclxcbiAgICBjb2xvcjogI2QyNGEwMDtcXHJcXG4gICAgZm9udC13ZWlnaHQ6IDYwMDtcXHJcXG4gIH1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTcxZGNiYzRhXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL2xlYWRlcmJvYXJkLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG5oMSB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxufVxcclxcbi8qIEFjb3JkZW9uIHN0eWxlcyAqL1xcbi50YWIge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgbWFyZ2luLWJvdHRvbTogMXB4O1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBjb2xvcjogI2ZmZjtcXHJcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcbmlucHV0IHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIG9wYWNpdHk6IDA7XFxyXFxuICB6LWluZGV4OiAtMTtcXG59XFxubGFiZWwge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICBwYWRkaW5nOiAwIDAgMCAxZW07XFxyXFxuICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMyk7XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAzO1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgY29sb3I6ICNmZmZjN2Y7XFxufVxcbi50YWItY29udGVudCB7XFxyXFxuICBtYXgtaGVpZ2h0OiAwO1xcclxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcclxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBtYXgtaGVpZ2h0IC4zNXM7XFxyXFxuICAtby10cmFuc2l0aW9uOiBtYXgtaGVpZ2h0IC4zNXM7XFxyXFxuICB0cmFuc2l0aW9uOiBtYXgtaGVpZ2h0IC4zNXM7XFxyXFxuICBjb2xvcjogI2ZmZjtcXG59XFxuLnRhYi1jb250ZW50IHAge1xcclxcbiAgbWFyZ2luOiAxZW07XFxufVxcclxcbi8qIDpjaGVja2VkICovXFxuaW5wdXQ6Y2hlY2tlZCB+IC50YWItY29udGVudCB7XFxyXFxuICBtYXgtaGVpZ2h0OiAxMGVtO1xcbn1cXHJcXG4vKiBJY29uICovXFxubGFiZWw6OmFmdGVyIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHJpZ2h0OiAwO1xcclxcbiAgdG9wOiAwO1xcclxcbiAgZGlzcGxheTogYmxvY2s7XFxyXFxuICB3aWR0aDogM2VtO1xcclxcbiAgaGVpZ2h0OiAzZW07XFxyXFxuICBsaW5lLWhlaWdodDogMztcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIC4zNXM7XFxyXFxuICAtby10cmFuc2l0aW9uOiBhbGwgLjM1cztcXHJcXG4gIHRyYW5zaXRpb246IGFsbCAuMzVzO1xcbn1cXG5pbnB1dFt0eXBlPWNoZWNrYm94XSArIGxhYmVsOjphZnRlciB7XFxyXFxuICBjb250ZW50OiBcXFwiK1xcXCI7XFxufVxcbmlucHV0W3R5cGU9cmFkaW9dICsgbGFiZWw6OmFmdGVyIHtcXHJcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcMjVCQ1xcXCI7XFxufVxcbmlucHV0W3R5cGU9Y2hlY2tib3hdOmNoZWNrZWQgKyBsYWJlbDo6YWZ0ZXIge1xcclxcbiAgdHJhbnNmb3JtOiByb3RhdGUoMzE1ZGVnKTtcXG59XFxuaW5wdXRbdHlwZT1yYWRpb106Y2hlY2tlZCArIGxhYmVsOjphZnRlciB7XFxyXFxuICB0cmFuc2Zvcm06IHJvdGF0ZVgoMTgwZGVnKTtcXG59XFxyXFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIkM6L1VzZXJzL3Nkb3JyaXMvZmFudGFzeW14L2NsaWVudC9jb21wb25lbnRzL2NsaWVudC9jb21wb25lbnRzL3J1bGVzLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBaUNBO0VBQ0EsbUJBQUE7Q0FDQTtBQUNBLHFCQUFBO0FBQ0E7RUFDQSxtQkFBQTtFQUNBLG1CQUFBO0VBQ0EsWUFBQTtFQUNBLFlBQUE7RUFDQSxpQkFBQTtDQUNBO0FBQ0E7RUFDQSxtQkFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0NBQ0E7QUFDQTtFQUNBLG1CQUFBO0VBQ0EsZUFBQTtFQUNBLG1CQUFBO0VBQ0EscUNBQUE7RUFDQSxrQkFBQTtFQUNBLGVBQUE7RUFDQSxnQkFBQTtFQUNBLGVBQUE7Q0FDQTtBQUNBO0VBQ0EsY0FBQTtFQUNBLGlCQUFBO0VBQ0Esd0JBQUE7RUFDQSxvQ0FBQTtFQUNBLCtCQUFBO0VBQ0EsNEJBQUE7RUFDQSxZQUFBO0NBQ0E7QUFDQTtFQUNBLFlBQUE7Q0FDQTtBQUNBLGNBQUE7QUFDQTtFQUNBLGlCQUFBO0NBQ0E7QUFDQSxVQUFBO0FBQ0E7RUFDQSxtQkFBQTtFQUNBLFNBQUE7RUFDQSxPQUFBO0VBQ0EsZUFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0VBQ0EsZUFBQTtFQUNBLG1CQUFBO0VBQ0EsNkJBQUE7RUFDQSx3QkFBQTtFQUNBLHFCQUFBO0NBQ0E7QUFDQTtFQUNBLGFBQUE7Q0FDQTtBQUNBO0VBQ0EsaUJBQUE7Q0FDQTtBQUNBO0VBQ0EsMEJBQUE7Q0FDQTtBQUNBO0VBQ0EsMkJBQUE7Q0FDQVwiLFwiZmlsZVwiOlwicnVsZXMudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIjx0ZW1wbGF0ZT5cXHJcXG4gIDxkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcIlxcXCI+XFxyXFxuICAgICAgPHA+UnVsZXM8L3A+XFxyXFxuICAgICAgPGRpdiBjbGFzcz1cXFwidGFiXFxcIj5cXHJcXG4gICAgICAgIDxpbnB1dCBpZD1cXFwidGFiLW9uZVxcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5hbWU9XFxcInRhYnNcXFwiPlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidGFiLW9uZVxcXCI+SG93IGRvZXMgc2NvcmluZyB3b3JrPzwvbGFiZWw+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudFxcXCI+XFxyXFxuICAgICAgICAgIDxwPlJpZ2h0IG5vdywgc2NvcmluZyBpcyBzZXQgYnkgcmFjZXIgZmluaXNoLiBJZiBhIHNlbGVjdGVkIHJhY2VyIGZvciB0aGF0IHdlZWsgZmluaXNoZXMgaW4gZmlyc3QsIHRoYXQgcmFjZXIgaXMgYXdhcmRlZCAxIHBvaW50LiBJZiBhIHJhY2VyIGZpbmlzaGVzIGluIGZvdXJ0aCwgdGhhdCByYWNlciBpcyBhd2FyZGVkIDQgcG9pbnRzLiBUaGUgbG93ZXIgdGhlIHBvaW50IHRvdGFsIHRoZSBiZXR0ZXIgc2NvcmUuPC9wPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgICAgPGRpdiBjbGFzcz1cXFwidGFiXFxcIj5cXHJcXG4gICAgICAgIDxpbnB1dCBpZD1cXFwidGFiLXR3b1xcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5hbWU9XFxcInRhYnNcXFwiPlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidGFiLXR3b1xcXCI+SG93IGRvZXMgdGVhbSBzZWxlY3Rpb24gd29yaz88L2xhYmVsPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidGFiLWNvbnRlbnRcXFwiPlxcclxcbiAgICAgICAgICA8cD5BcyBvZiBub3csIGVhY2ggdXNlciBpcyBSRVFVSVJFRCB0byBzZWxlY3QgNCByYWNlcnMgZm9yIGVhY2ggd2Vlay4gVGhlIGRlYWRsaW5lIGZvciBtYWtpbmcgcmFjZXIgc2VsZWN0aW9uIGlzIDNhbSBNb3VudGFpbiBUaW1lIG9uIHRoZSBkYXkgb2YgdGhlIHNjaGVkdWxlZCByYWNlLiBBZnRlciB0aGF0IHRpbWVcXHJcXG4gICAgICAgICAgICB1c2VycyB3aWxsIG5vIGxvbmdlciBiZSBhYmxlIHRvIHNlbGVjdCByYWNlcnMgZm9yIHRoYXQgd2VlaydzIHJhY2U7IHRoZSB0ZWFtIHNlbGVjdGlvbiBmb3IgdGhlIG5leHQgd2VlayB3aWxsIGJlIGF2YWlsYWJsZSBmb3Igc2VsZWN0aW9uPC9wPlxcclxcbiAgICAgICAgICA8cD5Vc2VycyBtYXkgb25seSBTQVZFIGEgcm9zdGVyIGlmIEFMTCA0IHJvc3RlciBzbG90cyBoYXZlIGEgcmFjZXIgY2hvc2VuLiBUaGUgU0FWRSBidXR0b24gaXMgZGlzYWJsZWQgaWYgYW4gT1BFTiBTTE9UIHN0aWxsIGV4aXN0cyBmb3IgYSB3ZWVrbHkgbGluZXVwLjwvcD5cXHJcXG4gICAgICAgICAgPHA+RWFjaCB1c2VyIGJlZ2lucyBlYWNoIHdlZWsgd2l0aCAkMTAsMDAwIHNhbGFyeSBjYXAgdG8gc3BlbmQgb24gZmlsbGluZyBvdXQgdGhlaXIgd2Vla2x5IGxpbmV1cCwgYW5kIHRoYXQgY2FwIHJvb20gaXMgdXNlZCB0byBzZWxlY3QgcmFjZXJzIGZvciB0aGVpciB3ZWVrJ3MgbGluZXVwIGZyb20gdGhlIGF2YWlsYWJsZSByYWNlcnMgcG9vbC5cXHJcXG4gICAgICAgICAgICBUaGUgc2VsZWN0ZWQgcmFjZXIncyBjb3N0LCBvbmNlIHNlbGVjdGVkLCB3aWxsIGJlIGRlZHVjdGVkIGZyb20gdGhlIGN1cnJlbnQgd2VlaydzIGF2YWlsYWJsZSBzYWxhcnkgY2FwLiBZb3UgYXJlIE5PVCBSRVFVSVJFRCB0byB1dGlsaXplIHlvdXIgZW50aXJlIGNhcCBzcGFjZSBlYWNoIHdlZWsuPC9wPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgICAgPGRpdiBjbGFzcz1cXFwidGFiXFxcIj5cXHJcXG4gICAgICAgIDxpbnB1dCBpZD1cXFwidGFiLXRocmVlXFxcIiB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmFtZT1cXFwidGFic1xcXCI+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0YWItdGhyZWVcXFwiPkN1c3RvbSBMZWFndWVzPC9sYWJlbD5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRhYi1jb250ZW50XFxcIj5cXHJcXG4gICAgICAgICAgPHA+Q3VycmVudGx5LCB0aGUgYXBwbGljYXRpb24gZG9lcyBub3Qgc3VwcG9ydCBjdXN0b20gLyBwcml2YXRlIGxlYWd1ZXM7IFdlIGFyZSBsb29raW5nIGludG8gaG93IGJlc3QgdG8gaW5jb3Jwb3JhdGUgdGhpcyBmZWF0dXJlIHdpdGggdGhlIFVJLiBJZiB5b3UgaGF2ZSBzdWdnZXN0aW9ucyBwbGVhc2UgbGV0IHVzIGtub3dcXHJcXG4gICAgICAgICAgYnkgZHJvcHBpbmcgYSBzdWdnZXN0aW9uLjwvcD5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgIDwvZGl2PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gIDwvZGl2PlxcclxcbjwvdGVtcGxhdGU+XFxyXFxuPHN0eWxlPlxcclxcbmgxIHtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG59XFxyXFxuLyogQWNvcmRlb24gc3R5bGVzICovXFxyXFxuLnRhYiB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICBtYXJnaW4tYm90dG9tOiAxcHg7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGNvbG9yOiAjZmZmO1xcclxcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXHJcXG59XFxyXFxuaW5wdXQge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgb3BhY2l0eTogMDtcXHJcXG4gIHotaW5kZXg6IC0xO1xcclxcbn1cXHJcXG5sYWJlbCB7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIHBhZGRpbmc6IDAgMCAwIDFlbTtcXHJcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zKTtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbiAgbGluZS1oZWlnaHQ6IDM7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICBjb2xvcjogI2ZmZmM3ZjtcXHJcXG59XFxyXFxuLnRhYi1jb250ZW50IHtcXHJcXG4gIG1heC1oZWlnaHQ6IDA7XFxyXFxuICBvdmVyZmxvdzogaGlkZGVuO1xcclxcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxyXFxuICAtd2Via2l0LXRyYW5zaXRpb246IG1heC1oZWlnaHQgLjM1cztcXHJcXG4gIC1vLXRyYW5zaXRpb246IG1heC1oZWlnaHQgLjM1cztcXHJcXG4gIHRyYW5zaXRpb246IG1heC1oZWlnaHQgLjM1cztcXHJcXG4gIGNvbG9yOiAjZmZmO1xcclxcbn1cXHJcXG4udGFiLWNvbnRlbnQgcCB7XFxyXFxuICBtYXJnaW46IDFlbTtcXHJcXG59XFxyXFxuLyogOmNoZWNrZWQgKi9cXHJcXG5pbnB1dDpjaGVja2VkIH4gLnRhYi1jb250ZW50IHtcXHJcXG4gIG1heC1oZWlnaHQ6IDEwZW07XFxyXFxufVxcclxcbi8qIEljb24gKi9cXHJcXG5sYWJlbDo6YWZ0ZXIge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgcmlnaHQ6IDA7XFxyXFxuICB0b3A6IDA7XFxyXFxuICBkaXNwbGF5OiBibG9jaztcXHJcXG4gIHdpZHRoOiAzZW07XFxyXFxuICBoZWlnaHQ6IDNlbTtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAzO1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgLjM1cztcXHJcXG4gIC1vLXRyYW5zaXRpb246IGFsbCAuMzVzO1xcclxcbiAgdHJhbnNpdGlvbjogYWxsIC4zNXM7XFxyXFxufVxcclxcbmlucHV0W3R5cGU9Y2hlY2tib3hdICsgbGFiZWw6OmFmdGVyIHtcXHJcXG4gIGNvbnRlbnQ6IFxcXCIrXFxcIjtcXHJcXG59XFxyXFxuaW5wdXRbdHlwZT1yYWRpb10gKyBsYWJlbDo6YWZ0ZXIge1xcclxcbiAgY29udGVudDogXFxcIlxcXFwyNUJDXFxcIjtcXHJcXG59XFxyXFxuaW5wdXRbdHlwZT1jaGVja2JveF06Y2hlY2tlZCArIGxhYmVsOjphZnRlciB7XFxyXFxuICB0cmFuc2Zvcm06IHJvdGF0ZSgzMTVkZWcpO1xcclxcbn1cXHJcXG5pbnB1dFt0eXBlPXJhZGlvXTpjaGVja2VkICsgbGFiZWw6OmFmdGVyIHtcXHJcXG4gIHRyYW5zZm9ybTogcm90YXRlWCgxODBkZWcpO1xcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTc1ZWYzYzg0XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL3J1bGVzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uZXJyb3JNZXNzYWdlIHtcXG4gIGNvbG9yOiAjZmYzODYwO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiQzovVXNlcnMvc2RvcnJpcy9mYW50YXN5bXgvY2xpZW50L2NvbXBvbmVudHMvY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUF5SkE7RUFDQSxlQUFBO0NBQ0FcIixcImZpbGVcIjpcInJlZ2lzdGVyLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxyXFxuICA8ZGl2IGNsYXNzPVxcXCJtb2RhbFxcXCIgdi1iaW5kOmNsYXNzPVxcXCJ7J2lzLWFjdGl2ZSc6IFNob3dSZWdpc3Rlck1vZGFsfVxcXCIgaWQ9XFxcInJlZ2lzdGVyTW9kYWxcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJtb2RhbC1iYWNrZ3JvdW5kXFxcIj48L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtY2FyZFxcXCI+XFxyXFxuICAgICAgPGhlYWRlciBjbGFzcz1cXFwibW9kYWwtY2FyZC1oZWFkXFxcIj5cXHJcXG4gICAgICAgIDxwIGNsYXNzPVxcXCJtb2RhbC1jYXJkLXRpdGxlXFxcIj5OZXcgVXNlciBSZWdpc3RyYXRpb248L3A+XFxyXFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJkZWxldGVcXFwiIEBjbGljaz1cXFwic2V0UmVnaXN0ZXJNb2RhbCh7IHNob3c6ICFTaG93UmVnaXN0ZXJNb2RhbH0pXFxcIj48L2J1dHRvbj5cXHJcXG4gICAgICA8L2hlYWRlcj5cXHJcXG4gICAgICA8c2VjdGlvbiBjbGFzcz1cXFwibW9kYWwtY2FyZC1ib2R5XFxcIj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRlbnRcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXHJcXG4gICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwibGFiZWxcXFwiPlVzZXJuYW1lOiA8L2xhYmVsPlxcclxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBjbGFzcz1cXFwiaW5wdXRcXFwiIHYtYmluZDpjbGFzcz1cXFwieyAnaXMtZGFuZ2VyJzogaW52YWxpZFVzZXJuYW1lIH1cXFwiIGlkPVxcXCJyZWctdXNlcm5hbWVcXFwiIHYtbW9kZWw9XFxcInVzZXJuYW1lXFxcIiBwbGFjZWhvbGRlcj1cXFwiVXNlcm5hbWVcXFwiIHJlcXVpcmVkPlxcclxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtdXNlclxcXCI+PC9pPlxcclxcbiAgICAgICAgICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxyXFxuICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcImxhYmVsXFxcIj5FbWFpbDogPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wgaGFzLWljb25zLWxlZnRcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiZW1haWxcXFwiIGNsYXNzPVxcXCJpbnB1dFxcXCIgdi1iaW5kOmNsYXNzPVxcXCJ7ICdpcy1kYW5nZXInOiBpbnZhbGlkRW1haWwgfVxcXCIgIGlkPVxcXCJyZWctZW1haWxcXFwiIHYtbW9kZWw9XFxcImVtYWlsXFxcIiBwbGFjZWhvbGRlcj1cXFwiRW1haWxcXFwiIHJlcXVpcmVkPlxcclxcbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtZW52ZWxvcGVcXFwiPjwvaT5cXHJcXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcclxcbiAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJsYWJlbFxcXCI+UGFzc3dvcmQ6IDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInBhc3N3b3JkXFxcIiBjbGFzcz1cXFwiaW5wdXRcXFwiIHYtYmluZDpjbGFzcz1cXFwieyAnaXMtZGFuZ2VyJzogYmxhbmtQYXNzd29yZCB9XFxcIiB2LW1vZGVsPVxcXCJwYXNzd29yZFxcXCIgcGxhY2Vob2xkZXI9XFxcIlBhc3N3b3JkXFxcIiByZXF1aXJlZD5cXHJcXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24gaXMtc21hbGwgaXMtbGVmdFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWxvY2tcXFwiPjwvaT5cXHJcXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcclxcbiAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcclxcbiAgICAgICAgICAgICAgPGRpdiBpZD1cXFwicmVnaXN0ZXItcmVjYXB0Y2hhXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJlcnJvck1lc3NhZ2VcXFwiIHYtZm9yPVxcXCJlcnJvciBpbiBlcnJvck1lc3NhZ2VcXFwiIHYtaWY9XFxcImVycm9yTWVzc2FnZSAhPSAnJ1xcXCI+XFxyXFxuICAgICAgICAgICAgICB7eyBlcnJvciB9fVxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgPC9zZWN0aW9uPlxcclxcbiAgICAgIDxmb290ZXIgY2xhc3M9XFxcIm1vZGFsLWNhcmQtZm9vdFxcXCI+XFxyXFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gaXMtc3VjY2Vzc1xcXCIgQGNsaWNrPVxcXCJSZWdpc3RlclxcXCIgdi1iaW5kOmNsYXNzPVxcXCJ7ICdpcy1sb2FkaW5nJzogaXNMb2FkaW5nIH1cXFwiPlJlZ2lzdGVyPC9idXR0b24+XFxyXFxuICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b25cXFwiIEBjbGljaz1cXFwic2V0UmVnaXN0ZXJNb2RhbCh7IHNob3c6ICFTaG93UmVnaXN0ZXJNb2RhbCB9KVxcXCI+Q2FuY2VsPC9idXR0b24+XFxyXFxuICAgICAgPC9mb290ZXI+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgPC9kaXY+XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG5cXHJcXG48c2NyaXB0PlxcclxcbmltcG9ydCB7IG1hcEdldHRlcnMsIG1hcE11dGF0aW9ucyB9IGZyb20gJ3Z1ZXgnO1xcclxcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XFxyXFxuICBleHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIGRhdGEoKSB7XFxyXFxuICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgIHVzZXJuYW1lOiAnJyxcXHJcXG4gICAgICAgIGVtYWlsOiAnJyxcXHJcXG4gICAgICAgIHBhc3N3b3JkOiAnJyxcXHJcXG4gICAgICAgIGVycm9yTWVzc2FnZTogW10sXFxyXFxuICAgICAgICBpbnZhbGlkVXNlcm5hbWU6IGZhbHNlLFxcclxcbiAgICAgICAgaW52YWxpZEVtYWlsOiBmYWxzZSxcXHJcXG4gICAgICAgIGJsYW5rUGFzc3dvcmQ6IGZhbHNlLFxcclxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZVxcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgY29tcHV0ZWQ6IG1hcEdldHRlcnMoW1xcclxcbiAgICAgICdTaG93UmVnaXN0ZXJNb2RhbCcsXFxyXFxuICAgICAgJ2dldFVzZXJEYXRhJ1xcclxcbiAgICBdKSxcXHJcXG4gICAgbWV0aG9kczoge1xcclxcbiAgICAgIC4uLm1hcE11dGF0aW9ucyhbXFxyXFxuICAgICAgICAnc2V0UmVnaXN0ZXJNb2RhbCcsXFxyXFxuICAgICAgICAnc2V0VXNlckRhdGEnLFxcclxcbiAgICAgICAgJ3NldExvZ2dlZEluJ1xcclxcbiAgICAgIF0pLFxcclxcbiAgICAgIFJlZ2lzdGVyKCkge1xcclxcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xcclxcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBbXTtcXHJcXG4gICAgICAgIHRoaXMuaW52YWxpZEVtYWlsID0gZmFsc2U7XFxyXFxuICAgICAgICB0aGlzLmJsYW5rUGFzc3dvcmQgPSBmYWxzZTtcXHJcXG4gICAgICAgIHRoaXMuaW52YWxpZFVzZXJuYW1lID0gZmFsc2U7XFxyXFxuICAgICAgICBpZiAodGhpcy5SZWdpc3RyYXRpb25Jc1ZhbGlkKCkpIHtcXHJcXG4gICAgICAgICAgYXhpb3MucG9zdCgnL3JlZ2lzdGVyJywge1xcclxcbiAgICAgICAgICAgIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lLFxcclxcbiAgICAgICAgICAgIGVtYWlsOiB0aGlzLmVtYWlsLFxcclxcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLnBhc3N3b3JkLFxcclxcbiAgICAgICAgICAgIGNhcHRjaGE6IGdyZWNhcHRjaGEuZ2V0UmVzcG9uc2UoMSlcXHJcXG4gICAgICAgICAgfSkudGhlbihkYXRhID0+IHtcXHJcXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcXHJcXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xcclxcbiAgICAgICAgICAgIHZhciBpc0ZhbHNlID0gIWRhdGEuZGF0YS5FcnJvck1lc3NhZ2U7XFxyXFxuICAgICAgICAgICAgY29uc29sZS5sb2coXFxcImlzRmFsc2VcXFwiLCBpc0ZhbHNlKVxcclxcbiAgICAgICAgICAgIGlmICghZGF0YS5kYXRhLkVycm9yTWVzc2FnZSkge1xcclxcbiAgICAgICAgICAgICAgdGhpcy5zZXRVc2VyRGF0YSh7IHVzZXJEYXRhOiBkYXRhLmRhdGEgfSlcXHJcXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJnZXRVc2VyRGF0YVxcXCIsIHRoaXMuZ2V0VXNlckRhdGEpXFxyXFxuICAgICAgICAgICAgICB0aGlzLnNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiBmYWxzZSB9KVxcclxcbiAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy4kc3RvcmUuc3RhdGUpO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZS5wdXNoKGRhdGEuZGF0YS5FcnJvck1lc3NhZ2UpO1xcclxcbiAgICAgICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UuZm9yRWFjaChtc2cgPT4ge1xcclxcbiAgICAgICAgICAgICAgICBpZiAobXNnLmluZGV4T2YoXFxcIlVzZXJuYW1lXFxcIikgPiAtMSkge1xcclxcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZFVzZXJuYW1lID0gdHJ1ZTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICBpZiAobXNnLmluZGV4T2YoXFxcIkVtYWlsXFxcIikgPi0xKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkRW1haWwgPSB0cnVlO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAgICAgZ3JlY2FwdGNoYS5yZXNldCgxKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgdGhpcy51c2VybmFtZSA9ICcnO1xcclxcbiAgICAgICAgICAgIHRoaXMuZW1haWwgPSAnJztcXHJcXG4gICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gJydcXHJcXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xcclxcbiAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAuY2F0Y2goZSA9PiB7XFxyXFxuICAgICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UucHVzaChlLnJlc3BvbnNlLmRhdGEuZXJyb3IpO1xcclxcbiAgICAgICAgICAgIGdyZWNhcHRjaGEucmVzZXQoMSk7XFxyXFxuICAgICAgICAgICAgdGhpcy51c2VybmFtZSA9ICcnO1xcclxcbiAgICAgICAgICAgIHRoaXMuZW1haWwgPSAnJztcXHJcXG4gICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gJydcXHJcXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xcclxcbiAgICAgICAgICB9KVxcclxcblxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0sXFxyXFxuICAgICAgUmVnaXN0cmF0aW9uSXNWYWxpZCgpIHtcXHJcXG4gICAgICAgIHZhciBlbWFpbFZhbGlkYXRpb24gPSB0aGlzLmVtYWlsLm1hdGNoKG5ldyBSZWdFeHAoL14oKFtePD4oKVxcXFxbXFxcXF1cXFxcXFxcXC4sOzpcXFxcc0BcXFwiXSsoXFxcXC5bXjw+KClcXFxcW1xcXFxdXFxcXFxcXFwuLDs6XFxcXHNAXFxcIl0rKSopfChcXFwiLitcXFwiKSlAKChcXFxcW1swLTldezEsM31cXFxcLlswLTldezEsM31cXFxcLlswLTldezEsM31cXFxcLlswLTldezEsM31dKXwoKFthLXpBLVpcXFxcLTAtOV0rXFxcXC4pK1thLXpBLVpdezIsfSkpJC8pLCBcXFwiaVxcXCIpO1xcclxcbiAgICAgICAgY29uc29sZS5sb2coZW1haWxWYWxpZGF0aW9uKTtcXHJcXG4gICAgICAgIGlmICh0aGlzLmVtYWlsID09IFxcXCJcXFwiKSB7XFxyXFxuICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlLnB1c2goXFxcIlVzZXJuYW1lIGNhbm5vdCBiZSBsZWZ0IGVtcHR5LlxcXCIpXFxyXFxuICAgICAgICAgIHRoaXMuaW52YWxpZFVzZXJuYW1lID0gdHJ1ZTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGlmIChlbWFpbFZhbGlkYXRpb24gPT0gbnVsbCkge1xcclxcbiAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZS5wdXNoKFxcXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbC5cXFwiKVxcclxcbiAgICAgICAgICB0aGlzLmludmFsaWRFbWFpbCA9IHRydWU7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBpZiAodGhpcy5wYXNzd29yZCA9PSAnJyB8fCB0aGlzLnBhc3N3b3JkLmxlbmd0aCA8IDYpIHtcXHJcXG4gICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UucHVzaChcXFwiUGFzc3dvcmQgY2Fubm90IGJlIGxlZnQgZW1wdHkgYW5kIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzLlxcXCIpXFxyXFxuICAgICAgICAgIHRoaXMuYmxhbmtQYXNzd29yZCA9IHRydWU7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICBpZiAodGhpcy5lcnJvck1lc3NhZ2UubGVuZ3RoID4gMCkge1xcclxcbiAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xcclxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG48L3NjcmlwdD5cXHJcXG48c3R5bGU+XFxyXFxuICAuZXJyb3JNZXNzYWdlIHtcXHJcXG4gICAgY29sb3I6ICNmZjM4NjA7XFxyXFxuICB9XFxyXFxuPC9zdHlsZT5cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi03YjhhMTliNFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWVcbi8vIG1vZHVsZSBpZCA9IDIxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmJvbGQtbWVzc2FnZSB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICBmb250LXNpemU6IDE4cHQ7XFxyXFxuICBjb2xvcjogI2ZmZmM3ZjtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA4MDA7XFxufVxcclxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9zZG9ycmlzL2ZhbnRhc3lteC9jbGllbnQvY29tcG9uZW50cy9jbGllbnQvY29tcG9uZW50cy9qb2lubGVhZ3VlLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBaURBO0VBQ0EsbUJBQUE7RUFDQSxnQkFBQTtFQUNBLGVBQUE7RUFDQSxpQkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJqb2lubGVhZ3VlLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxyXFxuICA8ZGl2PlxcclxcbiAgPGRpdiB2LWlmPVxcXCJnZXRVc2VyRGF0YS5hY2NvdW50dHlwZSA+IDBcXFwiIGNsYXNzPVxcXCJjb2x1bW4gaXMtaGFsZiBpcy1vZmZzZXQtb25lLXF1YXJ0ZXJcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxyXFxuICAgICAgPGxhYmVsPkxlYWd1ZSBOYW1lPC9sYWJlbD5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XFxcIj5cXHJcXG4gICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiaW5wdXRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJMZWFndWUgSURcXFwiPlxcclxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24gaXMtc21hbGwgaXMtbGVmdFxcXCI+XFxyXFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS10cm9waHlcXFwiPjwvaT5cXHJcXG4gICAgICAgIDwvc3Bhbj5cXHJcXG4gICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXHJcXG4gICAgICA8bGFiZWw+TGVhZ3VlIFBhc3N3b3JkPC9sYWJlbD5cXHJcXG4gICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XFxcIj5cXHJcXG4gICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiaW5wdXRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJMZWFndWUgUGFzc3dvcmRcXFwiPlxcclxcbiAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24gaXMtc21hbGwgaXMtbGVmdFxcXCI+XFxyXFxuICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1sb2NrXFxcIj48L2k+XFxyXFxuICAgICAgICA8L3NwYW4+XFxyXFxuICAgICAgPC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxyXFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiYnV0dG9uXFxcIj5TdWJtaXQ8L2J1dHRvbj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICA8L2Rpdj5cXHJcXG4gIDxkaXYgdi1pZj1cXFwiZ2V0VXNlckRhdGEuYWNjb3VudHR5cGUgPT0gMFxcXCI+XFxyXFxuICAgIDxwIGNsYXNzPVxcXCJib2xkLW1lc3NhZ2VcXFwiPlRoaXMgZmVhdHVyZSByZXF1aXJlcyBhdCBsZWFzdCBhIEJhc2ljIGFjY291bnQuIFBsZWFzZSB1cGdyYWRlIHlvdXIgYWNjb3VudCBpbiBvcmRlciB0byBhY3RpdmF0ZSB0aGlzIGZlYXR1cmUuPC9wPlxcclxcbiAgPC9kaXY+XFxyXFxuPC9kaXY+XFxyXFxuPC90ZW1wbGF0ZT5cXHJcXG5cXHJcXG48c2NyaXB0PlxcclxcbmltcG9ydCB7IG1hcEdldHRlcnMsIG1hcE11dGF0aW9ucyB9IGZyb20gJ3Z1ZXgnO1xcclxcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XFxyXFxuICBleHBvcnQgZGVmYXVsdCB7XFxyXFxuICAgIGRhdGEoKSB7XFxyXFxuICAgICAgcmV0dXJuIHtcXHJcXG5cXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuICAgIGNvbXB1dGVkOiBtYXBHZXR0ZXJzKFtcXHJcXG4gICAgICAnZ2V0VXNlckRhdGEnXFxyXFxuICAgIF0pLFxcclxcbiAgICBtZXRob2RzOiB7XFxyXFxuICAgICAgLi4ubWFwTXV0YXRpb25zKFtcXHJcXG4gICAgICBdKSxcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbjwvc2NyaXB0PlxcclxcbjxzdHlsZT5cXHJcXG4uYm9sZC1tZXNzYWdlIHtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIGZvbnQtc2l6ZTogMThwdDtcXHJcXG4gIGNvbG9yOiAjZmZmYzdmO1xcclxcbiAgZm9udC13ZWlnaHQ6IDgwMDtcXHJcXG59XFxyXFxuPC9zdHlsZT5cXHJcXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi1lM2ZmOWFjOFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9qb2lubGVhZ3VlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4uc3VnZ2VzdGlvbnMtY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIG1hcmdpbi10b3A6IDNyZW07XFxuICBjb2xvcjogd2hpdGU7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJDOi9Vc2Vycy9zZG9ycmlzL2ZhbnRhc3lteC9jbGllbnQvY29tcG9uZW50cy9jbGllbnQvY29tcG9uZW50cy9zdWdnZXN0aW9ucy52dWVcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXFHQTtFQUNBLGNBQUE7RUFDQSx3QkFBQTtFQUNBLGlCQUFBO0VBQ0EsYUFBQTtDQUNBXCIsXCJmaWxlXCI6XCJzdWdnZXN0aW9ucy52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcclxcbiAgPGRpdiBjbGFzcz1cXFwiY29udGFpbmVyIHN1Z2dlc3Rpb25zLWNvbnRhaW5lclxcXCI+XFxyXFxuICAgICAgPHNlY3Rpb24+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xcXFwiPlxcclxcbiAgICAgICAgICAgIDxsYWJlbD5BcmUgeW91IGEgcmVnaXN0ZXJlZCB1c2VyPzwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJyYWRpb1xcXCI+XFxyXFxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcIlJlZ2lzdGVyZWRcXFwiIHZhbHVlPVxcXCJ0cnVlXFxcIiB2LW1vZGVsPVxcXCJSZWdpc3RlcmVkXFxcIj5cXHJcXG4gICAgICAgICAgICAgIFllc1xcclxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJyYWRpb1xcXCI+XFxyXFxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcIlJlZ2lzdGVyZWRcXFwiIHZhbHVlPVxcXCJmYWxzZVxcXCIgdi1tb2RlbD1cXFwiUmVnaXN0ZXJlZFxcXCI+XFxyXFxuICAgICAgICAgICAgICBOb1xcclxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xcXFwiPlxcclxcbiAgICAgICAgICAgIDxsYWJlbD5JcyB0aGlzIGZlZWRiYWNrIG9yIGEgYnVnIHJlcG9ydD88L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwicmFkaW9cXFwiPlxcclxcbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJmZWVkYmFja1xcXCIgdi1tb2RlbD1cXFwiUmVwb3J0VHlwZVxcXCIgdmFsdWU9XFxcImZlZWRiYWNrXFxcIj5cXHJcXG4gICAgICAgICAgICAgIEZlZWRiYWNrXFxyXFxuICAgICAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcInJhZGlvXFxcIj5cXHJcXG4gICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwiZmVlZGJhY2tcXFwiIHYtbW9kZWw9XFxcIlJlcG9ydFR5cGVcXFwiIHZhbHVlPVxcXCJidWdcXFwiPlxcclxcbiAgICAgICAgICAgICAgQnVnIFJlcG9ydFxcclxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxyXFxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwibGFiZWxcXFwiPlVzZXJuYW1lPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sXFxcIj5cXHJcXG4gICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cXFwiaW5wdXRcXFwiIHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJVc2VybmFtZVxcXCIgdi1tb2RlbD1cXFwiVXNlcm5hbWVcXFwiPlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCIgdi1pZj1cXFwiUmVwb3J0VHlwZSA9PSAnZmVlZGJhY2snXFxcIj5cXHJcXG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJsYWJlbFxcXCI+U3VnZ2VzdCBGZWF0dXJlczwvbGFiZWw+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNlbGVjdFxcXCI+XFxyXFxuICAgICAgICAgICAgICA8c2VsZWN0IHYtbW9kZWw9XFxcImZlYXR1cmVcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIGRpc2FibGVkIHZhbHVlPVxcXCJcXFwiPlNFTEVDVCBDQVRFR09SWTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uPlVzZXIgSW50ZXJmYWNlPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24+TmF2aWdhdGlvbiBDb250ZW50PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24+TXkgVGVhbTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uPlNjb3Jpbmc8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbj5OZXcgRmVhdHVyZXM8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbj5TdGF0IFRyYWNrZXI8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbj5BY2NvdW50PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICA8L3NlbGVjdD5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIiB2LWlmPVxcXCJSZXBvcnRUeXBlID09ICdmZWVkYmFjaydcXFwiPlxcclxcbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcImxhYmVsXFxcIj5GZWVkYmFjazwvbGFiZWw+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xcXFwiPlxcclxcbiAgICAgICAgICAgIDx0ZXh0YXJlYSBjbGFzcz1cXFwidGV4dGFyZWFcXFwiIHYtbW9kZWw9XFxcImZlZWRiYWNrXFxcIiBwbGFjZWhvbGRlcj1cXFwiRGVzY3JpYmUgeW91ciBzdWdnZXN0aW9ucyBoZXJlLlxcXCI+PC90ZXh0YXJlYT5cXHJcXG4gICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIiB2LWlmPVxcXCJSZXBvcnRUeXBlID09ICdidWcnXFxcIj5cXHJcXG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJsYWJlbFxcXCI+UmVwb3J0IEJ1ZzwvbGFiZWw+XFxyXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2xcXFwiPlxcclxcbiAgICAgICAgICAgIDx0ZXh0YXJlYSBjbGFzcz1cXFwidGV4dGFyZWFcXFwiIHYtbW9kZWw9XFxcImJ1Z3JlcG9ydFxcXCIgcGxhY2Vob2xkZXI9XFxcIkRlc2NyaWJlIHRoZSBhY3Rpb25zIHlvdSB0b29rLCB5b3VyIGRlc2lyZWQgb3V0Y29tZSBhbmQgdGhlIGFjdHVhbCBvdXRjb21lIG9mIHRob3NlIGFjdGlvbnMuIFdlIHNob3VsZCBiZSBhYmxlIHRvIHJlcGxpY2F0ZSB0aGUgYnVnIGJhc2VkIG9mZiB0aGUgc3RlcHMgeW91IHByb3ZpZGUgaGVyZS5cXFwiPjwvdGV4dGFyZWE+XFxyXFxuICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxyXFxuICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBpcy1wcmltYXJ5XFxcIiB2LW9uOmNsaWNrPVxcXCJzdWJtaXRcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCI+U3VibWl0PC9idXR0b24+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICA8L3NlY3Rpb24+XFxyXFxuICA8L2Rpdj5cXHJcXG48L3RlbXBsYXRlPlxcclxcbjxzY3JpcHQ+XFxyXFxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcXHJcXG4gIGV4cG9ydCBkZWZhdWx0IHtcXHJcXG4gICAgZGF0YSgpIHtcXHJcXG4gICAgICByZXR1cm4ge1xcclxcbiAgICAgICAgVXNlcm5hbWU6ICcnLFxcclxcbiAgICAgICAgUmVwb3J0VHlwZTogJycsXFxyXFxuICAgICAgICBSZWdpc3RlcmVkOiBmYWxzZSxcXHJcXG4gICAgICAgIGZlYXR1cmU6ICcnLFxcclxcbiAgICAgICAgYnVncmVwb3J0OiAnJyxcXHJcXG4gICAgICAgIGZlZWRiYWNrOiAnJ1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG4gICAgbWV0aG9kczoge1xcclxcbiAgICAgIHN1Ym1pdCgpIHtcXHJcXG4gICAgICAgIHZhciBkYXRhID0ge1xcclxcbiAgICAgICAgICBVc2VybmFtZTogdGhpcy5Vc2VybmFtZSxcXHJcXG4gICAgICAgICAgUmVwb3J0VHlwZTogdGhpcy5SZXBvcnRUeXBlLFxcclxcbiAgICAgICAgICBSZWdpc3RlcmVkOiB0aGlzLlJlZ2lzdGVyZWQsXFxyXFxuICAgICAgICAgIEZlYXR1cmU6IHRoaXMuZmVhdHVyZSxcXHJcXG4gICAgICAgICAgQnVnUmVwb3J0OiB0aGlzLmJ1Z3JlcG9ydCxcXHJcXG4gICAgICAgICAgRmVlZGJhY2s6IHRoaXMuZmVlZGJhY2tcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIGF4aW9zLnBvc3QoJy9mZWVkYmFjaycsIGRhdGEpXFxyXFxuICAgICAgICAudGhlbihyZXMgPT4ge1xcclxcbiAgICAgICAgICBjb25zb2xlLmxvZyhyZXMpXFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcbjwvc2NyaXB0PlxcclxcbjxzdHlsZT5cXHJcXG4gIC5zdWdnZXN0aW9ucy1jb250YWluZXIge1xcclxcbiAgICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXHJcXG4gICAgbWFyZ2luLXRvcDogM3JlbTtcXHJcXG4gICAgY29sb3I6IHdoaXRlO1xcclxcbiAgfVxcclxcbjwvc3R5bGU+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtZjk2YzdhODhcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvc3VnZ2VzdGlvbnMudnVlXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0yYjc3MGQyNFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vQ3JlYXRlTGVhZ3VlLnZ1ZVwiKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbmV4cG9ydCAqIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0NyZWF0ZUxlYWd1ZS52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0NyZWF0ZUxlYWd1ZS52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCBfX3Z1ZV90ZW1wbGF0ZV9fIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTJiNzcwZDI0XFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vQ3JlYXRlTGVhZ3VlLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJjbGllbnRcXFxcY29tcG9uZW50c1xcXFxDcmVhdGVMZWFndWUudnVlXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTJiNzcwZDI0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMmI3NzBkMjRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5leHBvcnQgZGVmYXVsdCBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jbGllbnQvY29tcG9uZW50cy9DcmVhdGVMZWFndWUudnVlXG4vLyBtb2R1bGUgaWQgPSAyMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0xNTE2N2YyZlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vZGVsZXRlYWNjb3VudC52dWVcIilcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9kZWxldGVhY2NvdW50LnZ1ZVwiXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vZGVsZXRlYWNjb3VudC52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCBfX3Z1ZV90ZW1wbGF0ZV9fIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTE1MTY3ZjJmXFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vZGVsZXRlYWNjb3VudC52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcZGVsZXRlYWNjb3VudC52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMTUxNjdmMmZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0xNTE2N2YyZlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9jb21wb25lbnRzL2RlbGV0ZWFjY291bnQudnVlXG4vLyBtb2R1bGUgaWQgPSAyMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1lM2ZmOWFjOFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vam9pbmxlYWd1ZS52dWVcIilcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9qb2lubGVhZ3VlLnZ1ZVwiXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vam9pbmxlYWd1ZS52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCBfX3Z1ZV90ZW1wbGF0ZV9fIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWUzZmY5YWM4XFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vam9pbmxlYWd1ZS52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcam9pbmxlYWd1ZS52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZTNmZjlhYzhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1lM2ZmOWFjOFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9jb21wb25lbnRzL2pvaW5sZWFndWUudnVlXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi03MWRjYmM0YVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vbGVhZGVyYm9hcmQudnVlXCIpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIilcbi8qIHNjcmlwdCAqL1xuZXhwb3J0ICogZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vbGVhZGVyYm9hcmQudnVlXCJcbmltcG9ydCBfX3Z1ZV9zY3JpcHRfXyBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9sZWFkZXJib2FyZC52dWVcIlxuLyogdGVtcGxhdGUgKi9cbmltcG9ydCBfX3Z1ZV90ZW1wbGF0ZV9fIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTcxZGNiYzRhXFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vbGVhZGVyYm9hcmQudnVlXCJcbi8qIHRlbXBsYXRlIGZ1bmN0aW9uYWwgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18gPSBmYWxzZVxuLyogc3R5bGVzICovXG52YXIgX192dWVfc3R5bGVzX18gPSBpbmplY3RTdHlsZVxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcImNsaWVudFxcXFxjb21wb25lbnRzXFxcXGxlYWRlcmJvYXJkLnZ1ZVwiXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi03MWRjYmM0YVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTcxZGNiYzRhXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2xpZW50L2NvbXBvbmVudHMvbGVhZGVyYm9hcmQudnVlXG4vLyBtb2R1bGUgaWQgPSAyMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9sb2dpbi52dWVcIlxuaW1wb3J0IF9fdnVlX3NjcmlwdF9fIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2xvZ2luLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSAqL1xuaW1wb3J0IF9fdnVlX3RlbXBsYXRlX18gZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZTljOTRjMTRcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlLFxcXCJidWJsZVxcXCI6e1xcXCJ0cmFuc2Zvcm1zXFxcIjp7fX19IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9sb2dpbi52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IG51bGxcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJjbGllbnRcXFxcY29tcG9uZW50c1xcXFxsb2dpbi52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZTljOTRjMTRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1lOWM5NGMxNFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9jb21wb25lbnRzL2xvZ2luLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2VmZDlmMGVcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL215YWNjb3VudC52dWVcIilcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9teWFjY291bnQudnVlXCJcbmltcG9ydCBfX3Z1ZV9zY3JpcHRfXyBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9teWFjY291bnQudnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQgX192dWVfdGVtcGxhdGVfXyBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0zZWZkOWYwZVxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL215YWNjb3VudC52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcbXlhY2NvdW50LnZ1ZVwiXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0zZWZkOWYwZVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTNlZmQ5ZjBlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2xpZW50L2NvbXBvbmVudHMvbXlhY2NvdW50LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMTE3N2NiNjhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL215dGVhbS52dWVcIilcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9teXRlYW0udnVlXCJcbmltcG9ydCBfX3Z1ZV9zY3JpcHRfXyBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9teXRlYW0udnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQgX192dWVfdGVtcGxhdGVfXyBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0xMTc3Y2I2OFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL215dGVhbS52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcbXl0ZWFtLnZ1ZVwiXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0xMTc3Y2I2OFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTExNzdjYjY4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2xpZW50L2NvbXBvbmVudHMvbXl0ZWFtLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzY3OTQwZDNcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL25hdmJhci52dWVcIilcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG5leHBvcnQgKiBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9uYXZiYXIudnVlXCJcbmltcG9ydCBfX3Z1ZV9zY3JpcHRfXyBmcm9tIFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9uYXZiYXIudnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQgX192dWVfdGVtcGxhdGVfXyBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0zNjc5NDBkM1xcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL25hdmJhci52dWVcIlxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gbnVsbFxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiY2xpZW50XFxcXGNvbXBvbmVudHNcXFxcbmF2YmFyLnZ1ZVwiXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0zNjc5NDBkM1wiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTM2Nzk0MGQzXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGQ4OGZkODRcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL25hdmJhckRyb3Bkb3duLnZ1ZVwiKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbmV4cG9ydCAqIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL25hdmJhckRyb3Bkb3duLnZ1ZVwiXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vbmF2YmFyRHJvcGRvd24udnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQgX192dWVfdGVtcGxhdGVfXyBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi00ZDg4ZmQ4NFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL25hdmJhckRyb3Bkb3duLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJjbGllbnRcXFxcY29tcG9uZW50c1xcXFxuYXZiYXJEcm9wZG93bi52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNGQ4OGZkODRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi00ZDg4ZmQ4NFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9jb21wb25lbnRzL25hdmJhckRyb3Bkb3duLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNzVlZjNjODRcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3J1bGVzLnZ1ZVwiKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbnZhciBfX3Z1ZV9zY3JpcHRfXyA9IG51bGxcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQgX192dWVfdGVtcGxhdGVfXyBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03NWVmM2M4NFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3J1bGVzLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJjbGllbnRcXFxcY29tcG9uZW50c1xcXFxydWxlcy52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNzVlZjNjODRcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi03NWVmM2M4NFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9jb21wb25lbnRzL3J1bGVzLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2ZjMzU4OWVcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3N0YXR0cmFja2VyLnZ1ZVwiKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbmV4cG9ydCAqIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3N0YXR0cmFja2VyLnZ1ZVwiXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vc3RhdHRyYWNrZXIudnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQgX192dWVfdGVtcGxhdGVfXyBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0zZmMzNTg5ZVxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3N0YXR0cmFja2VyLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJjbGllbnRcXFxcY29tcG9uZW50c1xcXFxzdGF0dHJhY2tlci52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtM2ZjMzU4OWVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0zZmMzNTg5ZVwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9jb21wb25lbnRzL3N0YXR0cmFja2VyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZjk2YzdhODhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3N1Z2dlc3Rpb25zLnZ1ZVwiKVxufVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbmV4cG9ydCAqIGZyb20gXCIhIWJhYmVsLWxvYWRlciEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL3N1Z2dlc3Rpb25zLnZ1ZVwiXG5pbXBvcnQgX192dWVfc2NyaXB0X18gZnJvbSBcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vc3VnZ2VzdGlvbnMudnVlXCJcbi8qIHRlbXBsYXRlICovXG5pbXBvcnQgX192dWVfdGVtcGxhdGVfXyBmcm9tIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1mOTZjN2E4OFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3N1Z2dlc3Rpb25zLnZ1ZVwiXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJjbGllbnRcXFxcY29tcG9uZW50c1xcXFxzdWdnZXN0aW9ucy52dWVcIlxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZjk2YzdhODhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1mOTZjN2E4OFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9jb21wb25lbnRzL3N1Z2dlc3Rpb25zLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgW1xuICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwicGFnZS1oZWFkZXItY29udGFpbmVyXCIgfSwgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJwYWdlLWhlYWRlci1ibG9ja1wiIH0sIFtcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJsaC00clwiIH0sIFtcbiAgICAgICAgICBfdm0uX3YoXCJXZWVrOiBcIiksXG4gICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiYm9sZGVzdC1oZWFkZXIgcmlnaHRcIiB9LCBbXG4gICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5jdXJyZW50d2VlaykpXG4gICAgICAgICAgXSlcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibGgtNHJcIiB9LCBbXG4gICAgICAgICAgX3ZtLl92KFwiQmFsYW5jZSBSZW1haW5pbmc6XCIpLFxuICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImJvbGRlc3QtaGVhZGVyIHJpZ2h0XCIgfSwgW1xuICAgICAgICAgICAgX3ZtLl92KFwiICRcIiArIF92bS5fcyhfdm0uZG9sbGFycykpXG4gICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICAgIF0pXG4gICAgXSksXG4gICAgX3ZtLl92KFwiIFwiKSxcbiAgICBfYyhcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0YXRpY0NsYXNzOiBcImNvbnRhaW5lclwiIH0sXG4gICAgICBbXG4gICAgICAgIF9jKFwidHJhbnNpdGlvblwiLCB7IGF0dHJzOiB7IG5hbWU6IFwiZmFkZVwiLCBtb2RlOiBcIm91dC1pblwiIH0gfSwgW1xuICAgICAgICAgIF92bS5zaG93U2F2ZU1lc3NhZ2VcbiAgICAgICAgICAgID8gX2MoXCJwXCIsIHsgc3RhdGljQ2xhc3M6IFwic3VjY2Vzc2Z1bC1zYXZlXCIgfSwgW1xuICAgICAgICAgICAgICAgIF92bS5fdihcIllvdXIgdGVhbSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgc2F2ZWQhXCIpXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX3ZtLnNob3dGYWlsTWVzc2FnZVxuICAgICAgICAgICAgPyBfYyhcInBcIiwgeyBzdGF0aWNDbGFzczogXCJmYWlsdXJlLXNhdmVcIiB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiT29wcyEgU29tZXRoaW5nIFdlbnQgV3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCIpXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgIF0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcInRhYmxlXCIsIHsgc3RhdGljQ2xhc3M6IFwibXl0ZWFtLXRhYmxlXCIgfSwgW1xuICAgICAgICAgIF9jKFwidGhlYWRcIiwgW1xuICAgICAgICAgICAgX2MoXCJ0clwiLCBbXG4gICAgICAgICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIkFjdGlvblwiKV0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcInRoXCIsIHsgb246IHsgY2xpY2s6IF92bS5zb3J0QnlQcmljZSB9IH0sIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCJQcmljZVxcbiAgICAgICAgICAgIFwiKSxcbiAgICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJpY29uXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgX3ZtLkNvc3RTb3J0QnlBc2NcbiAgICAgICAgICAgICAgICAgICAgPyBfYyhcImlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZmEgZmEtY2FyZXQtdXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIDogX2MoXCJpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImZhIGZhLWNhcmV0LWRvd25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIlJhY2VyIE5hbWVcIildKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiUmFjZXIgTnVtYmVyXCIpXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIkhpZ2hlc3QgRmluaXNoXCIpXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIkxvd2VzdCBGaW5pc2hcIildKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiQXZlcmFnZSBGaW5pc2hcIildKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF92bS5fbSgwKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJ0Ym9keVwiLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfdm0uX2woX3ZtLnNlbGVjdGVkcmlkZXJzLCBmdW5jdGlvbihyYWNlciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2MoXCJ0clwiLCBbXG4gICAgICAgICAgICAgICAgICBfYyhcInRkXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgcmFjZXIubmFtZSAhPSBcIk9QRU4gU0xPVFwiXG4gICAgICAgICAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBocmVmOiBcIiMhXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0ucmVtb3ZlUmFjZXIocmFjZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBbX3ZtLl9tKDEsIHRydWUpXVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgIF9jKFwidGRcIiwgW192bS5fdihcIiRcIiArIF92bS5fcyhyYWNlci5jb3N0KSldKSxcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICBfYyhcInRkXCIsIFtfdm0uX3YoX3ZtLl9zKHJhY2VyLm5hbWUpKV0pLFxuICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgIF9jKFwidGRcIiwgW192bS5fdihfdm0uX3MocmFjZXIucmlkZXJfbnVtYmVyKSldKSxcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICBfYyhcInRkXCIsIFtfdm0uX3YoX3ZtLl9zKHJhY2VyLmhpZ2hlc3RGaW5pc2gpKV0pLFxuICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgIF9jKFwidGRcIiwgW192bS5fdihfdm0uX3MocmFjZXIubG93ZXN0RmluaXNoKSldKSxcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICBfYyhcInRkXCIsIFtfdm0uX3YoX3ZtLl9zKHJhY2VyLmF2ZXJhZ2VGaW5pc2gpKV0pXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwidHJcIiwgeyBzdGF0aWNDbGFzczogXCJsYXN0Um93XCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFwidGRcIiwgeyBhdHRyczogeyBjb2xzcGFuOiBcIjVcIiB9IH0pLFxuICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCB7IGF0dHJzOiB7IGNvbHNwYW46IFwiMVwiIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJidXR0b24gaXMtZGFuZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgZGlzYWJsZWQ6ICFfdm0uc2hvd1JlbW92ZUFsbCB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uUmVtb3ZlQWxsIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgW192bS5fdihcIlJlbW92ZSBBbGxcIildXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICBfYyhcInRkXCIsIHsgYXR0cnM6IHsgY29sc3BhbjogXCIxXCIgfSB9LCBbXG4gICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImJ1dHRvbiBpcy1zdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IHsgXCJpcy1sb2FkaW5nXCI6IF92bS5pc0xvYWRpbmcgfSxcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBkaXNhYmxlZDogX3ZtLmhhc09wZW5TbG90cyB9LFxuICAgICAgICAgICAgICAgICAgICAgIG9uOiB7IGNsaWNrOiBfdm0uU2F2ZVRlYW0gfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBbX3ZtLl92KFwiU2F2ZSBUZWFtXCIpXVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfdm0uX2woX3ZtLnBhZ2luYXRlZFJpZGVycywgZnVuY3Rpb24ocmlkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2MoXCJ0clwiLCBbXG4gICAgICAgICAgICAgICAgICBfYyhcInRkXCIsIFtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLnNob3dTZWxlY3QgJiYgcmlkZXIuY29zdCA8PSBfdm0uZG9sbGFyc1xuICAgICAgICAgICAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgaHJlZjogXCIjIVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLmFkZFJhY2VyKHJpZGVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW192bS5fbSgyLCB0cnVlKV1cbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICBfYyhcInRkXCIsIFtfdm0uX3YoXCIkXCIgKyBfdm0uX3MocmlkZXIuY29zdCkpXSksXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCBbX3ZtLl92KF92bS5fcyhyaWRlci5uYW1lKSldKSxcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICBfYyhcInRkXCIsIFtfdm0uX3YoX3ZtLl9zKHJpZGVyLnJpZGVyX251bWJlcikpXSksXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCBbX3ZtLl92KF92bS5fcyhyaWRlci5oaWdoZXN0RmluaXNoKSldKSxcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICBfYyhcInRkXCIsIFtfdm0uX3YoX3ZtLl9zKHJpZGVyLmxvd2VzdEZpbmlzaCkpXSksXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCBbX3ZtLl92KF92bS5fcyhyaWRlci5hdmVyYWdlRmluaXNoKSldKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgMlxuICAgICAgICAgIClcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY3VzdG9tLXBhZ2luYXRpb25cIiB9LCBbXG4gICAgICAgICAgX2MoXCJkaXZcIiwgW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiYVwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwicGFnaW5hdGlvbi1wcmV2aW91c1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzOiB7IFwiaGlkZS1wYWdpbmF0aW9uLWJ1dHRvblwiOiBfdm0uaGlkZVByZXZpb3VzIH0sXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLnBhZ2UtLVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgW192bS5fdihcIlByZXZpb3VzXCIpXVxuICAgICAgICAgICAgKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJkaXZcIiwgW1xuICAgICAgICAgICAgX2MoXCJhXCIsIHsgc3RhdGljQ2xhc3M6IFwicGFnaW5hdGlvbi1udW1iZXJcIiB9LCBbXG4gICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLnBhZ2UpICsgXCIvXCIgKyBfdm0uX3MoX3ZtLnBhZ2luYXRpb25QYWdlcykpXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJkaXZcIiwgW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiYVwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwicGFnaW5hdGlvbi1uZXh0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3M6IHsgXCJoaWRlLXBhZ2luYXRpb24tYnV0dG9uXCI6IF92bS5oaWRlTmV4dCB9LFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF92bS5wYWdlKytcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFtfdm0uX3YoXCJOZXh0IHBhZ2VcIildXG4gICAgICAgICAgICApXG4gICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICAgIF0sXG4gICAgICAxXG4gICAgKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJ0Zm9vdFwiLCBbXG4gICAgICBfYyhcInRyXCIsIFtcbiAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiQWN0aW9uXCIpXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIlByaWNlXCIpXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIlJhY2VyIE5hbWVcIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiUmFjZXIgTnVtYmVyXCIpXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIkhpZ2hlc3QgRmluaXNoXCIpXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIkxvd2VzdCBGaW5pc2hcIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiQXZlcmFnZSBGaW5pc2hcIildKVxuICAgICAgXSlcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJpY29uIG1pbnVzLWljb25cIiB9LCBbXG4gICAgICBfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJmYSBmYS1taW51c1wiLCBhdHRyczogeyBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiIH0gfSlcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJpY29uIHBsdXMtaWNvblwiIH0sIFtcbiAgICAgIF9jKFwiaVwiLCB7IHN0YXRpY0NsYXNzOiBcImZhIGZhLXBsdXNcIiwgYXR0cnM6IHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9IH0pXG4gICAgXSlcbiAgfVxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuZXhwb3J0IGRlZmF1bHQgZXNFeHBvcnRzXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTExNzdjYjY4XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTExNzdjYjY4XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL215dGVhbS52dWVcbi8vIG1vZHVsZSBpZCA9IDIyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF92bS5fbSgwKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb2x1bW4gaXMtaGFsZiBpcy1vZmZzZXQtb25lLXF1YXJ0ZXJcIiB9LCBbXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZpZWxkXCIgfSwgW1xuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbnRyb2xcIiB9LCBbXG4gICAgICAgICAgX2MoXCJsYWJlbFwiLCB7IHN0YXRpY0NsYXNzOiBcInJhZGlvXCIgfSwgW1xuICAgICAgICAgICAgX3ZtLl92KFwiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB5b3VyIGFjY291bnQ/XFxuICAgICAgICBcIiksXG4gICAgICAgICAgICBfYyhcImlucHV0XCIsIHsgYXR0cnM6IHsgdHlwZTogXCJyYWRpb1wiLCBuYW1lOiBcInF1ZXN0aW9uXCIgfSB9KSxcbiAgICAgICAgICAgIF92bS5fdihcIlxcbiAgICAgICAgWWVzXFxuICAgICAgXCIpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImxhYmVsXCIsIHsgc3RhdGljQ2xhc3M6IFwicmFkaW9cIiB9LCBbXG4gICAgICAgICAgICBfYyhcImlucHV0XCIsIHsgYXR0cnM6IHsgdHlwZTogXCJyYWRpb1wiLCBuYW1lOiBcInF1ZXN0aW9uXCIgfSB9KSxcbiAgICAgICAgICAgIF92bS5fdihcIlxcbiAgICAgICAgTm9cXG4gICAgICBcIilcbiAgICAgICAgICBdKVxuICAgICAgICBdKVxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJmaWVsZFwiIH0sIFtcbiAgICAgICAgX2MoXCJidXR0b25cIiwgeyBzdGF0aWNDbGFzczogXCJidXR0b25cIiB9LCBbX3ZtLl92KFwiU3VibWl0XCIpXSlcbiAgICAgIF0pXG4gICAgXSlcbiAgfVxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuZXhwb3J0IGRlZmF1bHQgZXNFeHBvcnRzXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTE1MTY3ZjJmXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTE1MTY3ZjJmXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL2RlbGV0ZWFjY291bnQudnVlXG4vLyBtb2R1bGUgaWQgPSAyMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCBbXG4gICAgX3ZtLmdldFVzZXJEYXRhLmFjY291bnR0eXBlID09IDJcbiAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb2x1bW4gaXMtaGFsZiBpcy1vZmZzZXQtb25lLXF1YXJ0ZXJcIiB9LCBbXG4gICAgICAgICAgX3ZtLl9tKDApLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX3ZtLl9tKDEpLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX3ZtLl9tKDIpLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX3ZtLl9tKDMpXG4gICAgICAgIF0pXG4gICAgICA6IF92bS5fZSgpLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX3ZtLmdldFVzZXJEYXRhLmFjY291bnR0eXBlICE9IDJcbiAgICAgID8gX2MoXCJkaXZcIiwgW1xuICAgICAgICAgIF9jKFwicFwiLCB7IHN0YXRpY0NsYXNzOiBcImJvbGQtbWVzc2FnZVwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgXCJUaGlzIGZlYXR1cmUgcmVxdWlyZXMgYSBQcmVtaXVtIGFjY291bnQuIFBsZWFzZSB1cGdyYWRlIHlvdXIgYWNjb3VudCBpbiBvcmRlciB0byBhY3RpdmF0ZSB0aGlzIGZlYXR1cmUuXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKVxuICAgICAgICBdKVxuICAgICAgOiBfdm0uX2UoKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJmaWVsZFwiIH0sIFtcbiAgICAgIF9jKFwibGFiZWxcIiwgW192bS5fdihcIkxlYWd1ZSBOYW1lXCIpXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCIgfSwgW1xuICAgICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJpbnB1dFwiLFxuICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwidGV4dFwiLCBwbGFjZWhvbGRlcjogXCJMZWFndWUgTmFtZVwiIH1cbiAgICAgICAgfSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImljb24gaXMtc21hbGwgaXMtbGVmdFwiIH0sIFtcbiAgICAgICAgICBfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJmYSBmYS10cm9waHlcIiB9KVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZpZWxkXCIgfSwgW1xuICAgICAgX2MoXCJsYWJlbFwiLCBbX3ZtLl92KFwiTGVhZ3VlIFBhc3N3b3JkXCIpXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCIgfSwgW1xuICAgICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJpbnB1dFwiLFxuICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwidGV4dFwiLCBwbGFjZWhvbGRlcjogXCJMZWFndWUgUGFzc3dvcmRcIiB9XG4gICAgICAgIH0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIiB9LCBbXG4gICAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiZmEgZmEtbG9ja1wiIH0pXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pXG4gIH0sXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZmllbGRcIiB9LCBbXG4gICAgICBfYyhcImxhYmVsXCIsIFtfdm0uX3YoXCJNYXggUGxheWVyc1wiKV0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiIH0sIFtcbiAgICAgICAgX2MoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwiaW5wdXRcIixcbiAgICAgICAgICBhdHRyczogeyB0eXBlOiBcIm51bWJlclwiLCBwbGFjZWhvbGRlcjogXCJNYXggUGxheWVyc1wiIH1cbiAgICAgICAgfSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImljb24gaXMtc21hbGwgaXMtbGVmdFwiIH0sIFtcbiAgICAgICAgICBfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJmYSBmYS1oYXNodGFnXCIgfSlcbiAgICAgICAgXSlcbiAgICAgIF0pXG4gICAgXSlcbiAgfSxcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJmaWVsZFwiIH0sIFtcbiAgICAgIF9jKFwiYnV0dG9uXCIsIHsgc3RhdGljQ2xhc3M6IFwiYnV0dG9uXCIgfSwgW192bS5fdihcIlN1Ym1pdFwiKV0pXG4gICAgXSlcbiAgfVxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuZXhwb3J0IGRlZmF1bHQgZXNFeHBvcnRzXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTJiNzcwZDI0XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTJiNzcwZDI0XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL0NyZWF0ZUxlYWd1ZS52dWVcbi8vIG1vZHVsZSBpZCA9IDIzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwibmF2XCIsXG4gICAgeyBzdGF0aWNDbGFzczogXCJuYXZiYXJcIiB9LFxuICAgIFtcbiAgICAgIF92bS5fbSgwKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfdm0uX20oMSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJuYXZiYXItbWVudVwiLCBhdHRyczogeyBpZDogXCJuYXZNZW51XCIgfSB9LCBbXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibmF2YmFyLXN0YXJ0XCIgfSwgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwibmF2YmFyLWl0ZW1cIiB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcInJvdXRlci1saW5rXCIsIHsgYXR0cnM6IHsgdG86IFwiL2hvbWVcIiwgZXhhY3Q6IFwiXCIgfSB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiSG9tZVwiKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIDFcbiAgICAgICAgICApLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX3ZtLkdldEF1dGhTdGF0dXNcbiAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm5hdmJhci1pdGVtXCIgfSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBfYyhcInJvdXRlci1saW5rXCIsIHsgYXR0cnM6IHsgdG86IFwiL215dGVhbVwiIH0gfSwgW1xuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCJNeSBUZWFtXCIpXG4gICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX3ZtLkdldEF1dGhTdGF0dXNcbiAgICAgICAgICAgID8gX2MoXG4gICAgICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIm5hdmJhci1pdGVtXCIgfSxcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBfYyhcInJvdXRlci1saW5rXCIsIHsgYXR0cnM6IHsgdG86IFwiL2xpdmVcIiB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiU3RhdCBUcmFja2VyXCIpXG4gICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJuYXZiYXItaXRlbVwiIH0sXG4gICAgICAgICAgICBbX2MoXCJyb3V0ZXItbGlua1wiLCB7IGF0dHJzOiB7IHRvOiBcIi9ydWxlc1wiIH0gfSwgW192bS5fdihcIkluZm9cIildKV0sXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwibmF2YmFyLWl0ZW1cIiB9LFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBfYyhcInJvdXRlci1saW5rXCIsIHsgYXR0cnM6IHsgdG86IFwiL3N1Z2dlc3Rpb25zXCIgfSB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiU3VnZ2VzdGlvbnNcIilcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAxXG4gICAgICAgICAgKVxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJuYXZiYXItZW5kXCIgfSwgW1xuICAgICAgICAgICFfdm0uR2V0QXV0aFN0YXR1c1xuICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm5hdmJhci1pdGVtXCIsXG4gICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLnNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiAhX3ZtLlNob3dSZWdpc3Rlck1vZGFsIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFtfYyhcImFcIiwgeyBhdHRyczogeyBocmVmOiBcIiMhXCIgfSB9LCBbX3ZtLl92KFwiUmVnaXN0ZXJcIildKV1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICFfdm0uR2V0QXV0aFN0YXR1c1xuICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcIm5hdmJhci1pdGVtXCIsXG4gICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLnNldExvZ2luTW9kYWwoeyBzaG93OiAhX3ZtLlNob3dMb2dpbk1vZGFsIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgIF92bS5fbSgyKSxcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICBfYyhcImFcIiwgeyBhdHRyczogeyBocmVmOiBcIiMhXCIgfSB9LCBbX3ZtLl92KFwiTG9naW5cIildKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF92bS5HZXRBdXRoU3RhdHVzXG4gICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJuYXZiYXItaXRlbVwiIH0sXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgX2MoXCJyb3V0ZXItbGlua1wiLCB7IGF0dHJzOiB7IHRvOiBcIi9teWFjY291bnRcIiB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiV2VsY29tZSwgXCIgKyBfdm0uX3MoX3ZtLmdldFVzZXJEYXRhLnVzZXJuYW1lKSArIFwiIVwiKVxuICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF92bS5HZXRBdXRoU3RhdHVzXG4gICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibmF2YmFyLWl0ZW1cIixcbiAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uc2V0TG9nZ2VkSW4oeyBpc0xvZ2dlZEluOiAhX3ZtLkdldEF1dGhTdGF0dXMgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgX3ZtLkdldEF1dGhTdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgPyBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJpY29uXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJpXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZmEgZmEtc2lnbi1vdXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgIFwiYVwiLFxuICAgICAgICAgICAgICAgICAgICB7IGF0dHJzOiB7IGhyZWY6IFwiIyFcIiB9LCBvbjogeyBjbGljazogX3ZtLmxvZ291dCB9IH0sXG4gICAgICAgICAgICAgICAgICAgIFtfdm0uX3YoXCJMb2dvdXRcIildXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgIF0pXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcInJlZ2lzdGVyXCIsIHsgYXR0cnM6IHsgc2hvdzogX3ZtLlNob3dSZWdpc3Rlck1vZGFsIH0gfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJsb2dpblwiLCB7IGF0dHJzOiB7IHNob3c6IF92bS5TaG93TG9naW5Nb2RhbCB9IH0pXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibmF2YmFyLWJyYW5kXCIgfSwgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJuYXZiYXItaXRlbVwiIH0pXG4gICAgXSlcbiAgfSxcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAge1xuICAgICAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItYnVyZ2VyIGJ1cmdlclwiLFxuICAgICAgICBhdHRyczogeyBcImRhdGEtdGFyZ2V0XCI6IFwibmF2TWVudVwiIH1cbiAgICAgIH0sXG4gICAgICBbX2MoXCJzcGFuXCIpLCBfdm0uX3YoXCIgXCIpLCBfYyhcInNwYW5cIiksIF92bS5fdihcIiBcIiksIF9jKFwic3BhblwiKV1cbiAgICApXG4gIH0sXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImljb25cIiB9LCBbXG4gICAgICBfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJmYSBmYS1zaWduLWluXCIgfSlcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG5leHBvcnQgZGVmYXVsdCBlc0V4cG9ydHNcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMzY3OTQwZDNcIiwgZXNFeHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMzY3OTQwZDNcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcImNvbnRhaW5lciBteWFjY291bnQtY29udGFpbmVyXCIgfSxcbiAgICBbXG4gICAgICBfYyhcInVsXCIsIHsgc3RhdGljQ2xhc3M6IFwidWxcIiB9LCBbXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwibGlcIixcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcInJvdXRlci1saW5rXCIsIHsgYXR0cnM6IHsgdG86IFwiL215YWNjb3VudC9jcmVhdGVsZWFndWVcIiB9IH0sIFtcbiAgICAgICAgICAgICAgX3ZtLl92KFwiQ3JlYXRlIExlYWd1ZVwiKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJsaVwiLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwicm91dGVyLWxpbmtcIiwgeyBhdHRyczogeyB0bzogXCIvbXlhY2NvdW50L2pvaW5sZWFndWVcIiB9IH0sIFtcbiAgICAgICAgICAgICAgX3ZtLl92KFwiSm9pbiBMZWFndWVcIilcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSxcbiAgICAgICAgICAxXG4gICAgICAgICksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwibGlcIixcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcInJvdXRlci1saW5rXCIsIHsgYXR0cnM6IHsgdG86IFwiL215YWNjb3VudC9kZWxldGVhY2NvdW50XCIgfSB9LCBbXG4gICAgICAgICAgICAgIF92bS5fdihcIkRlbGV0ZSBBY2NvdW50XCIpXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIF0sXG4gICAgICAgICAgMVxuICAgICAgICApLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcbiAgICAgICAgICBcImxpXCIsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgX2MoXCJyb3V0ZXItbGlua1wiLCB7IGF0dHJzOiB7IHRvOiBcIi9teWFjY291bnQvdXBncmFkZWFjY291bnRcIiB9IH0sIFtcbiAgICAgICAgICAgICAgX3ZtLl92KFwiVXBncmFkZSBBY2NvdW50XCIpXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIF0sXG4gICAgICAgICAgMVxuICAgICAgICApXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcInJvdXRlci12aWV3XCIpXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuZXhwb3J0IGRlZmF1bHQgZXNFeHBvcnRzXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTNlZmQ5ZjBlXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTNlZmQ5ZjBlXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL215YWNjb3VudC52dWVcbi8vIG1vZHVsZSBpZCA9IDIzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIFtcbiAgICAhX3ZtLmlzTG9hZGluZ1xuICAgICAgPyBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZsZXgtY2VudGVyIGZsIGxpdmUtaGVhZGVyXCIgfSwgW1xuICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibGl2ZS1oZWFkZXItYm94XCIgfSwgW1xuICAgICAgICAgICAgX2MoXCJkaXZcIiwgW1xuICAgICAgICAgICAgICBfdm0uX3YoXCJTZXNzaW9uIEV2ZW50OiBcIiksXG4gICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtaGlnaGxpZ2h0IGZsLXJpZ2h0XCIgfSwgW1xuICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLnJhY2VEYXRhLnJhY2VEYXRhLlMpKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJkaXZcIiwgW1xuICAgICAgICAgICAgICBfdm0uX3YoXCJTZWFzb24gRXZlbnQ6XCIpLFxuICAgICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJ0ZXh0LWhpZ2hsaWdodCBmbC1yaWdodFwiIH0sIFtcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIgKyBfdm0uX3MoX3ZtLnJhY2VEYXRhLnJhY2VEYXRhLkUpKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJkaXZcIiwgW1xuICAgICAgICAgICAgICBfdm0uX3YoXCJTZXNzaW9uIFN0YXR1czpcIiksXG4gICAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcInRleHQtaGlnaGxpZ2h0IGZsLXJpZ2h0XCIgfSwgW1xuICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiArIF92bS5fcyhfdm0ucmFjZURhdGEucmFjZURldGFpbHMuQikpXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgICA6IF92bS5fZSgpLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb2x1bW5zIGxlYWRlcmJvYXJkXCIgfSwgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb2x1bW4gaXMtaGFsZiBpcy1vZmZzZXQtb25lLXF1YXJ0ZXJcIiB9LCBbXG4gICAgICAgICFfdm0uaXNMb2FkaW5nXG4gICAgICAgICAgPyBfYyhcInRhYmxlXCIsIHsgc3RhdGljQ2xhc3M6IFwidGFibGUtbGl2ZVwiIH0sIFtcbiAgICAgICAgICAgICAgX3ZtLl9tKDApLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfdm0uX20oMSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgIFwidGJvZHlcIixcbiAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLnN0YW5kaW5ncywgZnVuY3Rpb24odXNlciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgICAgICAgICAgXCJ0clwiLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXIudXNlcm5hbWUgPT0gX3ZtLmdldFVzZXJEYXRhLnVzZXJuYW1lID8gXCJteVJvd1wiIDogXCJcIlxuICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgIF9jKFwidGRcIiwgW192bS5fdihfdm0uX3MoaW5kZXggKyAxKSArIFwiLlwiKV0pLFxuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCBbX3ZtLl92KF92bS5fcyh1c2VyLnRvdGFsKSldKSxcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgIF9jKFwidGRcIiwgW192bS5fdihfdm0uX3ModXNlci51c2VybmFtZSkpXSksXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInRkXCIsIHsgc3RhdGljQ2xhc3M6IFwicG9pbnRzYmFja1wiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLnBvaW50c2JlaGluZCh1c2VyKSkpXG4gICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgXSlcbiAgICBdKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJ0aGVhZFwiLCBbXG4gICAgICBfYyhcInRyXCIsIFtcbiAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiUG9zaXRpb25cIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiVG90YWwgUG9pbnRzXCIpXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIlVzZXJuYW1lXCIpXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIlBvaW50cyBCYWNrXCIpXSlcbiAgICAgIF0pXG4gICAgXSlcbiAgfSxcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJ0Zm9vdFwiLCBbXG4gICAgICBfYyhcInRyXCIsIFtcbiAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiUG9zaXRpb25cIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiVG90YWwgUG9pbnRzXCIpXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIlVzZXJuYW1lXCIpXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwidGhcIiwgW192bS5fdihcIlBvaW50cyBCYWNrXCIpXSlcbiAgICAgIF0pXG4gICAgXSlcbiAgfVxuXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuZXhwb3J0IGRlZmF1bHQgZXNFeHBvcnRzXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LTNmYzM1ODllXCIsIGVzRXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTNmYzM1ODllXCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL3N0YXR0cmFja2VyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBzdGF0aWNDbGFzczogXCJkcm9wZG93blwiLFxuICAgICAgY2xhc3M6IHsgXCJpcy1hY3RpdmVcIjogX3ZtLmlzQWN0aXZlIH0sXG4gICAgICBvbjoge1xuICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLmlzQWN0aXZlID0gIV92bS5pc0FjdGl2ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImRyb3Bkb3duLXRyaWdnZXJcIiB9LCBbXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwiaDNcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhdHRyczogeyBcImFyaWEtaGFzcG9wdXBcIjogXCJ0cnVlXCIsIFwiYXJpYS1jb250cm9sc1wiOiBcImRyb3Bkb3duLW1lbnVcIiB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcInNwYW5cIiwgW1xuICAgICAgICAgICAgICBfdm0uX3YoXCJDdXJyZW50bHkgTWFuYWdpbmc6IFwiICsgX3ZtLl9zKF92bS5NYW5hZ2VkTGVhZ3VlLm5hbWUpKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX3ZtLl9tKDApXG4gICAgICAgICAgXVxuICAgICAgICApXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImRyb3Bkb3duLW1lbnVcIixcbiAgICAgICAgICBhdHRyczogeyBpZDogXCJkcm9wZG93bi1tZW51XCIsIHJvbGU6IFwibWVudVwiIH1cbiAgICAgICAgfSxcbiAgICAgICAgX3ZtLl9sKF92bS5MZWFndWVMaXN0LCBmdW5jdGlvbihsZWFndWUpIHtcbiAgICAgICAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJkcm9wZG93bi1jb250ZW50XCIgfSwgW1xuICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgIFwiYVwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZHJvcGRvd24taXRlbVwiLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IGhyZWY6IFwiI1wiIH0sXG4gICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLmNoYW5nZUxlYWd1ZShsZWFndWUpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBbX3ZtLl92KFwiXFxuICAgICAgICBcIiArIF92bS5fcyhsZWFndWUubmFtZSkgKyBcIlxcbiAgICAgIFwiKV1cbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIF1cbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiaWNvbiBpcy1zbWFsbFwiIH0sIFtcbiAgICAgIF9jKFwiaVwiLCB7XG4gICAgICAgIHN0YXRpY0NsYXNzOiBcImZhIGZhLWFuZ2xlLWRvd25cIixcbiAgICAgICAgYXR0cnM6IHsgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiB9XG4gICAgICB9KVxuICAgIF0pXG4gIH1cbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmV4cG9ydCBkZWZhdWx0IGVzRXhwb3J0c1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi00ZDg4ZmQ4NFwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00ZDg4ZmQ4NFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXJEcm9wZG93bi52dWVcbi8vIG1vZHVsZSBpZCA9IDIzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAgeyBhdHRyczogeyBpZDogXCJhcHBcIiB9IH0sXG4gICAgW19jKFwibmF2aWdhdGlvblwiKSwgX3ZtLl92KFwiIFwiKSwgX2MoXCJyb3V0ZXItdmlld1wiKV0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmV4cG9ydCBkZWZhdWx0IGVzRXhwb3J0c1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi02ZGU1YWIzNFwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi02ZGU1YWIzNFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9pbmRleC52dWVcbi8vIG1vZHVsZSBpZCA9IDIzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIFtcbiAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbHVtbnMgbGVhZGVyYm9hcmRcIiB9LCBbXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbHVtbiBpcy1oYWxmIGlzLW9mZnNldC1vbmUtcXVhcnRlclwiIH0sIFtcbiAgICAgICAgX3ZtLmRvbmVMb2FkaW5nXG4gICAgICAgICAgPyBfYyhcInRhYmxlXCIsIHsgc3RhdGljQ2xhc3M6IFwibGVhZGVyYm9hcmQtdGFibGVcIiB9LCBbXG4gICAgICAgICAgICAgIF92bS5fbSgwKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX3ZtLl9tKDEpLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcInRib2R5XCIsXG4gICAgICAgICAgICAgICAgX3ZtLl9sKF92bS5zdGFuZGluZ3MsIGZ1bmN0aW9uKHVzZXIsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2MoXCJ0clwiLCB7IGNsYXNzOiB7IE1lOiBfdm0uSXNNZSh1c2VyKSB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJ0ZFwiLCBbX3ZtLl92KF92bS5fcyhpbmRleCArIDEpICsgXCIuXCIpXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwidGRcIiwgW192bS5fdihfdm0uX3ModXNlci50b3RhbHBvaW50cykpXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwidGRcIiwgW192bS5fdihfdm0uX3ModXNlci53ZWVrbHl0ZWFtc1swXS51c2VybmFtZSkpXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwidGRcIiwgeyBjbGFzczogeyBwb2ludHNiYWNrOiBpbmRleCA+IDAgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhfdm0ucG9pbnRzYmVoaW5kKHVzZXIpKSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAhX3ZtLmRvbmVMb2FkaW5nXG4gICAgICAgICAgPyBfYyhcImRpdlwiLCBbXG4gICAgICAgICAgICAgIF9jKFwicFwiLCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgJ1wiVGhpcyBkYXRhIGRvZXNuXFwndCBmZXRjaCBpdHNlbGYuLiBMb2FkaW5nIFJhY2UgVHJhY2tlci5cIidcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgIF0pXG4gICAgXSlcbiAgXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwidGhlYWRcIiwgW1xuICAgICAgX2MoXCJ0clwiLCB7IHN0YXRpY0NsYXNzOiBcInRpdGxlXCIgfSwgW1xuICAgICAgICBfYyhcInRoXCIsIHsgYXR0cnM6IHsgY29sc3BhbjogXCI0XCIgfSB9LCBbXG4gICAgICAgICAgX3ZtLl92KFwiMjAxOCBGYW50YXN5IFNYOiBNYWluIExlYWd1ZSBTdGFuZGluZ3NcIilcbiAgICAgICAgXSlcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwidHJcIiwgW1xuICAgICAgICBfYyhcInRoXCIsIFtfdm0uX3YoXCJQb3NpdGlvblwiKV0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcInRoXCIsIFtfdm0uX3YoXCJUb3RhbCBQb2ludHNcIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiVXNlcm5hbWVcIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiUG9pbnRzIEJhY2tcIildKVxuICAgICAgXSlcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcInRmb290XCIsIFtcbiAgICAgIF9jKFwidHJcIiwgW1xuICAgICAgICBfYyhcInRoXCIsIFtfdm0uX3YoXCJQb3NpdGlvblwiKV0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcInRoXCIsIFtfdm0uX3YoXCJUb3RhbCBQb2ludHNcIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiVXNlcm5hbWVcIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJ0aFwiLCBbX3ZtLl92KFwiUG9pbnRzIEJhY2tcIildKVxuICAgICAgXSlcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG5leHBvcnQgZGVmYXVsdCBlc0V4cG9ydHNcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNzFkY2JjNGFcIiwgZXNFeHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtNzFkY2JjNGFcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbGVhZGVyYm9hcmQudnVlXG4vLyBtb2R1bGUgaWQgPSAyMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfdm0uX20oMClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29udGFpbmVyXCIgfSwgW1xuICAgICAgX2MoXCJkaXZcIiwge30sIFtcbiAgICAgICAgX2MoXCJwXCIsIFtfdm0uX3YoXCJSdWxlc1wiKV0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInRhYlwiIH0sIFtcbiAgICAgICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7IGlkOiBcInRhYi1vbmVcIiwgdHlwZTogXCJjaGVja2JveFwiLCBuYW1lOiBcInRhYnNcIiB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImxhYmVsXCIsIHsgYXR0cnM6IHsgZm9yOiBcInRhYi1vbmVcIiB9IH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIkhvdyBkb2VzIHNjb3Jpbmcgd29yaz9cIilcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidGFiLWNvbnRlbnRcIiB9LCBbXG4gICAgICAgICAgICBfYyhcInBcIiwgW1xuICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgXCJSaWdodCBub3csIHNjb3JpbmcgaXMgc2V0IGJ5IHJhY2VyIGZpbmlzaC4gSWYgYSBzZWxlY3RlZCByYWNlciBmb3IgdGhhdCB3ZWVrIGZpbmlzaGVzIGluIGZpcnN0LCB0aGF0IHJhY2VyIGlzIGF3YXJkZWQgMSBwb2ludC4gSWYgYSByYWNlciBmaW5pc2hlcyBpbiBmb3VydGgsIHRoYXQgcmFjZXIgaXMgYXdhcmRlZCA0IHBvaW50cy4gVGhlIGxvd2VyIHRoZSBwb2ludCB0b3RhbCB0aGUgYmV0dGVyIHNjb3JlLlwiXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSlcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidGFiXCIgfSwgW1xuICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgYXR0cnM6IHsgaWQ6IFwidGFiLXR3b1wiLCB0eXBlOiBcImNoZWNrYm94XCIsIG5hbWU6IFwidGFic1wiIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwibGFiZWxcIiwgeyBhdHRyczogeyBmb3I6IFwidGFiLXR3b1wiIH0gfSwgW1xuICAgICAgICAgICAgX3ZtLl92KFwiSG93IGRvZXMgdGVhbSBzZWxlY3Rpb24gd29yaz9cIilcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidGFiLWNvbnRlbnRcIiB9LCBbXG4gICAgICAgICAgICBfYyhcInBcIiwgW1xuICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgXCJBcyBvZiBub3csIGVhY2ggdXNlciBpcyBSRVFVSVJFRCB0byBzZWxlY3QgNCByYWNlcnMgZm9yIGVhY2ggd2Vlay4gVGhlIGRlYWRsaW5lIGZvciBtYWtpbmcgcmFjZXIgc2VsZWN0aW9uIGlzIDNhbSBNb3VudGFpbiBUaW1lIG9uIHRoZSBkYXkgb2YgdGhlIHNjaGVkdWxlZCByYWNlLiBBZnRlciB0aGF0IHRpbWVcXG4gICAgICAgICAgdXNlcnMgd2lsbCBubyBsb25nZXIgYmUgYWJsZSB0byBzZWxlY3QgcmFjZXJzIGZvciB0aGF0IHdlZWsncyByYWNlOyB0aGUgdGVhbSBzZWxlY3Rpb24gZm9yIHRoZSBuZXh0IHdlZWsgd2lsbCBiZSBhdmFpbGFibGUgZm9yIHNlbGVjdGlvblwiXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFwicFwiLCBbXG4gICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICBcIlVzZXJzIG1heSBvbmx5IFNBVkUgYSByb3N0ZXIgaWYgQUxMIDQgcm9zdGVyIHNsb3RzIGhhdmUgYSByYWNlciBjaG9zZW4uIFRoZSBTQVZFIGJ1dHRvbiBpcyBkaXNhYmxlZCBpZiBhbiBPUEVOIFNMT1Qgc3RpbGwgZXhpc3RzIGZvciBhIHdlZWtseSBsaW5ldXAuXCJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJwXCIsIFtcbiAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgIFwiRWFjaCB1c2VyIGJlZ2lucyBlYWNoIHdlZWsgd2l0aCAkMTAsMDAwIHNhbGFyeSBjYXAgdG8gc3BlbmQgb24gZmlsbGluZyBvdXQgdGhlaXIgd2Vla2x5IGxpbmV1cCwgYW5kIHRoYXQgY2FwIHJvb20gaXMgdXNlZCB0byBzZWxlY3QgcmFjZXJzIGZvciB0aGVpciB3ZWVrJ3MgbGluZXVwIGZyb20gdGhlIGF2YWlsYWJsZSByYWNlcnMgcG9vbC5cXG4gICAgICAgICAgVGhlIHNlbGVjdGVkIHJhY2VyJ3MgY29zdCwgb25jZSBzZWxlY3RlZCwgd2lsbCBiZSBkZWR1Y3RlZCBmcm9tIHRoZSBjdXJyZW50IHdlZWsncyBhdmFpbGFibGUgc2FsYXJ5IGNhcC4gWW91IGFyZSBOT1QgUkVRVUlSRUQgdG8gdXRpbGl6ZSB5b3VyIGVudGlyZSBjYXAgc3BhY2UgZWFjaCB3ZWVrLlwiXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSlcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwidGFiXCIgfSwgW1xuICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgYXR0cnM6IHsgaWQ6IFwidGFiLXRocmVlXCIsIHR5cGU6IFwiY2hlY2tib3hcIiwgbmFtZTogXCJ0YWJzXCIgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJsYWJlbFwiLCB7IGF0dHJzOiB7IGZvcjogXCJ0YWItdGhyZWVcIiB9IH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIkN1c3RvbSBMZWFndWVzXCIpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInRhYi1jb250ZW50XCIgfSwgW1xuICAgICAgICAgICAgX2MoXCJwXCIsIFtcbiAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgIFwiQ3VycmVudGx5LCB0aGUgYXBwbGljYXRpb24gZG9lcyBub3Qgc3VwcG9ydCBjdXN0b20gLyBwcml2YXRlIGxlYWd1ZXM7IFdlIGFyZSBsb29raW5nIGludG8gaG93IGJlc3QgdG8gaW5jb3Jwb3JhdGUgdGhpcyBmZWF0dXJlIHdpdGggdGhlIFVJLiBJZiB5b3UgaGF2ZSBzdWdnZXN0aW9ucyBwbGVhc2UgbGV0IHVzIGtub3dcXG4gICAgICAgIGJ5IGRyb3BwaW5nIGEgc3VnZ2VzdGlvbi5cIlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pXG4gIH1cbl1cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmV4cG9ydCBkZWZhdWx0IGVzRXhwb3J0c1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi03NWVmM2M4NFwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi03NWVmM2M4NFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9ydWxlcy52dWVcbi8vIG1vZHVsZSBpZCA9IDIzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwibW9kYWxcIixcbiAgICAgIGNsYXNzOiB7IFwiaXMtYWN0aXZlXCI6IF92bS5TaG93UmVnaXN0ZXJNb2RhbCB9LFxuICAgICAgYXR0cnM6IHsgaWQ6IFwicmVnaXN0ZXJNb2RhbFwiIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibW9kYWwtYmFja2dyb3VuZFwiIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibW9kYWwtY2FyZFwiIH0sIFtcbiAgICAgICAgX2MoXCJoZWFkZXJcIiwgeyBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkLWhlYWRcIiB9LCBbXG4gICAgICAgICAgX2MoXCJwXCIsIHsgc3RhdGljQ2xhc3M6IFwibW9kYWwtY2FyZC10aXRsZVwiIH0sIFtcbiAgICAgICAgICAgIF92bS5fdihcIk5ldyBVc2VyIFJlZ2lzdHJhdGlvblwiKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZGVsZXRlXCIsXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgX3ZtLnNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiAhX3ZtLlNob3dSZWdpc3Rlck1vZGFsIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJzZWN0aW9uXCIsIHsgc3RhdGljQ2xhc3M6IFwibW9kYWwtY2FyZC1ib2R5XCIgfSwgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwiY29udGVudFwiIH0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZmllbGRcIiB9LCBbXG4gICAgICAgICAgICAgICAgX2MoXCJsYWJlbFwiLCB7IHN0YXRpY0NsYXNzOiBcImxhYmVsXCIgfSwgW192bS5fdihcIlVzZXJuYW1lOiBcIildKSxcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiIH0sIFtcbiAgICAgICAgICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJ1c2VybmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczogeyBcImlzLWRhbmdlclwiOiBfdm0uaW52YWxpZFVzZXJuYW1lIH0sXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IFwicmVnLXVzZXJuYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiVXNlcm5hbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogX3ZtLnVzZXJuYW1lIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnVzZXJuYW1lID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgX3ZtLl9tKDApXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZmllbGRcIiB9LCBbXG4gICAgICAgICAgICAgICAgX2MoXCJsYWJlbFwiLCB7IHN0YXRpY0NsYXNzOiBcImxhYmVsXCIgfSwgW192bS5fdihcIkVtYWlsOiBcIildKSxcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiIH0sIFtcbiAgICAgICAgICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLmVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJlbWFpbFwiXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczogeyBcImlzLWRhbmdlclwiOiBfdm0uaW52YWxpZEVtYWlsIH0sXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlbWFpbFwiLFxuICAgICAgICAgICAgICAgICAgICAgIGlkOiBcInJlZy1lbWFpbFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIkVtYWlsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5lbWFpbCB9LFxuICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5lbWFpbCA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgIF92bS5fbSgxKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZpZWxkXCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFwibGFiZWxcIiwgeyBzdGF0aWNDbGFzczogXCJsYWJlbFwiIH0sIFtfdm0uX3YoXCJQYXNzd29yZDogXCIpXSksXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbnRyb2wgaGFzLWljb25zLWxlZnRcIiB9LCBbXG4gICAgICAgICAgICAgICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwicGFzc3dvcmRcIlxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiaW5wdXRcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IHsgXCJpcy1kYW5nZXJcIjogX3ZtLmJsYW5rUGFzc3dvcmQgfSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBhc3N3b3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiUGFzc3dvcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogX3ZtLnBhc3N3b3JkIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnBhc3N3b3JkID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgX3ZtLl9tKDIpXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF92bS5fbSgzKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgX3ZtLl9sKF92bS5lcnJvck1lc3NhZ2UsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF92bS5lcnJvck1lc3NhZ2UgIT0gXCJcIlxuICAgICAgICAgICAgICAgICAgPyBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImVycm9yTWVzc2FnZVwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICBcIiArIF92bS5fcyhlcnJvcikgKyBcIlxcbiAgICAgICAgICBcIilcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKVxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJmb290ZXJcIiwgeyBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkLWZvb3RcIiB9LCBbXG4gICAgICAgICAgX2MoXG4gICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJidXR0b24gaXMtc3VjY2Vzc1wiLFxuICAgICAgICAgICAgICBjbGFzczogeyBcImlzLWxvYWRpbmdcIjogX3ZtLmlzTG9hZGluZyB9LFxuICAgICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLlJlZ2lzdGVyIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBbX3ZtLl92KFwiUmVnaXN0ZXJcIildXG4gICAgICAgICAgKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgX3ZtLnNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiAhX3ZtLlNob3dSZWdpc3Rlck1vZGFsIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW192bS5fdihcIkNhbmNlbFwiKV1cbiAgICAgICAgICApXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF1cbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCIgfSwgW1xuICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiZmEgZmEtdXNlclwiIH0pXG4gICAgXSlcbiAgfSxcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCIgfSwgW1xuICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiZmEgZmEtZW52ZWxvcGVcIiB9KVxuICAgIF0pXG4gIH0sXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImljb24gaXMtc21hbGwgaXMtbGVmdFwiIH0sIFtcbiAgICAgIF9jKFwiaVwiLCB7IHN0YXRpY0NsYXNzOiBcImZhIGZhLWxvY2tcIiB9KVxuICAgIF0pXG4gIH0sXG4gIGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdm0gPSB0aGlzXG4gICAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gICAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gICAgcmV0dXJuIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZmllbGRcIiB9LCBbXG4gICAgICBfYyhcImRpdlwiLCB7IGF0dHJzOiB7IGlkOiBcInJlZ2lzdGVyLXJlY2FwdGNoYVwiIH0gfSlcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG5leHBvcnQgZGVmYXVsdCBlc0V4cG9ydHNcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtN2I4YTE5YjRcIiwgZXNFeHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtN2I4YTE5YjRcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCBbXG4gICAgX3ZtLmdldFVzZXJEYXRhLmFjY291bnR0eXBlID4gMFxuICAgICAgPyBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbHVtbiBpcy1oYWxmIGlzLW9mZnNldC1vbmUtcXVhcnRlclwiIH0sIFtcbiAgICAgICAgICBfdm0uX20oMCksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfdm0uX20oMSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfdm0uX20oMilcbiAgICAgICAgXSlcbiAgICAgIDogX3ZtLl9lKCksXG4gICAgX3ZtLl92KFwiIFwiKSxcbiAgICBfdm0uZ2V0VXNlckRhdGEuYWNjb3VudHR5cGUgPT0gMFxuICAgICAgPyBfYyhcImRpdlwiLCBbXG4gICAgICAgICAgX2MoXCJwXCIsIHsgc3RhdGljQ2xhc3M6IFwiYm9sZC1tZXNzYWdlXCIgfSwgW1xuICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICBcIlRoaXMgZmVhdHVyZSByZXF1aXJlcyBhdCBsZWFzdCBhIEJhc2ljIGFjY291bnQuIFBsZWFzZSB1cGdyYWRlIHlvdXIgYWNjb3VudCBpbiBvcmRlciB0byBhY3RpdmF0ZSB0aGlzIGZlYXR1cmUuXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKVxuICAgICAgICBdKVxuICAgICAgOiBfdm0uX2UoKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJmaWVsZFwiIH0sIFtcbiAgICAgIF9jKFwibGFiZWxcIiwgW192bS5fdihcIkxlYWd1ZSBOYW1lXCIpXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCIgfSwgW1xuICAgICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgICBzdGF0aWNDbGFzczogXCJpbnB1dFwiLFxuICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwidGV4dFwiLCBwbGFjZWhvbGRlcjogXCJMZWFndWUgSURcIiB9XG4gICAgICAgIH0pLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIiB9LCBbXG4gICAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwiZmEgZmEtdHJvcGh5XCIgfSlcbiAgICAgICAgXSlcbiAgICAgIF0pXG4gICAgXSlcbiAgfSxcbiAgZnVuY3Rpb24oKSB7XG4gICAgdmFyIF92bSA9IHRoaXNcbiAgICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJmaWVsZFwiIH0sIFtcbiAgICAgIF9jKFwibGFiZWxcIiwgW192bS5fdihcIkxlYWd1ZSBQYXNzd29yZFwiKV0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiIH0sIFtcbiAgICAgICAgX2MoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwiaW5wdXRcIixcbiAgICAgICAgICBhdHRyczogeyB0eXBlOiBcInRleHRcIiwgcGxhY2Vob2xkZXI6IFwiTGVhZ3VlIFBhc3N3b3JkXCIgfVxuICAgICAgICB9KSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCIgfSwgW1xuICAgICAgICAgIF9jKFwiaVwiLCB7IHN0YXRpY0NsYXNzOiBcImZhIGZhLWxvY2tcIiB9KVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICBdKVxuICB9LFxuICBmdW5jdGlvbigpIHtcbiAgICB2YXIgX3ZtID0gdGhpc1xuICAgIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICAgIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICAgIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZpZWxkXCIgfSwgW1xuICAgICAgX2MoXCJidXR0b25cIiwgeyBzdGF0aWNDbGFzczogXCJidXR0b25cIiB9LCBbX3ZtLl92KFwiU3VibWl0XCIpXSlcbiAgICBdKVxuICB9XG5dXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbnZhciBlc0V4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG5leHBvcnQgZGVmYXVsdCBlc0V4cG9ydHNcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtZTNmZjlhYzhcIiwgZXNFeHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtZTNmZjlhYzhcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvam9pbmxlYWd1ZS52dWVcbi8vIG1vZHVsZSBpZCA9IDIzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgc3RhdGljQ2xhc3M6IFwibW9kYWxcIixcbiAgICAgIGNsYXNzOiB7IFwiaXMtYWN0aXZlXCI6IF92bS5zaG93IH0sXG4gICAgICBhdHRyczogeyBpZDogXCJsb2dpbk1vZGFsXCIgfVxuICAgIH0sXG4gICAgW1xuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJtb2RhbC1iYWNrZ3JvdW5kXCIgfSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkXCIgfSwgW1xuICAgICAgICBfYyhcImhlYWRlclwiLCB7IHN0YXRpY0NsYXNzOiBcIm1vZGFsLWNhcmQtaGVhZFwiIH0sIFtcbiAgICAgICAgICBfYyhcInBcIiwgeyBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkLXRpdGxlXCIgfSwgW192bS5fdihcIlVzZXIgTG9naW5cIildKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImRlbGV0ZVwiLFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgIF92bS5zZXRMb2dpbk1vZGFsKHsgc2hvdzogIV92bS5TaG93TG9naW5Nb2RhbCB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwic2VjdGlvblwiLCB7IHN0YXRpY0NsYXNzOiBcIm1vZGFsLWNhcmQtYm9keVwiIH0sIFtcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbnRlbnRcIiB9LCBbXG4gICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZpZWxkXCIgfSwgW1xuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcImxhYmVsXCIsXG4gICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJsYWJlbFwiLCBhdHRyczogeyBmb3I6IFwicmVnLXVzZXJuYW1lXCIgfSB9LFxuICAgICAgICAgICAgICAgIFtfdm0uX3YoXCJVc2VybmFtZTogXCIpXVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbnRyb2xcIiB9LCBbXG4gICAgICAgICAgICAgICAgX2MoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS51c2VybmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcInVzZXJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcInRleHRcIiB9LFxuICAgICAgICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS51c2VybmFtZSB9LFxuICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF92bS51c2VybmFtZSA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZpZWxkXCIgfSwgW1xuICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICBcImxhYmVsXCIsXG4gICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJsYWJlbFwiLCBhdHRyczogeyBmb3I6IFwicmVnLXBhc3N3b3JkXCIgfSB9LFxuICAgICAgICAgICAgICAgIFtfdm0uX3YoXCJQYXNzd29yZDogXCIpXVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbnRyb2xcIiB9LCBbXG4gICAgICAgICAgICAgICAgX2MoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5wYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcInBhc3N3b3JkXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImlucHV0XCIsXG4gICAgICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcInBhc3N3b3JkXCIsIGlkOiBcInJlZy1wYXNzd29yZFwiIH0sXG4gICAgICAgICAgICAgICAgICBkb21Qcm9wczogeyB2YWx1ZTogX3ZtLnBhc3N3b3JkIH0sXG4gICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLnBhc3N3b3JkID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IGF0dHJzOiB7IGlkOiBcImxvZ2luLXJlY2FwdGNoYVwiIH0gfSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfdm0uZXJyb3JNZXNzYWdlICE9IFwiXCJcbiAgICAgICAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJlcnJvck1lc3NhZ2VcIiB9LCBbXG4gICAgICAgICAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgIFwiICsgX3ZtLl9zKF92bS5lcnJvck1lc3NhZ2UpICsgXCJcXG4gICAgICAgIFwiKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICBdKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJmb290ZXJcIiwgeyBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkLWZvb3RcIiB9LCBbXG4gICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJmaWVsZFwiIH0sIFtcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiYnV0dG9uIGlzLXByaW1hcnlcIixcbiAgICAgICAgICAgICAgICBjbGFzczogeyBcImlzLWxvYWRpbmdcIjogX3ZtLmlzTG9hZGluZyB9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwiYnV0dG9uXCIsIHZhbHVlOiBcIkxvZ2luXCIsIGlkOiBcInN1Ym1pdC1sb2dpblwiIH0sXG4gICAgICAgICAgICAgICAgb246IHsgY2xpY2s6IF92bS5zdWJtaXQgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBbX3ZtLl92KFwiTG9naW5cIildXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImFcIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF92bS5zZXRMb2dpbk1vZGFsKHsgc2hvdzogIV92bS5TaG93TG9naW5Nb2RhbCB9KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgW192bS5fdihcIkNhbmNlbFwiKV1cbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICBdXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG52YXIgZXNFeHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuZXhwb3J0IGRlZmF1bHQgZXNFeHBvcnRzXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LWU5Yzk0YzE0XCIsIGVzRXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LWU5Yzk0YzE0XCIsXCJoYXNTY29wZWRcIjpmYWxzZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL2xvZ2luLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb250YWluZXIgc3VnZ2VzdGlvbnMtY29udGFpbmVyXCIgfSwgW1xuICAgIF9jKFwic2VjdGlvblwiLCBbXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZpZWxkXCIgfSwgW1xuICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbnRyb2xcIiB9LCBbXG4gICAgICAgICAgX2MoXCJsYWJlbFwiLCBbX3ZtLl92KFwiQXJlIHlvdSBhIHJlZ2lzdGVyZWQgdXNlcj9cIildKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwibGFiZWxcIiwgeyBzdGF0aWNDbGFzczogXCJyYWRpb1wiIH0sIFtcbiAgICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLlJlZ2lzdGVyZWQsXG4gICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcIlJlZ2lzdGVyZWRcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJyYWRpb1wiLCBuYW1lOiBcIlJlZ2lzdGVyZWRcIiwgdmFsdWU6IFwidHJ1ZVwiIH0sXG4gICAgICAgICAgICAgIGRvbVByb3BzOiB7IGNoZWNrZWQ6IF92bS5fcShfdm0uUmVnaXN0ZXJlZCwgXCJ0cnVlXCIpIH0sXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgY2hhbmdlOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgIF92bS5SZWdpc3RlcmVkID0gXCJ0cnVlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgICAgWWVzXFxuICAgICAgICAgIFwiKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJsYWJlbFwiLCB7IHN0YXRpY0NsYXNzOiBcInJhZGlvXCIgfSwgW1xuICAgICAgICAgICAgX2MoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uUmVnaXN0ZXJlZCxcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiUmVnaXN0ZXJlZFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcInJhZGlvXCIsIG5hbWU6IFwiUmVnaXN0ZXJlZFwiLCB2YWx1ZTogXCJmYWxzZVwiIH0sXG4gICAgICAgICAgICAgIGRvbVByb3BzOiB7IGNoZWNrZWQ6IF92bS5fcShfdm0uUmVnaXN0ZXJlZCwgXCJmYWxzZVwiKSB9LFxuICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICBfdm0uUmVnaXN0ZXJlZCA9IFwiZmFsc2VcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICBOb1xcbiAgICAgICAgICBcIilcbiAgICAgICAgICBdKVxuICAgICAgICBdKVxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJmaWVsZFwiIH0sIFtcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb250cm9sXCIgfSwgW1xuICAgICAgICAgIF9jKFwibGFiZWxcIiwgW192bS5fdihcIklzIHRoaXMgZmVlZGJhY2sgb3IgYSBidWcgcmVwb3J0P1wiKV0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJsYWJlbFwiLCB7IHN0YXRpY0NsYXNzOiBcInJhZGlvXCIgfSwgW1xuICAgICAgICAgICAgX2MoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uUmVwb3J0VHlwZSxcbiAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiUmVwb3J0VHlwZVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcInJhZGlvXCIsIG5hbWU6IFwiZmVlZGJhY2tcIiwgdmFsdWU6IFwiZmVlZGJhY2tcIiB9LFxuICAgICAgICAgICAgICBkb21Qcm9wczogeyBjaGVja2VkOiBfdm0uX3EoX3ZtLlJlcG9ydFR5cGUsIFwiZmVlZGJhY2tcIikgfSxcbiAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgX3ZtLlJlcG9ydFR5cGUgPSBcImZlZWRiYWNrXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgICAgRmVlZGJhY2tcXG4gICAgICAgICAgXCIpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImxhYmVsXCIsIHsgc3RhdGljQ2xhc3M6IFwicmFkaW9cIiB9LCBbXG4gICAgICAgICAgICBfYyhcImlucHV0XCIsIHtcbiAgICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5SZXBvcnRUeXBlLFxuICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJSZXBvcnRUeXBlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGF0dHJzOiB7IHR5cGU6IFwicmFkaW9cIiwgbmFtZTogXCJmZWVkYmFja1wiLCB2YWx1ZTogXCJidWdcIiB9LFxuICAgICAgICAgICAgICBkb21Qcm9wczogeyBjaGVja2VkOiBfdm0uX3EoX3ZtLlJlcG9ydFR5cGUsIFwiYnVnXCIpIH0sXG4gICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgY2hhbmdlOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgIF92bS5SZXBvcnRUeXBlID0gXCJidWdcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICBCdWcgUmVwb3J0XFxuICAgICAgICAgIFwiKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgICBdKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZpZWxkXCIgfSwgW1xuICAgICAgICBfYyhcImxhYmVsXCIsIHsgc3RhdGljQ2xhc3M6IFwibGFiZWxcIiB9LCBbX3ZtLl92KFwiVXNlcm5hbWVcIildKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb250cm9sXCIgfSwgW1xuICAgICAgICAgIF9jKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uVXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJVc2VybmFtZVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJpbnB1dFwiLFxuICAgICAgICAgICAgYXR0cnM6IHsgdHlwZTogXCJ0ZXh0XCIsIHBsYWNlaG9sZGVyOiBcIlVzZXJuYW1lXCIgfSxcbiAgICAgICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0uVXNlcm5hbWUgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGlucHV0OiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdm0uVXNlcm5hbWUgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICBdKVxuICAgICAgXSksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLlJlcG9ydFR5cGUgPT0gXCJmZWVkYmFja1wiXG4gICAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJmaWVsZFwiIH0sIFtcbiAgICAgICAgICAgIF9jKFwibGFiZWxcIiwgeyBzdGF0aWNDbGFzczogXCJsYWJlbFwiIH0sIFtfdm0uX3YoXCJTdWdnZXN0IEZlYXR1cmVzXCIpXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb250cm9sXCIgfSwgW1xuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInNlbGVjdFwiIH0sIFtcbiAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgIFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uZmVhdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiZmVhdHVyZVwiXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJCRzZWxlY3RlZFZhbCA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLCBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG8uc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IFwiX3ZhbHVlXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5mZWF0dXJlID0gJGV2ZW50LnRhcmdldC5tdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICQkc2VsZWN0ZWRWYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAkJHNlbGVjdGVkVmFsWzBdXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBfYyhcIm9wdGlvblwiLCB7IGF0dHJzOiB7IGRpc2FibGVkOiBcIlwiLCB2YWx1ZTogXCJcIiB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCJTRUxFQ1QgQ0FURUdPUllcIilcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwib3B0aW9uXCIsIFtfdm0uX3YoXCJVc2VyIEludGVyZmFjZVwiKV0pLFxuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICBfYyhcIm9wdGlvblwiLCBbX3ZtLl92KFwiTmF2aWdhdGlvbiBDb250ZW50XCIpXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwib3B0aW9uXCIsIFtfdm0uX3YoXCJNeSBUZWFtXCIpXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwib3B0aW9uXCIsIFtfdm0uX3YoXCJTY29yaW5nXCIpXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwib3B0aW9uXCIsIFtfdm0uX3YoXCJOZXcgRmVhdHVyZXNcIildKSxcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgX2MoXCJvcHRpb25cIiwgW192bS5fdihcIlN0YXQgVHJhY2tlclwiKV0pLFxuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICBfYyhcIm9wdGlvblwiLCBbX3ZtLl92KFwiQWNjb3VudFwiKV0pXG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICBdKVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5SZXBvcnRUeXBlID09IFwiZmVlZGJhY2tcIlxuICAgICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZmllbGRcIiB9LCBbXG4gICAgICAgICAgICBfYyhcImxhYmVsXCIsIHsgc3RhdGljQ2xhc3M6IFwibGFiZWxcIiB9LCBbX3ZtLl92KFwiRmVlZGJhY2tcIildKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbnRyb2xcIiB9LCBbXG4gICAgICAgICAgICAgIF9jKFwidGV4dGFyZWFcIiwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5mZWVkYmFjayxcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogXCJmZWVkYmFja1wiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0ZXh0YXJlYVwiLFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7IHBsYWNlaG9sZGVyOiBcIkRlc2NyaWJlIHlvdXIgc3VnZ2VzdGlvbnMgaGVyZS5cIiB9LFxuICAgICAgICAgICAgICAgIGRvbVByb3BzOiB7IHZhbHVlOiBfdm0uZmVlZGJhY2sgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdm0uZmVlZGJhY2sgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICBdKVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF92bS5SZXBvcnRUeXBlID09IFwiYnVnXCJcbiAgICAgICAgPyBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZpZWxkXCIgfSwgW1xuICAgICAgICAgICAgX2MoXCJsYWJlbFwiLCB7IHN0YXRpY0NsYXNzOiBcImxhYmVsXCIgfSwgW192bS5fdihcIlJlcG9ydCBCdWdcIildKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbnRyb2xcIiB9LCBbXG4gICAgICAgICAgICAgIF9jKFwidGV4dGFyZWFcIiwge1xuICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IF92bS5idWdyZXBvcnQsXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IFwiYnVncmVwb3J0XCJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRleHRhcmVhXCIsXG4gICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOlxuICAgICAgICAgICAgICAgICAgICBcIkRlc2NyaWJlIHRoZSBhY3Rpb25zIHlvdSB0b29rLCB5b3VyIGRlc2lyZWQgb3V0Y29tZSBhbmQgdGhlIGFjdHVhbCBvdXRjb21lIG9mIHRob3NlIGFjdGlvbnMuIFdlIHNob3VsZCBiZSBhYmxlIHRvIHJlcGxpY2F0ZSB0aGUgYnVnIGJhc2VkIG9mZiB0aGUgc3RlcHMgeW91IHByb3ZpZGUgaGVyZS5cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZG9tUHJvcHM6IHsgdmFsdWU6IF92bS5idWdyZXBvcnQgfSxcbiAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdm0uYnVncmVwb3J0ID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSlcbiAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImZpZWxkXCIgfSwgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImJ1dHRvbiBpcy1wcmltYXJ5XCIsXG4gICAgICAgICAgICBhdHRyczogeyB0eXBlOiBcImJ1dHRvblwiIH0sXG4gICAgICAgICAgICBvbjogeyBjbGljazogX3ZtLnN1Ym1pdCB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbX3ZtLl92KFwiU3VibWl0XCIpXVxuICAgICAgICApXG4gICAgICBdKVxuICAgIF0pXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxudmFyIGVzRXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmV4cG9ydCBkZWZhdWx0IGVzRXhwb3J0c1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi1mOTZjN2E4OFwiLCBlc0V4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1mOTZjN2E4OFwiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9zdWdnZXN0aW9ucy52dWVcbi8vIG1vZHVsZSBpZCA9IDI0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMTE3N2NiNjhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL215dGVhbS52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjE2NDc1NjlhXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTExNzdjYjY4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9teXRlYW0udnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTExNzdjYjY4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9teXRlYW0udnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTExNzdjYjY4XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL215dGVhbS52dWVcbi8vIG1vZHVsZSBpZCA9IDI0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMTUxNjdmMmZcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2RlbGV0ZWFjY291bnQudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCJhMzIzOWNlYVwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0xNTE2N2YyZlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vZGVsZXRlYWNjb3VudC52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMTUxNjdmMmZcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2RlbGV0ZWFjY291bnQudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTE1MTY3ZjJmXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL2RlbGV0ZWFjY291bnQudnVlXG4vLyBtb2R1bGUgaWQgPSAyNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTJiNzcwZDI0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9DcmVhdGVMZWFndWUudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCIzZDc0ZjFmNlwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0yYjc3MGQyNFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vQ3JlYXRlTGVhZ3VlLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0yYjc3MGQyNFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vQ3JlYXRlTGVhZ3VlLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0yYjc3MGQyNFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9DcmVhdGVMZWFndWUudnVlXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTM2Nzk0MGQzXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9uYXZiYXIudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI0M2E4M2MzYlwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zNjc5NDBkM1xcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbmF2YmFyLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zNjc5NDBkM1xcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbmF2YmFyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0zNjc5NDBkM1wiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTNlZmQ5ZjBlXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9teWFjY291bnQudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCJhNTEzYWM3NFwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zZWZkOWYwZVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbXlhY2NvdW50LnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zZWZkOWYwZVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbXlhY2NvdW50LnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0zZWZkOWYwZVwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9teWFjY291bnQudnVlXG4vLyBtb2R1bGUgaWQgPSAyNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTNmYzM1ODllXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zdGF0dHJhY2tlci52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjg3ZmNjNzNhXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTNmYzM1ODllXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zdGF0dHJhY2tlci52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtM2ZjMzU4OWVcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3N0YXR0cmFja2VyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0zZmMzNTg5ZVwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9zdGF0dHJhY2tlci52dWVcbi8vIG1vZHVsZSBpZCA9IDI0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGQ4OGZkODRcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL25hdmJhckRyb3Bkb3duLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiMmJmZTNhNDRcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGQ4OGZkODRcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL25hdmJhckRyb3Bkb3duLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi00ZDg4ZmQ4NFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbmF2YmFyRHJvcGRvd24udnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTRkODhmZDg0XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL25hdmJhckRyb3Bkb3duLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNmRlNWFiMzRcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vaW5kZXgudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjFiZWM1NGM4XCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi02ZGU1YWIzNFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9pbmRleC52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTZkZTVhYjM0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2luZGV4LnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi02ZGU1YWIzNFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9pbmRleC52dWVcbi8vIG1vZHVsZSBpZCA9IDI0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNzFkY2JjNGFcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2xlYWRlcmJvYXJkLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiNzU0ODU1NzVcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNzFkY2JjNGFcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2xlYWRlcmJvYXJkLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi03MWRjYmM0YVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbGVhZGVyYm9hcmQudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTcxZGNiYzRhXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL2xlYWRlcmJvYXJkLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi03NWVmM2M4NFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vcnVsZXMudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI3N2UyMzViN1wiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi03NWVmM2M4NFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vcnVsZXMudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTc1ZWYzYzg0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9ydWxlcy52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNzVlZjNjODRcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvcnVsZXMudnVlXG4vLyBtb2R1bGUgaWQgPSAyNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTdiOGExOWI0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9yZWdpc3Rlci52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjc3OWVhNWI0XCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTdiOGExOWI0XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9yZWdpc3Rlci52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtN2I4YTE5YjRcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3JlZ2lzdGVyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi03YjhhMTliNFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWVcbi8vIG1vZHVsZSBpZCA9IDI1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZTNmZjlhYzhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2pvaW5sZWFndWUudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCJkNDk5MGRhNlwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1lM2ZmOWFjOFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vam9pbmxlYWd1ZS52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZTNmZjlhYzhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2pvaW5sZWFndWUudnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LWUzZmY5YWM4XCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL2pvaW5sZWFndWUudnVlXG4vLyBtb2R1bGUgaWQgPSAyNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWY5NmM3YTg4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zdWdnZXN0aW9ucy52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjE2OGRjYjIwXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWY5NmM3YTg4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9zdWdnZXN0aW9ucy52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtZjk2YzdhODhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3N1Z2dlc3Rpb25zLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi1mOTZjN2E4OFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9zdWdnZXN0aW9ucy52dWVcbi8vIG1vZHVsZSBpZCA9IDI1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9