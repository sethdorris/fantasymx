/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 58);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var bind = __webpack_require__(39);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is a Node Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Node Buffer, otherwise false
 */
function isBuffer(val) {
  return typeof Buffer !== 'undefined' && Buffer.isBuffer && Buffer.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' && !isArray(obj)) {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge() /* obj1, obj2, obj3, ... */{
  var result = {};
  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(77).Buffer))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(46);

/** Detect free variable `self`. */
var freeSelf = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsNative = __webpack_require__(101),
    getValue = __webpack_require__(132);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate
    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(59);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(1);

/** Built-in value references. */
var _Symbol = root.Symbol;

module.exports = _Symbol;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(7),
    getRawTag = __webpack_require__(129),
    objectToString = __webpack_require__(158);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(12);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object';
}

module.exports = isObjectLike;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var baseGetTag = __webpack_require__(8),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * vuex v2.3.0
 * (c) 2017 Evan You
 * @license MIT
 */
var applyMixin = function applyMixin(Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;
    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if (options === void 0) options = {};

      options.init = options.init ? [vuexInit].concat(options.init) : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit() {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
};

var devtoolHook = typeof window !== 'undefined' && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin(store) {
  if (!devtoolHook) {
    return;
  }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */

/**
 * forEach for object
 */
function forEachValue(obj, fn) {
  Object.keys(obj).forEach(function (key) {
    return fn(obj[key], key);
  });
}

function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

function isPromise(val) {
  return val && typeof val.then === 'function';
}

function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}

var Module = function Module(rawModule, runtime) {
  this.runtime = runtime;
  this._children = Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = { namespaced: {} };

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced;
};

Module.prototype.addChild = function addChild(key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};

Module.prototype.update = function update(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild(fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter(fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction(fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation(fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties(Module.prototype, prototypeAccessors$1);

var ModuleCollection = function ModuleCollection(rawRootModule) {
  var this$1 = this;

  // register root module (Vuex.Store options)
  this.root = new Module(rawRootModule, false);

  // register all nested modules
  if (rawRootModule.modules) {
    forEachValue(rawRootModule.modules, function (rawModule, key) {
      this$1.register([key], rawModule, false);
    });
  }
};

ModuleCollection.prototype.get = function get(path) {
  return path.reduce(function (module, key) {
    return module.getChild(key);
  }, this.root);
};

ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '');
  }, '');
};

ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update(this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1 = this;
  if (runtime === void 0) runtime = true;

  var parent = this.get(path.slice(0, -1));
  var newModule = new Module(rawModule, runtime);
  parent.addChild(path[path.length - 1], newModule);

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister(path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (!parent.getChild(key).runtime) {
    return;
  }

  parent.removeChild(key);
};

function update(targetModule, newModule) {
  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        console.warn("[vuex] trying to add a new module '" + key + "' on hot reloading, " + 'manual reload is needed');
        return;
      }
      update(targetModule.getChild(key), newModule.modules[key]);
    }
  }
}

var Vue; // bind on install

var Store = function Store(options) {
  var this$1 = this;
  if (options === void 0) options = {};

  assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
  assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");

  var state = options.state;if (state === void 0) state = {};
  var plugins = options.plugins;if (plugins === void 0) plugins = [];
  var strict = options.strict;if (strict === void 0) strict = false;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch(type, payload) {
    return dispatch.call(store, type, payload);
  };
  this.commit = function boundCommit(type, payload, options) {
    return commit.call(store, type, payload, options);
  };

  // strict mode
  this.strict = strict;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.concat(devtoolPlugin).forEach(function (plugin) {
    return plugin(this$1);
  });
};

var prototypeAccessors = { state: {} };

prototypeAccessors.state.get = function () {
  return this._vm._data.$$state;
};

prototypeAccessors.state.set = function (v) {
  assert(false, "Use store.replaceState() to explicit replace store state.");
};

Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
  var type = ref.type;
  var payload = ref.payload;
  var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    console.error("[vuex] unknown mutation type: " + type);
    return;
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator(handler) {
      handler(payload);
    });
  });
  this._subscribers.forEach(function (sub) {
    return sub(mutation, this$1.state);
  });

  if (options && options.silent) {
    console.warn("[vuex] mutation type: " + type + ". Silent option has been removed. " + 'Use the filter functionality in the vue-devtools');
  }
};

Store.prototype.dispatch = function dispatch(_type, _payload) {
  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
  var type = ref.type;
  var payload = ref.payload;

  var entry = this._actions[type];
  if (!entry) {
    console.error("[vuex] unknown action type: " + type);
    return;
  }
  return entry.length > 1 ? Promise.all(entry.map(function (handler) {
    return handler(payload);
  })) : entry[0](payload);
};

Store.prototype.subscribe = function subscribe(fn) {
  var subs = this._subscribers;
  if (subs.indexOf(fn) < 0) {
    subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  };
};

Store.prototype.watch = function watch(getter, cb, options) {
  var this$1 = this;

  assert(typeof getter === 'function', "store.watch only accepts a function.");
  return this._watcherVM.$watch(function () {
    return getter(this$1.state, this$1.getters);
  }, cb, options);
};

Store.prototype.replaceState = function replaceState(state) {
  var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule(path, rawModule) {
  if (typeof path === 'string') {
    path = [path];
  }
  assert(Array.isArray(path), "module path must be a string or an Array.");
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path));
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1 = this;

  if (typeof path === 'string') {
    path = [path];
  }
  assert(Array.isArray(path), "module path must be a string or an Array.");
  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit(fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties(Store.prototype, prototypeAccessors);

function resetStore(store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM(store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    computed[key] = function () {
      return fn(store);
    };
    Object.defineProperty(store.getters, key, {
      get: function get() {
        return store._vm[key];
      },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () {
      return oldVm.$destroy();
    });
  }
}

function installModule(store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var namespacedType = namespace + key;
    registerAction(store, namespacedType, action, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext(store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (!store._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }

      return store.dispatch(type, payload);
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (!store._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function () {
        return store.getters;
      } : function () {
        return makeLocalGetters(store, namespace);
      }
    },
    state: {
      get: function get() {
        return getNestedState(store.state, path);
      }
    }
  });

  return local;
}

function makeLocalGetters(store, namespace) {
  var gettersProxy = {};

  var splitPos = namespace.length;
  Object.keys(store.getters).forEach(function (type) {
    // skip if the target getter is not match this namespace
    if (type.slice(0, splitPos) !== namespace) {
      return;
    }

    // extract local getter type
    var localType = type.slice(splitPos);

    // Add a port to the getters proxy.
    // Define as getter property because
    // we do not want to evaluate the getters in this time.
    Object.defineProperty(gettersProxy, localType, {
      get: function get() {
        return store.getters[type];
      },
      enumerable: true
    });
  });

  return gettersProxy;
}

function registerMutation(store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler(local.state, payload);
  });
}

function registerAction(store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler(payload, cb) {
    var res = handler({
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload, cb);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err;
      });
    } else {
      return res;
    }
  });
}

function registerGetter(store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    console.error("[vuex] duplicate getter key: " + type);
    return;
  }
  store._wrappedGetters[type] = function wrappedGetter(store) {
    return rawGetter(local.state, // local state
    local.getters, // local getters
    store.state, // root state
    store.getters // root getters
    );
  };
}

function enableStrictMode(store) {
  store._vm.$watch(function () {
    return this._data.$$state;
  }, function () {
    assert(store._committing, "Do not mutate vuex store state outside mutation handlers.");
  }, { deep: true, sync: true });
}

function getNestedState(state, path) {
  return path.length ? path.reduce(function (state, key) {
    return state[key];
  }, state) : state;
}

function unifyObjectStyle(type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  assert(typeof type === 'string', "Expects string as the type, but found " + (typeof type === 'undefined' ? 'undefined' : _typeof(type)) + ".");

  return { type: type, payload: payload, options: options };
}

function install(_Vue) {
  if (Vue) {
    console.error('[vuex] already installed. Vue.use(Vuex) should be called only once.');
    return;
  }
  Vue = _Vue;
  applyMixin(Vue);
}

// auto install in dist mode
if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
}

var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState() {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return;
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function' ? val.call(this, state, getters) : state[val];
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res;
});

var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedMutation() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }if (namespace && !getModuleByNamespace(this.$store, 'mapMutations', namespace)) {
        return;
      }
      return this.$store.commit.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});

var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedGetter() {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return;
      }
      if (!(val in this.$store.getters)) {
        console.error("[vuex] unknown getter: " + val);
        return;
      }
      return this.$store.getters[val];
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res;
});

var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    val = namespace + val;
    res[key] = function mappedAction() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }if (namespace && !getModuleByNamespace(this.$store, 'mapActions', namespace)) {
        return;
      }
      return this.$store.dispatch.apply(this.$store, [val].concat(args));
    };
  });
  return res;
});

function normalizeMap(map) {
  return Array.isArray(map) ? map.map(function (key) {
    return { key: key, val: key };
  }) : Object.keys(map).map(function (key) {
    return { key: key, val: map[key] };
  });
}

function normalizeNamespace(fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map);
  };
}

function getModuleByNamespace(store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (!module) {
    console.error("[vuex] module namespace not found in " + helper + "(): " + namespace);
  }
  return module;
}

var index_esm = {
  Store: Store,
  install: install,
  version: '2.3.0',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions
};

exports.Store = Store;
exports.mapState = mapState;
exports.mapMutations = mapMutations;
exports.mapGetters = mapGetters;
exports.mapActions = mapActions;
exports.default = index_esm;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(196)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var listCacheClear = __webpack_require__(144),
    listCacheDelete = __webpack_require__(145),
    listCacheGet = __webpack_require__(146),
    listCacheHas = __webpack_require__(147),
    listCacheSet = __webpack_require__(148);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var eq = __webpack_require__(30);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isKeyable = __webpack_require__(141);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(3);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(51),
    isLength = __webpack_require__(32);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * Vue.js v2.3.3
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */
/*  */

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}
/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number';
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

var _toString = Object.prototype.toString;

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /([^-])([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
});

/**
 * Simple bind, faster than native
 */
function bind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn;
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 */
function noop() {}

/**
 * Always return false.
 */
var no = function no() {
  return false;
};

/**
 * Return same value
 */
var identity = function identity(_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      return JSON.stringify(a) === JSON.stringify(b);
    } catch (e) {
      // possible circular reference
      return a === b;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = ['component', 'directive', 'filter'];

var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};

/*  */

var emptyObject = Object.freeze({});

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */

var warn = noop;
var tip = noop;
var formatComponentName = null; // work around flow check

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function classify(str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function warn(msg, vm) {
    if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  tip = function tip(msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function formatComponentName(vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;

    var file = vm._isVue && vm.$options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function repeat(str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) {
        res += str;
      }
      if (n > 1) {
        str += str;
      }
      n >>= 1;
    }
    return res;
  };

  var generateComponentTrace = function generateComponentTrace(vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}

/*  */

function handleError(err, vm, info) {
  if (config.errorHandler) {
    config.errorHandler.call(null, err, vm, info);
  } else {
    if (true) {
      warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }
}

/*  */
/* globals MutationObserver */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function isServerRendering() {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

/**
 * Defer a task to execute it asynchronously.
 */
var nextTick = function () {
  var callbacks = [];
  var pending = false;
  var timerFunc;

  function nextTickHandler() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    var logError = function logError(err) {
      console.error(err);
    };
    timerFunc = function timerFunc() {
      p.then(nextTickHandler).catch(logError);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
  } else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    var counter = 1;
    var observer = new MutationObserver(nextTickHandler);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function timerFunc() {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    timerFunc = function timerFunc() {
      setTimeout(nextTickHandler, 0);
    };
  }

  return function queueNextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve, reject) {
        _resolve = resolve;
      });
    }
  };
}();

var _Set;
/* istanbul ignore if */
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

/*  */

var uid$1 = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid$1++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var arguments$1 = arguments;

    // avoid leaking arguments:
    // http://jsperf.com/closure-with-arguments
    var i = arguments.length;
    var args = new Array(i);
    while (i--) {
      args[i] = arguments$1[i];
    }
    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
        inserted = args;
        break;
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true,
  isSettingProps: false
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value)) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1(obj, key, val, customSetter) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
        }
        if (Array.isArray(value)) {
          dependArray(value);
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if ("development" !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (Array.isArray(target) && typeof key === 'number') {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (hasOwn(target, key)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    "development" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (Array.isArray(target) && typeof key === 'number') {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    "development" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (typeof childVal !== 'function') {
      "development" !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(childVal.call(this), parentVal.call(this));
    };
  } else if (parentVal || childVal) {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal) {
  var res = Object.create(parentVal || null);
  return childVal ? extend(res, childVal) : res;
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal) {
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key in childVal) {
    var parent = ret[key];
    var child = childVal[key];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key] = parent ? parent.concat(child) : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  extend(ret, childVal);
  return ret;
};

/**
 * Default strategy.
 */
var defaultStrat = function defaultStrat(parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  }
  options.props = res;
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ("development" !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (true) {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ("development" !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn('Invalid prop: type check failed for prop "' + name + '".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    valid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === expectedType.toLowerCase();
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isType(type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type);
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true;
    }
  }
  /* istanbul ignore next */
  return false;
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function warnNonPresent(target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + "referenced during render. Make sure to declare reactive data " + "properties in the data option.", target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function mark(tag) {
      return perf.mark(tag);
    };
    measure = function measure(name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.functionalContext = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
};

var prototypeAccessors = { child: {} };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function createEmptyVNode() {
  var node = new VNode();
  node.text = '';
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.isCloned = true;
  return cloned;
}

function cloneVNodes(vnodes) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i]);
  }
  return res;
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      for (var i = 0; i < fns.length; i++) {
        fns[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      "development" !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }
    last = res[res.length - 1];
    //  nested
    if (Array.isArray(c)) {
      res.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + "_" + i));
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        last.text += String(c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[res.length - 1] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function ensureCtor(comp, base) {
  return isObject(comp) ? base.extend(comp) : comp;
}

function resolveAsyncComponent(factory, baseCtor, context) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function forceRender() {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "development" !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject( true ? "timeout (" + res.timeout + "ms)" : null);
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}

/*  */

function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && isDef(c.componentOptions)) {
        return c;
      }
    }
  }
}

/*  */

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once$$1) {
  if (once$$1) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        this$1.$off(event[i$1], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (arguments.length === 1) {
      vm._events[event] = null;
      return vm;
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break;
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        cbs[i].apply(vm, args);
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  var defaultSlot = [];
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {
      var name = child.data.slot;
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      defaultSlot.push(child);
    }
  }
  // ignore whitespace
  if (!defaultSlot.every(isWhitespace)) {
    slots.default = defaultSlot;
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment || node.text === ' ';
}

function resolveScopedSlots(fns, // see flow/vnode
res) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res;
}

/*  */

var activeInstance = null;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // remove reference to DOM nodes (prevents leak)
    vm.$options._parentElm = vm.$options._refElm = null;
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ("development" !== 'production' && config.performance && mark) {
    updateComponent = function updateComponent() {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function updateComponent() {
      vm._update(vm._render(), hydrating);
    };
  }

  vm._watcher = new Watcher(vm, updateComponent, noop);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    if (true) {
      observerState.isSettingProps = true;
    }
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    if (true) {
      observerState.isSettingProps = false;
    }
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }
  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ("development" !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdateHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdateHooks(queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options) {
  this.vm = vm;
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "development" !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  if (this.user) {
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    }
  } else {
    value = this.getter.call(vm, vm);
  }
  // "touch" every property so they are all tracked as
  // dependencies for deep watching
  if (this.deep) {
    traverse(value);
  }
  popTarget();
  this.cleanupDeps();
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
var seenObjects = new _Set();
function traverse(val) {
  seenObjects.clear();
  _traverse(val, seenObjects);
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || !Object.isExtensible(val)) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch) {
    initWatch(vm, opts.watch);
  }
}

var isReservedProp = {
  key: 1,
  ref: 1,
  slot: 1
};

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function loop(key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      if (isReservedProp[key] || config.isReservedAttr(key)) {
        warn("\"" + key + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive$$1(props, key, value, function () {
        if (vm.$parent && !observerState.isSettingProps) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive$$1(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) {
    loop(key);
  }observerState.shouldConvert = true;
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "development" !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var i = keys.length;
  while (i--) {
    if (props && hasOwn(props, keys[i])) {
      "development" !== 'production' && warn("The data property \"" + keys[i] + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(keys[i])) {
      proxy(vm, "_data", keys[i]);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData(data, vm) {
  try {
    return data.call(vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (true) {
      if (getter === undefined) {
        warn("No getter function has been defined for computed property \"" + key + "\".", vm);
        getter = noop;
      }
    }
    // create internal watcher for the computed property.
    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = createComputedGetter(key);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    if (true) {
      if (methods[key] == null) {
        warn("method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("method \"" + key + "\" has already been defined as a prop.", vm);
      }
    }
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, key, handler) {
  var options;
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  vm.$watch(key, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (true) {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive$$1(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {
        defineReactive$$1(vm, key, result[key]);
      }
    });
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    // isArray here
    var isArray = Array.isArray(inject);
    var result = Object.create(null);
    var keys = isArray ? inject : hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = isArray ? key : inject[key];
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break;
        }
        source = source.$parent;
      }
    }
    return result;
  }
}

/*  */

function createFunctionalComponent(Ctor, propsData, data, context, children) {
  var props = {};
  var propOptions = Ctor.options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || {});
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }
    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var _context = Object.create(context);
  var h = function h(a, b, c, d) {
    return createElement(_context, a, b, c, d, true);
  };
  var vnode = Ctor.options.render.call(null, h, {
    data: data,
    props: props,
    children: children,
    parent: context,
    listeners: data.on || {},
    injections: resolveInject(Ctor.options.inject, context),
    slots: function slots() {
      return resolveSlots(children, context);
    }
  });
  if (vnode instanceof VNode) {
    vnode.functionalContext = context;
    vnode.functionalOptions = Ctor.options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }
  return vnode;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  if (isUndef(Ctor.cid)) {
    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);
    if (Ctor === undefined) {
      // return nothing if this is indeed an async component
      // wait for the callback to trigger parent update.
      return;
    }
  }

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  data = data || {};

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners
    data = {};
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options);
}

function mergeHooks(data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1(one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  };
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    "development" !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) {
      applyNS(vnode, ns);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    return;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && isUndef(child.ns)) {
        applyNS(child, ns);
      }
    }
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    ret._isVList = true;
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      extend(props, bindObject);
    }
    return scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes && "development" !== 'production') {
      slotNodes._rendered && warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      slotNodes._rendered = true;
    }
    return slotNodes || fallback;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 */
function checkKeyCodes(eventKeyCode, key, builtInAlias) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (Array.isArray(keyCodes)) {
    return keyCodes.indexOf(eventKeyCode) === -1;
  } else {
    return keyCodes !== eventKeyCode;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp) {
  if (value) {
    if (!isObject(value)) {
      "development" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      for (var key in value) {
        if (key === 'class' || key === 'style') {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];
        }
      }
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
  var tree = this._staticTrees[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
  }
  // otherwise, render a fresh tree.
  tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function initRender(vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null;
  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };
}

function renderMixin(Vue) {
  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var staticRenderFns = ref.staticRenderFns;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // clone slot nodes on re-renders
      for (var key in vm.$slots) {
        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
      }
    }

    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

    if (staticRenderFns && !vm._staticTrees) {
      vm._staticTrees = [];
    }
    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render function");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (true) {
        vnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ("development" !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };

  // internal render helpers.
  // these are exposed on the instance prototype to reduce generated render
  // code size.
  Vue.prototype._o = markOnce;
  Vue.prototype._n = toNumber;
  Vue.prototype._s = toString;
  Vue.prototype._l = renderList;
  Vue.prototype._t = renderSlot;
  Vue.prototype._q = looseEqual;
  Vue.prototype._i = looseIndexOf;
  Vue.prototype._m = renderStatic;
  Vue.prototype._f = resolveFilter;
  Vue.prototype._k = checkKeyCodes;
  Vue.prototype._b = bindObjectProps;
  Vue.prototype._v = createTextVNode;
  Vue.prototype._e = createEmptyVNode;
  Vue.prototype._u = resolveScopedSlots;
}

/*  */

var uid = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      startTag = "vue-perf-init:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue$3(options) {
  if ("development" !== 'production' && !(this instanceof Vue$3)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    /* istanbul ignore if */
    if (plugin.installed) {
      return this;
    }
    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    plugin.installed = true;
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (true) {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
      }
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (true) {
          if (type === 'component' && config.isReservedTag(id)) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

var patternTypes = [String, RegExp];

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(cache, current, filter) {
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        if (cachedNode !== current) {
          pruneCacheEntry(cachedNode);
        }
        cache[key] = null;
      }
    }
  }
}

function pruneCacheEntry(vnode) {
  if (vnode) {
    vnode.componentInstance.$destroy();
  }
}

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes
  },

  created: function created() {
    this.cache = Object.create(null);
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache[key]);
    }
  },

  watch: {
    include: function include(val) {
      pruneCache(this.cache, this._vnode, function (name) {
        return matches(val, name);
      });
    },
    exclude: function exclude(val) {
      pruneCache(this.cache, this._vnode, function (name) {
        return !matches(val, name);
      });
    }
  },

  render: function render() {
    var vnode = getFirstComponentChild(this.$slots.default);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      if (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {
        return vnode;
      }
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (this.cache[key]) {
        vnode.componentInstance = this.cache[key].componentInstance;
      } else {
        this.cache[key] = vnode;
      }
      vnode.data.keepAlive = true;
    }
    return vnode;
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (true) {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode.ssrContext;
  }
});

Vue$3.version = '2.3.3';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select');
var mustUseProp = function mustUseProp(tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function isXlink(name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function getXlinkProp(name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function isFalsyAttrValue(val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return genClassFromData(data);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function genClassFromData(data) {
  var dynamicClass = data.class;
  var staticClass = data.staticClass;
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (isUndef(value)) {
    return '';
  }
  if (typeof value === 'string') {
    return value;
  }
  var res = '';
  if (Array.isArray(value)) {
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(value[i])) {
        if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
          res += stringified + ' ';
        }
      }
    }
    return res.slice(0, -1);
  }
  if (isObject(value)) {
    for (var key in value) {
      if (value[key]) {
        res += key + ' ';
      }
    }
    return res.slice(0, -1);
  }
  /* istanbul ignore next */
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isReservedTag = function isReservedTag(tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      "development" !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setAttribute(node, key, val) {
  node.setAttribute(key, val);
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
        refs[key].push(ref);
      } else {
        refs[key] = [ref];
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *

/*
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b);
}

// Some browsers do not support dynamically changing type for <input>
// so they need to be treated as different nodes
function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB;
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove$$1() {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  var inPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          inPre++;
        }
        if (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if ("development" !== 'production' && data && data.pre) {
        inPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref) {
    if (isDef(parent)) {
      if (isDef(ref)) {
        if (ref.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    var ancestor = vnode;
    while (ancestor) {
      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
        nodeOps.setAttribute(vnode.elm, i, '');
      }
      ancestor = ancestor.parent;
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, elmToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          newStartVnode = newCh[++newStartIdx];
        } else {
          elmToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if ("development" !== 'production' && !elmToMove) {
            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
          }
          if (sameVnode(elmToMove, newStartVnode)) {
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
            newStartVnode = newCh[++newStartIdx];
          }
        }
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }
    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.elm = oldVnode.elm;
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }
    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }
    var elm = vnode.elm = oldVnode.elm;
    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var bailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue) {
    if (true) {
      if (!assertNodeMatch(elm, vnode)) {
        return false;
      }
    }
    vnode.elm = elm;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          var childrenMatch = true;
          var childNode = elm.firstChild;
          for (var i$1 = 0; i$1 < children.length; i$1++) {
            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
              childrenMatch = false;
              break;
            }
            childNode = childNode.nextSibling;
          }
          // if childNode is not null, it means the actual childNodes list is
          // longer than the virtual children list.
          if (!childrenMatch || childNode) {
            if ("development" !== 'production' && typeof console !== 'undefined' && !bailed) {
              bailed = true;
              console.warn('Parent: ', elm);
              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
            }
            return false;
          }
        }
      }
      if (isDef(data)) {
        for (var key in data) {
          if (!isRenderedModule(key)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (true) {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }
        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        if (isDef(vnode.parent)) {
          // component root element replaced.
          // update parent placeholder node element, recursively
          var ancestor = vnode.parent;
          while (ancestor) {
            ancestor.elm = vnode.elm;
            ancestor = ancestor.parent;
          }
          if (isPatchable(vnode)) {
            for (var i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, vnode.parent);
            }
          }
        }

        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function callInsert() {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  /* istanbul ignore if */
  if (isIE9 && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, key);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + "," + args;
  }
}

/*  */

/*  */

/**
 * Cross-platform code generation for component v-model
 */

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */

/**
 * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
 *
 * for loop possible cases:
 *
 * - test
 * - test[idx]
 * - test[test1[idx]]
 * - test["a"][idx]
 * - xxx.test[a[a].test1[idx]]
 * - test.xxx.a["asa"][test1[idx]]
 *
 */

var str;
var index$1;

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  var event;
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    // Chrome fires microtasks in between click/change, leads to #4521
    event = isChrome ? 'click' : 'change';
    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function add$1(event, _handler, once$$1, capture, passive) {
  if (once$$1) {
    var oldHandler = _handler;
    var _target = target$1; // save current target element in closure
    _handler = function handler(ev) {
      var res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, _handler, capture, _target);
      }
    };
  }
  target$1.addEventListener(event, _handler, supportsPassive ? { capture: capture, passive: passive } : capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, vnode, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, vnode, checkVal) {
  return !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
}

function isDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
  return document.activeElement !== elm && elm.value !== checkVal;
}

function isInputChanged(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers) && modifiers.number || elm.type === 'number') {
    return toNumber(value) !== toNumber(newVal);
  }
  if (isDef(modifiers) && modifiers.trim) {
    return value.trim() !== newVal.trim();
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function setProp(el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var prefixes = ['Webkit', 'Moz', 'ms'];

var testEl;
var normalize = cached(function (prop) {
  testEl = testEl || document.createElement('div');
  prop = camelize(prop);
  if (prop !== 'filter' && prop in testEl.style) {
    return prop;
  }
  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < prefixes.length; i++) {
    var prefixed = prefixes[i] + upper;
    if (prefixed in testEl.style) {
      return prefixed;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likley wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    el.setAttribute('class', cur.trim());
  }
}

/*  */

function resolveTransition(def$$1) {
  if (!def$$1) {
    return;
  }
  /* istanbul ignore else */
  if ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res;
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
  addClass(el, cls);
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function end() {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function onEnd(e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return;
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if ("development" !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return rm();
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if ("development" !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var model$1 = {
  inserted: function inserted(el, binding, vnode) {
    if (vnode.tag === 'select') {
      var cb = function cb() {
        setSelected(el, binding, vnode.context);
      };
      cb();
      /* istanbul ignore if */
      if (isIE || isEdge) {
        setTimeout(cb, 0);
      }
    } else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },
  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var needReset = el.multiple ? binding.value.some(function (v) {
        return hasNoMatchingOption(v, el.options);
      }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
      if (needReset) {
        trigger(el, 'change');
      }
    }
  }
};

function setSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    "development" !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  for (var i = 0, l = options.length; i < l; i++) {
    if (looseEqual(getValue(options[i]), value)) {
      return false;
    }
  }
  return true;
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition && !isIE9) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition = vnode.data && vnode.data.transition;
    if (transition && !isIE9) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: model$1,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag;
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if ("development" !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if ("development" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        var delayedLeave;
        var performLeave = function performLeave() {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    var body = document.body;
    var f = body.offsetHeight; // eslint-disable-line

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      if (this._hasMove != null) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
setTimeout(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if ("development" !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
  }
  if ("development" !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
  }
}, 0);

/*  */

exports.default = Vue$3;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(0);
var normalizeHeaderName = __webpack_require__(73);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(35);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(35);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {/* Ignore */}
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(188)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(3),
    root = __webpack_require__(1);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var mapCacheClear = __webpack_require__(149),
    mapCacheDelete = __webpack_require__(150),
    mapCacheGet = __webpack_require__(151),
    mapCacheHas = __webpack_require__(152),
    mapCacheSet = __webpack_require__(153);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var castPath = __webpack_require__(28),
    toKey = __webpack_require__(9);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var baseMatches = __webpack_require__(105),
    baseMatchesProperty = __webpack_require__(106),
    identity = __webpack_require__(20),
    isArray = __webpack_require__(2),
    property = __webpack_require__(179);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArray = __webpack_require__(2),
    isKey = __webpack_require__(29),
    stringToPath = __webpack_require__(172),
    toString = __webpack_require__(187);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isArray = __webpack_require__(2),
    isSymbol = __webpack_require__(12);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsArguments = __webpack_require__(98),
    isObjectLike = __webpack_require__(11);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function () {
    return arguments;
}()) ? baseIsArguments : function (value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayLikeKeys = __webpack_require__(89),
    baseKeys = __webpack_require__(103),
    isArrayLike = __webpack_require__(21);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var settle = __webpack_require__(65);
var buildURL = __webpack_require__(68);
var parseHeaders = __webpack_require__(74);
var isURLSameOrigin = __webpack_require__(72);
var createError = __webpack_require__(38);
var btoa = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || __webpack_require__(67);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if ("development" !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || request.readyState !== 4 && !xDomain) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(70);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(64);

/**
 * Create an Error with the specified message, config, error code, and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 @ @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, response);
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ListCache = __webpack_require__(15),
    stackClear = __webpack_require__(167),
    stackDelete = __webpack_require__(168),
    stackGet = __webpack_require__(169),
    stackHas = __webpack_require__(170),
    stackSet = __webpack_require__(171);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsEqualDeep = __webpack_require__(99),
    isObjectLike = __webpack_require__(11);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SetCache = __webpack_require__(84),
    arraySome = __webpack_require__(90),
    cacheHas = __webpack_require__(118);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(10);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

module.exports = matchesStrictComparable;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var root = __webpack_require__(1),
    stubFalse = __webpack_require__(183);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)(module)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(8),
    isObject = __webpack_require__(10);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsTypedArray = __webpack_require__(102),
    baseUnary = __webpack_require__(44),
    nodeUtil = __webpack_require__(157);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(213)
}
var Component = __webpack_require__(4)(
  /* script */
  __webpack_require__(193),
  /* template */
  __webpack_require__(207),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasymx2/client/components/register.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] register.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-1ad06d68", Component.options)
  } else {
    hotAPI.reload("data-v-1ad06d68", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRouter = createRouter;

var _vue = __webpack_require__(22);

var _vue2 = _interopRequireDefault(_vue);

var _vueRouter = __webpack_require__(195);

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _leaderboard = __webpack_require__(202);

var _leaderboard2 = _interopRequireDefault(_leaderboard);

var _register = __webpack_require__(54);

var _register2 = _interopRequireDefault(_register);

var _myteam = __webpack_require__(204);

var _myteam2 = _interopRequireDefault(_myteam);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vueRouter2.default);

function createRouter() {
  return new _vueRouter2.default({
    mode: 'history',
    routes: [{ path: "/", component: _leaderboard2.default }, { path: "/register", component: _register2.default }, { path: "/myteam", component: _myteam2.default }]
  });
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _vue = __webpack_require__(22);

var _vue2 = _interopRequireDefault(_vue);

var _vuex = __webpack_require__(13);

var _vuex2 = _interopRequireDefault(_vuex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_vue2.default.use(_vuex2.default);

var state = {
  user: {
    username: ''
  },
  isLoggedIn: false,
  modalControl: {
    showLoginModal: false,
    showRegisterModal: false
  }
};

var getters = {
  getUserData: function getUserData() {
    return state.user;
  },
  ShowLoginModal: function ShowLoginModal() {
    return state.modalControl.showLoginModal;
  },
  ShowRegisterModal: function ShowRegisterModal() {
    return state.modalControl.showRegisterModal;
  },
  GetAuthStatus: function GetAuthStatus() {
    return state.isLoggedIn;
  }
};

var mutations = {
  changeTeam: function changeTeam(state, riderArray) {
    state.user.riders = riderArray;
  },
  setLoginModal: function setLoginModal(state, _ref) {
    var show = _ref.show;

    state.modalControl.showLoginModal = show;
  },
  setRegisterModal: function setRegisterModal(state, _ref2) {
    var show = _ref2.show;

    state.modalControl.showRegisterModal = show;
  },
  setUserData: function setUserData(state, _ref3) {
    var userData = _ref3.userData;

    state.user = userData;
  },
  setLoggedIn: function setLoggedIn(state, _ref4) {
    var loggedIn = _ref4.loggedIn;

    state.isLoggedIn = loggedIn;
  },
  logout: function logout(state) {
    state.user.riders = [];
    state.user = {};
    state.isLoggedIn = false;
  }
};

exports.default = new _vuex2.default.Store({
  state: state,
  getters: getters,
  mutations: mutations
});

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(215)
}
var Component = __webpack_require__(4)(
  /* script */
  __webpack_require__(194),
  /* template */
  __webpack_require__(210),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasymx2/index.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] index.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4f4e5dd2", Component.options)
  } else {
    hotAPI.reload("data-v-4f4e5dd2", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _vue = __webpack_require__(22);

var _vue2 = _interopRequireDefault(_vue);

var _index = __webpack_require__(57);

var _index2 = _interopRequireDefault(_index);

var _router = __webpack_require__(55);

var _store = __webpack_require__(56);

var _store2 = _interopRequireDefault(_store);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var router = (0, _router.createRouter)();
var app = new _vue2.default({
  el: "#app",
  router: router,
  store: _store2.default,
  render: function render(h) {
    return h(_index2.default);
  }
}).$mount("#app");

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var bind = __webpack_require__(39);
var Axios = __webpack_require__(61);
var defaults = __webpack_require__(23);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(36);
axios.CancelToken = __webpack_require__(60);
axios.isCancel = __webpack_require__(37);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(75);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(36);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(23);
var utils = __webpack_require__(0);
var InterceptorManager = __webpack_require__(62);
var dispatchRequest = __webpack_require__(63);
var isAbsoluteURL = __webpack_require__(71);
var combineURLs = __webpack_require__(69);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);
var transformData = __webpack_require__(66);
var isCancel = __webpack_require__(37);
var defaults = __webpack_require__(23);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(config.data, config.headers, config.transformRequest);

  // Flatten headers
  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});

  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(response.data, response.headers, config.transformResponse);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 @ @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.response = response;
  return error;
};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(38);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response));
  }
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error();
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
  // initialize result and counter
  var block, charCode, idx = 0, map = chars;
  // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1);
  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },

    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },

    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() :

// Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
  );
};

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;

  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :

// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(0);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(76);
var ieee754 = __webpack_require__(78);
var isArray = __webpack_require__(79);

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
        return 42;
      } };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }
  return createBuffer(that, size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0;

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
    // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(34)))

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(3),
    root = __webpack_require__(1);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hashClear = __webpack_require__(134),
    hashDelete = __webpack_require__(135),
    hashGet = __webpack_require__(136),
    hashHas = __webpack_require__(137),
    hashSet = __webpack_require__(138);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(3),
    root = __webpack_require__(1);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(3),
    root = __webpack_require__(1);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MapCache = __webpack_require__(25),
    setCacheAdd = __webpack_require__(162),
    setCacheHas = __webpack_require__(163);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new MapCache();
    while (++index < length) {
        this.add(values[index]);
    }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(1);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(3),
    root = __webpack_require__(1);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseTimes = __webpack_require__(115),
    isArguments = __webpack_require__(31),
    isArray = __webpack_require__(2),
    isBuffer = __webpack_require__(50),
    isIndex = __webpack_require__(18),
    isTypedArray = __webpack_require__(52);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
    // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' ||
    // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') ||
    // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
    // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseForOwn = __webpack_require__(95),
    createBaseEach = __webpack_require__(122);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayPush = __webpack_require__(42),
    isFlattenable = __webpack_require__(139);

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createBaseFor = __webpack_require__(123);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFor = __webpack_require__(94),
    keys = __webpack_require__(33);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayPush = __webpack_require__(42),
    isArray = __webpack_require__(2);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(8),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Stack = __webpack_require__(40),
    equalArrays = __webpack_require__(45),
    equalByTag = __webpack_require__(125),
    equalObjects = __webpack_require__(126),
    getTag = __webpack_require__(131),
    isArray = __webpack_require__(2),
    isBuffer = __webpack_require__(50),
    isTypedArray = __webpack_require__(52);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Stack = __webpack_require__(40),
    baseIsEqual = __webpack_require__(43);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isFunction = __webpack_require__(51),
    isMasked = __webpack_require__(142),
    isObject = __webpack_require__(10),
    toSource = __webpack_require__(49);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetTag = __webpack_require__(8),
    isLength = __webpack_require__(32),
    isObjectLike = __webpack_require__(11);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isPrototype = __webpack_require__(143),
    nativeKeys = __webpack_require__(156);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseEach = __webpack_require__(91),
    isArrayLike = __webpack_require__(21);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsMatch = __webpack_require__(100),
    getMatchData = __webpack_require__(128),
    matchesStrictComparable = __webpack_require__(48);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIsEqual = __webpack_require__(43),
    get = __webpack_require__(175),
    hasIn = __webpack_require__(176),
    isKey = __webpack_require__(29),
    isStrictComparable = __webpack_require__(47),
    matchesStrictComparable = __webpack_require__(48),
    toKey = __webpack_require__(9);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayMap = __webpack_require__(41),
    baseIteratee = __webpack_require__(27),
    baseMap = __webpack_require__(104),
    baseSortBy = __webpack_require__(114),
    baseUnary = __webpack_require__(44),
    compareMultiple = __webpack_require__(120),
    identity = __webpack_require__(20);

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));

  var result = baseMap(collection, function (value, key, collection) {
    var criteria = arrayMap(iteratees, function (iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function (object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGet = __webpack_require__(26);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseUnset = __webpack_require__(117),
    isIndex = __webpack_require__(18);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * The base implementation of `_.pullAt` without support for individual
 * indexes or capturing the removed elements.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {number[]} indexes The indexes of elements to remove.
 * @returns {Array} Returns `array`.
 */
function basePullAt(array, indexes) {
  var length = array ? indexes.length : 0,
      lastIndex = length - 1;

  while (length--) {
    var index = indexes[length];
    if (length == lastIndex || index !== previous) {
      var previous = index;
      if (isIndex(index)) {
        splice.call(array, index, 1);
      } else {
        baseUnset(array, index);
      }
    }
  }
  return array;
}

module.exports = basePullAt;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var identity = __webpack_require__(20),
    overRest = __webpack_require__(160),
    setToString = __webpack_require__(165);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var constant = __webpack_require__(173),
    defineProperty = __webpack_require__(124),
    identity = __webpack_require__(20);

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(7),
    arrayMap = __webpack_require__(41),
    isArray = __webpack_require__(2),
    isSymbol = __webpack_require__(12);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var castPath = __webpack_require__(28),
    last = __webpack_require__(177),
    parent = __webpack_require__(161),
    toKey = __webpack_require__(9);

/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = castPath(path, object);
  object = parent(object, path);
  return object == null || delete object[toKey(last(path))];
}

module.exports = baseUnset;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isSymbol = __webpack_require__(12);

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compareAscending = __webpack_require__(119);

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var root = __webpack_require__(1);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isArrayLike = __webpack_require__(21);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getNative = __webpack_require__(3);

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(7),
    Uint8Array = __webpack_require__(85),
    eq = __webpack_require__(30),
    equalArrays = __webpack_require__(45),
    mapToArray = __webpack_require__(154),
    setToArray = __webpack_require__(164);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getAllKeys = __webpack_require__(127);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGetAllKeys = __webpack_require__(96),
    getSymbols = __webpack_require__(130),
    keys = __webpack_require__(33);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isStrictComparable = __webpack_require__(47),
    keys = __webpack_require__(33);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
}

module.exports = getMatchData;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(7);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var arrayFilter = __webpack_require__(88),
    stubArray = __webpack_require__(182);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DataView = __webpack_require__(80),
    Map = __webpack_require__(24),
    Promise = __webpack_require__(82),
    Set = __webpack_require__(83),
    WeakMap = __webpack_require__(86),
    baseGetTag = __webpack_require__(8),
    toSource = __webpack_require__(49);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function getTag(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
            switch (ctorString) {
                case dataViewCtorString:
                    return dataViewTag;
                case mapCtorString:
                    return mapTag;
                case promiseCtorString:
                    return promiseTag;
                case setCtorString:
                    return setTag;
                case weakMapCtorString:
                    return weakMapTag;
            }
        }
        return result;
    };
}

module.exports = getTag;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var castPath = __webpack_require__(28),
    isArguments = __webpack_require__(31),
    isArray = __webpack_require__(2),
    isIndex = __webpack_require__(18),
    isLength = __webpack_require__(32),
    toKey = __webpack_require__(9);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(19);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(19);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(19);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var nativeCreate = __webpack_require__(19);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Symbol = __webpack_require__(7),
    isArguments = __webpack_require__(31),
    isArray = __webpack_require__(2);

/** Built-in value references. */
var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var eq = __webpack_require__(30),
    isArrayLike = __webpack_require__(21),
    isIndex = __webpack_require__(18),
    isObject = __webpack_require__(10);

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index === 'undefined' ? 'undefined' : _typeof(index);
  if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var coreJsData = __webpack_require__(121);

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

module.exports = isPrototype;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(16);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(16);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(16);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assocIndexOf = __webpack_require__(16);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Hash = __webpack_require__(81),
    ListCache = __webpack_require__(15),
    Map = __webpack_require__(24);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(17);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(17);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(17);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getMapData = __webpack_require__(17);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var memoize = __webpack_require__(178);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var overArg = __webpack_require__(159);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var freeGlobal = __webpack_require__(46);

/** Detect free variable `exports`. */
var freeExports = ( false ? 'undefined' : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && ( false ? 'undefined' : _typeof(module)) == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(53)(module)))

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = __webpack_require__(87);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGet = __webpack_require__(26),
    baseSlice = __webpack_require__(113);

/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function parent(object, path) {
  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
}

module.exports = parent;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseSetToString = __webpack_require__(112),
    shortOut = __webpack_require__(166);

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ListCache = __webpack_require__(15);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ListCache = __webpack_require__(15),
    Map = __webpack_require__(24),
    MapCache = __webpack_require__(25);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var memoizeCapped = __webpack_require__(155);

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function (string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function (match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

module.exports = stringToPath;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFindIndex = __webpack_require__(92),
    baseIteratee = __webpack_require__(27),
    toInteger = __webpack_require__(185);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseGet = __webpack_require__(26);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseHasIn = __webpack_require__(97),
    hasPath = __webpack_require__(133);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MapCache = __webpack_require__(25);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseProperty = __webpack_require__(108),
    basePropertyDeep = __webpack_require__(109),
    isKey = __webpack_require__(29),
    toKey = __webpack_require__(9);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseIteratee = __webpack_require__(27),
    basePullAt = __webpack_require__(110);

/**
 * Removes all elements from `array` that `predicate` returns truthy for
 * and returns an array of the removed elements. The predicate is invoked
 * with three arguments: (value, index, array).
 *
 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
 * to pull elements from an array by value.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Array
 * @param {Array} array The array to modify.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new array of removed elements.
 * @example
 *
 * var array = [1, 2, 3, 4];
 * var evens = _.remove(array, function(n) {
 *   return n % 2 == 0;
 * });
 *
 * console.log(array);
 * // => [1, 3]
 *
 * console.log(evens);
 * // => [2, 4]
 */
function remove(array, predicate) {
  var result = [];
  if (!(array && array.length)) {
    return result;
  }
  var index = -1,
      indexes = [],
      length = array.length;

  predicate = baseIteratee(predicate, 3);
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result.push(value);
      indexes.push(index);
    }
  }
  basePullAt(array, indexes);
  return result;
}

module.exports = remove;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseFlatten = __webpack_require__(93),
    baseOrderBy = __webpack_require__(107),
    baseRest = __webpack_require__(111),
    isIterateeCall = __webpack_require__(140);

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 */
var sortBy = baseRest(function (collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toNumber = __webpack_require__(186);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toFinite = __webpack_require__(184);

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? remainder ? result - remainder : result : 0;
}

module.exports = toInteger;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(10),
    isSymbol = __webpack_require__(12);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var baseToString = __webpack_require__(116);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _axios = __webpack_require__(5);

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      doneLoading: false,
      results: [],
      mainLeagueUsers: [],
      weeklyteams: []
    };
  },

  computed: {
    standings: function standings() {
      return this.mainLeagueUsers.sort(function (a, b) {
        var aPoints = 0;
        var bPoints = 0;
        a.weeklyteams.forEach(function (team) {
          aPoints += team.place;
        });
        b.weeklyteams.forEach(function (team) {
          bPoints += team.place;
        });
        return aPoints - bPoints;
      });
    },
    newstandings: function newstandings() {}
  },
  created: function created() {
    var _this = this;

    _axios2.default.get('/MainLeagueStandings').then(function (data) {
      _this.mainLeagueUsers = data.data;
      _this.mainLeagueUsers.forEach(function (user) {
        user.totalpoints = 0;
        user.weeklyteams.forEach(function (wt) {
          user.totalpoints += wt.place;
        });
        user.weeklyteams.sort(function (a, b) {
          return a - b;
        });
      });
      _this.doneLoading = true;
    });
  },

  methods: {
    pointsbehind: function pointsbehind(user) {
      var objIndex = this.standings.indexOf(user);
      if (objIndex != 0) {
        return user.totalpoints - this.standings[0].totalpoints;
      }
      return '-';
    }
  }
  // beforeCreate() {
  //    setTimeout(() => {
  //      axios.get('/RaceResults')
  //      .then(data => {
  //        console.time();
  //        var results = data.data.B;
  //        console.log(results);
  //        this.mainLeagueUsers.forEach(user => {
  //          user.totalpoints = 0;
  //          user.riders.forEach(rider => {
  //            results.forEach(result => {
  //              if (result.F.slice(0, -1) == rider.name) {
  //                rider.points = result.A;
  //              }
  //            })
  //            user.totalpoints += rider.points;
  //          })
  //        })
  //       console.timeEnd();
  //       this.doneLoading = true;
  //       console.log(this.mainLeagueUsers)
  //     })
  //    }, 3000);
  //   axios.get('/getMainLeagueInfo')
  //   .then(data => {
  //     console.log(data.data);
  //     data.data.forEach(user => {
  //       this.mainLeagueUsers.push(user)
  //     })
  //   })
  // }
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(5);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      username: '',
      password: '',
      isLoading: false
    };
  },

  computed: (0, _vuex.mapGetters)(['ShowLoginModal']),
  props: {
    show: {
      type: Boolean,
      required: true
    }
  },
  methods: _extends({}, (0, _vuex.mapMutations)(['setLoginModal', 'setUserData', 'setLoggedIn']), {
    submit: function submit(e) {
      var _this = this;

      e.preventDefault();
      this.isLoading = true;
      _axios2.default.post('/login', {
        username: this.username,
        password: this.password
      }).then(function (data) {
        _this.isLoading = false;
        _this.setUserData({ userData: data.data });
        _this.setLoggedIn({ loggedIn: true });
        _this.setLoginModal({ show: false });
      }).catch(function (err) {
        _this.isLoading = false;
        console.log("Login error: ", err);
      });
    }
  })
};

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(5);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(13);

var _findIndex2 = __webpack_require__(174);

var _findIndex3 = _interopRequireDefault(_findIndex2);

var _sortBy2 = __webpack_require__(181);

var _sortBy3 = _interopRequireDefault(_sortBy2);

var _remove2 = __webpack_require__(180);

var _remove3 = _interopRequireDefault(_remove2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      currentweek: 0,
      selectedriders: [],
      availableRiders: [],
      CostSortByAsc: true,
      page: 1
    };
  },

  computed: _extends({}, (0, _vuex.mapGetters)(['getUserData']), {
    dollars: function dollars() {
      var total = 8;
      this.selectedriders.forEach(function (rider) {
        total -= rider.cost;
      });
      return total;
    },
    hidePrevious: function hidePrevious() {
      return this.page <= 1;
    },
    hideNext: function hideNext() {
      return this.page >= this.paginationPages;
    },
    paginatedRiders: function paginatedRiders() {
      if (this.page == 1) {
        console.log("entire array", this.availableRiders);
        console.log(this.availableRiders.slice(0, 10));
        return this.availableRiders.slice(0, 10);
      } else {
        var beginSlice = this.page * 10 - 9;
        var endSlice = beginSlice + 10;
        console.log(this.availableRiders);
        console.log(this.availableRiders.slice(beginSlice, endSlice));
        return this.availableRiders.slice(beginSlice, endSlice);
      }
    },
    paginationPages: function paginationPages() {
      return Math.ceil(this.availableRiders.length / 10);
    },
    showSelect: function showSelect() {
      var openSlots = this.selectedriders.some(function (rider) {
        return rider.name == "OPEN SLOT";
      });
      var lowestCostAvailable = (0, _sortBy3.default)(this.availableRiders, function (o) {
        return o.cost;
      });
      console.log("showSelect", lowestCostAvailable[0]);
      if (this.dollars >= lowestCostAvailable[0].cost && openSlots) {
        return true;
      }
      return false;
    }
  }),
  methods: {
    removeRacer: function removeRacer(racer) {
      console.log("removed racers", racer);
      var selectedRacerIndex = (0, _findIndex3.default)(this.selectedriders, function (o) {
        return o.riderid === racer.riderid;
      });
      var openSpace = {
        avatar_url: 'http://www.shopaardvark.com/media/catalog/product/W/S/WS-18655.jpg',
        cost: 0,
        highestFinish: '-',
        lowestFinish: '-',
        name: 'OPEN SLOT',
        rider_number: 0,
        riderid: 0,
        leagueid: 1,
        season_weeksid: this.currentweek
      };
      this.availableRiders.push(racer);
      this.$set(this.selectedriders, selectedRacerIndex, openSpace);
      //call to save to DB;
    },
    addRacer: function addRacer(racer) {
      var openSlotIndex = (0, _findIndex3.default)(this.selectedriders, function (o) {
        return o.name == "OPEN SLOT";
      });
      (0, _remove3.default)(this.availableRiders, function (o) {
        return o.riderid == racer.riderid;
      });
      this.$set(this.selectedriders, openSlotIndex, racer);
    },
    sortByPrice: function sortByPrice() {
      if (this.CostSortByAsc) {
        this.CostSortByAsc = false;
        this.paginatedRiders = this.paginatedRiders.sort(function (a, b) {
          if (a.cost > b.cost) {
            return -1;
          }
          if (a.cost < b.cost) {
            return 1;
          }
          return 0;
        });
      } else {
        this.CostSortByAsc = true;
        this.paginatedRiders = this.paginatedRiders.sort(function (a, b) {
          if (a.cost > b.cost) {
            return 1;
          }
          if (a.cost < b.cost) {
            return -1;
          }
          return 0;
        });
      }
    },
    SaveTeam: function SaveTeam() {
      _axios2.default.post("/SaveTeam", this.selectedriders).then(function (data) {
        console.log(data);
      });
    }
  },
  beforeCreate: function beforeCreate() {
    var _this = this;

    _axios2.default.get('/CurrentMyTeamModel').then(function (data) {
      console.log("data", data.data);
      _this.currentweek = data.data.CurrentTeam[0].season_weeksid;
      _this.availableRiders = (0, _sortBy3.default)(data.data.AvailableRiders, function (o) {
        return o.cost;
      });
      _this.selectedriders = data.data.CurrentTeam;
    });
  },
  mounted: function mounted() {
    console.log("mounted", this.getUserData);
  }
};

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _axios = __webpack_require__(5);

var _axios2 = _interopRequireDefault(_axios);

var _vuex = __webpack_require__(13);

var _register = __webpack_require__(54);

var _register2 = _interopRequireDefault(_register);

var _login = __webpack_require__(203);

var _login2 = _interopRequireDefault(_login);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      username: '',
      password: '',
      showRegisterModal: false
    };
  },

  computed: (0, _vuex.mapGetters)(['ShowLoginModal', 'ShowRegisterModal', 'getUserData', 'GetAuthStatus']),
  mounted: function mounted() {
    // Get all "navbar-burger" elements
    var $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);
    console.log($navbarBurgers);
    // Check if there are any nav burgers
    if ($navbarBurgers.length > 0) {

      // Add a click event on each of them
      $navbarBurgers.forEach(function ($el) {
        $el.addEventListener('click', function () {

          // Get the target from the "data-target" attribute
          var target = $el.dataset.target;
          var $target = document.getElementById(target);

          // Toggle the class on both the "navbar-burger" and the "navbar-menu"
          $el.classList.toggle('is-active');
          $target.classList.toggle('is-active');
        });
      });
    }
  },
  created: function created() {
    var _this = this;

    _axios2.default.get('/loginrefresh').then(function (data) {
      console.log(data.data);
      if (typeof data.data.username != 'undefined') {
        console.log("User Is Authenticated");
        _this.setUserData({ userData: data.data });
        _this.setLoggedIn({ loggedIn: true });
      }
    }).catch(function (err) {
      console.log("login refresh error", err);
    });
  },

  methods: _extends({}, (0, _vuex.mapMutations)(['setRegisterModal', 'setLoginModal', 'setLoggedIn', 'setUserData', 'logout']), {
    logout: function logout() {
      var _this2 = this;

      _axios2.default.get('logout').then(function (data) {
        _this2.logout();
        _this2.$router.push("/");
      });
    }
  }),
  components: {
    'register': _register2.default,
    'login': _login2.default
  }
};

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var _vuex = __webpack_require__(13);

var _axios = __webpack_require__(5);

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  data: function data() {
    return {
      username: '',
      email: '',
      password: '',
      errorMessage: [],
      invalidUsername: false,
      invalidEmail: false,
      blankPassword: false,
      isLoading: false
    };
  },

  computed: (0, _vuex.mapGetters)(['ShowRegisterModal', 'getUserData']),
  methods: _extends({}, (0, _vuex.mapMutations)(['setRegisterModal', 'setUserData', 'setLoggedIn']), {
    Register: function Register() {
      var _this = this;

      this.isLoading = true;
      this.errorMessage = [];
      this.invalidEmail = false;
      this.blankPassword = false;
      this.invalidUsername = false;
      if (this.RegistrationIsValid()) {

        _axios2.default.post('/register', {
          username: this.username,
          email: this.email,
          password: this.password
        }).then(function (data) {
          console.log(data);
          _this.isLoading = false;
          var isFalse = !data.data.ErrorMessage;
          console.log("isFalse", isFalse);
          if (!data.data.ErrorMessage) {
            _this.setUserData({ userData: data.data });
            console.log("getUserData", _this.getUserData);
            _this.setRegisterModal({ show: false });
            _this.setLoggedIn({ loggedIn: true });
            console.log(_this.$store.state);
          } else {
            _this.errorMessage.push(data.data.ErrorMessage);
            _this.errorMessage.forEach(function (msg) {
              if (msg.indexOf("Username") > -1) {
                _this.invalidUsername = true;
              }
              if (msg.indexOf("Email") > -1) {
                _this.invalidEmail = true;
              }
            });
          }
        });
      }
    },
    RegistrationIsValid: function RegistrationIsValid() {
      var emailValidation = this.email.match(new RegExp(/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/), "i");
      console.log(emailValidation);
      if (this.email == "") {
        this.errorMessage.push("Username cannot be left empty.");
        this.invalidUsername = true;
      }
      if (emailValidation == null) {
        this.errorMessage.push("Please enter a valid email.");
        this.invalidEmail = true;
      }
      if (this.password == '' || this.password.length < 6) {
        this.errorMessage.push("Password cannot be left empty and must be at least 6 characters.");
        this.blankPassword = true;
      }
      if (this.errorMessage.length > 0) {
        this.isLoading = false;
        return false;
      }
      return true;
    }
  })
};

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _navbar = __webpack_require__(205);

var _navbar2 = _interopRequireDefault(_navbar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  computed: {
    username: function username() {
      return this.$store.state.username;
    },
    isLoggedIn: function isLoggedIn() {
      return this.$store.state.isLoggedIn;
    }
  },
  components: {
    'navigation': _navbar2.default
  }
}; //
//
//
//
//
//
//
//
//
//

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
  * vue-router v2.5.3
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert(condition, message) {
  if (!condition) {
    throw new Error("[vue-router] " + message);
  }
}

function warn(condition, message) {
  if ("development" !== 'production' && !condition) {
    typeof console !== 'undefined' && console.warn("[vue-router] " + message);
  }
}

var View = {
  name: 'router-view',
  functional: true,
  props: {
    name: {
      type: String,
      default: 'default'
    }
  },
  render: function render(_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    // directly use parent context's createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent) {
      if (parent.$vnode && parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name];

    // attach instance registration hook
    // this will be called in the instance's injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (val && current !== vm || !val && current === vm) {
        matched.instances[name] = val;
      }
    }

    // also regiseter instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // resolve props
    data.props = resolveProps(route, matched.props && matched.props[name]);

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config === 'undefined' ? 'undefined' : _typeof(config)) {
    case 'undefined':
      return;
    case 'object':
      return config;
    case 'function':
      return config(route);
    case 'boolean':
      return config ? route.params : undefined;
    default:
      if (true) {
        warn(false, "props in \"" + route.path + "\" is a " + (typeof config === 'undefined' ? 'undefined' : _typeof(config)) + ", " + "expecting an object, function or boolean.");
      }
  }
}

/*  */

var encodeReserveRE = /[!'()*]/g;
var encodeReserveReplacer = function encodeReserveReplacer(c) {
  return '%' + c.charCodeAt(0).toString(16);
};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!'()*]
// - preserve commas
var encode = function encode(str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery, _parseQuery) {
  if (extraQuery === void 0) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || '');
  } catch (e) {
    "development" !== 'production' && warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    var val = extraQuery[key];
    parsedQuery[key] = Array.isArray(val) ? val.slice() : val;
  }
  return parsedQuery;
}

function parseQuery(query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&)/, '');

  if (!query) {
    return res;
  }

  query.split('&').forEach(function (param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = decode(parts.shift());
    var val = parts.length > 0 ? decode(parts.join('=')) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return '';
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.slice().forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + '=' + encode(val2));
        }
      });
      return result.join('&');
    }

    return encode(key) + '=' + encode(val);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : null;
  return res ? "?" + res : '';
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom, router) {
  var stringifyQuery$$1 = router && router.options.stringifyQuery;
  var route = {
    name: location.name || record && record.name,
    meta: record && record.meta || {},
    path: location.path || '/',
    hash: location.hash || '',
    query: location.query || {},
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }
  return Object.freeze(route);
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: '/'
});

function formatMatch(record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res;
}

function getFullPath(ref, _stringifyQuery) {
  var path = ref.path;
  var query = ref.query;if (query === void 0) query = {};
  var hash = ref.hash;if (hash === void 0) hash = '';

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || '/') + stringify(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path && b.path) {
    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);
  } else if (a.name && b.name) {
    return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {};

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(function (key) {
    return String(a[key]) === String(b[key]);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: 'router-link',
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: 'a'
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: 'click'
    }
  },
  render: function render(h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;
    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;
    var compareTarget = location.path ? createRoute(null, location, null, router) : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);

    var handler = function handler(e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === 'a') {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first <a> child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the <a> is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn't have <a> child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don't redirect with control keys
  if (e.metaKey || e.ctrlKey || e.shiftKey) {
    return;
  }
  // don't redirect when preventDefault called
  if (e.defaultPrevented) {
    return;
  }
  // don't redirect on right click
  if (e.button !== undefined && e.button !== 0) {
    return;
  }
  // don't redirect if `target="_blank"`
  if (e.currentTarget && e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute('target');
    if (/\b_blank\b/i.test(target)) {
      return;
    }
  }
  // this may be a Weex event which doesn't have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true;
}

function findAnchor(children) {
  if (children) {
    var child;
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      if (child.tag === 'a') {
        return child;
      }
      if (child.children && (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed) {
    return;
  }
  install.installed = true;

  _Vue = Vue;

  Object.defineProperty(Vue.prototype, '$router', {
    get: function get() {
      return this.$root._router;
    }
  });

  Object.defineProperty(Vue.prototype, '$route', {
    get: function get() {
      return this.$root._route;
    }
  });

  var isDef = function isDef(v) {
    return v !== undefined;
  };

  var registerInstance = function registerInstance(vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (isDef(this.$options.router)) {
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, '_route', this._router.history.current);
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed() {
      registerInstance(this);
    }
  });

  Vue.component('router-view', View);
  Vue.component('router-link', Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;
}

/*  */

var inBrowser = typeof window !== 'undefined';

/*  */

function resolvePath(relative, base, append) {
  var firstChar = relative.charAt(0);
  if (firstChar === '/') {
    return relative;
  }

  if (firstChar === '?' || firstChar === '#') {
    return base + relative;
  }

  var stack = base.split('/');

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, '').split('/');
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    if (segment === '..') {
      stack.pop();
    } else if (segment !== '.') {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== '') {
    stack.unshift('');
  }

  return stack.join('/');
}

function parsePath(path) {
  var hash = '';
  var query = '';

  var hashIndex = path.indexOf('#');
  if (hashIndex >= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf('?');
  if (queryIndex >= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, '/');
}

var index$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var index = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (_typeof(tokens[i]) === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (index$1(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!index$1(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!index$1(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (index$1(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

index.parse = parse_1;
index.compile = compile_1;
index.tokensToFunction = tokensToFunction_1;
index.tokensToRegExp = tokensToRegExp_1;

/*  */

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = index.compile(path));
    return filler(params || {}, { pretty: true });
  } catch (e) {
    if (true) {
      warn(false, "missing param for " + routeMsg + ": " + e.message);
    }
    return '';
  }
}

/*  */

function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  var pathMap = oldPathMap || Object.create(null);
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i < l; i++) {
    if (pathList[i] === '*') {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;
  if (true) {
    assert(path != null, "\"path\" is required in a route configuration.");
    assert(typeof route.component !== 'string', "route config \"component\" for path: " + String(path || name) + " cannot be a " + "string id. Use an actual component instead.");
  }

  var normalizedPath = normalizePath(path, parent);
  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (true) {
      if (route.name && route.children.some(function (child) {
        return (/^\/?$/.test(child.path)
        );
      })) {
        warn(false, "Named Route '" + route.name + "' has a default child route. " + "When navigating to this named route (:to=\"{name: '" + route.name + "'\"), " + "the default child route will not be rendered. Remove the name from " + "this route and use the name of the default child route for named " + "links instead.");
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + "/" + child.path) : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    if (Array.isArray(route.alias)) {
      route.alias.forEach(function (alias) {
        var aliasRoute = {
          path: alias,
          children: route.children
        };
        addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path);
      });
    } else {
      var aliasRoute = {
        path: route.alias,
        children: route.children
      };
      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path);
    }
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if ("development" !== 'production' && !matchAs) {
      warn(false, "Duplicate named routes definition: " + "{ name: \"" + name + "\", path: \"" + record.path + "\" }");
    }
  }
}

function compileRouteRegex(path) {
  var regex = index(path);
  if (true) {
    var keys = {};
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], "Duplicate param keys in route with path: \"" + path + "\"");
      keys[key.name] = true;
    });
  }
  return regex;
}

function normalizePath(path, parent) {
  path = path.replace(/\/$/, '');
  if (path[0] === '/') {
    return path;
  }
  if (parent == null) {
    return path;
  }
  return cleanPath(parent.path + "/" + path);
}

/*  */

function normalizeLocation(raw, current, append, router) {
  var next = typeof raw === 'string' ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next;
  }

  // relative params
  if (!next.path && next.params && current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, "path " + current.path);
    } else if (true) {
      warn(false, "relative params navigation requires a current route.");
    }
    return next;
  }

  var parsedPath = parsePath(next.path || '');
  var basePath = current && current.path || '/';
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;

  var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);

  var hash = next.hash || parsedPath.hash;
  if (hash && hash.charAt(0) !== '#') {
    hash = "#" + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
}

/*  */

function createMatcher(routes, router) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (true) {
        warn(record, "Route with name '" + name + "' does not exist");
      }
      var paramNames = record.regex.keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (_typeof(location.params) !== 'object') {
        location.params = {};
      }

      if (currentRoute && _typeof(currentRoute.params) === 'object') {
        for (var key in currentRoute.params) {
          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, "named route \"" + name + "\"");
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i < pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom);
        }
      }
    }
    // no match
    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;

    if (typeof redirect === 'string') {
      redirect = { path: redirect };
    }

    if (!redirect || (typeof redirect === 'undefined' ? 'undefined' : _typeof(redirect)) !== 'object') {
      if (true) {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty('query') ? re.query : query;
    hash = re.hasOwnProperty('hash') ? re.hash : hash;
    params = re.hasOwnProperty('params') ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (true) {
        assert(targetRecord, "redirect failed: named route \"" + name + "\" not found.");
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, "redirect route with path \"" + rawPath + "\"");
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      if (true) {
        warn(false, "invalid redirect option: " + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, "aliased route with path \"" + matchAs + "\"");
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }
    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record && record.redirect) {
      return redirect(record, redirectedFrom || location);
    }
    if (record && record.matchAs) {
      return alias(record, location, record.matchAs);
    }
    return createRoute(record, location, redirectedFrom, router);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(regex, path, params) {
  var m = path.match(regex);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i < len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : '/', true);
}

/*  */

var positionStore = Object.create(null);

function setupScroll() {
  window.addEventListener('popstate', function (e) {
    saveScrollPosition();
    if (e.state && e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return;
  }

  if (true) {
    assert(typeof behavior === 'function', "scrollBehavior must be a function");
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);
    if (!shouldScroll) {
      return;
    }
    var isObject = (typeof shouldScroll === 'undefined' ? 'undefined' : _typeof(shouldScroll)) === 'object';
    if (isObject && typeof shouldScroll.selector === 'string') {
      var el = document.querySelector(shouldScroll.selector);
      if (el) {
        position = getElementPosition(el);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject && isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();
  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left,
    y: elRect.top - docRect.top
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function isNumber(v) {
  return typeof v === 'number';
}

/*  */

var supportsPushState = inBrowser && function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
    return false;
  }

  return window.history && 'pushState' in window.history;
}();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, '', url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, '', url);
    }
  } catch (e) {
    window.location[replace ? 'replace' : 'assign'](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}

/*  */

function runQueue(queue, fn, cb) {
  var step = function step(index) {
    if (index >= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for "nowhere"
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError(errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete && onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }
    if (err && !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) {
        cb(err);
      });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;

  var current = this.current;
  var abort = function abort(err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, 'uncaught error during route navigation:');
        console.error(err);
      }
    }
    onAbort && onAbort(err);
  };
  if (isSameRoute(route, current) &&
  // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;

  var queue = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),
  // global before hooks
  this.router.beforeHooks,
  // in-component update hooks
  extractUpdateHooks(updated),
  // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }),
  // async components
  resolveAsyncComponents(activated));

  this.pending = route;
  var iterator = function iterator(hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }
    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (typeof to === 'string' || (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {
          // next('/') or next({ path: '/' }) -> redirect
          abort();
          if ((typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' && to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function isValid() {
      return this$1.current === route;
    };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb && this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook && hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect <base> tag
      var baseEl = document.querySelector('base');
      base = baseEl && baseEl.getAttribute('href') || '/';
    } else {
      base = '/';
    }
  }
  // make sure there's the starting slash
  if (base.charAt(0) !== '/') {
    base = '/' + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, '');
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i < max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== 'function') {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, 'beforeRouteUpdate', bindGuard);
}

function bindGuard(guard, instance) {
  if (instance) {
    return function boundRouteGuard() {
      return guard.apply(instance, arguments);
    };
  }
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === 'function') {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

function resolveAsyncComponents(matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it's a function and doesn't have cid attached,
      // assume it's an async component resolve function.
      // we are not using Vue's default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === 'function' && def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          // save resolved on async factory in case it's used elsewhere
          def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending <= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = "Failed to resolve async component " + key + ": " + reason;
          "development" !== 'production' && warn(false, msg);
          if (!error) {
            error = isError(reason) ? reason : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === 'function') {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp && typeof comp.then === 'function') {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) {
      next();
    }
  };
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    return fn.apply(this, arguments);
  };
}

function isError(err) {
  return Object.prototype.toString.call(err).indexOf('Error') > -1;
}

/*  */

var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    window.addEventListener('popstate', function (e) {
      this$1.transitionTo(getLocation(this$1.base), function (route) {
        if (expectScroll) {
          handleScroll(router, route, this$1.current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;
  if (base && path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || '/') + window.location.search + window.location.hash;
}

/*  */

var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback && checkFallback(this.base)) {
      return;
    }
    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    window.addEventListener('hashchange', function () {
      if (!ensureSlash()) {
        return;
      }
      this$1.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath);
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      onComplete && onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + '/#' + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();
  if (path.charAt(0) === '/') {
    return true;
  }
  replaceHash('/' + path);
  return false;
}

function getHash() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf('#');
  return index === -1 ? '' : href.slice(index + 1);
}

function pushHash(path) {
  window.location.hash = path;
}

function replaceHash(path) {
  var i = window.location.href.indexOf('#');
  window.location.replace(window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path);
}

/*  */

var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete && onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex < 0 || targetIndex >= this.stack.length) {
      return;
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : '/';
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {
    // noop
  };

  return AbstractHistory;
}(History);

/*  */

var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || 'hash';
  this.fallback = mode === 'history' && !supportsPushState;
  if (this.fallback) {
    mode = 'hash';
  }
  if (!inBrowser) {
    mode = 'abstract';
  }
  this.mode = mode;

  switch (mode) {
    case 'history':
      this.history = new HTML5History(this, options.base);
      break;
    case 'hash':
      this.history = new HashHistory(this, options.base, this.fallback);
      break;
    case 'abstract':
      this.history = new AbstractHistory(this, options.base);
      break;
    default:
      if (true) {
        assert(false, "invalid mode: " + mode);
      }
  }
};

var prototypeAccessors = { currentRoute: {} };

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history && this.history.current;
};

VueRouter.prototype.init = function init(app /* Vue component instance */) {
  var this$1 = this;

  "development" !== 'production' && assert(install.installed, "not installed. Make sure to call `Vue.use(VueRouter)` " + "before creating root instance.");

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return;
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function setupHashListener() {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  return registerHook(this.beforeHooks, fn);
};

VueRouter.prototype.beforeResolve = function beforeResolve(fn) {
  return registerHook(this.resolveHooks, fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  return registerHook(this.afterHooks, fn);
};

VueRouter.prototype.onReady = function onReady(cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError(errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;
  if (!route) {
    return [];
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append, this);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function registerHook(list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i > -1) {
      list.splice(i, 1);
    }
  };
}

function createHref(base, fullPath, mode) {
  var path = mode === 'hash' ? '#' + fullPath : fullPath;
  return base ? cleanPath(base + '/' + path) : path;
}

VueRouter.install = install;
VueRouter.version = '2.5.3';

if (inBrowser && window.Vue) {
  window.Vue.use(VueRouter);
}

exports.default = VueRouter;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] });
    } else {
      newStyles[id].parts.push(part);
    }
  }
  return styles;
};

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(true);
// imports


// module
exports.push([module.i, "\n.pointsback: {\n  font-weight: bolder;\n  color: #ff3860;\n}\n.leaderboard {\n  margin-top: 50px;\n}\ntable td, th {\n  text-align: center !important;\n}\n.leaderboard-main {\n  margin-top: 25px;\n}\n.leaderboard-title {\n  text-align: center;\n  text-decoration: underline;\n  font-weight: 700;\n}\n", "", {"version":3,"sources":["/Users/Seth/Projects/fantasymx2/client/components/leaderboard.vue?8a365b84"],"names":[],"mappings":";AA0HA;EACA,oBAAA;EACA,eAAA;CACA;AACA;EACA,iBAAA;CACA;AACA;EACA,8BAAA;CACA;AACA;EACA,iBAAA;CACA;AACA;EACA,mBAAA;EACA,2BAAA;EACA,iBAAA;CACA","file":"leaderboard.vue","sourcesContent":["<template>\n  <div>\n  <div class=\"leaderboard-title\">\n    2018 FantasySX Main League\n  </div>\n  <div class=\"columns leaderboard\">\n    <div class=\"column is-half is-offset-one-quarter\">\n      <table class=\"table is-striped\" v-if=\"doneLoading\">\n        <thead>\n          <tr>\n            <th>Position</th>\n            <th>Total Points</th>\n            <th>Username</th>\n            <th>Points Back</th>\n          </tr>\n        </thead>\n        <tfoot>\n          <tr>\n            <th>Position</th>\n            <th>Total Points</th>\n            <th>Username</th>\n            <th>Points Back</th>\n          </tr>\n        </tfoot>\n        <tbody>\n          <tr v-for=\"(user, index) in standings\">\n            <td>{{ index + 1 }}.</td>\n            <td>{{user.totalpoints}}</td>\n            <td>{{user.weeklyteams[0].username}}</td>\n            <td class=\"pointsback\">{{ pointsbehind(user) }}</td>\n          </tr>\n        </tbody>\n      </table>\n      <div v-if=\"!doneLoading\">\n        <p>\"This data doesn't fetch itself.. Loading Race Tracker.\"</p>\n      </div>\n    </div>\n  </div>\n</div>\n</template>\n<script>\nimport axios from 'axios';\n  export default {\n    data() {\n      return {\n        doneLoading: false,\n        results: [],\n        mainLeagueUsers: [],\n        weeklyteams: []\n      }\n    },\n    computed: {\n      standings: function() {\n        return this.mainLeagueUsers.sort((a, b) => {\n          var aPoints = 0;\n          var bPoints = 0;\n          a.weeklyteams.forEach(team => { aPoints += team.place })\n          b.weeklyteams.forEach(team => { bPoints += team.place })\n          return aPoints - bPoints;\n        })\n      },\n      newstandings: function() {\n\n      }\n    },\n    created() {\n      axios.get('/MainLeagueStandings')\n      .then(data => {\n        this.mainLeagueUsers = data.data;\n        this.mainLeagueUsers.forEach((user) => {\n          user.totalpoints = 0\n          user.weeklyteams.forEach(wt => { user.totalpoints += wt.place })\n          user.weeklyteams.sort((a, b) => {\n            return a - b;\n          })\n        })\n        this.doneLoading = true;\n      })\n    },\n    methods: {\n      pointsbehind: function(user) {\n        var objIndex = this.standings.indexOf(user);\n        if (objIndex != 0) {\n          return user.totalpoints - this.standings[0].totalpoints;\n        }\n        return '-'\n      }\n    }\n    // beforeCreate() {\n    //    setTimeout(() => {\n    //      axios.get('/RaceResults')\n    //      .then(data => {\n    //        console.time();\n    //        var results = data.data.B;\n    //        console.log(results);\n    //        this.mainLeagueUsers.forEach(user => {\n    //          user.totalpoints = 0;\n    //          user.riders.forEach(rider => {\n    //            results.forEach(result => {\n    //              if (result.F.slice(0, -1) == rider.name) {\n    //                rider.points = result.A;\n    //              }\n    //            })\n    //            user.totalpoints += rider.points;\n    //          })\n    //        })\n    //       console.timeEnd();\n    //       this.doneLoading = true;\n    //       console.log(this.mainLeagueUsers)\n    //     })\n    //    }, 3000);\n    //   axios.get('/getMainLeagueInfo')\n    //   .then(data => {\n    //     console.log(data.data);\n    //     data.data.forEach(user => {\n    //       this.mainLeagueUsers.push(user)\n    //     })\n    //   })\n    // }\n  }\n</script>\n<style>\n  .pointsback: {\n    font-weight: bolder;\n    color: #ff3860;\n  }\n  .leaderboard {\n    margin-top: 50px;\n  }\n  table td, th {\n    text-align: center !important;\n  }\n  .leaderboard-main {\n    margin-top: 25px;\n  }\n  .leaderboard-title {\n    text-align: center;\n    text-decoration: underline;\n    font-weight: 700;\n  }\n</style>\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(true);
// imports


// module
exports.push([module.i, "\n.errorMessage {\n  color: #ff3860;\n}\n", "", {"version":3,"sources":["/Users/Seth/Projects/fantasymx2/client/components/register.vue?be1086d2"],"names":[],"mappings":";AA8IA;EACA,eAAA;CACA","file":"register.vue","sourcesContent":["<template>\n  <div class=\"modal\" v-bind:class=\"{'is-active': ShowRegisterModal}\" id=\"registerModal\">\n    <div class=\"modal-background\"></div>\n    <div class=\"modal-card\">\n      <header class=\"modal-card-head\">\n        <p class=\"modal-card-title\">New User Registration</p>\n        <button class=\"delete\" @click=\"setRegisterModal({ show: !ShowRegisterModal})\"></button>\n      </header>\n      <section class=\"modal-card-body\">\n        <div class=\"content\">\n            <div class=\"field\">\n              <label class=\"label\">Username: </label>\n              <div class=\"control has-icons-left\">\n                <input type=\"text\" class=\"input\" v-bind:class=\"{ 'is-danger': invalidUsername }\" id=\"reg-username\" v-model=\"username\" placeholder=\"Username\" required>\n                <span class=\"icon is-small is-left\">\n                  <i class=\"fa fa-user\"></i>\n                </span>\n              </div>\n            </div>\n            <div class=\"field\">\n              <label class=\"label\">Email: </label>\n              <div class=\"control has-icons-left\">\n                <input type=\"email\" class=\"input\" v-bind:class=\"{ 'is-danger': invalidEmail }\"  id=\"reg-email\" v-model=\"email\" placeholder=\"Email\" required>\n                <span class=\"icon is-small is-left\">\n                  <i class=\"fa fa-envelope\"></i>\n                </span>\n              </div>\n            </div>\n            <div class=\"field\">\n              <label class=\"label\">Password: </label>\n              <div class=\"control has-icons-left\">\n                <input type=\"password\" class=\"input\" v-bind:class=\"{ 'is-danger': blankPassword }\" id=\"reg-password\" v-model=\"password\" placeholder=\"Password\" required>\n                <span class=\"icon is-small is-left\">\n                  <i class=\"fa fa-lock\"></i>\n                </span>\n              </div>\n            </div>\n            <div class=\"field\">\n              RECAPTCHA PLACEHOLDER\n            </div>\n            <div class=\"errorMessage\" v-for=\"error in errorMessage\" v-if=\"errorMessage != ''\">\n              {{ error }}\n            </div>\n        </div>\n      </section>\n      <footer class=\"modal-card-foot\">\n        <a class=\"button is-success\" @click=\"Register\" v-bind:class=\"{ 'is-loading': isLoading }\">Register</a>\n        <a class=\"button\" @click=\"setRegisterModal({ show: !ShowRegisterModal })\">Cancel</a>\n      </footer>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { mapGetters, mapMutations } from 'vuex';\nimport axios from 'axios';\n  export default {\n    data() {\n      return {\n        username: '',\n        email: '',\n        password: '',\n        errorMessage: [],\n        invalidUsername: false,\n        invalidEmail: false,\n        blankPassword: false,\n        isLoading: false\n      }\n    },\n    computed: mapGetters([\n      'ShowRegisterModal',\n      'getUserData'\n    ]),\n    methods: {\n      ...mapMutations([\n        'setRegisterModal',\n        'setUserData',\n        'setLoggedIn'\n      ]),\n      Register() {\n        this.isLoading = true;\n        this.errorMessage = [];\n        this.invalidEmail = false;\n        this.blankPassword = false;\n        this.invalidUsername = false;\n        if (this.RegistrationIsValid()) {\n\n          axios.post('/register', {\n            username: this.username,\n            email: this.email,\n            password: this.password\n          }).then(data => {\n            console.log(data);\n            this.isLoading = false;\n            var isFalse = !data.data.ErrorMessage;\n            console.log(\"isFalse\", isFalse)\n            if (!data.data.ErrorMessage) {\n              this.setUserData({ userData: data.data })\n              console.log(\"getUserData\", this.getUserData)\n              this.setRegisterModal({ show: false })\n              this.setLoggedIn({ loggedIn: true })\n              console.log(this.$store.state);\n            } else {\n              this.errorMessage.push(data.data.ErrorMessage);\n              this.errorMessage.forEach(msg => {\n                if (msg.indexOf(\"Username\") > -1) {\n                  this.invalidUsername = true;\n                }\n                if (msg.indexOf(\"Email\") >-1) {\n                  this.invalidEmail = true;\n                }\n              })\n            }\n          })\n\n        }\n      },\n      RegistrationIsValid() {\n        var emailValidation = this.email.match(new RegExp(/^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/), \"i\");\n        console.log(emailValidation);\n        if (this.email == \"\") {\n          this.errorMessage.push(\"Username cannot be left empty.\")\n          this.invalidUsername = true;\n        }\n        if (emailValidation == null) {\n          this.errorMessage.push(\"Please enter a valid email.\")\n          this.invalidEmail = true;\n        }\n        if (this.password == '' || this.password.length < 6) {\n          this.errorMessage.push(\"Password cannot be left empty and must be at least 6 characters.\")\n          this.blankPassword = true;\n        }\n        if (this.errorMessage.length > 0) {\n          this.isLoading = false;\n          return false;\n        }\n        return true;\n      }\n    }\n  }\n</script>\n<style>\n  .errorMessage {\n    color: #ff3860;\n  }\n</style>\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(true);
// imports


// module
exports.push([module.i, "\n.riders-container {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: center;\n}\n.rider-block {\n  min-width: 15rem;\n  border: 1px solid #dedede;\n  margin: 1rem;\n  box-shadow: 1px 1px 1px #cecece;\n  padding: 1rem;\n  max-width: 15rem;\n}\n.page-title {\n  text-align: center;\n  text-decoration: underline;\n  font-weight: 700;\n}\n.page-title {\n  text-align: center;\n  text-decoration: underline;\n  font-weight: 700;\n}\n.page-subheader {\n  text-align:center;\n}\n.card-footer {\n  flex-direction: column;\n  border: 1px solid #eee;\n}\n.card-content {\n  min-height: 11rem;\n  max-height: 11rem;\n  overflow: hidden;\n  margin-bottom: 1rem;\n}\n.card-footer div:nth-child(even) {\n  background-color: #eee;\n}\n.footer-row {\n  display:flex;\n  justify-content: space-between;\n}\np.card-header-title {\n  display:flex;\n  justify-content: space-around;\n}\np span.icon {\n  color: #ff3860;\n}\nth:hover {\n  cursor: pointer;\n}\n.save-button {\n  position: fixed;\n}\n.hide-pagination-button {\n  visibility: hidden;\n}\n.custom-pagination {\n  display: flex;\n  justify-content: space-between;\n}\n", "", {"version":3,"sources":["/Users/Seth/Projects/fantasymx2/client/components/myteam.vue?75d35d2a"],"names":[],"mappings":";AA+NA;EACA,cAAA;EACA,gBAAA;EACA,wBAAA;CACA;AACA;EACA,iBAAA;EACA,0BAAA;EACA,aAAA;EACA,gCAAA;EACA,cAAA;EACA,iBAAA;CACA;AACA;EACA,mBAAA;EACA,2BAAA;EACA,iBAAA;CACA;AACA;EACA,mBAAA;EACA,2BAAA;EACA,iBAAA;CACA;AACA;EACA,kBAAA;CACA;AACA;EACA,uBAAA;EACA,uBAAA;CACA;AACA;EACA,kBAAA;EACA,kBAAA;EACA,iBAAA;EACA,oBAAA;CACA;AACA;EACA,uBAAA;CACA;AACA;EACA,aAAA;EACA,+BAAA;CACA;AACA;EACA,aAAA;EACA,8BAAA;CACA;AACA;EACA,eAAA;CACA;AACA;EACA,gBAAA;CACA;AACA;EACA,gBAAA;CACA;AACA;EACA,mBAAA;CACA;AACA;EACA,cAAA;EACA,+BAAA;CACA","file":"myteam.vue","sourcesContent":["<template>\n  <div class=\"content\">\n    <div class=\"page-title\">MY TEAM - TEAM SELECTION FOR WEEK {{ currentweek }}</div>\n    <a class=\"button is-success save-button\" @click=\"SaveTeam\">Save Team</a>\n    <p class=\"page-subheader\">Week {{ currentweek }} Balance: ${{dollars}}</p>\n    <!-- <div class=\"riders-container\">\n      <div class=\"card rider-block\" v-for=\"rider in selectedriders\">\n        <header class=\"card-header\">\n          <p class=\"card-header-title\">\n            {{rider.name}} - {{rider.rider_number}}\n              <span class=\"icon\" v-if=\"rider.name !== 'OPEN SLOT'\" @click=\"removeRacer(rider)\">\n                <i class=\"fa fa-times\" aria-hidden=\"true\"></i>\n              </span>\n          </p>\n        </header>\n        <div class=\"card-content\">\n          <div class=\"content\">\n            <img :src=\"rider.avatar_url\" />\n          </div>\n        </div>\n        <footer class=\"card-footer\">\n          <div class=\"footer-row\">\n            Cost: <span>${{rider.cost}}</span>\n          </div>\n          <div class=\"footer-row\">\n            Avg Finish: <span>{{rider.averageFinish}}</span>\n          </div>\n          <div class=\"footer-row\">\n            Highest Finish: <span>{{rider.highestFinish}}</span>\n          </div>\n          <div class=\"footer-row\">\n            Lowest Finish: <span>{{rider.lowestFinish}}</span>\n          </div>\n        </footer>\n      </div>\n    </div>\n    <p class=\"page-title\">AVAILABLE RIDERS</p> -->\n    <div class=\"container\">\n      <table class=\"table is-striped\">\n        <thead>\n          <tr>\n            <th @click=\"sortByPrice\">Price\n              <span class=\"icon\">\n                <i class=\"fa fa-caret-up\" v-if=\"CostSortByAsc\" aria-hidden=\"true\"></i>\n                <i class=\"fa fa-caret-down\" v-else aria-hidden=\"true\"></i>\n              </span>\n            </th>\n            <th>Racer Name</th>\n            <th>Racer Number</th>\n            <th>Highest Finish</th>\n            <th>Lowest Finish</th>\n            <th>Average Finish</th>\n            <th>Action</th>\n          </tr>\n        </thead>\n        <tfoot>\n          <tr>\n            <th>Price</th>\n            <th>Racer Name</th>\n            <th>Racer Number</th>\n            <th>Highest Finish</th>\n            <th>Lowest Finish</th>\n            <th>Average Finish</th>\n            <th>Action</th>\n          </tr>\n        </tfoot>\n        <tbody>\n          <tr v-for=\"rider in paginatedRiders\">\n            <td>${{rider.cost}}</td>\n            <td>{{rider.name}}</td>\n            <td>{{rider.rider_number}}</td>\n            <td>{{rider.highestFinish}}</td>\n            <td>{{rider.lowestFinish}}</td>\n            <td>{{rider.averageFinish}}</td>\n            <td><a href=\"#!\" v-if=\"showSelect && rider.cost <= dollars\" @click=\"addRacer(rider)\">SELECT</a></td>\n          </tr>\n        </tbody>\n      </table>\n      <div class=\"custom-pagination\">\n        <div>\n          <a class=\"pagination-previous\" @click=\"page--\" v-bind:class=\"{ 'hide-pagination-button' : hidePrevious }\">Previous</a>\n        </div>\n        <div>\n          <a class=\"pagination-number\">{{page}}/{{paginationPages}}</a>\n        </div>\n        <div>\n          <a class=\"pagination-next\" @click=\"page++\" v-bind:class=\"{ 'hide-pagination-button' : hideNext }\">Next page</a>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport axios from 'axios';\nimport { mapGetters } from 'vuex';\nimport _findIndex from 'lodash/findIndex';\nimport _sortBy from 'lodash/sortBy';\nimport _remove from 'lodash/remove';\n  export default {\n    data() {\n      return {\n        currentweek: 0,\n        selectedriders: [],\n        availableRiders: [],\n        CostSortByAsc: true,\n        page: 1\n      }\n    },\n    computed: {\n      ...mapGetters([\n        'getUserData'\n      ]),\n      dollars() {\n        var total = 8;\n        this.selectedriders.forEach(rider => {\n          total -= rider.cost;\n        })\n        return total;\n      },\n      hidePrevious() {\n        return this.page <= 1;\n      },\n      hideNext() {\n        return this.page >= this.paginationPages;\n      },\n      paginatedRiders() {\n        if (this.page == 1) {\n          console.log(\"entire array\", this.availableRiders)\n          console.log(this.availableRiders.slice(0, 10));\n          return this.availableRiders.slice(0, 10);\n        } else {\n          var beginSlice = this.page * 10 - 9;\n          var endSlice = beginSlice + 10;\n          console.log(this.availableRiders)\n          console.log(this.availableRiders.slice(beginSlice, endSlice))\n          return this.availableRiders.slice(beginSlice, endSlice);\n        }\n      },\n      paginationPages() {\n        return Math.ceil(this.availableRiders.length / 10);\n      },\n      showSelect() {\n        var openSlots = this.selectedriders.some((rider) => {return rider.name == \"OPEN SLOT\"});\n        var lowestCostAvailable = _sortBy(this.availableRiders, o => { return o.cost });\n        console.log(\"showSelect\", lowestCostAvailable[0])\n        if ((this.dollars >= lowestCostAvailable[0].cost) && openSlots) {\n          return true;\n        }\n        return false;\n      }\n    },\n    methods: {\n      removeRacer(racer) {\n        console.log(\"removed racers\", racer);\n        var selectedRacerIndex = _findIndex(this.selectedriders, o => { return o.riderid === racer.riderid });\n        var openSpace = {\n          avatar_url: 'http://www.shopaardvark.com/media/catalog/product/W/S/WS-18655.jpg',\n          cost: 0,\n          highestFinish: '-',\n          lowestFinish: '-',\n          name: 'OPEN SLOT',\n          rider_number: 0,\n          riderid: 0,\n          leagueid: 1,\n          season_weeksid: this.currentweek\n        }\n        this.availableRiders.push(racer);\n        this.$set(this.selectedriders, selectedRacerIndex, openSpace)\n        //call to save to DB;\n      },\n      addRacer(racer) {\n        var openSlotIndex = _findIndex(this.selectedriders, o => { return o.name == \"OPEN SLOT\" });\n        _remove(this.availableRiders, o => { return o.riderid == racer.riderid })\n        this.$set(this.selectedriders, openSlotIndex, racer);\n      },\n      sortByPrice() {\n        if (this.CostSortByAsc) {\n          this.CostSortByAsc = false;\n          this.paginatedRiders = this.paginatedRiders.sort((a, b) => {\n            if (a.cost > b.cost) {\n              return -1\n            }\n            if (a.cost < b.cost) {\n              return 1\n            }\n            return 0\n          })\n        } else {\n          this.CostSortByAsc = true;\n          this.paginatedRiders = this.paginatedRiders.sort((a, b) => {\n            if (a.cost > b.cost) {\n              return 1\n            }\n            if (a.cost < b.cost) {\n              return -1\n            }\n            return 0\n          })\n        }\n      },\n      SaveTeam() {\n        axios.post(\"/SaveTeam\", this.selectedriders)\n        .then(data => {\n          console.log(data);\n        })\n      }\n    },\n    beforeCreate() {\n      axios.get('/CurrentMyTeamModel')\n      .then(data => {\n        console.log(\"data\", data.data);\n        this.currentweek = data.data.CurrentTeam[0].season_weeksid;\n        this.availableRiders = _sortBy(data.data.AvailableRiders, o => { return o.cost });\n        this.selectedriders = data.data.CurrentTeam;\n      })\n    },\n    mounted() {\n      console.log(\"mounted\", this.getUserData)\n    }\n  }\n</script>\n<style>\n  .riders-container {\n    display: flex;\n    flex-wrap: wrap;\n    justify-content: center;\n  }\n  .rider-block {\n    min-width: 15rem;\n    border: 1px solid #dedede;\n    margin: 1rem;\n    box-shadow: 1px 1px 1px #cecece;\n    padding: 1rem;\n    max-width: 15rem;\n  }\n  .page-title {\n    text-align: center;\n    text-decoration: underline;\n    font-weight: 700;\n  }\n  .page-title {\n    text-align: center;\n    text-decoration: underline;\n    font-weight: 700;\n  }\n  .page-subheader {\n    text-align:center;\n  }\n  .card-footer {\n    flex-direction: column;\n    border: 1px solid #eee;\n  }\n  .card-content {\n    min-height: 11rem;\n    max-height: 11rem;\n    overflow: hidden;\n    margin-bottom: 1rem;\n  }\n  .card-footer div:nth-child(even) {\n    background-color: #eee;\n  }\n  .footer-row {\n    display:flex;\n    justify-content: space-between;\n  }\n  p.card-header-title {\n    display:flex;\n    justify-content: space-around;\n  }\n  p span.icon {\n    color: #ff3860;\n  }\n  th:hover {\n    cursor: pointer;\n  }\n  .save-button {\n    position: fixed;\n  }\n  .hide-pagination-button {\n    visibility: hidden;\n  }\n  .custom-pagination {\n    display: flex;\n    justify-content: space-between;\n  }\n</style>\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(true);
// imports


// module
exports.push([module.i, "\n\n\n\n\n\n\n\n", "", {"version":3,"sources":[],"names":[],"mappings":"","file":"index.vue","sourceRoot":""}]);

// exports


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(6)(true);
// imports


// module
exports.push([module.i, "\n.navbar-menu {\n  padding: 0 100px 0 50px;\n}\n.icon {\n  margin-right: 5px;\n  color: #00d1b2;\n}\n", "", {"version":3,"sources":["/Users/Seth/Projects/fantasymx2/client/components/navbar.vue?244cc86c"],"names":[],"mappings":";AA0IA;EACA,wBAAA;CACA;AACA;EACA,kBAAA;EACA,eAAA;CACA","file":"navbar.vue","sourcesContent":["\n  <template>\n    <nav class=\"navbar\">\n      <div class=\"navbar-brand\">\n        <div class=\"navbar-item\">\n          FANTASYMX\n        </div>\n        <div class=\"navbar-burger burger\" data-target=\"navMenu\">\n          <span></span>\n          <span></span>\n          <span></span>\n        </div>\n      </div>\n      <div class=\"navbar-menu\" id=\"navMenu\">\n        <div class=\"navbar-start\">\n          <div class=\"navbar-item\">\n            <span class=\"icon\">\n              <i class=\"fa fa-home\"></i>\n            </span>\n            <router-link to=\"/\">Home</router-link>\n          </div>\n          <div class=\"navbar-item\" v-if=\"GetAuthStatus\">\n            <span class=\"icon\" v-if=\"GetAuthStatus\">\n              <i class=\"fa fa-motorcycle\"></i>\n            </span>\n            <router-link to=\"/myteam\">My Team</router-link>\n          </div>\n          <div class=\"navbar-item\">\n            <span class=\"icon\">\n              <i class=\"fa fa-gavel\"></i>\n            </span>\n            <a href=\"#!\">Rules</a>\n          </div>\n        </div>\n        <div class=\"navbar-end\">\n          <div class=\"navbar-item\" v-if=\"!GetAuthStatus\" @click=\"setRegisterModal({ show: !ShowRegisterModal })\">\n            <span class=\"icon\">\n              <i class=\"fa fa-pencil-square-o\" aria-hidden=\"true\"></i>\n            </span>\n            <a href=\"#!\">Register</a>\n          </div>\n          <div class=\"navbar-item\" v-if=\"!GetAuthStatus\" @click=\"setLoginModal({ show: !ShowLoginModal })\">\n            <span class=\"icon\">\n              <i class=\"fa fa-sign-in\"></i>\n            </span>\n            <a href=\"#!\">Login</a>\n          </div>\n          <div class=\"navbar-item\" v-if=\"GetAuthStatus\">\n            <a href=\"#!\">Welcome, {{ getUserData.username }}!</a>\n          </div>\n          <div class=\"navbar-item\" v-if=\"GetAuthStatus\" @click=\"setLoggedIn({ isLoggedIn: !GetAuthStatus })\">\n            <span class=\"icon\" v-if=\"GetAuthStatus\">\n              <i class=\"fa fa-sign-out\" aria-hidden=\"true\"></i>\n            </span>\n            <a href=\"#!\" @click=\"logout\">Logout</a>\n          </div>\n        </div>\n      </div>\n      <register :show=\"ShowRegisterModal\"></register>\n      <login v-bind:show=\"ShowLoginModal\"></login>\n    </nav>\n  </template>\n  <script>\n    import axios from 'axios';\n    import { mapGetters, mapMutations } from 'vuex';\n    import register from './register.vue';\n    import login from './login.vue';\n    export default {\n      data() {\n        return  {\n          username: '',\n          password: '',\n          showRegisterModal: false,\n        }\n      },\n      computed: mapGetters([\n        'ShowLoginModal',\n        'ShowRegisterModal',\n        'getUserData',\n        'GetAuthStatus'\n      ]),\n      mounted() {\n        // Get all \"navbar-burger\" elements\n        var $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);\n        console.log($navbarBurgers);\n        // Check if there are any nav burgers\n        if ($navbarBurgers.length > 0) {\n\n          // Add a click event on each of them\n          $navbarBurgers.forEach(function ($el) {\n            $el.addEventListener('click', () => {\n\n              // Get the target from the \"data-target\" attribute\n              var target = $el.dataset.target;\n              var $target = document.getElementById(target);\n\n              // Toggle the class on both the \"navbar-burger\" and the \"navbar-menu\"\n              $el.classList.toggle('is-active');\n              $target.classList.toggle('is-active');\n\n            });\n          });\n        }\n      },\n      created() {\n        axios.get('/loginrefresh').then(data => {\n          console.log(data.data)\n          if (typeof data.data.username != 'undefined') {\n            console.log(\"User Is Authenticated\")\n            this.setUserData({ userData: data.data })\n            this.setLoggedIn({ loggedIn: true })\n          }\n        }).catch(err => {\n          console.log(\"login refresh error\", err);\n        })\n      },\n      methods: {\n        ...mapMutations([\n          'setRegisterModal',\n          'setLoginModal',\n          'setLoggedIn',\n          'setUserData',\n          'logout'\n        ]),\n        logout() {\n          axios.get('logout').then(data => {\n            this.logout();\n            this.$router.push(\"/\");\n          })\n        }\n      },\n      components: {\n        'register': register,\n        'login': login\n      }\n    }\n  </script>\n  <style>\n    .navbar-menu {\n      padding: 0 100px 0 50px;\n    }\n    .icon {\n      margin-right: 5px;\n      color: #00d1b2;\n    }\n  </style>\n})\n"],"sourceRoot":""}]);

// exports


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(212)
}
var Component = __webpack_require__(4)(
  /* script */
  __webpack_require__(189),
  /* template */
  __webpack_require__(206),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasymx2/client/components/leaderboard.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] leaderboard.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0cbb02c8", Component.options)
  } else {
    hotAPI.reload("data-v-0cbb02c8", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var Component = __webpack_require__(4)(
  /* script */
  __webpack_require__(190),
  /* template */
  __webpack_require__(208),
  /* styles */
  null,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasymx2/client/components/login.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] login.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-21d7d6f4", Component.options)
  } else {
    hotAPI.reload("data-v-21d7d6f4", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(214)
}
var Component = __webpack_require__(4)(
  /* script */
  __webpack_require__(191),
  /* template */
  __webpack_require__(209),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasymx2/client/components/myteam.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] myteam.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-38173d0e", Component.options)
  } else {
    hotAPI.reload("data-v-38173d0e", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(216)
}
var Component = __webpack_require__(4)(
  /* script */
  __webpack_require__(192),
  /* template */
  __webpack_require__(211),
  /* styles */
  injectStyle,
  /* scopeId */
  null,
  /* moduleIdentifier (server only) */
  null
)
Component.options.__file = "/Users/Seth/Projects/fantasymx2/client/components/navbar.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] navbar.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-774c6395", Component.options)
  } else {
    hotAPI.reload("data-v-774c6395", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('div', {
    staticClass: "leaderboard-title"
  }, [_vm._v("\n    2018 FantasySX Main League\n  ")]), _vm._v(" "), _c('div', {
    staticClass: "columns leaderboard"
  }, [_c('div', {
    staticClass: "column is-half is-offset-one-quarter"
  }, [(_vm.doneLoading) ? _c('table', {
    staticClass: "table is-striped"
  }, [_vm._m(0), _vm._v(" "), _c('tfoot', [_c('tr', [_c('th', [_vm._v("Position")]), _vm._v(" "), _c('th', [_vm._v("Total Points")]), _vm._v(" "), _c('th', [_vm._v("Username")]), _vm._v(" "), _c('th', [_vm._v("Points Back")])])]), _vm._v(" "), _c('tbody', _vm._l((_vm.standings), function(user, index) {
    return _c('tr', [_c('td', [_vm._v(_vm._s(index + 1) + ".")]), _vm._v(" "), _c('td', [_vm._v(_vm._s(user.totalpoints))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(user.weeklyteams[0].username))]), _vm._v(" "), _c('td', {
      staticClass: "pointsback"
    }, [_vm._v(_vm._s(_vm.pointsbehind(user)))])])
  }))], 1) : _vm._e(), _vm._v(" "), (!_vm.doneLoading) ? _c('div', [_c('p', [_vm._v("\"This data doesn't fetch itself.. Loading Race Tracker.\"")])]) : _vm._e()])])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('thead', [_c('tr', [_c('th', [_vm._v("Position")]), _vm._v(" "), _c('th', [_vm._v("Total Points")]), _vm._v(" "), _c('th', [_vm._v("Username")]), _vm._v(" "), _c('th', [_vm._v("Points Back")])])])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-0cbb02c8", module.exports)
  }
}

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "modal",
    class: {
      'is-active': _vm.ShowRegisterModal
    },
    attrs: {
      "id": "registerModal"
    }
  }, [_c('div', {
    staticClass: "modal-background"
  }), _vm._v(" "), _c('div', {
    staticClass: "modal-card"
  }, [_c('header', {
    staticClass: "modal-card-head"
  }, [_c('p', {
    staticClass: "modal-card-title"
  }, [_vm._v("New User Registration")]), _vm._v(" "), _c('button', {
    staticClass: "delete",
    on: {
      "click": function($event) {
        _vm.setRegisterModal({
          show: !_vm.ShowRegisterModal
        })
      }
    }
  })]), _vm._v(" "), _c('section', {
    staticClass: "modal-card-body"
  }, [_c('div', {
    staticClass: "content"
  }, [_c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label"
  }, [_vm._v("Username: ")]), _vm._v(" "), _c('div', {
    staticClass: "control has-icons-left"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.username),
      expression: "username"
    }],
    staticClass: "input",
    class: {
      'is-danger': _vm.invalidUsername
    },
    attrs: {
      "type": "text",
      "id": "reg-username",
      "placeholder": "Username",
      "required": ""
    },
    domProps: {
      "value": (_vm.username)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.username = $event.target.value
      }
    }
  }), _vm._v(" "), _vm._m(0)])]), _vm._v(" "), _c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label"
  }, [_vm._v("Email: ")]), _vm._v(" "), _c('div', {
    staticClass: "control has-icons-left"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.email),
      expression: "email"
    }],
    staticClass: "input",
    class: {
      'is-danger': _vm.invalidEmail
    },
    attrs: {
      "type": "email",
      "id": "reg-email",
      "placeholder": "Email",
      "required": ""
    },
    domProps: {
      "value": (_vm.email)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.email = $event.target.value
      }
    }
  }), _vm._v(" "), _vm._m(1)])]), _vm._v(" "), _c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label"
  }, [_vm._v("Password: ")]), _vm._v(" "), _c('div', {
    staticClass: "control has-icons-left"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.password),
      expression: "password"
    }],
    staticClass: "input",
    class: {
      'is-danger': _vm.blankPassword
    },
    attrs: {
      "type": "password",
      "id": "reg-password",
      "placeholder": "Password",
      "required": ""
    },
    domProps: {
      "value": (_vm.password)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.password = $event.target.value
      }
    }
  }), _vm._v(" "), _vm._m(2)])]), _vm._v(" "), _c('div', {
    staticClass: "field"
  }, [_vm._v("\n            RECAPTCHA PLACEHOLDER\n          ")]), _vm._v(" "), _vm._l((_vm.errorMessage), function(error) {
    return (_vm.errorMessage != '') ? _c('div', {
      staticClass: "errorMessage"
    }, [_vm._v("\n            " + _vm._s(error) + "\n          ")]) : _vm._e()
  })], 2)]), _vm._v(" "), _c('footer', {
    staticClass: "modal-card-foot"
  }, [_c('a', {
    staticClass: "button is-success",
    class: {
      'is-loading': _vm.isLoading
    },
    on: {
      "click": _vm.Register
    }
  }, [_vm._v("Register")]), _vm._v(" "), _c('a', {
    staticClass: "button",
    on: {
      "click": function($event) {
        _vm.setRegisterModal({
          show: !_vm.ShowRegisterModal
        })
      }
    }
  }, [_vm._v("Cancel")])])])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('span', {
    staticClass: "icon is-small is-left"
  }, [_c('i', {
    staticClass: "fa fa-user"
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('span', {
    staticClass: "icon is-small is-left"
  }, [_c('i', {
    staticClass: "fa fa-envelope"
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('span', {
    staticClass: "icon is-small is-left"
  }, [_c('i', {
    staticClass: "fa fa-lock"
  })])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-1ad06d68", module.exports)
  }
}

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "modal",
    class: {
      'is-active': _vm.show
    },
    attrs: {
      "id": "loginModal"
    }
  }, [_c('div', {
    staticClass: "modal-background"
  }), _vm._v(" "), _c('div', {
    staticClass: "modal-card"
  }, [_c('header', {
    staticClass: "modal-card-head"
  }, [_c('p', {
    staticClass: "modal-card-title"
  }, [_vm._v("User Login")]), _vm._v(" "), _c('button', {
    staticClass: "delete",
    on: {
      "click": function($event) {
        _vm.setLoginModal({
          show: !_vm.ShowLoginModal
        })
      }
    }
  })]), _vm._v(" "), _c('section', {
    staticClass: "modal-card-body"
  }, [_c('div', {
    staticClass: "content"
  }, [_c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label",
    attrs: {
      "for": "reg-username"
    }
  }, [_vm._v("Username: ")]), _vm._v(" "), _c('div', {
    staticClass: "control"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.username),
      expression: "username"
    }],
    staticClass: "input",
    attrs: {
      "type": "text"
    },
    domProps: {
      "value": (_vm.username)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.username = $event.target.value
      }
    }
  })])]), _vm._v(" "), _c('div', {
    staticClass: "field"
  }, [_c('label', {
    staticClass: "label",
    attrs: {
      "for": "reg-password"
    }
  }, [_vm._v("Password: ")]), _vm._v(" "), _c('div', {
    staticClass: "control"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.password),
      expression: "password"
    }],
    staticClass: "input",
    attrs: {
      "type": "password",
      "id": "reg-password"
    },
    domProps: {
      "value": (_vm.password)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.password = $event.target.value
      }
    }
  })])])])]), _vm._v(" "), _c('footer', {
    staticClass: "modal-card-foot"
  }, [_c('div', {
    staticClass: "field"
  }, [_c('button', {
    staticClass: "button is-primary",
    class: {
      'is-loading': _vm.isLoading
    },
    attrs: {
      "type": "button",
      "value": "Login",
      "id": "submit-login"
    },
    on: {
      "click": _vm.submit
    }
  }, [_vm._v("Login")]), _vm._v(" "), _c('a', {
    staticClass: "button",
    on: {
      "click": function($event) {
        _vm.setLoginModal({
          show: !_vm.ShowLoginModal
        })
      }
    }
  }, [_vm._v("Cancel")])])])])])
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-21d7d6f4", module.exports)
  }
}

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "content"
  }, [_c('div', {
    staticClass: "page-title"
  }, [_vm._v("MY TEAM - TEAM SELECTION FOR WEEK " + _vm._s(_vm.currentweek))]), _vm._v(" "), _c('a', {
    staticClass: "button is-success save-button",
    on: {
      "click": _vm.SaveTeam
    }
  }, [_vm._v("Save Team")]), _vm._v(" "), _c('p', {
    staticClass: "page-subheader"
  }, [_vm._v("Week " + _vm._s(_vm.currentweek) + " Balance: $" + _vm._s(_vm.dollars))]), _vm._v(" "), _c('div', {
    staticClass: "container"
  }, [_c('table', {
    staticClass: "table is-striped"
  }, [_c('thead', [_c('tr', [_c('th', {
    on: {
      "click": _vm.sortByPrice
    }
  }, [_vm._v("Price\n            "), _c('span', {
    staticClass: "icon"
  }, [(_vm.CostSortByAsc) ? _c('i', {
    staticClass: "fa fa-caret-up",
    attrs: {
      "aria-hidden": "true"
    }
  }) : _c('i', {
    staticClass: "fa fa-caret-down",
    attrs: {
      "aria-hidden": "true"
    }
  })])]), _vm._v(" "), _c('th', [_vm._v("Racer Name")]), _vm._v(" "), _c('th', [_vm._v("Racer Number")]), _vm._v(" "), _c('th', [_vm._v("Highest Finish")]), _vm._v(" "), _c('th', [_vm._v("Lowest Finish")]), _vm._v(" "), _c('th', [_vm._v("Average Finish")]), _vm._v(" "), _c('th', [_vm._v("Action")])])]), _vm._v(" "), _c('tfoot', [_c('tr', [_c('th', [_vm._v("Price")]), _vm._v(" "), _c('th', [_vm._v("Racer Name")]), _vm._v(" "), _c('th', [_vm._v("Racer Number")]), _vm._v(" "), _c('th', [_vm._v("Highest Finish")]), _vm._v(" "), _c('th', [_vm._v("Lowest Finish")]), _vm._v(" "), _c('th', [_vm._v("Average Finish")]), _vm._v(" "), _c('th', [_vm._v("Action")])])]), _vm._v(" "), _c('tbody', _vm._l((_vm.paginatedRiders), function(rider) {
    return _c('tr', [_c('td', [_vm._v("$" + _vm._s(rider.cost))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(rider.name))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(rider.rider_number))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(rider.highestFinish))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(rider.lowestFinish))]), _vm._v(" "), _c('td', [_vm._v(_vm._s(rider.averageFinish))]), _vm._v(" "), _c('td', [(_vm.showSelect && rider.cost <= _vm.dollars) ? _c('a', {
      attrs: {
        "href": "#!"
      },
      on: {
        "click": function($event) {
          _vm.addRacer(rider)
        }
      }
    }, [_vm._v("SELECT")]) : _vm._e()])])
  }))], 1), _vm._v(" "), _c('div', {
    staticClass: "custom-pagination"
  }, [_c('div', [_c('a', {
    staticClass: "pagination-previous",
    class: {
      'hide-pagination-button': _vm.hidePrevious
    },
    on: {
      "click": function($event) {
        _vm.page--
      }
    }
  }, [_vm._v("Previous")])]), _vm._v(" "), _c('div', [_c('a', {
    staticClass: "pagination-number"
  }, [_vm._v(_vm._s(_vm.page) + "/" + _vm._s(_vm.paginationPages))])]), _vm._v(" "), _c('div', [_c('a', {
    staticClass: "pagination-next",
    class: {
      'hide-pagination-button': _vm.hideNext
    },
    on: {
      "click": function($event) {
        _vm.page++
      }
    }
  }, [_vm._v("Next page")])])])])])
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-38173d0e", module.exports)
  }
}

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    attrs: {
      "id": "app"
    }
  }, [_c('navigation'), _vm._v(" "), _c('router-view')], 1)
},staticRenderFns: []}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-4f4e5dd2", module.exports)
  }
}

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('nav', {
    staticClass: "navbar"
  }, [_vm._m(0), _vm._v(" "), _c('div', {
    staticClass: "navbar-menu",
    attrs: {
      "id": "navMenu"
    }
  }, [_c('div', {
    staticClass: "navbar-start"
  }, [_c('div', {
    staticClass: "navbar-item"
  }, [_vm._m(1), _vm._v(" "), _c('router-link', {
    attrs: {
      "to": "/"
    }
  }, [_vm._v("Home")])], 1), _vm._v(" "), (_vm.GetAuthStatus) ? _c('div', {
    staticClass: "navbar-item"
  }, [(_vm.GetAuthStatus) ? _c('span', {
    staticClass: "icon"
  }, [_c('i', {
    staticClass: "fa fa-motorcycle"
  })]) : _vm._e(), _vm._v(" "), _c('router-link', {
    attrs: {
      "to": "/myteam"
    }
  }, [_vm._v("My Team")])], 1) : _vm._e(), _vm._v(" "), _vm._m(2)]), _vm._v(" "), _c('div', {
    staticClass: "navbar-end"
  }, [(!_vm.GetAuthStatus) ? _c('div', {
    staticClass: "navbar-item",
    on: {
      "click": function($event) {
        _vm.setRegisterModal({
          show: !_vm.ShowRegisterModal
        })
      }
    }
  }, [_vm._m(3), _vm._v(" "), _c('a', {
    attrs: {
      "href": "#!"
    }
  }, [_vm._v("Register")])]) : _vm._e(), _vm._v(" "), (!_vm.GetAuthStatus) ? _c('div', {
    staticClass: "navbar-item",
    on: {
      "click": function($event) {
        _vm.setLoginModal({
          show: !_vm.ShowLoginModal
        })
      }
    }
  }, [_vm._m(4), _vm._v(" "), _c('a', {
    attrs: {
      "href": "#!"
    }
  }, [_vm._v("Login")])]) : _vm._e(), _vm._v(" "), (_vm.GetAuthStatus) ? _c('div', {
    staticClass: "navbar-item"
  }, [_c('a', {
    attrs: {
      "href": "#!"
    }
  }, [_vm._v("Welcome, " + _vm._s(_vm.getUserData.username) + "!")])]) : _vm._e(), _vm._v(" "), (_vm.GetAuthStatus) ? _c('div', {
    staticClass: "navbar-item",
    on: {
      "click": function($event) {
        _vm.setLoggedIn({
          isLoggedIn: !_vm.GetAuthStatus
        })
      }
    }
  }, [(_vm.GetAuthStatus) ? _c('span', {
    staticClass: "icon"
  }, [_c('i', {
    staticClass: "fa fa-sign-out",
    attrs: {
      "aria-hidden": "true"
    }
  })]) : _vm._e(), _vm._v(" "), _c('a', {
    attrs: {
      "href": "#!"
    },
    on: {
      "click": _vm.logout
    }
  }, [_vm._v("Logout")])]) : _vm._e()])]), _vm._v(" "), _c('register', {
    attrs: {
      "show": _vm.ShowRegisterModal
    }
  }), _vm._v(" "), _c('login', {
    attrs: {
      "show": _vm.ShowLoginModal
    }
  })], 1)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "navbar-brand"
  }, [_c('div', {
    staticClass: "navbar-item"
  }, [_vm._v("\n      FANTASYMX\n    ")]), _vm._v(" "), _c('div', {
    staticClass: "navbar-burger burger",
    attrs: {
      "data-target": "navMenu"
    }
  }, [_c('span'), _vm._v(" "), _c('span'), _vm._v(" "), _c('span')])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('span', {
    staticClass: "icon"
  }, [_c('i', {
    staticClass: "fa fa-home"
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "navbar-item"
  }, [_c('span', {
    staticClass: "icon"
  }, [_c('i', {
    staticClass: "fa fa-gavel"
  })]), _vm._v(" "), _c('a', {
    attrs: {
      "href": "#!"
    }
  }, [_vm._v("Rules")])])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('span', {
    staticClass: "icon"
  }, [_c('i', {
    staticClass: "fa fa-pencil-square-o",
    attrs: {
      "aria-hidden": "true"
    }
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('span', {
    staticClass: "icon"
  }, [_c('i', {
    staticClass: "fa fa-sign-in"
  })])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-774c6395", module.exports)
  }
}

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(197);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(14)("1c8353b2", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-0cbb02c8\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./leaderboard.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-0cbb02c8\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./leaderboard.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(198);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(14)("030dbb78", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-1ad06d68\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./register.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-1ad06d68\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./register.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(199);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(14)("50262aa3", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-38173d0e\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./myteam.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-38173d0e\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./myteam.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(200);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(14)("013b0d28", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-4f4e5dd2\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./index.vue", function() {
     var newContent = require("!!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-4f4e5dd2\",\"scoped\":false,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./index.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(201);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(14)("70cdc113", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-774c6395\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./navbar.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js?sourceMap!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-774c6395\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./navbar.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMmU5NWMwZGMwODRiYTk3YTlhNTEiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovLy8uL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3RvS2V5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZXgvZGlzdC92dWV4LmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX25hdGl2ZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0FycmF5TGlrZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3Z1ZS9kaXN0L3Z1ZS5ydW50aW1lLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jYXN0UGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gva2V5cy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FycmF5TWFwLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2VxdWFsQXJyYXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hdGNoZXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL3JlZ2lzdGVyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9yb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3RvcmUvc3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vaW5kZXgudnVlIiwid2VicGFjazovLy8uL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9idG9hLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwid2VicGFjazovLy8uL34vYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIndlYnBhY2s6Ly8vLi9+L2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2Jhc2U2NC1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19EYXRhVmlldy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19TZXRDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fVWludDhBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fV2Vha01hcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheUxpa2VLZXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19hcnJheVNvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VFYWNoLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlRmluZEluZGV4LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUZvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUZvck93bi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlSXNFcXVhbERlZXAuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VJc01hdGNoLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlTWFwLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlTWF0Y2hlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZU9yZGVyQnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVB1bGxBdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVNsaWNlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlU29ydEJ5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2Jhc2VUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fYmFzZVVuc2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY29tcGFyZUFzY2VuZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY29tcGFyZU11bHRpcGxlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19jcmVhdGVCYXNlRWFjaC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2VxdWFsQnlUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19nZXRSYXdUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fZ2V0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2hhc1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faGFzaFNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNJdGVyYXRlZUNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWFwQ2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWFwVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX29iamVjdFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fcGFyZW50LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zZXRDYWNoZUFkZC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc2V0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3NldFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3NldFRvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zaG9ydE91dC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc3RhY2tEZWxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL19zdGFja0hhcy5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9fc3RhY2tTZXQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvX3N0cmluZ1RvUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9maW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvZ2V0LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2hhc0luLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL2xhc3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvbWVtb2l6ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvc29ydEJ5LmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3N0dWJBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9+L2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvdG9GaW5pdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3RvTnVtYmVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy9sZWFkZXJib2FyZC52dWUiLCJ3ZWJwYWNrOi8vL2xvZ2luLnZ1ZSIsIndlYnBhY2s6Ly8vbXl0ZWFtLnZ1ZSIsIndlYnBhY2s6Ly8vbmF2YmFyLnZ1ZSIsIndlYnBhY2s6Ly8vcmVnaXN0ZXIudnVlIiwid2VicGFjazovLy9pbmRleC52dWUiLCJ3ZWJwYWNrOi8vLy4vfi92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbGVhZGVyYm9hcmQudnVlPzViMTUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlP2Q1ZTAiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbXl0ZWFtLnZ1ZT81ZDU5Iiwid2VicGFjazovLy8uL2luZGV4LnZ1ZT8xMTdmIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL25hdmJhci52dWU/NmQ5MCIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbG9naW4udnVlIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL215dGVhbS52dWUiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZSIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWU/MTgxYiIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWU/MWY0NyIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9sb2dpbi52dWU/ZDBhMCIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9teXRlYW0udnVlPzc5MzYiLCJ3ZWJwYWNrOi8vLy4vaW5kZXgudnVlPzQ0M2QiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZT81ZGIzIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL2xlYWRlcmJvYXJkLnZ1ZT9lOTAzIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL3JlZ2lzdGVyLnZ1ZT83OWYxIiwid2VicGFjazovLy8uL2NsaWVudC9jb21wb25lbnRzL215dGVhbS52dWU/ODdlZiIsIndlYnBhY2s6Ly8vLi9pbmRleC52dWU/YjM1MCIsIndlYnBhY2s6Ly8vLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXIudnVlPzYxNzMiXSwibmFtZXMiOlsiYmluZCIsInJlcXVpcmUiLCJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsImlzQXJyYXkiLCJ2YWwiLCJjYWxsIiwiaXNCdWZmZXIiLCJCdWZmZXIiLCJpc0FycmF5QnVmZmVyIiwiaXNGb3JtRGF0YSIsIkZvcm1EYXRhIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJyZXN1bHQiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc1VuZGVmaW5lZCIsImlzT2JqZWN0IiwiaXNEYXRlIiwiaXNGaWxlIiwiaXNCbG9iIiwiaXNGdW5jdGlvbiIsImlzU3RyZWFtIiwicGlwZSIsImlzVVJMU2VhcmNoUGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwidHJpbSIsInN0ciIsInJlcGxhY2UiLCJpc1N0YW5kYXJkQnJvd3NlckVudiIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImZvckVhY2giLCJvYmoiLCJmbiIsImkiLCJsIiwibGVuZ3RoIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJtZXJnZSIsImFzc2lnblZhbHVlIiwiYXJndW1lbnRzIiwiZXh0ZW5kIiwiYSIsImIiLCJ0aGlzQXJnIiwibW9kdWxlIiwiZXhwb3J0cyIsImZyZWVHbG9iYWwiLCJmcmVlU2VsZiIsInNlbGYiLCJyb290IiwiRnVuY3Rpb24iLCJBcnJheSIsImJhc2VJc05hdGl2ZSIsImdldFZhbHVlIiwiZ2V0TmF0aXZlIiwib2JqZWN0IiwidmFsdWUiLCJ1bmRlZmluZWQiLCJ1c2VTb3VyY2VNYXAiLCJsaXN0IiwibWFwIiwiaXRlbSIsImNvbnRlbnQiLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwiam9pbiIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImlkIiwicHVzaCIsImNzc01hcHBpbmciLCJidG9hIiwic291cmNlTWFwcGluZyIsInRvQ29tbWVudCIsInNvdXJjZVVSTHMiLCJzb3VyY2VzIiwic291cmNlIiwic291cmNlUm9vdCIsImNvbmNhdCIsInNvdXJjZU1hcCIsImJhc2U2NCIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiSlNPTiIsInN0cmluZ2lmeSIsImRhdGEiLCJTeW1ib2wiLCJnZXRSYXdUYWciLCJvYmplY3RUb1N0cmluZyIsIm51bGxUYWciLCJ1bmRlZmluZWRUYWciLCJzeW1Ub1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiYmFzZUdldFRhZyIsImlzU3ltYm9sIiwiSU5GSU5JVFkiLCJ0b0tleSIsInR5cGUiLCJpc09iamVjdExpa2UiLCJzeW1ib2xUYWciLCJhcHBseU1peGluIiwiVnVlIiwidmVyc2lvbiIsIk51bWJlciIsInNwbGl0IiwidXNlc0luaXQiLCJjb25maWciLCJfbGlmZWN5Y2xlSG9va3MiLCJpbmRleE9mIiwibWl4aW4iLCJpbml0IiwidnVleEluaXQiLCJiZWZvcmVDcmVhdGUiLCJfaW5pdCIsIm9wdGlvbnMiLCIkb3B0aW9ucyIsInN0b3JlIiwiJHN0b3JlIiwicGFyZW50IiwiZGV2dG9vbEhvb2siLCJfX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiZGV2dG9vbFBsdWdpbiIsIl9kZXZ0b29sSG9vayIsImVtaXQiLCJvbiIsInRhcmdldFN0YXRlIiwicmVwbGFjZVN0YXRlIiwic3Vic2NyaWJlIiwibXV0YXRpb24iLCJzdGF0ZSIsImZvckVhY2hWYWx1ZSIsImtleXMiLCJpc1Byb21pc2UiLCJ0aGVuIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwibXNnIiwiRXJyb3IiLCJNb2R1bGUiLCJyYXdNb2R1bGUiLCJydW50aW1lIiwiX2NoaWxkcmVuIiwiY3JlYXRlIiwiX3Jhd01vZHVsZSIsInJhd1N0YXRlIiwicHJvdG90eXBlQWNjZXNzb3JzJDEiLCJuYW1lc3BhY2VkIiwiZ2V0IiwiYWRkQ2hpbGQiLCJyZW1vdmVDaGlsZCIsImdldENoaWxkIiwidXBkYXRlIiwiYWN0aW9ucyIsIm11dGF0aW9ucyIsImdldHRlcnMiLCJmb3JFYWNoQ2hpbGQiLCJmb3JFYWNoR2V0dGVyIiwiZm9yRWFjaEFjdGlvbiIsImZvckVhY2hNdXRhdGlvbiIsImRlZmluZVByb3BlcnRpZXMiLCJNb2R1bGVDb2xsZWN0aW9uIiwicmF3Um9vdE1vZHVsZSIsInRoaXMkMSIsInJlZ2lzdGVyIiwicGF0aCIsInJlZHVjZSIsImdldE5hbWVzcGFjZSIsIm5hbWVzcGFjZSIsInVwZGF0ZSQxIiwic2xpY2UiLCJuZXdNb2R1bGUiLCJyYXdDaGlsZE1vZHVsZSIsInVucmVnaXN0ZXIiLCJ0YXJnZXRNb2R1bGUiLCJjb25zb2xlIiwid2FybiIsIlN0b3JlIiwiUHJvbWlzZSIsInBsdWdpbnMiLCJzdHJpY3QiLCJfY29tbWl0dGluZyIsIl9hY3Rpb25zIiwiX211dGF0aW9ucyIsIl93cmFwcGVkR2V0dGVycyIsIl9tb2R1bGVzIiwiX21vZHVsZXNOYW1lc3BhY2VNYXAiLCJfc3Vic2NyaWJlcnMiLCJfd2F0Y2hlclZNIiwicmVmIiwiZGlzcGF0Y2giLCJjb21taXQiLCJib3VuZERpc3BhdGNoIiwicGF5bG9hZCIsImJvdW5kQ29tbWl0IiwiaW5zdGFsbE1vZHVsZSIsInJlc2V0U3RvcmVWTSIsInBsdWdpbiIsInByb3RvdHlwZUFjY2Vzc29ycyIsIl92bSIsIl9kYXRhIiwiJCRzdGF0ZSIsInNldCIsInYiLCJfdHlwZSIsIl9wYXlsb2FkIiwiX29wdGlvbnMiLCJ1bmlmeU9iamVjdFN0eWxlIiwiZW50cnkiLCJlcnJvciIsIl93aXRoQ29tbWl0IiwiY29tbWl0SXRlcmF0b3IiLCJoYW5kbGVyIiwic3ViIiwic2lsZW50IiwiYWxsIiwic3VicyIsInNwbGljZSIsIndhdGNoIiwiZ2V0dGVyIiwiY2IiLCIkd2F0Y2giLCJyZWdpc3Rlck1vZHVsZSIsInVucmVnaXN0ZXJNb2R1bGUiLCJwYXJlbnRTdGF0ZSIsImdldE5lc3RlZFN0YXRlIiwiZGVsZXRlIiwicmVzZXRTdG9yZSIsImhvdFVwZGF0ZSIsIm5ld09wdGlvbnMiLCJjb21taXR0aW5nIiwiaG90Iiwib2xkVm0iLCJ3cmFwcGVkR2V0dGVycyIsImNvbXB1dGVkIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZW5hYmxlU3RyaWN0TW9kZSIsIm5leHRUaWNrIiwiJGRlc3Ryb3kiLCJyb290U3RhdGUiLCJpc1Jvb3QiLCJtb2R1bGVOYW1lIiwibG9jYWwiLCJjb250ZXh0IiwibWFrZUxvY2FsQ29udGV4dCIsIm5hbWVzcGFjZWRUeXBlIiwicmVnaXN0ZXJNdXRhdGlvbiIsImFjdGlvbiIsInJlZ2lzdGVyQWN0aW9uIiwicmVnaXN0ZXJHZXR0ZXIiLCJjaGlsZCIsIm5vTmFtZXNwYWNlIiwiYXJncyIsIm1ha2VMb2NhbEdldHRlcnMiLCJnZXR0ZXJzUHJveHkiLCJzcGxpdFBvcyIsImxvY2FsVHlwZSIsIndyYXBwZWRNdXRhdGlvbkhhbmRsZXIiLCJ3cmFwcGVkQWN0aW9uSGFuZGxlciIsInJlcyIsInJvb3RHZXR0ZXJzIiwicmVzb2x2ZSIsImNhdGNoIiwiZXJyIiwicmF3R2V0dGVyIiwid3JhcHBlZEdldHRlciIsImRlZXAiLCJzeW5jIiwiaW5zdGFsbCIsIl9WdWUiLCJtYXBTdGF0ZSIsIm5vcm1hbGl6ZU5hbWVzcGFjZSIsInN0YXRlcyIsIm5vcm1hbGl6ZU1hcCIsIm1hcHBlZFN0YXRlIiwiZ2V0TW9kdWxlQnlOYW1lc3BhY2UiLCJ2dWV4IiwibWFwTXV0YXRpb25zIiwibWFwcGVkTXV0YXRpb24iLCJsZW4iLCJhcHBseSIsIm1hcEdldHRlcnMiLCJtYXBwZWRHZXR0ZXIiLCJtYXBBY3Rpb25zIiwibWFwcGVkQWN0aW9uIiwiY2hhckF0IiwiaGVscGVyIiwiaW5kZXhfZXNtIiwibGlzdENhY2hlQ2xlYXIiLCJsaXN0Q2FjaGVEZWxldGUiLCJsaXN0Q2FjaGVHZXQiLCJsaXN0Q2FjaGVIYXMiLCJsaXN0Q2FjaGVTZXQiLCJMaXN0Q2FjaGUiLCJlbnRyaWVzIiwiaW5kZXgiLCJjbGVhciIsImhhcyIsImVxIiwiYXNzb2NJbmRleE9mIiwiYXJyYXkiLCJpc0tleWFibGUiLCJnZXRNYXBEYXRhIiwiX19kYXRhX18iLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJpc0luZGV4IiwidGVzdCIsIm5hdGl2ZUNyZWF0ZSIsImlkZW50aXR5IiwiaXNMZW5ndGgiLCJpc0FycmF5TGlrZSIsImlzVW5kZWYiLCJpc0RlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsIl90b1N0cmluZyIsImlzUGxhaW5PYmplY3QiLCJpc1JlZ0V4cCIsIlN0cmluZyIsInRvTnVtYmVyIiwibiIsInBhcnNlRmxvYXQiLCJpc05hTiIsIm1ha2VNYXAiLCJleHBlY3RzTG93ZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJpc0J1aWx0SW5UYWciLCJyZW1vdmUiLCJhcnIiLCJoYXNPd24iLCJjYWNoZWQiLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwiXyIsImMiLCJ0b1VwcGVyQ2FzZSIsImNhcGl0YWxpemUiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsImN0eCIsImJvdW5kRm4iLCJfbGVuZ3RoIiwidG9BcnJheSIsInN0YXJ0IiwicmV0IiwidG8iLCJfZnJvbSIsInRvT2JqZWN0Iiwibm9vcCIsIm5vIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImUiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsInBlcmZvcm1hbmNlIiwiZXJyb3JIYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsImVtcHR5T2JqZWN0IiwiZnJlZXplIiwiaXNSZXNlcnZlZCIsImNoYXJDb2RlQXQiLCJkZWYiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImJhaWxSRSIsInBhcnNlUGF0aCIsInNlZ21lbnRzIiwidGlwIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJ2bSIsImdlbmVyYXRlQ29tcG9uZW50VHJhY2UiLCJpbmNsdWRlRmlsZSIsIiRyb290IiwibmFtZSIsIl9pc1Z1ZSIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwibWF0Y2giLCJyZXBlYXQiLCIkcGFyZW50IiwidHJlZSIsImN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSIsImxhc3QiLCJjb25zdHJ1Y3RvciIsImhhbmRsZUVycm9yIiwiaW5mbyIsImluQnJvd3NlciIsImhhc1Byb3RvIiwiVUEiLCJ1c2VyQWdlbnQiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwic3VwcG9ydHNQYXNzaXZlIiwib3B0cyIsImFkZEV2ZW50TGlzdGVuZXIiLCJfaXNTZXJ2ZXIiLCJpc1NlcnZlclJlbmRlcmluZyIsImdsb2JhbCIsImVudiIsIlZVRV9FTlYiLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsImNhbGxiYWNrcyIsInBlbmRpbmciLCJ0aW1lckZ1bmMiLCJuZXh0VGlja0hhbmRsZXIiLCJjb3BpZXMiLCJwIiwibG9nRXJyb3IiLCJzZXRUaW1lb3V0IiwiTXV0YXRpb25PYnNlcnZlciIsImNvdW50ZXIiLCJvYnNlcnZlciIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsInF1ZXVlTmV4dFRpY2siLCJfcmVzb2x2ZSIsInJlamVjdCIsIl9TZXQiLCJTZXQiLCJhZGQiLCJ1aWQkMSIsIkRlcCIsImFkZFN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsInRhcmdldCIsImFkZERlcCIsIm5vdGlmeSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsIl90YXJnZXQiLCJwb3BUYXJnZXQiLCJwb3AiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwiYXJndW1lbnRzJDEiLCJvYiIsIl9fb2JfXyIsImluc2VydGVkIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9ic2VydmVyU3RhdGUiLCJzaG91bGRDb252ZXJ0IiwiaXNTZXR0aW5nUHJvcHMiLCJPYnNlcnZlciIsInZtQ291bnQiLCJhdWdtZW50IiwicHJvdG9BdWdtZW50IiwiY29weUF1Z21lbnQiLCJ3YWxrIiwiZGVmaW5lUmVhY3RpdmUkJDEiLCJpdGVtcyIsInNyYyIsIl9fcHJvdG9fXyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJjdXN0b21TZXR0ZXIiLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJNYXRoIiwibWF4IiwicHJvY2VzcyIsImRlbCIsInN0cmF0cyIsImVsIiwicHJvcHNEYXRhIiwiZGVmYXVsdFN0cmF0IiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImhvb2siLCJtZXJnZUFzc2V0cyIsInByb3BzIiwibWV0aG9kcyIsImNoZWNrQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJsb3dlciIsIm5vcm1hbGl6ZVByb3BzIiwibm9ybWFsaXplRGlyZWN0aXZlcyIsImRpcnMiLCJkaXJlY3RpdmVzIiwibWVyZ2VPcHRpb25zIiwiZXh0ZW5kc0Zyb20iLCJleHRlbmRzIiwibWl4aW5zIiwibWVyZ2VGaWVsZCIsInN0cmF0IiwicmVzb2x2ZUFzc2V0Iiwid2Fybk1pc3NpbmciLCJhc3NldHMiLCJjYW1lbGl6ZWRJZCIsIlBhc2NhbENhc2VJZCIsInZhbGlkYXRlUHJvcCIsInByb3BPcHRpb25zIiwicHJvcCIsImFic2VudCIsImlzVHlwZSIsIkJvb2xlYW4iLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZENvbnZlcnQiLCJhc3NlcnRQcm9wIiwiZGVmYXVsdCIsIl9wcm9wcyIsImdldFR5cGUiLCJyZXF1aXJlZCIsInZhbGlkIiwiZXhwZWN0ZWRUeXBlcyIsImFzc2VydGVkVHlwZSIsImFzc2VydFR5cGUiLCJleHBlY3RlZFR5cGUiLCJ2YWxpZGF0b3IiLCJzaW1wbGVDaGVja1JFIiwiaW5pdFByb3h5IiwiYWxsb3dlZEdsb2JhbHMiLCJ3YXJuTm9uUHJlc2VudCIsImhhc1Byb3h5IiwiUHJveHkiLCJpc0J1aWx0SW5Nb2RpZmllciIsImhhc0hhbmRsZXIiLCJpc0FsbG93ZWQiLCJnZXRIYW5kbGVyIiwiaGFuZGxlcnMiLCJyZW5kZXIiLCJfd2l0aFN0cmlwcGVkIiwiX3JlbmRlclByb3h5IiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJ0YWciLCJzdGFydFRhZyIsImVuZFRhZyIsIlZOb2RlIiwiY2hpbGRyZW4iLCJ0ZXh0IiwiZWxtIiwiY29tcG9uZW50T3B0aW9ucyIsIm5zIiwiZnVuY3Rpb25hbENvbnRleHQiLCJjb21wb25lbnRJbnN0YW5jZSIsInJhdyIsImlzU3RhdGljIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJjcmVhdGVFbXB0eVZOb2RlIiwibm9kZSIsImNyZWF0ZVRleHRWTm9kZSIsImNsb25lVk5vZGUiLCJ2bm9kZSIsImNsb25lZCIsImNsb25lVk5vZGVzIiwidm5vZGVzIiwibm9ybWFsaXplRXZlbnQiLCJwYXNzaXZlIiwib25jZSQkMSIsImNhcHR1cmUiLCJjcmVhdGVGbkludm9rZXIiLCJmbnMiLCJpbnZva2VyIiwidXBkYXRlTGlzdGVuZXJzIiwib2xkT24iLCJyZW1vdmUkJDEiLCJjdXIiLCJvbGQiLCJldmVudCIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsImV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEiLCJhdHRycyIsImFsdEtleSIsImtleUluTG93ZXJDYXNlIiwiY2hlY2tQcm9wIiwiaGFzaCIsInByZXNlcnZlIiwic2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4iLCJpc1RleHROb2RlIiwibmVzdGVkSW5kZXgiLCJfaXNWTGlzdCIsImVuc3VyZUN0b3IiLCJjb21wIiwiYmFzZSIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImZhY3RvcnkiLCJiYXNlQ3RvciIsImVycm9yQ29tcCIsInJlc29sdmVkIiwibG9hZGluZyIsImxvYWRpbmdDb21wIiwiY29udGV4dHMiLCJmb3JjZVJlbmRlciIsIiRmb3JjZVVwZGF0ZSIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsImhvb2tSRSIsImkkMSIsImNicyIsIiRlbWl0IiwibG93ZXJDYXNlRXZlbnQiLCJyZXNvbHZlU2xvdHMiLCJzbG90cyIsImRlZmF1bHRTbG90Iiwic2xvdCIsImV2ZXJ5IiwiaXNXaGl0ZXNwYWNlIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiYWN0aXZlSW5zdGFuY2UiLCJpbml0TGlmZWN5Y2xlIiwiYWJzdHJhY3QiLCIkY2hpbGRyZW4iLCIkcmVmcyIsIl93YXRjaGVyIiwiX2luYWN0aXZlIiwiX2RpcmVjdEluYWN0aXZlIiwiX2lzTW91bnRlZCIsIl9pc0Rlc3Ryb3llZCIsIl9pc0JlaW5nRGVzdHJveWVkIiwibGlmZWN5Y2xlTWl4aW4iLCJfdXBkYXRlIiwiaHlkcmF0aW5nIiwiY2FsbEhvb2siLCJwcmV2RWwiLCIkZWwiLCJwcmV2Vm5vZGUiLCJfdm5vZGUiLCJwcmV2QWN0aXZlSW5zdGFuY2UiLCJfX3BhdGNoX18iLCJfcGFyZW50RWxtIiwiX3JlZkVsbSIsIl9fdnVlX18iLCIkdm5vZGUiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIm1vdW50Q29tcG9uZW50IiwidGVtcGxhdGUiLCJ1cGRhdGVDb21wb25lbnQiLCJfbmFtZSIsIl91aWQiLCJfcmVuZGVyIiwiV2F0Y2hlciIsInVwZGF0ZUNoaWxkQ29tcG9uZW50IiwicGFyZW50Vm5vZGUiLCJyZW5kZXJDaGlsZHJlbiIsImhhc0NoaWxkcmVuIiwiX3JlbmRlckNoaWxkcmVuIiwic2NvcGVkU2xvdHMiLCIkc2NvcGVkU2xvdHMiLCJfcGFyZW50Vm5vZGUiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVIb29rcyIsInF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50IiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwibGF6eSIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJ0cmF2ZXJzZSIsImNsZWFudXBEZXBzIiwidG1wIiwib2xkVmFsdWUiLCJldmFsdWF0ZSIsInNlZW5PYmplY3RzIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImRlcElkIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsImlzUmVzZXJ2ZWRQcm9wIiwicHJvcHNPcHRpb25zIiwibG9vcCIsImdldERhdGEiLCJjb21wdXRlZFdhdGNoZXJPcHRpb25zIiwid2F0Y2hlcnMiLCJfY29tcHV0ZWRXYXRjaGVycyIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsIiRkYXRhIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjb21wdXRlZEdldHRlciIsImNyZWF0ZVdhdGNoZXIiLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJwcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwiaW5qZWN0IiwicHJvdmlkZUtleSIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwiX2NvbnRleHQiLCJoIiwiZCIsImNyZWF0ZUVsZW1lbnQiLCJpbmplY3Rpb25zIiwiZnVuY3Rpb25hbE9wdGlvbnMiLCJjb21wb25lbnRWTm9kZUhvb2tzIiwicGFyZW50RWxtIiwicmVmRWxtIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsIiRtb3VudCIsImtlZXBBbGl2ZSIsIm1vdW50ZWROb2RlIiwicHJlcGF0Y2giLCJvbGRWbm9kZSIsImluc2VydCIsImRlc3Ryb3kiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJfYmFzZSIsImNpZCIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwiZnVuY3Rpb25hbCIsIm5hdGl2ZU9uIiwibWVyZ2VIb29rcyIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsIl9pc0NvbXBvbmVudCIsImlubGluZVRlbXBsYXRlIiwic3RhdGljUmVuZGVyRm5zIiwiZnJvbVBhcmVudCIsIm91cnMiLCJtZXJnZUhvb2skMSIsIm9uZSIsInR3byIsImNhbGxiYWNrIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwiYXBwbHlOUyIsInJlbmRlckxpc3QiLCJyZW5kZXJTbG90IiwiZmFsbGJhY2siLCJiaW5kT2JqZWN0Iiwic2NvcGVkU2xvdEZuIiwic2xvdE5vZGVzIiwiX3JlbmRlcmVkIiwicmVzb2x2ZUZpbHRlciIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluQWxpYXMiLCJiaW5kT2JqZWN0UHJvcHMiLCJhc1Byb3AiLCJkb21Qcm9wcyIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJfc3RhdGljVHJlZXMiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImluaXRSZW5kZXIiLCJyZW5kZXJDb250ZXh0IiwiX2MiLCIkY3JlYXRlRWxlbWVudCIsInJlbmRlck1peGluIiwiJG5leHRUaWNrIiwicmVuZGVyRXJyb3IiLCJfbyIsIl9uIiwiX3MiLCJfbCIsIl90IiwiX3EiLCJfaSIsIl9tIiwiX2YiLCJfayIsIl9iIiwiX3YiLCJfZSIsIl91IiwidWlkIiwiaW5pdE1peGluIiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJleHRlbmRlZCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJWdWUkMyIsImluaXRVc2UiLCJ1c2UiLCJpbnN0YWxsZWQiLCJ1bnNoaWZ0IiwiaW5pdE1peGluJDEiLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsInBhdHRlcm5UeXBlcyIsIlJlZ0V4cCIsImdldENvbXBvbmVudE5hbWUiLCJtYXRjaGVzIiwicGF0dGVybiIsInBydW5lQ2FjaGUiLCJjdXJyZW50IiwiZmlsdGVyIiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwiY3JlYXRlZCIsImRlc3Ryb3llZCIsImJ1aWx0SW5Db21wb25lbnRzIiwiaW5pdEdsb2JhbEFQSSIsImNvbmZpZ0RlZiIsInV0aWwiLCJkZWZpbmVSZWFjdGl2ZSIsInNzckNvbnRleHQiLCJhY2NlcHRWYWx1ZSIsImF0dHIiLCJpc0VudW1lcmF0ZWRBdHRyIiwiaXNCb29sZWFuQXR0ciIsInhsaW5rTlMiLCJpc1hsaW5rIiwiZ2V0WGxpbmtQcm9wIiwiaXNGYWxzeUF0dHJWYWx1ZSIsImdlbkNsYXNzRm9yVm5vZGUiLCJwYXJlbnROb2RlIiwiY2hpbGROb2RlIiwibWVyZ2VDbGFzc0RhdGEiLCJnZW5DbGFzc0Zyb21EYXRhIiwic3RhdGljQ2xhc3MiLCJjbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZpZWQiLCJuYW1lc3BhY2VNYXAiLCJzdmciLCJtYXRoIiwiaXNIVE1MVGFnIiwiaXNTVkciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJxdWVyeSIsInNlbGVjdGVkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50Iiwibm9kZU9wcyIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwiaG9va3MiLCJzYW1lVm5vZGUiLCJzYW1lSW5wdXRUeXBlIiwidHlwZUEiLCJ0eXBlQiIsImNyZWF0ZUtleVRvT2xkSWR4IiwiYmVnaW5JZHgiLCJlbmRJZHgiLCJjcmVhdGVQYXRjaEZ1bmN0aW9uIiwiYmFja2VuZCIsImVtcHR5Tm9kZUF0IiwiY3JlYXRlUm1DYiIsImNoaWxkRWxtIiwicmVtb3ZlTm9kZSIsImluUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwibmVzdGVkIiwicHJlIiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwiYW5jZXN0b3IiLCJfc2NvcGVJZCIsImFkZFZub2RlcyIsInN0YXJ0SWR4IiwiaW52b2tlRGVzdHJveUhvb2siLCJyZW1vdmVWbm9kZXMiLCJjaCIsInJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2siLCJybSIsInVwZGF0ZUNoaWxkcmVuIiwib2xkQ2giLCJuZXdDaCIsInJlbW92ZU9ubHkiLCJvbGRTdGFydElkeCIsIm5ld1N0YXJ0SWR4Iiwib2xkRW5kSWR4Iiwib2xkU3RhcnRWbm9kZSIsIm9sZEVuZFZub2RlIiwibmV3RW5kSWR4IiwibmV3U3RhcnRWbm9kZSIsIm5ld0VuZFZub2RlIiwib2xkS2V5VG9JZHgiLCJpZHhJbk9sZCIsImVsbVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwicG9zdHBhdGNoIiwiaW52b2tlSW5zZXJ0SG9vayIsImluaXRpYWwiLCJiYWlsZWQiLCJpc1JlbmRlcmVkTW9kdWxlIiwiaHlkcmF0ZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJub2RlVHlwZSIsInBhdGNoIiwiaXNJbml0aWFsUGF0Y2giLCJpc1JlYWxFbGVtZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwicGFyZW50RWxtJDEiLCJfbGVhdmVDYiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJkaXIiLCJjYWxsSG9vayQxIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwic2V0QXR0cmlidXRlTlMiLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwia2xhc3MiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwid3JhcEZpbHRlciIsImV4cCIsImluZGV4JDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwibm9ybWFsaXplRXZlbnRzIiwidGFyZ2V0JDEiLCJhZGQkMSIsIm9sZEhhbmRsZXIiLCJldiIsInJlbW92ZSQyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZURPTUxpc3RlbmVycyIsImV2ZW50cyIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJfdmFsdWUiLCJzdHJDdXIiLCJzaG91bGRVcGRhdGVWYWx1ZSIsImNoZWNrVmFsIiwiY29tcG9zaW5nIiwiaXNEaXJ0eSIsImlzSW5wdXRDaGFuZ2VkIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwibnVtYmVyIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwic3R5bGUiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemVkTmFtZSIsIm5vcm1hbGl6ZSIsInByZWZpeGVzIiwidGVzdEVsIiwidXBwZXIiLCJwcmVmaXhlZCIsInVwZGF0ZVN0eWxlIiwib2xkU3RhdGljU3R5bGUiLCJvbGRTdHlsZUJpbmRpbmciLCJub3JtYWxpemVkU3R5bGUiLCJvbGRTdHlsZSIsIm5ld1N0eWxlIiwiYWRkQ2xhc3MiLCJjbGFzc0xpc3QiLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVDbGFzcyIsInRhciIsInJlc29sdmVUcmFuc2l0aW9uIiwiZGVmJCQxIiwiY3NzIiwiYXV0b0Nzc1RyYW5zaXRpb24iLCJlbnRlckNsYXNzIiwiZW50ZXJUb0NsYXNzIiwiZW50ZXJBY3RpdmVDbGFzcyIsImxlYXZlQ2xhc3MiLCJsZWF2ZVRvQ2xhc3MiLCJsZWF2ZUFjdGl2ZUNsYXNzIiwiaGFzVHJhbnNpdGlvbiIsIlRSQU5TSVRJT04iLCJBTklNQVRJT04iLCJ0cmFuc2l0aW9uUHJvcCIsInRyYW5zaXRpb25FbmRFdmVudCIsImFuaW1hdGlvblByb3AiLCJhbmltYXRpb25FbmRFdmVudCIsIm9udHJhbnNpdGlvbmVuZCIsIm9ud2Via2l0dHJhbnNpdGlvbmVuZCIsIm9uYW5pbWF0aW9uZW5kIiwib253ZWJraXRhbmltYXRpb25lbmQiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJuZXh0RnJhbWUiLCJhZGRUcmFuc2l0aW9uQ2xhc3MiLCJyZW1vdmVUcmFuc2l0aW9uQ2xhc3MiLCJ3aGVuVHJhbnNpdGlvbkVuZHMiLCJnZXRUcmFuc2l0aW9uSW5mbyIsInByb3BDb3VudCIsImVuZGVkIiwiZW5kIiwib25FbmQiLCJ0cmFuc2Zvcm1SRSIsInN0eWxlcyIsImdldENvbXB1dGVkU3R5bGUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwicyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsIm1vZGVsJDEiLCJiaW5kaW5nIiwic2V0U2VsZWN0ZWQiLCJvbkNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvblN0YXJ0IiwibmVlZFJlc2V0Iiwic29tZSIsImhhc05vTWF0Y2hpbmdPcHRpb24iLCJpc011bHRpcGxlIiwib3B0aW9uIiwic2VsZWN0ZWRJbmRleCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImxvY2F0ZU5vZGUiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwia2V5JDEiLCJwbGFjZWhvbGRlciIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJrZXB0IiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJlZm9yZVVwZGF0ZSIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJib2R5IiwiZiIsIm9mZnNldEhlaWdodCIsIm1vdmVkIiwidHJhbnNmb3JtIiwiV2Via2l0VHJhbnNmb3JtIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwiX21vdmVDYiIsInByb3BlcnR5TmFtZSIsIl9oYXNNb3ZlIiwiY2xvbmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsInBsYXRmb3JtQ29tcG9uZW50cyIsInV0aWxzIiwibm9ybWFsaXplSGVhZGVyTmFtZSIsIkRFRkFVTFRfQ09OVEVOVF9UWVBFIiwic2V0Q29udGVudFR5cGVJZlVuc2V0IiwiaGVhZGVycyIsImdldERlZmF1bHRBZGFwdGVyIiwiYWRhcHRlciIsIlhNTEh0dHBSZXF1ZXN0IiwiZGVmYXVsdHMiLCJ0cmFuc2Zvcm1SZXF1ZXN0IiwidHJhbnNmb3JtUmVzcG9uc2UiLCJwYXJzZSIsInhzcmZDb29raWVOYW1lIiwieHNyZkhlYWRlck5hbWUiLCJtYXhDb250ZW50TGVuZ3RoIiwidmFsaWRhdGVTdGF0dXMiLCJzdGF0dXMiLCJjb21tb24iLCJmb3JFYWNoTWV0aG9kTm9EYXRhIiwiZm9yRWFjaE1ldGhvZFdpdGhEYXRhIiwiTWFwIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJjYXN0UGF0aCIsImJhc2VHZXQiLCJiYXNlTWF0Y2hlcyIsImJhc2VNYXRjaGVzUHJvcGVydHkiLCJiYXNlSXRlcmF0ZWUiLCJpc0tleSIsInN0cmluZ1RvUGF0aCIsInJlSXNEZWVwUHJvcCIsInJlSXNQbGFpblByb3AiLCJvdGhlciIsImJhc2VJc0FyZ3VtZW50cyIsIm9iamVjdFByb3RvIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJpc0FyZ3VtZW50cyIsImFycmF5TGlrZUtleXMiLCJiYXNlS2V5cyIsImciLCJldmFsIiwic2V0dGxlIiwiYnVpbGRVUkwiLCJwYXJzZUhlYWRlcnMiLCJpc1VSTFNhbWVPcmlnaW4iLCJjcmVhdGVFcnJvciIsInhockFkYXB0ZXIiLCJkaXNwYXRjaFhoclJlcXVlc3QiLCJyZXF1ZXN0RGF0YSIsInJlcXVlc3RIZWFkZXJzIiwicmVxdWVzdCIsImxvYWRFdmVudCIsInhEb21haW4iLCJYRG9tYWluUmVxdWVzdCIsInVybCIsIm9ucHJvZ3Jlc3MiLCJoYW5kbGVQcm9ncmVzcyIsIm9udGltZW91dCIsImhhbmRsZVRpbWVvdXQiLCJhdXRoIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIkF1dGhvcml6YXRpb24iLCJvcGVuIiwicGFyYW1zIiwicGFyYW1zU2VyaWFsaXplciIsImhhbmRsZUxvYWQiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VVUkwiLCJyZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZSIsInN0YXR1c1RleHQiLCJvbmVycm9yIiwiY29va2llcyIsInhzcmZWYWx1ZSIsIndpdGhDcmVkZW50aWFscyIsInJlYWQiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25Eb3dubG9hZFByb2dyZXNzIiwib25VcGxvYWRQcm9ncmVzcyIsInVwbG9hZCIsImNhbmNlbFRva2VuIiwicHJvbWlzZSIsIm9uQ2FuY2VsZWQiLCJjYW5jZWwiLCJhYm9ydCIsInNlbmQiLCJDYW5jZWwiLCJtZXNzYWdlIiwiX19DQU5DRUxfXyIsImlzQ2FuY2VsIiwiZW5oYW5jZUVycm9yIiwiY29kZSIsIndyYXAiLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJTdGFjayIsInNpemUiLCJhcnJheU1hcCIsIml0ZXJhdGVlIiwiYXJyYXlQdXNoIiwidmFsdWVzIiwib2Zmc2V0IiwiYmFzZUlzRXF1YWxEZWVwIiwiYmFzZUlzRXF1YWwiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsInN0YWNrIiwiYmFzZVVuYXJ5IiwiZnVuYyIsIlNldENhY2hlIiwiYXJyYXlTb21lIiwiY2FjaGVIYXMiLCJDT01QQVJFX1BBUlRJQUxfRkxBRyIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJlcXVhbEFycmF5cyIsImVxdWFsRnVuYyIsImlzUGFydGlhbCIsImFyckxlbmd0aCIsIm90aExlbmd0aCIsInN0YWNrZWQiLCJhcnJWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJvdGhJbmRleCIsImlzU3RyaWN0Q29tcGFyYWJsZSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwic3JjVmFsdWUiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJ0b1NvdXJjZSIsInN0dWJGYWxzZSIsImZyZWVFeHBvcnRzIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJuYXRpdmVJc0J1ZmZlciIsImFzeW5jVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsInByb3h5VGFnIiwiYmFzZUlzVHlwZWRBcnJheSIsIm5vZGVVdGlsIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiY3JlYXRlUm91dGVyIiwicm91dGVzIiwiaXNMb2dnZWRJbiIsIm1vZGFsQ29udHJvbCIsInNob3dMb2dpbk1vZGFsIiwic2hvd1JlZ2lzdGVyTW9kYWwiLCJnZXRVc2VyRGF0YSIsIlNob3dMb2dpbk1vZGFsIiwiU2hvd1JlZ2lzdGVyTW9kYWwiLCJHZXRBdXRoU3RhdHVzIiwiY2hhbmdlVGVhbSIsInJpZGVyQXJyYXkiLCJyaWRlcnMiLCJzZXRMb2dpbk1vZGFsIiwic2V0UmVnaXN0ZXJNb2RhbCIsInNldFVzZXJEYXRhIiwidXNlckRhdGEiLCJzZXRMb2dnZWRJbiIsImxvZ2dlZEluIiwibG9nb3V0Iiwicm91dGVyIiwiYXBwIiwiQXhpb3MiLCJjcmVhdGVJbnN0YW5jZSIsImRlZmF1bHRDb25maWciLCJpbnN0YW5jZSIsImF4aW9zIiwiaW5zdGFuY2VDb25maWciLCJDYW5jZWxUb2tlbiIsInByb21pc2VzIiwic3ByZWFkIiwiZXhlY3V0b3IiLCJUeXBlRXJyb3IiLCJyZXNvbHZlUHJvbWlzZSIsInByb21pc2VFeGVjdXRvciIsInRva2VuIiwidGhyb3dJZlJlcXVlc3RlZCIsIkludGVyY2VwdG9yTWFuYWdlciIsImRpc3BhdGNoUmVxdWVzdCIsImlzQWJzb2x1dGVVUkwiLCJjb21iaW5lVVJMcyIsImludGVyY2VwdG9ycyIsImJhc2VVUkwiLCJjaGFpbiIsInVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzIiwiaW50ZXJjZXB0b3IiLCJmdWxmaWxsZWQiLCJyZWplY3RlZCIsInB1c2hSZXNwb25zZUludGVyY2VwdG9ycyIsInNoaWZ0IiwiZWplY3QiLCJmb3JFYWNoSGFuZGxlciIsInRyYW5zZm9ybURhdGEiLCJ0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwiY2xlYW5IZWFkZXJDb25maWciLCJvbkFkYXB0ZXJSZXNvbHV0aW9uIiwib25BZGFwdGVyUmVqZWN0aW9uIiwiY2hhcnMiLCJFIiwiaW5wdXQiLCJvdXRwdXQiLCJibG9jayIsImNoYXJDb2RlIiwiaWR4IiwiZW5jb2RlIiwic2VyaWFsaXplZFBhcmFtcyIsInBhcnRzIiwic2VyaWFsaXplIiwicGFyc2VWYWx1ZSIsInRvSVNPU3RyaW5nIiwicmVsYXRpdmVVUkwiLCJzdGFuZGFyZEJyb3dzZXJFbnYiLCJ3cml0ZSIsImV4cGlyZXMiLCJkb21haW4iLCJzZWN1cmUiLCJjb29raWUiLCJEYXRlIiwidG9HTVRTdHJpbmciLCJkZWNvZGVVUklDb21wb25lbnQiLCJub3ciLCJub25TdGFuZGFyZEJyb3dzZXJFbnYiLCJtc2llIiwidXJsUGFyc2luZ05vZGUiLCJvcmlnaW5VUkwiLCJyZXNvbHZlVVJMIiwiaHJlZiIsInByb3RvY29sIiwiaG9zdCIsInNlYXJjaCIsImhvc3RuYW1lIiwicG9ydCIsInBhdGhuYW1lIiwibG9jYXRpb24iLCJyZXF1ZXN0VVJMIiwicGFyc2VkIiwicHJvY2Vzc0hlYWRlciIsInBhcnNlciIsImxpbmUiLCJzdWJzdHIiLCJieXRlTGVuZ3RoIiwidG9CeXRlQXJyYXkiLCJmcm9tQnl0ZUFycmF5IiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiVWludDhBcnJheSIsInBsYWNlSG9sZGVyc0NvdW50IiwiYjY0IiwicGxhY2VIb2xkZXJzIiwiTCIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJleHRyYUJ5dGVzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwiaWVlZTc1NCIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJ0eXBlZEFycmF5U3VwcG9ydCIsImtNYXhMZW5ndGgiLCJmb28iLCJzdWJhcnJheSIsImNyZWF0ZUJ1ZmZlciIsInRoYXQiLCJSYW5nZUVycm9yIiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsImFsbG9jVW5zYWZlIiwicG9vbFNpemUiLCJfYXVnbWVudCIsImZyb21BcnJheUJ1ZmZlciIsImZyb21TdHJpbmciLCJmcm9tT2JqZWN0Iiwic3BlY2llcyIsImFzc2VydFNpemUiLCJhbGxvYyIsImZpbGwiLCJlbmNvZGluZyIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJzdHJpbmciLCJpc0VuY29kaW5nIiwiYWN0dWFsIiwiZnJvbUFycmF5TGlrZSIsImJ5dGVPZmZzZXQiLCJjb3B5IiwiaXNuYW4iLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwieCIsInkiLCJtaW4iLCJidWYiLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwibSIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsImVxdWFscyIsImluc3BlY3QiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJhcnJheUluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsInZhbExlbmd0aCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJmb3VuZCIsImluY2x1ZGVzIiwiaGV4V3JpdGUiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZUludCIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwibGF0aW4xV3JpdGUiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJ0b0pTT04iLCJfYXJyIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsIm91dCIsInRvSGV4IiwiYnl0ZXMiLCJuZXdCdWYiLCJzbGljZUxlbiIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVJbnRMRSIsIm5vQXNzZXJ0IiwibXVsIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVSW50QkUiLCJ3cml0ZVVJbnQ4IiwiZmxvb3IiLCJvYmplY3RXcml0ZVVJbnQxNiIsImxpdHRsZUVuZGlhbiIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwib2JqZWN0V3JpdGVVSW50MzIiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVSW50MzJCRSIsIndyaXRlSW50TEUiLCJsaW1pdCIsIndyaXRlSW50QkUiLCJ3cml0ZUludDgiLCJ3cml0ZUludDE2TEUiLCJ3cml0ZUludDE2QkUiLCJ3cml0ZUludDMyTEUiLCJ3cml0ZUludDMyQkUiLCJjaGVja0lFRUU3NTQiLCJ3cml0ZUZsb2F0Iiwid3JpdGVGbG9hdExFIiwid3JpdGVGbG9hdEJFIiwid3JpdGVEb3VibGUiLCJ3cml0ZURvdWJsZUxFIiwid3JpdGVEb3VibGVCRSIsInRhcmdldFN0YXJ0IiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInN0cmluZ3RyaW0iLCJ1bml0cyIsIkluZmluaXR5IiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsImhpIiwibG8iLCJkc3QiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsInJ0IiwiYWJzIiwibG9nIiwiTE4yIiwiRGF0YVZpZXciLCJoYXNoQ2xlYXIiLCJoYXNoRGVsZXRlIiwiaGFzaEdldCIsImhhc2hIYXMiLCJoYXNoU2V0IiwiSGFzaCIsInNldENhY2hlQWRkIiwic2V0Q2FjaGVIYXMiLCJXZWFrTWFwIiwiYXJyYXlGaWx0ZXIiLCJwcmVkaWNhdGUiLCJyZXNJbmRleCIsImJhc2VUaW1lcyIsImluaGVyaXRlZCIsImlzQXJyIiwiaXNBcmciLCJpc0J1ZmYiLCJza2lwSW5kZXhlcyIsImJhc2VGb3JPd24iLCJjcmVhdGVCYXNlRWFjaCIsImJhc2VFYWNoIiwiYmFzZUZpbmRJbmRleCIsImZyb21JbmRleCIsImZyb21SaWdodCIsImlzRmxhdHRlbmFibGUiLCJiYXNlRmxhdHRlbiIsImRlcHRoIiwiaXNTdHJpY3QiLCJjcmVhdGVCYXNlRm9yIiwiYmFzZUZvciIsImJhc2VHZXRBbGxLZXlzIiwia2V5c0Z1bmMiLCJzeW1ib2xzRnVuYyIsImJhc2VIYXNJbiIsImFyZ3NUYWciLCJlcXVhbEJ5VGFnIiwiZXF1YWxPYmplY3RzIiwiZ2V0VGFnIiwiYXJyYXlUYWciLCJvYmplY3RUYWciLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImJhc2VJc01hdGNoIiwibWF0Y2hEYXRhIiwibm9DdXN0b21pemVyIiwib2JqVmFsdWUiLCJpc01hc2tlZCIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsInJlSXNOYXRpdmUiLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwibWFwVGFnIiwibnVtYmVyVGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJ0eXBlZEFycmF5VGFncyIsImlzUHJvdG90eXBlIiwibmF0aXZlS2V5cyIsImJhc2VNYXAiLCJjb2xsZWN0aW9uIiwiZ2V0TWF0Y2hEYXRhIiwiaGFzSW4iLCJiYXNlU29ydEJ5IiwiY29tcGFyZU11bHRpcGxlIiwiYmFzZU9yZGVyQnkiLCJpdGVyYXRlZXMiLCJvcmRlcnMiLCJjcml0ZXJpYSIsImJhc2VQcm9wZXJ0eSIsImJhc2VQcm9wZXJ0eURlZXAiLCJiYXNlVW5zZXQiLCJiYXNlUHVsbEF0IiwiaW5kZXhlcyIsImxhc3RJbmRleCIsInByZXZpb3VzIiwib3ZlclJlc3QiLCJzZXRUb1N0cmluZyIsImJhc2VSZXN0IiwiY29uc3RhbnQiLCJiYXNlU2V0VG9TdHJpbmciLCJiYXNlU2xpY2UiLCJjb21wYXJlciIsInN5bWJvbFByb3RvIiwic3ltYm9sVG9TdHJpbmciLCJiYXNlVG9TdHJpbmciLCJjb21wYXJlQXNjZW5kaW5nIiwidmFsSXNEZWZpbmVkIiwidmFsSXNOdWxsIiwidmFsSXNSZWZsZXhpdmUiLCJ2YWxJc1N5bWJvbCIsIm90aElzRGVmaW5lZCIsIm90aElzTnVsbCIsIm90aElzUmVmbGV4aXZlIiwib3RoSXNTeW1ib2wiLCJvYmpDcml0ZXJpYSIsIm90aENyaXRlcmlhIiwib3JkZXJzTGVuZ3RoIiwib3JkZXIiLCJjb3JlSnNEYXRhIiwiZWFjaEZ1bmMiLCJpdGVyYWJsZSIsIm1hcFRvQXJyYXkiLCJzZXRUb0FycmF5Iiwic3ltYm9sVmFsdWVPZiIsInZhbHVlT2YiLCJjb252ZXJ0IiwiZ2V0QWxsS2V5cyIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiZ2V0U3ltYm9scyIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwiaXNPd24iLCJ1bm1hc2tlZCIsInN0dWJBcnJheSIsIm5hdGl2ZUdldFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2wiLCJwcm9taXNlVGFnIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwiY3RvclN0cmluZyIsImhhc1BhdGgiLCJoYXNGdW5jIiwiSEFTSF9VTkRFRklORUQiLCJzcHJlYWRhYmxlU3ltYm9sIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwiaXNJdGVyYXRlZUNhbGwiLCJtYXNrU3JjS2V5IiwiZXhlYyIsIklFX1BST1RPIiwicHJvdG8iLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQiLCJvdmVyQXJnIiwiZnJlZVByb2Nlc3MiLCJuYXRpdmVNYXgiLCJvdGhlckFyZ3MiLCJzaG9ydE91dCIsIkhPVF9DT1VOVCIsIkhPVF9TUEFOIiwibmF0aXZlTm93IiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJMQVJHRV9BUlJBWV9TSVpFIiwicGFpcnMiLCJyZUxlYWRpbmdEb3QiLCJyZVByb3BOYW1lIiwicmVFc2NhcGVDaGFyIiwicXVvdGUiLCJ0b0ludGVnZXIiLCJmaW5kSW5kZXgiLCJkZWZhdWx0VmFsdWUiLCJGVU5DX0VSUk9SX1RFWFQiLCJyZXNvbHZlciIsIm1lbW9pemVkIiwiQ2FjaGUiLCJzb3J0QnkiLCJNQVhfSU5URUdFUiIsInRvRmluaXRlIiwic2lnbiIsInJlbWFpbmRlciIsIk5BTiIsInJlVHJpbSIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc09jdGFsIiwiZnJlZVBhcnNlSW50IiwiaXNCaW5hcnkiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsIkl0ZW0iLCJ0aXRsZSIsImJyb3dzZXIiLCJhcmd2IiwidmVyc2lvbnMiLCJhZGRMaXN0ZW5lciIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImN3ZCIsImNoZGlyIiwidW1hc2siLCJWaWV3Iiwicm91dGVyVmlldyIsInJvdXRlIiwiJHJvdXRlIiwiX3JvdXRlclZpZXdDYWNoZSIsImluYWN0aXZlIiwicm91dGVyVmlld0RlcHRoIiwibWF0Y2hlZCIsInJlZ2lzdGVyUm91dGVJbnN0YW5jZSIsImluc3RhbmNlcyIsInJlc29sdmVQcm9wcyIsImVuY29kZVJlc2VydmVSRSIsImVuY29kZVJlc2VydmVSZXBsYWNlciIsImNvbW1hUkUiLCJkZWNvZGUiLCJyZXNvbHZlUXVlcnkiLCJleHRyYVF1ZXJ5IiwiX3BhcnNlUXVlcnkiLCJwYXJzZVF1ZXJ5IiwicGFyc2VkUXVlcnkiLCJwYXJhbSIsInN0cmluZ2lmeVF1ZXJ5IiwidmFsMiIsInRyYWlsaW5nU2xhc2hSRSIsImNyZWF0ZVJvdXRlIiwicmVjb3JkIiwicmVkaXJlY3RlZEZyb20iLCJzdHJpbmdpZnlRdWVyeSQkMSIsIm1ldGEiLCJmdWxsUGF0aCIsImdldEZ1bGxQYXRoIiwiZm9ybWF0TWF0Y2giLCJTVEFSVCIsIl9zdHJpbmdpZnlRdWVyeSIsImlzU2FtZVJvdXRlIiwiaXNPYmplY3RFcXVhbCIsImFLZXlzIiwiYktleXMiLCJpc0luY2x1ZGVkUm91dGUiLCJxdWVyeUluY2x1ZGVzIiwidG9UeXBlcyIsImV2ZW50VHlwZXMiLCJMaW5rIiwiZXhhY3QiLCJhcHBlbmQiLCJleGFjdEFjdGl2ZUNsYXNzIiwiJHJvdXRlciIsImNsYXNzZXMiLCJnbG9iYWxBY3RpdmVDbGFzcyIsImxpbmtBY3RpdmVDbGFzcyIsImdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MiLCJsaW5rRXhhY3RBY3RpdmVDbGFzcyIsImFjdGl2ZUNsYXNzRmFsbGJhY2siLCJleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2siLCJjb21wYXJlVGFyZ2V0IiwiZ3VhcmRFdmVudCIsImNsaWNrIiwiZmluZEFuY2hvciIsImFEYXRhIiwiYUF0dHJzIiwibWV0YUtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsImRlZmF1bHRQcmV2ZW50ZWQiLCJidXR0b24iLCJjdXJyZW50VGFyZ2V0IiwicHJldmVudERlZmF1bHQiLCJfcm91dGVyIiwiX3JvdXRlIiwicmVnaXN0ZXJJbnN0YW5jZSIsImNhbGxWYWwiLCJoaXN0b3J5IiwiYmVmb3JlUm91dGVFbnRlciIsImJlZm9yZVJvdXRlTGVhdmUiLCJyZXNvbHZlUGF0aCIsInJlbGF0aXZlIiwiZmlyc3RDaGFyIiwic2VnbWVudCIsImhhc2hJbmRleCIsInF1ZXJ5SW5kZXgiLCJjbGVhblBhdGgiLCJwYXRoVG9SZWdleHAiLCJwYXJzZV8xIiwiY29tcGlsZV8xIiwiY29tcGlsZSIsInRva2Vuc1RvRnVuY3Rpb25fMSIsInRva2Vuc1RvRnVuY3Rpb24iLCJ0b2tlbnNUb1JlZ0V4cF8xIiwidG9rZW5zVG9SZWdFeHAiLCJQQVRIX1JFR0VYUCIsInRva2VucyIsImRlZmF1bHREZWxpbWl0ZXIiLCJkZWxpbWl0ZXIiLCJlc2NhcGVkIiwibmV4dCIsInByZWZpeCIsImdyb3VwIiwibW9kaWZpZXIiLCJhc3RlcmlzayIsInBhcnRpYWwiLCJvcHRpb25hbCIsImVzY2FwZUdyb3VwIiwiZXNjYXBlU3RyaW5nIiwiZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IiwiZW5jb2RlVVJJIiwiZW5jb2RlQXN0ZXJpc2siLCJwcmV0dHkiLCJhdHRhY2hLZXlzIiwicmUiLCJmbGFncyIsInNlbnNpdGl2ZSIsInJlZ2V4cFRvUmVnZXhwIiwiZ3JvdXBzIiwiYXJyYXlUb1JlZ2V4cCIsInJlZ2V4cCIsInN0cmluZ1RvUmVnZXhwIiwiZW5kc1dpdGhEZWxpbWl0ZXIiLCJyZWdleHBDb21waWxlQ2FjaGUiLCJmaWxsUGFyYW1zIiwicm91dGVNc2ciLCJmaWxsZXIiLCJjcmVhdGVSb3V0ZU1hcCIsIm9sZFBhdGhMaXN0Iiwib2xkUGF0aE1hcCIsIm9sZE5hbWVNYXAiLCJwYXRoTGlzdCIsInBhdGhNYXAiLCJuYW1lTWFwIiwiYWRkUm91dGVSZWNvcmQiLCJtYXRjaEFzIiwibm9ybWFsaXplZFBhdGgiLCJub3JtYWxpemVQYXRoIiwicmVnZXgiLCJjb21waWxlUm91dGVSZWdleCIsInJlZGlyZWN0IiwiY2hpbGRNYXRjaEFzIiwiYWxpYXMiLCJhbGlhc1JvdXRlIiwibm9ybWFsaXplTG9jYXRpb24iLCJfbm9ybWFsaXplZCIsImFzc2lnbiIsInJhd1BhdGgiLCJwYXJzZWRQYXRoIiwiYmFzZVBhdGgiLCJjcmVhdGVNYXRjaGVyIiwiYWRkUm91dGVzIiwiY3VycmVudFJvdXRlIiwicGFyYW1OYW1lcyIsIl9jcmVhdGVSb3V0ZSIsInJlY29yZCQxIiwibWF0Y2hSb3V0ZSIsIm9yaWdpbmFsUmVkaXJlY3QiLCJ0YXJnZXRSZWNvcmQiLCJyZXNvbHZlUmVjb3JkUGF0aCIsInJlc29sdmVkUGF0aCIsImFsaWFzZWRQYXRoIiwiYWxpYXNlZE1hdGNoIiwiYWxpYXNlZFJlY29yZCIsInBvc2l0aW9uU3RvcmUiLCJzZXR1cFNjcm9sbCIsInNhdmVTY3JvbGxQb3NpdGlvbiIsInNldFN0YXRlS2V5IiwiaGFuZGxlU2Nyb2xsIiwiaXNQb3AiLCJiZWhhdmlvciIsInNjcm9sbEJlaGF2aW9yIiwicG9zaXRpb24iLCJnZXRTY3JvbGxQb3NpdGlvbiIsInNob3VsZFNjcm9sbCIsInNlbGVjdG9yIiwiZ2V0RWxlbWVudFBvc2l0aW9uIiwiaXNWYWxpZFBvc2l0aW9uIiwibm9ybWFsaXplUG9zaXRpb24iLCJzY3JvbGxUbyIsImdldFN0YXRlS2V5IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsImRvY0VsIiwiZG9jdW1lbnRFbGVtZW50IiwiZG9jUmVjdCIsImVsUmVjdCIsInN1cHBvcnRzUHVzaFN0YXRlIiwidWEiLCJUaW1lIiwiX2tleSIsImdlbktleSIsInRvRml4ZWQiLCJwdXNoU3RhdGUiLCJydW5RdWV1ZSIsInN0ZXAiLCJIaXN0b3J5Iiwibm9ybWFsaXplQmFzZSIsInJlYWR5IiwicmVhZHlDYnMiLCJyZWFkeUVycm9yQ2JzIiwiZXJyb3JDYnMiLCJsaXN0ZW4iLCJvblJlYWR5IiwiZXJyb3JDYiIsIm9uRXJyb3IiLCJ0cmFuc2l0aW9uVG8iLCJvbkNvbXBsZXRlIiwib25BYm9ydCIsImNvbmZpcm1UcmFuc2l0aW9uIiwidXBkYXRlUm91dGUiLCJlbnN1cmVVUkwiLCJpc0Vycm9yIiwicmVzb2x2ZVF1ZXVlIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJleHRyYWN0TGVhdmVHdWFyZHMiLCJiZWZvcmVIb29rcyIsImV4dHJhY3RVcGRhdGVIb29rcyIsInJlc29sdmVBc3luY0NvbXBvbmVudHMiLCJpdGVyYXRvciIsInBvc3RFbnRlckNicyIsImlzVmFsaWQiLCJlbnRlckd1YXJkcyIsImV4dHJhY3RFbnRlckd1YXJkcyIsInJlc29sdmVIb29rcyIsInByZXYiLCJhZnRlckhvb2tzIiwiYmFzZUVsIiwiZXh0cmFjdEd1YXJkcyIsInJlY29yZHMiLCJyZXZlcnNlIiwiZ3VhcmRzIiwiZmxhdE1hcENvbXBvbmVudHMiLCJndWFyZCIsImV4dHJhY3RHdWFyZCIsImZsYXR0ZW4iLCJiaW5kR3VhcmQiLCJib3VuZFJvdXRlR3VhcmQiLCJiaW5kRW50ZXJHdWFyZCIsInJvdXRlRW50ZXJHdWFyZCIsInBvbGwiLCJoYXNBc3luYyIsInJlc29sdmVkRGVmIiwiSFRNTDVIaXN0b3J5IiwiSGlzdG9yeSQkMSIsImV4cGVjdFNjcm9sbCIsImdldExvY2F0aW9uIiwiZ28iLCJmcm9tUm91dGUiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJIYXNoSGlzdG9yeSIsImNoZWNrRmFsbGJhY2siLCJlbnN1cmVTbGFzaCIsInNldHVwTGlzdGVuZXJzIiwiZ2V0SGFzaCIsInJlcGxhY2VIYXNoIiwicHVzaEhhc2giLCJBYnN0cmFjdEhpc3RvcnkiLCJ0YXJnZXRJbmRleCIsIlZ1ZVJvdXRlciIsImFwcHMiLCJtYXRjaGVyIiwic2V0dXBIYXNoTGlzdGVuZXIiLCJiZWZvcmVFYWNoIiwicmVnaXN0ZXJIb29rIiwiYmVmb3JlUmVzb2x2ZSIsImFmdGVyRWFjaCIsImJhY2siLCJmb3J3YXJkIiwiZ2V0TWF0Y2hlZENvbXBvbmVudHMiLCJjcmVhdGVIcmVmIiwibm9ybWFsaXplZFRvIiwibGlzdFRvU3R5bGVzIiwicGFyZW50SWQiLCJuZXdTdHlsZXMiLCJtZWRpYSIsInBhcnQiXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FB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Z0IsbUJBQW1CLGFBQWEsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQywrQkFBK0IsYUFBYSwwQkFBMEI7QUFDdkU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDLGFBQWEsYUFBYSwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDLGFBQWEsYUFBYSwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7O0FDakxBLGdCQUFnQixtQkFBbUIsYUFBYSwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNB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QUVBO0FBQ0EscUNBQXdOO0FBQ3hOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0ksbUZBQW1GO0FBQ3ZOLDZJQUE2SSxtRkFBbUY7QUFDaE87QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyxDIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbiBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNTgpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDJlOTVjMGRjMDg0YmE5N2E5YTUxIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTm9kZSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE5vZGUgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiAoKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQnVmZmVyLmlzQnVmZmVyKSAmJiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgJiYgIWlzQXJyYXkob2JqKSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXG4gIGlzQnVmZmVyOiBpc0J1ZmZlcixcbiAgaXNGb3JtRGF0YTogaXNGb3JtRGF0YSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzTnVtYmVyOiBpc051bWJlcixcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc0ZpbGU6IGlzRmlsZSxcbiAgaXNCbG9iOiBpc0Jsb2IsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzU3RyZWFtOiBpc1N0cmVhbSxcbiAgaXNVUkxTZWFyY2hQYXJhbXM6IGlzVVJMU2VhcmNoUGFyYW1zLFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIG1lcmdlOiBtZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi91dGlscy5qcyIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19yb290LmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2lzQXJyYXkuanMiLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19nZXROYXRpdmUuanMiLCIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gdGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxuICAgIHZhciBleGlzdGluZyA9IGZ1bmN0aW9uYWxcbiAgICAgID8gb3B0aW9ucy5yZW5kZXJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICBpZiAoIWZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBleGlzdGluZyhoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvaW5kZXguanMiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19TeW1ib2wuanMiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3RvS2V5LmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc09iamVjdC5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2lzU3ltYm9sLmpzIiwiLyoqXG4gKiB2dWV4IHYyLjMuMFxuICogKGMpIDIwMTcgRXZhbiBZb3VcbiAqIEBsaWNlbnNlIE1JVFxuICovXG52YXIgYXBwbHlNaXhpbiA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgdmFyIHZlcnNpb24gPSBOdW1iZXIoVnVlLnZlcnNpb24uc3BsaXQoJy4nKVswXSk7XG5cbiAgaWYgKHZlcnNpb24gPj0gMikge1xuICAgIHZhciB1c2VzSW5pdCA9IFZ1ZS5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmluZGV4T2YoJ2luaXQnKSA+IC0xO1xuICAgIFZ1ZS5taXhpbih1c2VzSW5pdCA/IHsgaW5pdDogdnVleEluaXQgfSA6IHsgYmVmb3JlQ3JlYXRlOiB2dWV4SW5pdCB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdmVycmlkZSBpbml0IGFuZCBpbmplY3QgdnVleCBpbml0IHByb2NlZHVyZVxuICAgIC8vIGZvciAxLnggYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgdmFyIF9pbml0ID0gVnVlLnByb3RvdHlwZS5faW5pdDtcbiAgICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBvcHRpb25zLmluaXQgPSBvcHRpb25zLmluaXRcbiAgICAgICAgPyBbdnVleEluaXRdLmNvbmNhdChvcHRpb25zLmluaXQpXG4gICAgICAgIDogdnVleEluaXQ7XG4gICAgICBfaW5pdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVnVleCBpbml0IGhvb2ssIGluamVjdGVkIGludG8gZWFjaCBpbnN0YW5jZXMgaW5pdCBob29rcyBsaXN0LlxuICAgKi9cblxuICBmdW5jdGlvbiB2dWV4SW5pdCAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgIC8vIHN0b3JlIGluamVjdGlvblxuICAgIGlmIChvcHRpb25zLnN0b3JlKSB7XG4gICAgICB0aGlzLiRzdG9yZSA9IG9wdGlvbnMuc3RvcmU7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC4kc3RvcmUpIHtcbiAgICAgIHRoaXMuJHN0b3JlID0gb3B0aW9ucy5wYXJlbnQuJHN0b3JlO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRldnRvb2xIb29rID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbmZ1bmN0aW9uIGRldnRvb2xQbHVnaW4gKHN0b3JlKSB7XG4gIGlmICghZGV2dG9vbEhvb2spIHsgcmV0dXJuIH1cblxuICBzdG9yZS5fZGV2dG9vbEhvb2sgPSBkZXZ0b29sSG9vaztcblxuICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4OmluaXQnLCBzdG9yZSk7XG5cbiAgZGV2dG9vbEhvb2sub24oJ3Z1ZXg6dHJhdmVsLXRvLXN0YXRlJywgZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgc3RvcmUucmVwbGFjZVN0YXRlKHRhcmdldFN0YXRlKTtcbiAgfSk7XG5cbiAgc3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChtdXRhdGlvbiwgc3RhdGUpIHtcbiAgICBkZXZ0b29sSG9vay5lbWl0KCd2dWV4Om11dGF0aW9uJywgbXV0YXRpb24sIHN0YXRlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBpdGVtIHRoYXQgcGFzcyB0aGUgdGVzdFxuICogYnkgc2Vjb25kIGFyZ3VtZW50IGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbGlzdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHJldHVybiB7Kn1cbiAqL1xuLyoqXG4gKiBEZWVwIGNvcHkgdGhlIGdpdmVuIG9iamVjdCBjb25zaWRlcmluZyBjaXJjdWxhciBzdHJ1Y3R1cmUuXG4gKiBUaGlzIGZ1bmN0aW9uIGNhY2hlcyBhbGwgbmVzdGVkIG9iamVjdHMgYW5kIGl0cyBjb3BpZXMuXG4gKiBJZiBpdCBkZXRlY3RzIGNpcmN1bGFyIHN0cnVjdHVyZSwgdXNlIGNhY2hlZCBjb3B5IHRvIGF2b2lkIGluZmluaXRlIGxvb3AuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gY2FjaGVcbiAqIEByZXR1cm4geyp9XG4gKi9cblxuXG4vKipcbiAqIGZvckVhY2ggZm9yIG9iamVjdFxuICovXG5mdW5jdGlvbiBmb3JFYWNoVmFsdWUgKG9iaiwgZm4pIHtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKG9ialtrZXldLCBrZXkpOyB9KTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZSAodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtc2cpIHtcbiAgaWYgKCFjb25kaXRpb24pIHsgdGhyb3cgbmV3IEVycm9yKChcIlt2dWV4XSBcIiArIG1zZykpIH1cbn1cblxudmFyIE1vZHVsZSA9IGZ1bmN0aW9uIE1vZHVsZSAocmF3TW9kdWxlLCBydW50aW1lKSB7XG4gIHRoaXMucnVudGltZSA9IHJ1bnRpbWU7XG4gIHRoaXMuX2NoaWxkcmVuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fcmF3TW9kdWxlID0gcmF3TW9kdWxlO1xuICB2YXIgcmF3U3RhdGUgPSByYXdNb2R1bGUuc3RhdGU7XG4gIHRoaXMuc3RhdGUgPSAodHlwZW9mIHJhd1N0YXRlID09PSAnZnVuY3Rpb24nID8gcmF3U3RhdGUoKSA6IHJhd1N0YXRlKSB8fCB7fTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMkMSA9IHsgbmFtZXNwYWNlZDoge30gfTtcblxucHJvdG90eXBlQWNjZXNzb3JzJDEubmFtZXNwYWNlZC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhIXRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKGtleSwgbW9kdWxlKSB7XG4gIHRoaXMuX2NoaWxkcmVuW2tleV0gPSBtb2R1bGU7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGtleSkge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5ba2V5XTtcbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiBnZXRDaGlsZCAoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9jaGlsZHJlbltrZXldXG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAocmF3TW9kdWxlKSB7XG4gIHRoaXMuX3Jhd01vZHVsZS5uYW1lc3BhY2VkID0gcmF3TW9kdWxlLm5hbWVzcGFjZWQ7XG4gIGlmIChyYXdNb2R1bGUuYWN0aW9ucykge1xuICAgIHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zID0gcmF3TW9kdWxlLmFjdGlvbnM7XG4gIH1cbiAgaWYgKHJhd01vZHVsZS5tdXRhdGlvbnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zID0gcmF3TW9kdWxlLm11dGF0aW9ucztcbiAgfVxuICBpZiAocmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICB0aGlzLl9yYXdNb2R1bGUuZ2V0dGVycyA9IHJhd01vZHVsZS5nZXR0ZXJzO1xuICB9XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIGZvckVhY2hDaGlsZCAoZm4pIHtcbiAgZm9yRWFjaFZhbHVlKHRoaXMuX2NoaWxkcmVuLCBmbik7XG59O1xuXG5Nb2R1bGUucHJvdG90eXBlLmZvckVhY2hHZXR0ZXIgPSBmdW5jdGlvbiBmb3JFYWNoR2V0dGVyIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMpIHtcbiAgICBmb3JFYWNoVmFsdWUodGhpcy5fcmF3TW9kdWxlLmdldHRlcnMsIGZuKTtcbiAgfVxufTtcblxuTW9kdWxlLnByb3RvdHlwZS5mb3JFYWNoQWN0aW9uID0gZnVuY3Rpb24gZm9yRWFjaEFjdGlvbiAoZm4pIHtcbiAgaWYgKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zKSB7XG4gICAgZm9yRWFjaFZhbHVlKHRoaXMuX3Jhd01vZHVsZS5hY3Rpb25zLCBmbik7XG4gIH1cbn07XG5cbk1vZHVsZS5wcm90b3R5cGUuZm9yRWFjaE11dGF0aW9uID0gZnVuY3Rpb24gZm9yRWFjaE11dGF0aW9uIChmbikge1xuICBpZiAodGhpcy5fcmF3TW9kdWxlLm11dGF0aW9ucykge1xuICAgIGZvckVhY2hWYWx1ZSh0aGlzLl9yYXdNb2R1bGUubXV0YXRpb25zLCBmbik7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNb2R1bGUucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMkMSApO1xuXG52YXIgTW9kdWxlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIE1vZHVsZUNvbGxlY3Rpb24gKHJhd1Jvb3RNb2R1bGUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gcmVnaXN0ZXIgcm9vdCBtb2R1bGUgKFZ1ZXguU3RvcmUgb3B0aW9ucylcbiAgdGhpcy5yb290ID0gbmV3IE1vZHVsZShyYXdSb290TW9kdWxlLCBmYWxzZSk7XG5cbiAgLy8gcmVnaXN0ZXIgYWxsIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdSb290TW9kdWxlLm1vZHVsZXMpIHtcbiAgICBmb3JFYWNoVmFsdWUocmF3Um9vdE1vZHVsZS5tb2R1bGVzLCBmdW5jdGlvbiAocmF3TW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3Rlcihba2V5XSwgcmF3TW9kdWxlLCBmYWxzZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAocGF0aCkge1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKG1vZHVsZSwga2V5KSB7XG4gICAgcmV0dXJuIG1vZHVsZS5nZXRDaGlsZChrZXkpXG4gIH0sIHRoaXMucm9vdClcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldE5hbWVzcGFjZSA9IGZ1bmN0aW9uIGdldE5hbWVzcGFjZSAocGF0aCkge1xuICB2YXIgbW9kdWxlID0gdGhpcy5yb290O1xuICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwga2V5KSB7XG4gICAgbW9kdWxlID0gbW9kdWxlLmdldENoaWxkKGtleSk7XG4gICAgcmV0dXJuIG5hbWVzcGFjZSArIChtb2R1bGUubmFtZXNwYWNlZCA/IGtleSArICcvJyA6ICcnKVxuICB9LCAnJylcbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSQxIChyYXdSb290TW9kdWxlKSB7XG4gIHVwZGF0ZSh0aGlzLnJvb3QsIHJhd1Jvb3RNb2R1bGUpO1xufTtcblxuTW9kdWxlQ29sbGVjdGlvbi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlciAocGF0aCwgcmF3TW9kdWxlLCBydW50aW1lKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgaWYgKCBydW50aW1lID09PSB2b2lkIDAgKSBydW50aW1lID0gdHJ1ZTtcblxuICB2YXIgcGFyZW50ID0gdGhpcy5nZXQocGF0aC5zbGljZSgwLCAtMSkpO1xuICB2YXIgbmV3TW9kdWxlID0gbmV3IE1vZHVsZShyYXdNb2R1bGUsIHJ1bnRpbWUpO1xuICBwYXJlbnQuYWRkQ2hpbGQocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBuZXdNb2R1bGUpO1xuXG4gIC8vIHJlZ2lzdGVyIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChyYXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvckVhY2hWYWx1ZShyYXdNb2R1bGUubW9kdWxlcywgZnVuY3Rpb24gKHJhd0NoaWxkTW9kdWxlLCBrZXkpIHtcbiAgICAgIHRoaXMkMS5yZWdpc3RlcihwYXRoLmNvbmNhdChrZXkpLCByYXdDaGlsZE1vZHVsZSwgcnVudGltZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbk1vZHVsZUNvbGxlY3Rpb24ucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyIChwYXRoKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmdldChwYXRoLnNsaWNlKDAsIC0xKSk7XG4gIHZhciBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGlmICghcGFyZW50LmdldENoaWxkKGtleSkucnVudGltZSkgeyByZXR1cm4gfVxuXG4gIHBhcmVudC5yZW1vdmVDaGlsZChrZXkpO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlICh0YXJnZXRNb2R1bGUsIG5ld01vZHVsZSkge1xuICAvLyB1cGRhdGUgdGFyZ2V0IG1vZHVsZVxuICB0YXJnZXRNb2R1bGUudXBkYXRlKG5ld01vZHVsZSk7XG5cbiAgLy8gdXBkYXRlIG5lc3RlZCBtb2R1bGVzXG4gIGlmIChuZXdNb2R1bGUubW9kdWxlcykge1xuICAgIGZvciAodmFyIGtleSBpbiBuZXdNb2R1bGUubW9kdWxlcykge1xuICAgICAgaWYgKCF0YXJnZXRNb2R1bGUuZ2V0Q2hpbGQoa2V5KSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJbdnVleF0gdHJ5aW5nIHRvIGFkZCBhIG5ldyBtb2R1bGUgJ1wiICsga2V5ICsgXCInIG9uIGhvdCByZWxvYWRpbmcsIFwiICtcbiAgICAgICAgICAnbWFudWFsIHJlbG9hZCBpcyBuZWVkZWQnXG4gICAgICAgICk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdXBkYXRlKHRhcmdldE1vZHVsZS5nZXRDaGlsZChrZXkpLCBuZXdNb2R1bGUubW9kdWxlc1trZXldKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFZ1ZTsgLy8gYmluZCBvbiBpbnN0YWxsXG5cbnZhciBTdG9yZSA9IGZ1bmN0aW9uIFN0b3JlIChvcHRpb25zKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBhc3NlcnQoVnVlLCBcIm11c3QgY2FsbCBWdWUudXNlKFZ1ZXgpIGJlZm9yZSBjcmVhdGluZyBhIHN0b3JlIGluc3RhbmNlLlwiKTtcbiAgYXNzZXJ0KHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJywgXCJ2dWV4IHJlcXVpcmVzIGEgUHJvbWlzZSBwb2x5ZmlsbCBpbiB0aGlzIGJyb3dzZXIuXCIpO1xuXG4gIHZhciBzdGF0ZSA9IG9wdGlvbnMuc3RhdGU7IGlmICggc3RhdGUgPT09IHZvaWQgMCApIHN0YXRlID0ge307XG4gIHZhciBwbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zOyBpZiAoIHBsdWdpbnMgPT09IHZvaWQgMCApIHBsdWdpbnMgPSBbXTtcbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0OyBpZiAoIHN0cmljdCA9PT0gdm9pZCAwICkgc3RyaWN0ID0gZmFsc2U7XG5cbiAgLy8gc3RvcmUgaW50ZXJuYWwgc3RhdGVcbiAgdGhpcy5fY29tbWl0dGluZyA9IGZhbHNlO1xuICB0aGlzLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fbXV0YXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGhpcy5fd3JhcHBlZEdldHRlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9tb2R1bGVzID0gbmV3IE1vZHVsZUNvbGxlY3Rpb24ob3B0aW9ucyk7XG4gIHRoaXMuX21vZHVsZXNOYW1lc3BhY2VNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB0aGlzLl9zdWJzY3JpYmVycyA9IFtdO1xuICB0aGlzLl93YXRjaGVyVk0gPSBuZXcgVnVlKCk7XG5cbiAgLy8gYmluZCBjb21taXQgYW5kIGRpc3BhdGNoIHRvIHNlbGZcbiAgdmFyIHN0b3JlID0gdGhpcztcbiAgdmFyIHJlZiA9IHRoaXM7XG4gIHZhciBkaXNwYXRjaCA9IHJlZi5kaXNwYXRjaDtcbiAgdmFyIGNvbW1pdCA9IHJlZi5jb21taXQ7XG4gIHRoaXMuZGlzcGF0Y2ggPSBmdW5jdGlvbiBib3VuZERpc3BhdGNoICh0eXBlLCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoLmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQpXG4gIH07XG4gIHRoaXMuY29tbWl0ID0gZnVuY3Rpb24gYm91bmRDb21taXQgKHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29tbWl0LmNhbGwoc3RvcmUsIHR5cGUsIHBheWxvYWQsIG9wdGlvbnMpXG4gIH07XG5cbiAgLy8gc3RyaWN0IG1vZGVcbiAgdGhpcy5zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgLy8gaW5pdCByb290IG1vZHVsZS5cbiAgLy8gdGhpcyBhbHNvIHJlY3Vyc2l2ZWx5IHJlZ2lzdGVycyBhbGwgc3ViLW1vZHVsZXNcbiAgLy8gYW5kIGNvbGxlY3RzIGFsbCBtb2R1bGUgZ2V0dGVycyBpbnNpZGUgdGhpcy5fd3JhcHBlZEdldHRlcnNcbiAgaW5zdGFsbE1vZHVsZSh0aGlzLCBzdGF0ZSwgW10sIHRoaXMuX21vZHVsZXMucm9vdCk7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0aGUgc3RvcmUgdm0sIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgcmVhY3Rpdml0eVxuICAvLyAoYWxzbyByZWdpc3RlcnMgX3dyYXBwZWRHZXR0ZXJzIGFzIGNvbXB1dGVkIHByb3BlcnRpZXMpXG4gIHJlc2V0U3RvcmVWTSh0aGlzLCBzdGF0ZSk7XG5cbiAgLy8gYXBwbHkgcGx1Z2luc1xuICBwbHVnaW5zLmNvbmNhdChkZXZ0b29sUGx1Z2luKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHsgcmV0dXJuIHBsdWdpbih0aGlzJDEpOyB9KTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IHN0YXRlOiB7fSB9O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuc3RhdGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdm0uX2RhdGEuJCRzdGF0ZVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLnN0YXRlLnNldCA9IGZ1bmN0aW9uICh2KSB7XG4gIGFzc2VydChmYWxzZSwgXCJVc2Ugc3RvcmUucmVwbGFjZVN0YXRlKCkgdG8gZXhwbGljaXQgcmVwbGFjZSBzdG9yZSBzdGF0ZS5cIik7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuY29tbWl0ID0gZnVuY3Rpb24gY29tbWl0IChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gY2hlY2sgb2JqZWN0LXN0eWxlIGNvbW1pdFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKTtcbiAgICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICAgIHZhciBwYXlsb2FkID0gcmVmLnBheWxvYWQ7XG4gICAgdmFyIG9wdGlvbnMgPSByZWYub3B0aW9ucztcblxuICB2YXIgbXV0YXRpb24gPSB7IHR5cGU6IHR5cGUsIHBheWxvYWQ6IHBheWxvYWQgfTtcbiAgdmFyIGVudHJ5ID0gdGhpcy5fbXV0YXRpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBtdXRhdGlvbiB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICBlbnRyeS5mb3JFYWNoKGZ1bmN0aW9uIGNvbW1pdEl0ZXJhdG9yIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKHBheWxvYWQpO1xuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5fc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIobXV0YXRpb24sIHRoaXMkMS5zdGF0ZSk7IH0pO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2lsZW50KSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbdnVleF0gbXV0YXRpb24gdHlwZTogXCIgKyB0eXBlICsgXCIuIFNpbGVudCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZC4gXCIgK1xuICAgICAgJ1VzZSB0aGUgZmlsdGVyIGZ1bmN0aW9uYWxpdHkgaW4gdGhlIHZ1ZS1kZXZ0b29scydcbiAgICApO1xuICB9XG59O1xuXG5TdG9yZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiBkaXNwYXRjaCAoX3R5cGUsIF9wYXlsb2FkKSB7XG4gIC8vIGNoZWNrIG9iamVjdC1zdHlsZSBkaXNwYXRjaFxuICB2YXIgcmVmID0gdW5pZnlPYmplY3RTdHlsZShfdHlwZSwgX3BheWxvYWQpO1xuICAgIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gICAgdmFyIHBheWxvYWQgPSByZWYucGF5bG9hZDtcblxuICB2YXIgZW50cnkgPSB0aGlzLl9hY3Rpb25zW3R5cGVdO1xuICBpZiAoIWVudHJ5KSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBhY3Rpb24gdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgcmV0dXJuXG4gIH1cbiAgcmV0dXJuIGVudHJ5Lmxlbmd0aCA+IDFcbiAgICA/IFByb21pc2UuYWxsKGVudHJ5Lm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlcihwYXlsb2FkKTsgfSkpXG4gICAgOiBlbnRyeVswXShwYXlsb2FkKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZSAoZm4pIHtcbiAgdmFyIHN1YnMgPSB0aGlzLl9zdWJzY3JpYmVycztcbiAgaWYgKHN1YnMuaW5kZXhPZihmbikgPCAwKSB7XG4gICAgc3Vicy5wdXNoKGZuKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gc3Vicy5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7XG4gICAgICBzdWJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn07XG5cblN0b3JlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uIHdhdGNoIChnZXR0ZXIsIGNiLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgYXNzZXJ0KHR5cGVvZiBnZXR0ZXIgPT09ICdmdW5jdGlvbicsIFwic3RvcmUud2F0Y2ggb25seSBhY2NlcHRzIGEgZnVuY3Rpb24uXCIpO1xuICByZXR1cm4gdGhpcy5fd2F0Y2hlclZNLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiBnZXR0ZXIodGhpcyQxLnN0YXRlLCB0aGlzJDEuZ2V0dGVycyk7IH0sIGNiLCBvcHRpb25zKVxufTtcblxuU3RvcmUucHJvdG90eXBlLnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAoc3RhdGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl93aXRoQ29tbWl0KGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEuX3ZtLl9kYXRhLiQkc3RhdGUgPSBzdGF0ZTtcbiAgfSk7XG59O1xuXG5TdG9yZS5wcm90b3R5cGUucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiByZWdpc3Rlck1vZHVsZSAocGF0aCwgcmF3TW9kdWxlKSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsgcGF0aCA9IFtwYXRoXTsgfVxuICBhc3NlcnQoQXJyYXkuaXNBcnJheShwYXRoKSwgXCJtb2R1bGUgcGF0aCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFuIEFycmF5LlwiKTtcbiAgdGhpcy5fbW9kdWxlcy5yZWdpc3RlcihwYXRoLCByYXdNb2R1bGUpO1xuICBpbnN0YWxsTW9kdWxlKHRoaXMsIHRoaXMuc3RhdGUsIHBhdGgsIHRoaXMuX21vZHVsZXMuZ2V0KHBhdGgpKTtcbiAgLy8gcmVzZXQgc3RvcmUgdG8gdXBkYXRlIGdldHRlcnMuLi5cbiAgcmVzZXRTdG9yZVZNKHRoaXMsIHRoaXMuc3RhdGUpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLnVucmVnaXN0ZXJNb2R1bGUgPSBmdW5jdGlvbiB1bnJlZ2lzdGVyTW9kdWxlIChwYXRoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgeyBwYXRoID0gW3BhdGhdOyB9XG4gIGFzc2VydChBcnJheS5pc0FycmF5KHBhdGgpLCBcIm1vZHVsZSBwYXRoIG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gQXJyYXkuXCIpO1xuICB0aGlzLl9tb2R1bGVzLnVucmVnaXN0ZXIocGF0aCk7XG4gIHRoaXMuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnRTdGF0ZSA9IGdldE5lc3RlZFN0YXRlKHRoaXMkMS5zdGF0ZSwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIFZ1ZS5kZWxldGUocGFyZW50U3RhdGUsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSk7XG4gIH0pO1xuICByZXNldFN0b3JlKHRoaXMpO1xufTtcblxuU3RvcmUucHJvdG90eXBlLmhvdFVwZGF0ZSA9IGZ1bmN0aW9uIGhvdFVwZGF0ZSAobmV3T3B0aW9ucykge1xuICB0aGlzLl9tb2R1bGVzLnVwZGF0ZShuZXdPcHRpb25zKTtcbiAgcmVzZXRTdG9yZSh0aGlzLCB0cnVlKTtcbn07XG5cblN0b3JlLnByb3RvdHlwZS5fd2l0aENvbW1pdCA9IGZ1bmN0aW9uIF93aXRoQ29tbWl0IChmbikge1xuICB2YXIgY29tbWl0dGluZyA9IHRoaXMuX2NvbW1pdHRpbmc7XG4gIHRoaXMuX2NvbW1pdHRpbmcgPSB0cnVlO1xuICBmbigpO1xuICB0aGlzLl9jb21taXR0aW5nID0gY29tbWl0dGluZztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTdG9yZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5mdW5jdGlvbiByZXNldFN0b3JlIChzdG9yZSwgaG90KSB7XG4gIHN0b3JlLl9hY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgc3RvcmUuX211dGF0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl93cmFwcGVkR2V0dGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHN0YXRlID0gc3RvcmUuc3RhdGU7XG4gIC8vIGluaXQgYWxsIG1vZHVsZXNcbiAgaW5zdGFsbE1vZHVsZShzdG9yZSwgc3RhdGUsIFtdLCBzdG9yZS5fbW9kdWxlcy5yb290LCB0cnVlKTtcbiAgLy8gcmVzZXQgdm1cbiAgcmVzZXRTdG9yZVZNKHN0b3JlLCBzdGF0ZSwgaG90KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRTdG9yZVZNIChzdG9yZSwgc3RhdGUsIGhvdCkge1xuICB2YXIgb2xkVm0gPSBzdG9yZS5fdm07XG5cbiAgLy8gYmluZCBzdG9yZSBwdWJsaWMgZ2V0dGVyc1xuICBzdG9yZS5nZXR0ZXJzID0ge307XG4gIHZhciB3cmFwcGVkR2V0dGVycyA9IHN0b3JlLl93cmFwcGVkR2V0dGVycztcbiAgdmFyIGNvbXB1dGVkID0ge307XG4gIGZvckVhY2hWYWx1ZSh3cmFwcGVkR2V0dGVycywgZnVuY3Rpb24gKGZuLCBrZXkpIHtcbiAgICAvLyB1c2UgY29tcHV0ZWQgdG8gbGV2ZXJhZ2UgaXRzIGxhenktY2FjaGluZyBtZWNoYW5pc21cbiAgICBjb21wdXRlZFtrZXldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZm4oc3RvcmUpOyB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdG9yZS5nZXR0ZXJzLCBrZXksIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuX3ZtW2tleV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlIC8vIGZvciBsb2NhbCBnZXR0ZXJzXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHVzZSBhIFZ1ZSBpbnN0YW5jZSB0byBzdG9yZSB0aGUgc3RhdGUgdHJlZVxuICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBqdXN0IGluIGNhc2UgdGhlIHVzZXIgaGFzIGFkZGVkXG4gIC8vIHNvbWUgZnVua3kgZ2xvYmFsIG1peGluc1xuICB2YXIgc2lsZW50ID0gVnVlLmNvbmZpZy5zaWxlbnQ7XG4gIFZ1ZS5jb25maWcuc2lsZW50ID0gdHJ1ZTtcbiAgc3RvcmUuX3ZtID0gbmV3IFZ1ZSh7XG4gICAgZGF0YToge1xuICAgICAgJCRzdGF0ZTogc3RhdGVcbiAgICB9LFxuICAgIGNvbXB1dGVkOiBjb21wdXRlZFxuICB9KTtcbiAgVnVlLmNvbmZpZy5zaWxlbnQgPSBzaWxlbnQ7XG5cbiAgLy8gZW5hYmxlIHN0cmljdCBtb2RlIGZvciBuZXcgdm1cbiAgaWYgKHN0b3JlLnN0cmljdCkge1xuICAgIGVuYWJsZVN0cmljdE1vZGUoc3RvcmUpO1xuICB9XG5cbiAgaWYgKG9sZFZtKSB7XG4gICAgaWYgKGhvdCkge1xuICAgICAgLy8gZGlzcGF0Y2ggY2hhbmdlcyBpbiBhbGwgc3Vic2NyaWJlZCB3YXRjaGVyc1xuICAgICAgLy8gdG8gZm9yY2UgZ2V0dGVyIHJlLWV2YWx1YXRpb24gZm9yIGhvdCByZWxvYWRpbmcuXG4gICAgICBzdG9yZS5fd2l0aENvbW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9sZFZtLl9kYXRhLiQkc3RhdGUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFZ1ZS5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJldHVybiBvbGRWbS4kZGVzdHJveSgpOyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnN0YWxsTW9kdWxlIChzdG9yZSwgcm9vdFN0YXRlLCBwYXRoLCBtb2R1bGUsIGhvdCkge1xuICB2YXIgaXNSb290ID0gIXBhdGgubGVuZ3RoO1xuICB2YXIgbmFtZXNwYWNlID0gc3RvcmUuX21vZHVsZXMuZ2V0TmFtZXNwYWNlKHBhdGgpO1xuXG4gIC8vIHJlZ2lzdGVyIGluIG5hbWVzcGFjZSBtYXBcbiAgaWYgKG1vZHVsZS5uYW1lc3BhY2VkKSB7XG4gICAgc3RvcmUuX21vZHVsZXNOYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSA9IG1vZHVsZTtcbiAgfVxuXG4gIC8vIHNldCBzdGF0ZVxuICBpZiAoIWlzUm9vdCAmJiAhaG90KSB7XG4gICAgdmFyIHBhcmVudFN0YXRlID0gZ2V0TmVzdGVkU3RhdGUocm9vdFN0YXRlLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgdmFyIG1vZHVsZU5hbWUgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgc3RvcmUuX3dpdGhDb21taXQoZnVuY3Rpb24gKCkge1xuICAgICAgVnVlLnNldChwYXJlbnRTdGF0ZSwgbW9kdWxlTmFtZSwgbW9kdWxlLnN0YXRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBsb2NhbCA9IG1vZHVsZS5jb250ZXh0ID0gbWFrZUxvY2FsQ29udGV4dChzdG9yZSwgbmFtZXNwYWNlLCBwYXRoKTtcblxuICBtb2R1bGUuZm9yRWFjaE11dGF0aW9uKGZ1bmN0aW9uIChtdXRhdGlvbiwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyTXV0YXRpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBtdXRhdGlvbiwgbG9jYWwpO1xuICB9KTtcblxuICBtb2R1bGUuZm9yRWFjaEFjdGlvbihmdW5jdGlvbiAoYWN0aW9uLCBrZXkpIHtcbiAgICB2YXIgbmFtZXNwYWNlZFR5cGUgPSBuYW1lc3BhY2UgKyBrZXk7XG4gICAgcmVnaXN0ZXJBY3Rpb24oc3RvcmUsIG5hbWVzcGFjZWRUeXBlLCBhY3Rpb24sIGxvY2FsKTtcbiAgfSk7XG5cbiAgbW9kdWxlLmZvckVhY2hHZXR0ZXIoZnVuY3Rpb24gKGdldHRlciwga2V5KSB7XG4gICAgdmFyIG5hbWVzcGFjZWRUeXBlID0gbmFtZXNwYWNlICsga2V5O1xuICAgIHJlZ2lzdGVyR2V0dGVyKHN0b3JlLCBuYW1lc3BhY2VkVHlwZSwgZ2V0dGVyLCBsb2NhbCk7XG4gIH0pO1xuXG4gIG1vZHVsZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkLCBrZXkpIHtcbiAgICBpbnN0YWxsTW9kdWxlKHN0b3JlLCByb290U3RhdGUsIHBhdGguY29uY2F0KGtleSksIGNoaWxkLCBob3QpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBtYWtlIGxvY2FsaXplZCBkaXNwYXRjaCwgY29tbWl0LCBnZXR0ZXJzIGFuZCBzdGF0ZVxuICogaWYgdGhlcmUgaXMgbm8gbmFtZXNwYWNlLCBqdXN0IHVzZSByb290IG9uZXNcbiAqL1xuZnVuY3Rpb24gbWFrZUxvY2FsQ29udGV4dCAoc3RvcmUsIG5hbWVzcGFjZSwgcGF0aCkge1xuICB2YXIgbm9OYW1lc3BhY2UgPSBuYW1lc3BhY2UgPT09ICcnO1xuXG4gIHZhciBsb2NhbCA9IHtcbiAgICBkaXNwYXRjaDogbm9OYW1lc3BhY2UgPyBzdG9yZS5kaXNwYXRjaCA6IGZ1bmN0aW9uIChfdHlwZSwgX3BheWxvYWQsIF9vcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyA9IHVuaWZ5T2JqZWN0U3R5bGUoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucyk7XG4gICAgICB2YXIgcGF5bG9hZCA9IGFyZ3MucGF5bG9hZDtcbiAgICAgIHZhciBvcHRpb25zID0gYXJncy5vcHRpb25zO1xuICAgICAgdmFyIHR5cGUgPSBhcmdzLnR5cGU7XG5cbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yb290KSB7XG4gICAgICAgIHR5cGUgPSBuYW1lc3BhY2UgKyB0eXBlO1xuICAgICAgICBpZiAoIXN0b3JlLl9hY3Rpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBhY3Rpb24gdHlwZTogXCIgKyAoYXJncy50eXBlKSArIFwiLCBnbG9iYWwgdHlwZTogXCIgKyB0eXBlKSk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoKHR5cGUsIHBheWxvYWQpXG4gICAgfSxcblxuICAgIGNvbW1pdDogbm9OYW1lc3BhY2UgPyBzdG9yZS5jb21taXQgOiBmdW5jdGlvbiAoX3R5cGUsIF9wYXlsb2FkLCBfb3B0aW9ucykge1xuICAgICAgdmFyIGFyZ3MgPSB1bmlmeU9iamVjdFN0eWxlKF90eXBlLCBfcGF5bG9hZCwgX29wdGlvbnMpO1xuICAgICAgdmFyIHBheWxvYWQgPSBhcmdzLnBheWxvYWQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3Mub3B0aW9ucztcbiAgICAgIHZhciB0eXBlID0gYXJncy50eXBlO1xuXG4gICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucm9vdCkge1xuICAgICAgICB0eXBlID0gbmFtZXNwYWNlICsgdHlwZTtcbiAgICAgICAgaWYgKCFzdG9yZS5fbXV0YXRpb25zW3R5cGVdKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBsb2NhbCBtdXRhdGlvbiB0eXBlOiBcIiArIChhcmdzLnR5cGUpICsgXCIsIGdsb2JhbCB0eXBlOiBcIiArIHR5cGUpKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdG9yZS5jb21taXQodHlwZSwgcGF5bG9hZCwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGdldHRlcnMgYW5kIHN0YXRlIG9iamVjdCBtdXN0IGJlIGdvdHRlbiBsYXppbHlcbiAgLy8gYmVjYXVzZSB0aGV5IHdpbGwgYmUgY2hhbmdlZCBieSB2bSB1cGRhdGVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobG9jYWwsIHtcbiAgICBnZXR0ZXJzOiB7XG4gICAgICBnZXQ6IG5vTmFtZXNwYWNlXG4gICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0dGVyczsgfVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VMb2NhbEdldHRlcnMoc3RvcmUsIG5hbWVzcGFjZSk7IH1cbiAgICB9LFxuICAgIHN0YXRlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldE5lc3RlZFN0YXRlKHN0b3JlLnN0YXRlLCBwYXRoKTsgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGxvY2FsXG59XG5cbmZ1bmN0aW9uIG1ha2VMb2NhbEdldHRlcnMgKHN0b3JlLCBuYW1lc3BhY2UpIHtcbiAgdmFyIGdldHRlcnNQcm94eSA9IHt9O1xuXG4gIHZhciBzcGxpdFBvcyA9IG5hbWVzcGFjZS5sZW5ndGg7XG4gIE9iamVjdC5rZXlzKHN0b3JlLmdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAvLyBza2lwIGlmIHRoZSB0YXJnZXQgZ2V0dGVyIGlzIG5vdCBtYXRjaCB0aGlzIG5hbWVzcGFjZVxuICAgIGlmICh0eXBlLnNsaWNlKDAsIHNwbGl0UG9zKSAhPT0gbmFtZXNwYWNlKSB7IHJldHVybiB9XG5cbiAgICAvLyBleHRyYWN0IGxvY2FsIGdldHRlciB0eXBlXG4gICAgdmFyIGxvY2FsVHlwZSA9IHR5cGUuc2xpY2Uoc3BsaXRQb3MpO1xuXG4gICAgLy8gQWRkIGEgcG9ydCB0byB0aGUgZ2V0dGVycyBwcm94eS5cbiAgICAvLyBEZWZpbmUgYXMgZ2V0dGVyIHByb3BlcnR5IGJlY2F1c2VcbiAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBldmFsdWF0ZSB0aGUgZ2V0dGVycyBpbiB0aGlzIHRpbWUuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldHRlcnNQcm94eSwgbG9jYWxUeXBlLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0b3JlLmdldHRlcnNbdHlwZV07IH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBnZXR0ZXJzUHJveHlcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJNdXRhdGlvbiAoc3RvcmUsIHR5cGUsIGhhbmRsZXIsIGxvY2FsKSB7XG4gIHZhciBlbnRyeSA9IHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gfHwgKHN0b3JlLl9tdXRhdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZE11dGF0aW9uSGFuZGxlciAocGF5bG9hZCkge1xuICAgIGhhbmRsZXIobG9jYWwuc3RhdGUsIHBheWxvYWQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJBY3Rpb24gKHN0b3JlLCB0eXBlLCBoYW5kbGVyLCBsb2NhbCkge1xuICB2YXIgZW50cnkgPSBzdG9yZS5fYWN0aW9uc1t0eXBlXSB8fCAoc3RvcmUuX2FjdGlvbnNbdHlwZV0gPSBbXSk7XG4gIGVudHJ5LnB1c2goZnVuY3Rpb24gd3JhcHBlZEFjdGlvbkhhbmRsZXIgKHBheWxvYWQsIGNiKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIoe1xuICAgICAgZGlzcGF0Y2g6IGxvY2FsLmRpc3BhdGNoLFxuICAgICAgY29tbWl0OiBsb2NhbC5jb21taXQsXG4gICAgICBnZXR0ZXJzOiBsb2NhbC5nZXR0ZXJzLFxuICAgICAgc3RhdGU6IGxvY2FsLnN0YXRlLFxuICAgICAgcm9vdEdldHRlcnM6IHN0b3JlLmdldHRlcnMsXG4gICAgICByb290U3RhdGU6IHN0b3JlLnN0YXRlXG4gICAgfSwgcGF5bG9hZCwgY2IpO1xuICAgIGlmICghaXNQcm9taXNlKHJlcykpIHtcbiAgICAgIHJlcyA9IFByb21pc2UucmVzb2x2ZShyZXMpO1xuICAgIH1cbiAgICBpZiAoc3RvcmUuX2RldnRvb2xIb29rKSB7XG4gICAgICByZXR1cm4gcmVzLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc3RvcmUuX2RldnRvb2xIb29rLmVtaXQoJ3Z1ZXg6ZXJyb3InLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlckdldHRlciAoc3RvcmUsIHR5cGUsIHJhd0dldHRlciwgbG9jYWwpIHtcbiAgaWYgKHN0b3JlLl93cmFwcGVkR2V0dGVyc1t0eXBlXSkge1xuICAgIGNvbnNvbGUuZXJyb3IoKFwiW3Z1ZXhdIGR1cGxpY2F0ZSBnZXR0ZXIga2V5OiBcIiArIHR5cGUpKTtcbiAgICByZXR1cm5cbiAgfVxuICBzdG9yZS5fd3JhcHBlZEdldHRlcnNbdHlwZV0gPSBmdW5jdGlvbiB3cmFwcGVkR2V0dGVyIChzdG9yZSkge1xuICAgIHJldHVybiByYXdHZXR0ZXIoXG4gICAgICBsb2NhbC5zdGF0ZSwgLy8gbG9jYWwgc3RhdGVcbiAgICAgIGxvY2FsLmdldHRlcnMsIC8vIGxvY2FsIGdldHRlcnNcbiAgICAgIHN0b3JlLnN0YXRlLCAvLyByb290IHN0YXRlXG4gICAgICBzdG9yZS5nZXR0ZXJzIC8vIHJvb3QgZ2V0dGVyc1xuICAgIClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5hYmxlU3RyaWN0TW9kZSAoc3RvcmUpIHtcbiAgc3RvcmUuX3ZtLiR3YXRjaChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhLiQkc3RhdGUgfSwgZnVuY3Rpb24gKCkge1xuICAgIGFzc2VydChzdG9yZS5fY29tbWl0dGluZywgXCJEbyBub3QgbXV0YXRlIHZ1ZXggc3RvcmUgc3RhdGUgb3V0c2lkZSBtdXRhdGlvbiBoYW5kbGVycy5cIik7XG4gIH0sIHsgZGVlcDogdHJ1ZSwgc3luYzogdHJ1ZSB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TmVzdGVkU3RhdGUgKHN0YXRlLCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aFxuICAgID8gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKHN0YXRlLCBrZXkpIHsgcmV0dXJuIHN0YXRlW2tleV07IH0sIHN0YXRlKVxuICAgIDogc3RhdGVcbn1cblxuZnVuY3Rpb24gdW5pZnlPYmplY3RTdHlsZSAodHlwZSwgcGF5bG9hZCwgb3B0aW9ucykge1xuICBpZiAoaXNPYmplY3QodHlwZSkgJiYgdHlwZS50eXBlKSB7XG4gICAgb3B0aW9ucyA9IHBheWxvYWQ7XG4gICAgcGF5bG9hZCA9IHR5cGU7XG4gICAgdHlwZSA9IHR5cGUudHlwZTtcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycsIChcIkV4cGVjdHMgc3RyaW5nIGFzIHRoZSB0eXBlLCBidXQgZm91bmQgXCIgKyAodHlwZW9mIHR5cGUpICsgXCIuXCIpKTtcblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBwYXlsb2FkOiBwYXlsb2FkLCBvcHRpb25zOiBvcHRpb25zIH1cbn1cblxuZnVuY3Rpb24gaW5zdGFsbCAoX1Z1ZSkge1xuICBpZiAoVnVlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgICdbdnVleF0gYWxyZWFkeSBpbnN0YWxsZWQuIFZ1ZS51c2UoVnVleCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgVnVlID0gX1Z1ZTtcbiAgYXBwbHlNaXhpbihWdWUpO1xufVxuXG4vLyBhdXRvIGluc3RhbGwgaW4gZGlzdCBtb2RlXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LlZ1ZSkge1xuICBpbnN0YWxsKHdpbmRvdy5WdWUpO1xufVxuXG52YXIgbWFwU3RhdGUgPSBub3JtYWxpemVOYW1lc3BhY2UoZnVuY3Rpb24gKG5hbWVzcGFjZSwgc3RhdGVzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKHN0YXRlcykuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgdmFyIHZhbCA9IHJlZi52YWw7XG5cbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZFN0YXRlICgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHN0b3JlLnN0YXRlO1xuICAgICAgdmFyIGdldHRlcnMgPSB0aGlzLiRzdG9yZS5nZXR0ZXJzO1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICB2YXIgbW9kdWxlID0gZ2V0TW9kdWxlQnlOYW1lc3BhY2UodGhpcy4kc3RvcmUsICdtYXBTdGF0ZScsIG5hbWVzcGFjZSk7XG4gICAgICAgIGlmICghbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUgPSBtb2R1bGUuY29udGV4dC5zdGF0ZTtcbiAgICAgICAgZ2V0dGVycyA9IG1vZHVsZS5jb250ZXh0LmdldHRlcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHZhbC5jYWxsKHRoaXMsIHN0YXRlLCBnZXR0ZXJzKVxuICAgICAgICA6IHN0YXRlW3ZhbF1cbiAgICB9O1xuICAgIC8vIG1hcmsgdnVleCBnZXR0ZXIgZm9yIGRldnRvb2xzXG4gICAgcmVzW2tleV0udnVleCA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxudmFyIG1hcE11dGF0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBtdXRhdGlvbnMpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBub3JtYWxpemVNYXAobXV0YXRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICB2YXIgdmFsID0gcmVmLnZhbDtcblxuICAgIHZhbCA9IG5hbWVzcGFjZSArIHZhbDtcbiAgICByZXNba2V5XSA9IGZ1bmN0aW9uIG1hcHBlZE11dGF0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcE11dGF0aW9ucycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4kc3RvcmUuY29tbWl0LmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwR2V0dGVycyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBnZXR0ZXJzKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGdldHRlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkR2V0dGVyICgpIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgJiYgIWdldE1vZHVsZUJ5TmFtZXNwYWNlKHRoaXMuJHN0b3JlLCAnbWFwR2V0dGVycycsIG5hbWVzcGFjZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoISh2YWwgaW4gdGhpcy4kc3RvcmUuZ2V0dGVycykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gdW5rbm93biBnZXR0ZXI6IFwiICsgdmFsKSk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnNbdmFsXVxuICAgIH07XG4gICAgLy8gbWFyayB2dWV4IGdldHRlciBmb3IgZGV2dG9vbHNcbiAgICByZXNba2V5XS52dWV4ID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG52YXIgbWFwQWN0aW9ucyA9IG5vcm1hbGl6ZU5hbWVzcGFjZShmdW5jdGlvbiAobmFtZXNwYWNlLCBhY3Rpb25zKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgbm9ybWFsaXplTWFwKGFjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgIHZhciB2YWwgPSByZWYudmFsO1xuXG4gICAgdmFsID0gbmFtZXNwYWNlICsgdmFsO1xuICAgIHJlc1trZXldID0gZnVuY3Rpb24gbWFwcGVkQWN0aW9uICgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgICBpZiAobmFtZXNwYWNlICYmICFnZXRNb2R1bGVCeU5hbWVzcGFjZSh0aGlzLiRzdG9yZSwgJ21hcEFjdGlvbnMnLCBuYW1lc3BhY2UpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmRpc3BhdGNoLmFwcGx5KHRoaXMuJHN0b3JlLCBbdmFsXS5jb25jYXQoYXJncykpXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG5mdW5jdGlvbiBub3JtYWxpemVNYXAgKG1hcCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShtYXApXG4gICAgPyBtYXAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IGtleSB9KTsgfSlcbiAgICA6IE9iamVjdC5rZXlzKG1hcCkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWw6IG1hcFtrZXldIH0pOyB9KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOYW1lc3BhY2UgKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAobmFtZXNwYWNlLCBtYXApIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG1hcCA9IG5hbWVzcGFjZTtcbiAgICAgIG5hbWVzcGFjZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAobmFtZXNwYWNlLmNoYXJBdChuYW1lc3BhY2UubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgICAgbmFtZXNwYWNlICs9ICcvJztcbiAgICB9XG4gICAgcmV0dXJuIGZuKG5hbWVzcGFjZSwgbWFwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZUJ5TmFtZXNwYWNlIChzdG9yZSwgaGVscGVyLCBuYW1lc3BhY2UpIHtcbiAgdmFyIG1vZHVsZSA9IHN0b3JlLl9tb2R1bGVzTmFtZXNwYWNlTWFwW25hbWVzcGFjZV07XG4gIGlmICghbW9kdWxlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbdnVleF0gbW9kdWxlIG5hbWVzcGFjZSBub3QgZm91bmQgaW4gXCIgKyBoZWxwZXIgKyBcIigpOiBcIiArIG5hbWVzcGFjZSkpO1xuICB9XG4gIHJldHVybiBtb2R1bGVcbn1cblxudmFyIGluZGV4X2VzbSA9IHtcbiAgU3RvcmU6IFN0b3JlLFxuICBpbnN0YWxsOiBpbnN0YWxsLFxuICB2ZXJzaW9uOiAnMi4zLjAnLFxuICBtYXBTdGF0ZTogbWFwU3RhdGUsXG4gIG1hcE11dGF0aW9uczogbWFwTXV0YXRpb25zLFxuICBtYXBHZXR0ZXJzOiBtYXBHZXR0ZXJzLFxuICBtYXBBY3Rpb25zOiBtYXBBY3Rpb25zXG59O1xuXG5leHBvcnQgeyBTdG9yZSwgbWFwU3RhdGUsIG1hcE11dGF0aW9ucywgbWFwR2V0dGVycywgbWFwQWN0aW9ucyB9O2V4cG9ydCBkZWZhdWx0IGluZGV4X2VzbTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdnVleC9kaXN0L3Z1ZXguZXNtLmpzIiwiLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuICBNb2RpZmllZCBieSBFdmFuIFlvdSBAeXl4OTkwODAzXG4qL1xuXG52YXIgaGFzRG9jdW1lbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG5cbmlmICh0eXBlb2YgREVCVUcgIT09ICd1bmRlZmluZWQnICYmIERFQlVHKSB7XG4gIGlmICghaGFzRG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3Z1ZS1zdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudC4gJyArXG4gICAgXCJVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiXG4gICkgfVxufVxuXG52YXIgbGlzdFRvU3R5bGVzID0gcmVxdWlyZSgnLi9saXN0VG9TdHlsZXMnKVxuXG4vKlxudHlwZSBTdHlsZU9iamVjdCA9IHtcbiAgaWQ6IG51bWJlcjtcbiAgcGFydHM6IEFycmF5PFN0eWxlT2JqZWN0UGFydD5cbn1cblxudHlwZSBTdHlsZU9iamVjdFBhcnQgPSB7XG4gIGNzczogc3RyaW5nO1xuICBtZWRpYTogc3RyaW5nO1xuICBzb3VyY2VNYXA6ID9zdHJpbmdcbn1cbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHsvKlxuICBbaWQ6IG51bWJlcl06IHtcbiAgICBpZDogbnVtYmVyLFxuICAgIHJlZnM6IG51bWJlcixcbiAgICBwYXJ0czogQXJyYXk8KG9iaj86IFN0eWxlT2JqZWN0UGFydCkgPT4gdm9pZD5cbiAgfVxuKi99XG5cbnZhciBoZWFkID0gaGFzRG9jdW1lbnQgJiYgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSlcbnZhciBzaW5nbGV0b25FbGVtZW50ID0gbnVsbFxudmFyIHNpbmdsZXRvbkNvdW50ZXIgPSAwXG52YXIgaXNQcm9kdWN0aW9uID0gZmFsc2VcbnZhciBub29wID0gZnVuY3Rpb24gKCkge31cblxuLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG52YXIgaXNPbGRJRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9tc2llIFs2LTldXFxiLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFyZW50SWQsIGxpc3QsIF9pc1Byb2R1Y3Rpb24pIHtcbiAgaXNQcm9kdWN0aW9uID0gX2lzUHJvZHVjdGlvblxuXG4gIHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMocGFyZW50SWQsIGxpc3QpXG4gIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG4gICAgdmFyIG1heVJlbW92ZSA9IFtdXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gc3R5bGVzW2ldXG4gICAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgICAgZG9tU3R5bGUucmVmcy0tXG4gICAgICBtYXlSZW1vdmUucHVzaChkb21TdHlsZSlcbiAgICB9XG4gICAgaWYgKG5ld0xpc3QpIHtcbiAgICAgIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbmV3TGlzdClcbiAgICAgIGFkZFN0eWxlc1RvRG9tKHN0eWxlcylcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzID0gW11cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXVxuICAgICAgaWYgKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKClcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMgLyogQXJyYXk8U3R5bGVPYmplY3Q+ICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICB2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXVxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUucmVmcysrXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pXG4gICAgICB9XG4gICAgICBmb3IgKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIGlmIChkb21TdHlsZS5wYXJ0cy5sZW5ndGggPiBpdGVtLnBhcnRzLmxlbmd0aCkge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5sZW5ndGggPSBpdGVtLnBhcnRzLmxlbmd0aFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFydHMgPSBbXVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSkpXG4gICAgICB9XG4gICAgICBzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHsgaWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0cyB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAoKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJ1xuICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudClcbiAgcmV0dXJuIHN0eWxlRWxlbWVudFxufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqIC8qIFN0eWxlT2JqZWN0UGFydCAqLykge1xuICB2YXIgdXBkYXRlLCByZW1vdmVcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlW2RhdGEtdnVlLXNzci1pZH49XCInICsgb2JqLmlkICsgJ1wiXScpXG5cbiAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgIGlmIChpc1Byb2R1Y3Rpb24pIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGFuZCBpbiBwcm9kdWN0aW9uIG1vZGUuXG4gICAgICAvLyBzaW1wbHkgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBub29wXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhhcyBTU1Igc3R5bGVzIGJ1dCBpbiBkZXYgbW9kZS5cbiAgICAgIC8vIGZvciBzb21lIHJlYXNvbiBDaHJvbWUgY2FuJ3QgaGFuZGxlIHNvdXJjZSBtYXAgaW4gc2VydmVyLXJlbmRlcmVkXG4gICAgICAvLyBzdHlsZSB0YWdzIC0gc291cmNlIG1hcHMgaW4gPHN0eWxlPiBvbmx5IHdvcmtzIGlmIHRoZSBzdHlsZSB0YWcgaXNcbiAgICAgIC8vIGNyZWF0ZWQgYW5kIGluc2VydGVkIGR5bmFtaWNhbGx5LiBTbyB3ZSByZW1vdmUgdGhlIHNlcnZlciByZW5kZXJlZFxuICAgICAgLy8gc3R5bGVzIGFuZCBpbmplY3QgbmV3IG9uZXMuXG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgaWYgKGlzT2xkSUUpIHtcbiAgICAvLyB1c2Ugc2luZ2xldG9uIG1vZGUgZm9yIElFOS5cbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrK1xuICAgIHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKSlcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSlcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKVxuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBtdWx0aS1zdHlsZS10YWcgbW9kZSBpbiBhbGwgb3RoZXIgY2FzZXNcbiAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZShvYmopXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gICAgaWYgKG5ld09iaikge1xuICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcbiAgICAgICAgICBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuICAgICAgICAgIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgdGV4dFN0b3JlID0gW11cblxuICByZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudFxuICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpXG4gIH1cbn0pKClcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcbiAgdmFyIGNzcyA9IHJlbW92ZSA/ICcnIDogb2JqLmNzc1xuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKVxuICB9IGVsc2Uge1xuICAgIHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKVxuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXNcbiAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSlcbiAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZUVsZW1lbnQsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzc1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWFcbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXBcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKVxuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuICAgIC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcbiAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLydcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArICcgKi8nXG4gIH1cblxuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzXG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpXG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKVxuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX0xpc3RDYWNoZS5qcyIsInZhciBlcSA9IHJlcXVpcmUoJy4vZXEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NvY0luZGV4T2Y7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19pc0luZGV4LmpzIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaWRlbnRpdHkuanMiLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwiLyohXG4gKiBWdWUuanMgdjIuMy4zXG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXG5mdW5jdGlvbiBpc1VuZGVmICh2KSB7XG4gIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAodikge1xuICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNUcnVlICh2KSB7XG4gIHJldHVybiB2ID09PSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzRmFsc2UgKHYpIHtcbiAgcmV0dXJuIHYgPT09IGZhbHNlXG59XG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuICAgIC50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHBvc3NpYmxlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgcmV0dXJuIGEgPT09IGJcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcbiAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgKi9cbiAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAqL1xuICBfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xufSk7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAqL1xuZnVuY3Rpb24gaXNSZXNlcnZlZCAoc3RyKSB7XG4gIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICB2YWx1ZTogdmFsLFxuICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gKi9cbnZhciBiYWlsUkUgPSAvW15cXHcuJF0vO1xuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG51bGwpOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgdmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcbiAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltWdWUgd2Fybl06IFwiICsgbXNnICsgKFxuICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJ1xuICAgICAgPyB2bVxuICAgICAgOiB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0ub3B0aW9uc1xuICAgICAgICA/IHZtLm9wdGlvbnMubmFtZVxuICAgICAgICA6IHZtLl9pc1Z1ZVxuICAgICAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICAgICAgOiB2bS5uYW1lO1xuXG4gICAgdmFyIGZpbGUgPSB2bS5faXNWdWUgJiYgdm0uJG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgdmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcbiAgICAgIHZhciB0cmVlID0gW107XG4gICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICBpZiAodHJlZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPiAwKSB7XG4gICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyZWUucHVzaCh2bSk7XG4gICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbnZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xudmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xudmFyIGlzQW5kcm9pZCA9IFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDA7XG52YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSApKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzI4NVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxudmFyIF9pc1NlcnZlcjtcbnZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcblxuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IH07XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xuICAgICAgLy8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XG4gICAgdmFyIGNvdW50ZXIgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG4gICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgY291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXVlTmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59KSgpO1xuXG52YXIgX1NldDtcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXG4gKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuICovXG52YXIgRGVwID0gZnVuY3Rpb24gRGVwICgpIHtcbiAgdGhpcy5pZCA9IHVpZCQxKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKlxuICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcbiAqL1xuXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl1cbi5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gIHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcbiAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcbiAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9jbG9zdXJlLXdpdGgtYXJndW1lbnRzXG4gICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHMkMVtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzcGxpY2UnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG4gICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pO1xufSk7XG5cbi8qICAqL1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuLyoqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIGEgcmVhY3RpdmUgcHJvcGVydHkgaXMgc2V0LCB0aGUgbmV3IHZhbHVlIGlzXG4gKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG4gKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG4gKiB1bmRlciBhIGZyb3plbiBkYXRhIHN0cnVjdHVyZS4gQ29udmVydGluZyBpdCB3b3VsZCBkZWZlYXQgdGhlIG9wdGltaXphdGlvbi5cbiAqL1xudmFyIG9ic2VydmVyU3RhdGUgPSB7XG4gIHNob3VsZENvbnZlcnQ6IHRydWUsXG4gIGlzU2V0dGluZ1Byb3BzOiBmYWxzZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlclxuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgdmFyIHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcblxuICB2YXIgY2hpbGRPYiA9IG9ic2VydmUodmFsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlU2V0dGVyIChuZXdWYWwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChuZXdWYWwgPT09IHZhbHVlIHx8IChuZXdWYWwgIT09IG5ld1ZhbCAmJiB2YWx1ZSAhPT0gdmFsdWUpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGN1c3RvbVNldHRlcikge1xuICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gbmV3VmFsO1xuICAgICAgfVxuICAgICAgY2hpbGRPYiA9IG9ic2VydmUobmV3VmFsKTtcbiAgICAgIGRlcC5ub3RpZnkoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuICogdHJpZ2dlcnMgY2hhbmdlIG5vdGlmaWNhdGlvbiBpZiB0aGUgcHJvcGVydHkgZG9lc24ndFxuICogYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgdHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcbiAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgaWYgKGhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgdmFyIG9iID0gKHRhcmdldCApLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlJCQxKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0ICkuX19vYl9fO1xuICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIHRhcmdldFtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuICogdmFsdWUgaW50byB0aGUgZmluYWwgdmFsdWUuXG4gKi9cbnZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG4vKipcbiAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcbiAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICovXG5mdW5jdGlvbiBtZXJnZURhdGEgKHRvLCBmcm9tKSB7XG4gIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICB2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgZnJvbVZhbCA9IGZyb21ba2V5XTtcbiAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgc2V0KHRvLCBrZXksIGZyb21WYWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogRGF0YVxuICovXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgLy8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcGFyZW50VmFsXG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWxcbiAgICB9XG4gICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgIC8vIG1lcmdlZCByZXN1bHQgb2YgYm90aCBmdW5jdGlvbnMuLi4gbm8gbmVlZCB0b1xuICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWREYXRhRm4gKCkge1xuICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgY2hpbGRWYWwuY2FsbCh0aGlzKSxcbiAgICAgICAgcGFyZW50VmFsLmNhbGwodGhpcylcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFyZW50VmFsIHx8IGNoaWxkVmFsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgIC8vIGluc3RhbmNlIG1lcmdlXG4gICAgICB2YXIgaW5zdGFuY2VEYXRhID0gdHlwZW9mIGNoaWxkVmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHR5cGVvZiBwYXJlbnRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwYXJlbnRWYWwuY2FsbCh2bSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgOiByZXNcbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5XTtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXldID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICByZXR1cm4gcmV0XG59O1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBrZXlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucykge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFsID0gcHJvcHNba2V5XTtcbiAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgcmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG4gICAgICAgID8gdmFsXG4gICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQpO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICtcbiAgICAgICcgRXhwZWN0ZWQgJyArIGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykgK1xuICAgICAgJywgZ290ICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSArICcuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFsaWQgPSB0eXBlb2YgdmFsdWUgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzVHlwZSAodHlwZSwgZm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gZ2V0VHlwZSh0eXBlKVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChnZXRUeXBlKGZuW2ldKSA9PT0gZ2V0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGluaXRQcm94eTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICBcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcIiArXG4gICAgICBcInByb3BlcnRpZXMgaW4gdGhlIGRhdGEgb3B0aW9uLlwiLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9uc1xuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHt9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICBub2RlLnRleHQgPSAnJztcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zXG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG4gIHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm5zW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuICAgICAgfVxuICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQub25jZSwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdCA9IHJlc1tyZXMubGVuZ3RoIC0gMV07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICByZXMucHVzaC5hcHBseShyZXMsIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgKChuZXN0ZWRJbmRleCB8fCAnJykgKyBcIl9cIiArIGkpKSk7XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICAobGFzdCkudGV4dCArPSBTdHJpbmcoYyk7XG4gICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG4gICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICByZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIHJldHVybiBpc09iamVjdChjb21wKVxuICAgID8gYmFzZS5leHRlbmQoY29tcClcbiAgICA6IGNvbXBcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSQkMSkge1xuICBpZiAob25jZSQkMSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSQxIDwgbDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgdmFyIGNiO1xuICAgIHZhciBpID0gY2JzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjYiA9IGNic1tpXTtcbiAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuICAgICAgICB0aXAoXG4gICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoY2JzKSB7XG4gICAgICBjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcbiAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICovXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuICBjaGlsZHJlbixcbiAgY29udGV4dFxuKSB7XG4gIHZhciBzbG90cyA9IHt9O1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIHNsb3RzXG4gIH1cbiAgdmFyIGRlZmF1bHRTbG90ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mdW5jdGlvbmFsQ29udGV4dCA9PT0gY29udGV4dCkgJiZcbiAgICAgIGNoaWxkLmRhdGEgJiYgY2hpbGQuZGF0YS5zbG90ICE9IG51bGxcbiAgICApIHtcbiAgICAgIHZhciBuYW1lID0gY2hpbGQuZGF0YS5zbG90O1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgd2hpdGVzcGFjZVxuICBpZiAoIWRlZmF1bHRTbG90LmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICBzbG90cy5kZWZhdWx0ID0gZGVmYXVsdFNsb3Q7XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIERPTSBub2RlcyAocHJldmVudHMgbGVhaylcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgdm0sXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICB2bS4kZWwgPSBlbDtcbiAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2bS4kb3B0aW9ucy5yZW5kZXIgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG4gICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICB2YXIgdXBkYXRlQ29tcG9uZW50O1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmFtZSA9IHZtLl9uYW1lO1xuICAgICAgdmFyIGlkID0gdm0uX3VpZDtcbiAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgIHZhciBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArIGlkO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIHZtLl93YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcbiAgaWYgKHZtLl92bm9kZSkgeyAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxuICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgfVxuICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGZhbHNlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgdm0uJG9wdGlvbnMucHJvcHMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG4gIH1cbiAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcbiAgfVxuICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICBpZiAoaGFzQ2hpbGRyZW4pIHtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xuICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG4gIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgIGlmICh2bS5faW5hY3RpdmUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG4gIGlmIChkaXJlY3QpIHtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayAodm0sIGhvb2spIHtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2lyY3VsYXIgPSB7fTtcbiAgfVxuICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAqL1xuZnVuY3Rpb24gZmx1c2hTY2hlZHVsZXJRdWV1ZSAoKSB7XG4gIGZsdXNoaW5nID0gdHJ1ZTtcbiAgdmFyIHdhdGNoZXIsIGlkO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHdhdGNoZXIgPSBxdWV1ZVtpbmRleF07XG4gICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGhhc1tpZF0gPSBudWxsO1xuICAgIHdhdGNoZXIucnVuKCk7XG4gICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZUhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlSG9va3MgKHF1ZXVlKSB7XG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMiA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9uc1xuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgID8gZXhwT3JGbi50b1N0cmluZygpXG4gICAgOiAnJztcbiAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gIGlmICh0eXBlb2YgZXhwT3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcbiAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIGlmICh0aGlzLnVzZXIpIHtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbiAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCkgeyBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpOyB9XG59XG5cbnZhciBpc1Jlc2VydmVkUHJvcCA9IHtcbiAga2V5OiAxLFxuICByZWY6IDEsXG4gIHNsb3Q6IDFcbn07XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IGlzUm9vdDtcbiAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpc1Jlc2VydmVkUHJvcFtrZXldIHx8IGNvbmZpZy5pc1Jlc2VydmVkQXR0cihrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG4gIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgZGF0YSA9IHZtLl9kYXRhID0gdHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbidcbiAgICA/IGdldERhdGEoZGF0YSwgdm0pXG4gICAgOiBkYXRhIHx8IHt9O1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICBkYXRhID0ge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgJ2h0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICB2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleXNbaV0pKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsgKGtleXNbaV0pICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG4gICAgICAgIFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleXNbaV0pKSB7XG4gICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtKVxuICB9IGNhdGNoIChlKSB7XG4gICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgIHJldHVybiB7fVxuICB9XG59XG5cbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbmZ1bmN0aW9uIGluaXRDb21wdXRlZCAodm0sIGNvbXB1dGVkKSB7XG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJObyBnZXR0ZXIgZnVuY3Rpb24gaGFzIGJlZW4gZGVmaW5lZCBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgICBnZXR0ZXIgPSBub29wO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkICh0YXJnZXQsIGtleSwgdXNlckRlZikge1xuICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIHZtW2tleV0gPSBtZXRob2RzW2tleV0gPT0gbnVsbCA/IG5vb3AgOiBiaW5kKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG4gIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKHZtLCBrZXksIGhhbmRsZXIpIHtcbiAgdmFyIG9wdGlvbnM7XG4gIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgb3B0aW9ucyA9IGhhbmRsZXI7XG4gICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICB9XG4gIHZtLiR3YXRjaChrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCByZXN1bHRba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICAvLyBpc0FycmF5IGhlcmVcbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5qZWN0KTtcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGlzQXJyYXlcbiAgICAgID8gaW5qZWN0XG4gICAgICA6IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpXG4gICAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGlzQXJyYXkgPyBrZXkgOiBpbmplY3Rba2V5XTtcbiAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgIHdoaWxlIChzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNvdXJjZS5fcHJvdmlkZWQgJiYgcHJvdmlkZUtleSBpbiBzb3VyY2UuX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW5cbikge1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCB7fSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG4gIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICB2YXIgX2NvbnRleHQgPSBPYmplY3QuY3JlYXRlKGNvbnRleHQpO1xuICB2YXIgaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KF9jb250ZXh0LCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcbiAgdmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgcGFyZW50OiBjb250ZXh0LFxuICAgIGxpc3RlbmVyczogZGF0YS5vbiB8fCB7fSxcbiAgICBpbmplY3Rpb25zOiByZXNvbHZlSW5qZWN0KEN0b3Iub3B0aW9ucy5pbmplY3QsIGNvbnRleHQpLFxuICAgIHNsb3RzOiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpOyB9XG4gIH0pO1xuICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHZub2RlLmZ1bmN0aW9uYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICB2bm9kZS5mdW5jdGlvbmFsT3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG4gIH1cbn1cblxuLyogICovXG5cbi8vIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoIXZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChDdG9yLCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIG5vdGhpbmcgaWYgdGhpcyBpcyBpbmRlZWQgYW4gYXN5bmMgY29tcG9uZW50XG4gICAgICAvLyB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gdHJpZ2dlciBwYXJlbnQgdXBkYXRlLlxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcbiAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzXG4gICAgZGF0YSA9IHt9O1xuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH1cbiAgKTtcbiAgcmV0dXJuIHZub2RlXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gIHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG4gIHBhcmVudEVsbSxcbiAgcmVmRWxtXG4pIHtcbiAgdmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0ge1xuICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBwcm9wc0RhdGE6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGEsXG4gICAgX2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcbiAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgIF9wYXJlbnRMaXN0ZW5lcnM6IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMsXG4gICAgX3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG4gICAgX3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG4gICAgX3JlZkVsbTogcmVmRWxtIHx8IG51bGxcbiAgfTtcbiAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgdmFyIGlubGluZVRlbXBsYXRlID0gdm5vZGUuZGF0YS5pbmxpbmVUZW1wbGF0ZTtcbiAgaWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuICBpZiAoIWRhdGEuaG9vaykge1xuICAgIGRhdGEuaG9vayA9IHt9O1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICB2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuICAgIHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgb25lKGEsIGIsIGMsIGQpO1xuICAgIHR3byhhLCBiLCBjLCBkKTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChpc0RlZihvbltldmVudF0pKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIGlzVW5kZWYoY2hpbGQubnMpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgZXh0ZW5kKHByb3BzLCBiaW5kT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzXG4pIHtcbiAgdmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuICBpZiAoQXJyYXkuaXNBcnJheShrZXlDb2RlcykpIHtcbiAgICByZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBrZXlDb2RlcyAhPT0gZXZlbnRLZXlDb2RlXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3Jcbikge1xuICB2YXIgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cbiAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgPyBjbG9uZVZOb2Rlcyh0cmVlKVxuICAgICAgOiBjbG9uZVZOb2RlKHRyZWUpXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdID1cbiAgICB0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSAoXG4gIHRyZWUsXG4gIGluZGV4LFxuICBrZXlcbikge1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyAoXG4gIHRyZWUsXG4gIGtleSxcbiAgaXNPbmNlXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgbm9kZS5rZXkgPSBrZXk7XG4gIG5vZGUuaXNPbmNlID0gaXNPbmNlO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgdm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcbiAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG4gICAgICAgICAgOiB2bS5fdm5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuICAvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG4gIC8vIGNvZGUgc2l6ZS5cbiAgVnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuICBWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSB0b1N0cmluZztcbiAgVnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSByZW5kZXJTbG90O1xuICBWdWUucHJvdG90eXBlLl9xID0gbG9vc2VFcXVhbDtcbiAgVnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcbiAgVnVlLnByb3RvdHlwZS5fbSA9IHJlbmRlclN0YXRpYztcbiAgVnVlLnByb3RvdHlwZS5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xuICBWdWUucHJvdG90eXBlLl9iID0gYmluZE9iamVjdFByb3BzO1xuICBWdWUucHJvdG90eXBlLl92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICBWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgVnVlLnByb3RvdHlwZS5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCsrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1pbml0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcbiAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgb3B0cy5yZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcbiAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIGlmIChDdG9yLnN1cGVyKSB7XG4gICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgIHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcbiAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllZE9wdGlvbnMgKEN0b3IpIHtcbiAgdmFyIG1vZGlmaWVkO1xuICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgZXh0ZW5kZWQgPSBDdG9yLmV4dGVuZE9wdGlvbnM7XG4gIHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG4gIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcbiAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICBpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cbiAgICAgIG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVkXG59XG5cbmZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG4gIC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG4gIC8vIGJldHdlZW4gbWVyZ2VzXG4gIGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgc2VhbGVkID0gQXJyYXkuaXNBcnJheShzZWFsZWQpID8gc2VhbGVkIDogW3NlYWxlZF07XG4gICAgZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gcHVzaCBvcmlnaW5hbCBvcHRpb25zIGFuZCBub3Qgc2VhbGVkIG9wdGlvbnMgdG8gZXhjbHVkZSBkdXBsaWNhdGVkIG9wdGlvbnNcbiAgICAgIGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuICAgICAgICByZXMucHVzaChsYXRlc3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxhdGVzdFxuICB9XG59XG5cbmZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlJDMpO1xuc3RhdGVNaXhpbihWdWUkMyk7XG5ldmVudHNNaXhpbihWdWUkMyk7XG5saWZlY3ljbGVNaXhpbihWdWUkMyk7XG5yZW5kZXJNaXhpbihWdWUkMyk7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcbiAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcbiAgICAgICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICBTdWIuY2lkID0gY2lkKys7XG4gICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICBTdXBlci5vcHRpb25zLFxuICAgICAgZXh0ZW5kT3B0aW9uc1xuICAgICk7XG4gICAgU3ViWydzdXBlciddID0gU3VwZXI7XG5cbiAgICAvLyBGb3IgcHJvcHMgYW5kIGNvbXB1dGVkIHByb3BlcnRpZXMsIHdlIGRlZmluZSB0aGUgcHJveHkgZ2V0dGVycyBvblxuICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgLy8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuICAgIGlmIChTdWIub3B0aW9ucy5wcm9wcykge1xuICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICB9XG4gICAgaWYgKFN1Yi5vcHRpb25zLmNvbXB1dGVkKSB7XG4gICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgIH1cblxuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcblxuICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgfSk7XG4gICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgIGlmIChuYW1lKSB7XG4gICAgICBTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuICAgIH1cblxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG5cbiAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgIHJldHVybiBTdWJcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzJDEgKENvbXApIHtcbiAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQkMSAoQ29tcCkge1xuICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gIGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAvKipcbiAgICogQ3JlYXRlIGFzc2V0IHJlZ2lzdHJhdGlvbiBtZXRob2RzLlxuICAgKi9cbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZVt0eXBlXSA9IGZ1bmN0aW9uIChcbiAgICAgIGlkLFxuICAgICAgZGVmaW5pdGlvblxuICAgICkge1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAgICAgJ2lkOiAnICsgaWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xuICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblxuICAgICAgfVxuICAgIH07XG4gIH0pO1xufVxuXG4vKiAgKi9cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi50ZXN0KG5hbWUpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGUgKGNhY2hlLCBjdXJyZW50LCBmaWx0ZXIpIHtcbiAgZm9yICh2YXIga2V5IGluIGNhY2hlKSB7XG4gICAgdmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY2FjaGVkTm9kZS5jb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcbiAgICAgICAgaWYgKGNhY2hlZE5vZGUgIT09IGN1cnJlbnQpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGVkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAodm5vZGUpIHtcbiAgaWYgKHZub2RlKSB7XG4gICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxufVxuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9LFxuXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzJDEuY2FjaGUpIHtcbiAgICAgIHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGVba2V5XSk7XG4gICAgfVxuICB9LFxuXG4gIHdhdGNoOiB7XG4gICAgaW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9LFxuICAgIGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuICAgICAgcHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIGlmIChuYW1lICYmIChcbiAgICAgICAgKHRoaXMuaW5jbHVkZSAmJiAhbWF0Y2hlcyh0aGlzLmluY2x1ZGUsIG5hbWUpKSB8fFxuICAgICAgICAodGhpcy5leGNsdWRlICYmIG1hdGNoZXModGhpcy5leGNsdWRlLCBuYW1lKSlcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAodGhpcy5jYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5jYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICB9XG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZVxuICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gIC8vIGNvbmZpZ1xuICB2YXIgY29uZmlnRGVmID0ge307XG4gIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLidcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgLy8gTk9URTogdGhlc2UgYXJlIG5vdCBjb25zaWRlcmVkIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgLSBhdm9pZCByZWx5aW5nIG9uXG4gIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gIFZ1ZS51dGlsID0ge1xuICAgIHdhcm46IHdhcm4sXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgbWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG4gICAgZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxXG4gIH07XG5cbiAgVnVlLnNldCA9IHNldDtcbiAgVnVlLmRlbGV0ZSA9IGRlbDtcbiAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9KTtcblxuICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XG4gIC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuXG4gIGluaXRVc2UoVnVlKTtcbiAgaW5pdE1peGluJDEoVnVlKTtcbiAgaW5pdEV4dGVuZChWdWUpO1xuICBpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUkMyk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG4gIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG4gIH1cbn0pO1xuXG5WdWUkMy52ZXJzaW9uID0gJzIuMy4zJztcblxuLyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG52YXIgaXNSZXNlcnZlZEF0dHIgPSBtYWtlTWFwKCdzdHlsZSxjbGFzcycpO1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0Jyk7XG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcbiAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgIChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcbiAgKVxufTtcblxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuICAnYWxsb3dmdWxsc2NyZWVuLGFzeW5jLGF1dG9mb2N1cyxhdXRvcGxheSxjaGVja2VkLGNvbXBhY3QsY29udHJvbHMsZGVjbGFyZSwnICtcbiAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICdtdXRlZCxub2hyZWYsbm9yZXNpemUsbm9zaGFkZSxub3ZhbGlkYXRlLG5vd3JhcCxvcGVuLHBhdXNlb25leGl0LHJlYWRvbmx5LCcgK1xuICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG4pO1xuXG52YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxudmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmFtZS5jaGFyQXQoNSkgPT09ICc6JyAmJiBuYW1lLnNsaWNlKDAsIDUpID09PSAneGxpbmsnXG59O1xuXG52YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnXG59O1xuXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gZmFsc2Vcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlICh2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoZGF0YSwgcGFyZW50Tm9kZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlbkNsYXNzRnJvbURhdGEoZGF0YSlcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkNsYXNzRnJvbURhdGEgKGRhdGEpIHtcbiAgdmFyIGR5bmFtaWNDbGFzcyA9IGRhdGEuY2xhc3M7XG4gIHZhciBzdGF0aWNDbGFzcyA9IGRhdGEuc3RhdGljQ2xhc3M7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKGlzVW5kZWYodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICB2YXIgcmVzID0gJyc7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGlzRGVmKHZhbHVlW2ldKSkge1xuICAgICAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZCArICcgJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgbmFtZXNwYWNlTWFwID0ge1xuICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xufTtcblxudmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG4gICdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG5cblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgdmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuICBpZiAoIWtleSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkgJiYgcmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcblxuLypcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiZcbiAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICApXG59XG5cbi8vIFNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgZHluYW1pY2FsbHkgY2hhbmdpbmcgdHlwZSBmb3IgPGlucHV0PlxuLy8gc28gdGhleSBuZWVkIHRvIGJlIHRyZWF0ZWQgYXMgZGlmZmVyZW50IG5vZGVzXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUkJDEubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmUkJDFcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGluUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgaW5QcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgIWluUHJlICYmXG4gICAgICAgICAgIXZub2RlLm5zICYmXG4gICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJiBjb25maWcuaWdub3JlZEVsZW1lbnRzLmluZGV4T2YodGFnKSA+IC0xKSAmJlxuICAgICAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHRhZylcbiAgICAgICAgKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGluUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG4gICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGk7XG4gICAgLy8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAvLyBhZ2Fpbi4gSXQncyBub3QgaWRlYWwgdG8gaW52b2x2ZSBtb2R1bGUtc3BlY2lmaWMgbG9naWMgaW4gaGVyZSBidXRcbiAgICAvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5hY3RpdmF0ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG4gICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICBpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYpIHtcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgaWYgKGlzRGVmKHJlZikpIHtcbiAgICAgICAgaWYgKHJlZi5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZChwYXJlbnQsIGVsbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcbiAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIHZub2RlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgIH1cbiAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgIGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBhcyBhIHNwZWNpYWwgY2FzZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWRcbiAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZTtcbiAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgICAgfVxuICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG4gICAgKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIGVsbVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KSA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XSA6IG51bGw7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2FtZVZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG5ld1N0YXJ0Vm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLHN0eWxlLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgIWJhaWxlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuXG5cbmZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG4gIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgaWYgKGkgPCAwKSB7XG4gICAgLy8gX2Y6IHJlc29sdmVGaWx0ZXJcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgbmFtZSArIFwiXFxcIikoXCIgKyBleHAgKyBcIixcIiArIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGUgZ2VuZXJhdGlvbiBmb3IgY29tcG9uZW50IHYtbW9kZWxcbiAqL1xuXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gKi9cblxuXG4vKipcbiAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcbiAqXG4gKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtpZHhdXG4gKiAtIHRlc3RbdGVzdDFbaWR4XV1cbiAqIC0gdGVzdFtcImFcIl1baWR4XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cbiAqXG4gKi9cblxudmFyIHN0cjtcbnZhciBpbmRleCQxO1xuXG4vKiAgKi9cblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICB2YXIgZXZlbnQ7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgLy8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXG4gICAgZXZlbnQgPSBpc0Nocm9tZSA/ICdjbGljaycgOiAnY2hhbmdlJztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlJCQxLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgaWYgKG9uY2UkJDEpIHtcbiAgICB2YXIgb2xkSGFuZGxlciA9IGhhbmRsZXI7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICBoYW5kbGVyID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IG9sZEhhbmRsZXIoZXYpXG4gICAgICAgIDogb2xkSGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmUkMihldmVudCwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuICAgICAgZWxtLl92YWx1ZSA9IGN1cjtcbiAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCB2bm9kZSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG4gIGVsbSxcbiAgdm5vZGUsXG4gIGNoZWNrVmFsXG4pIHtcbiAgcmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG4gICAgdm5vZGUudGFnID09PSAnb3B0aW9uJyB8fFxuICAgIGlzRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICBpc0lucHV0Q2hhbmdlZChlbG0sIGNoZWNrVmFsKVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXMgbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG0gJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxufVxuXG5mdW5jdGlvbiBpc0lucHV0Q2hhbmdlZCAoZWxtLCBuZXdWYWwpIHtcbiAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcbiAgaWYgKChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy5udW1iZXIpIHx8IGVsbS50eXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbClcbiAgfVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMudHJpbSkge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgfVxuICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxufVxuXG52YXIgZG9tUHJvcHMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChjaGlsZE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcbiAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICB9XG5cbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgY3NzVmFyUkUgPSAvXi0tLztcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xudmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICB9IGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxudmFyIHRlc3RFbDtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgdGVzdEVsID0gdGVzdEVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwcm9wID0gY2FtZWxpemUocHJvcCk7XG4gIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiB0ZXN0RWwuc3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgdXBwZXIgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgdXBwZXI7XG4gICAgaWYgKHByZWZpeGVkIGluIHRlc3RFbC5zdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkXG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcbiAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2xleSB3YW50c1xuICAvLyB0byBtdXRhdGUgaXQuXG4gIHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG4gICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgaWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcbiAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHN0eWxlID0ge1xuICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG59O1xuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIudHJpbSgpKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuICBpZiAoIWRlZiQkMSkge1xuICAgIHJldHVyblxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgZGVmJCQxID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMS5uYW1lIHx8ICd2JykpO1xuICAgIH1cbiAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gIH1cbn1cblxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcbiAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcbiAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIilcbiAgfVxufSk7XG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgdHJhbnNpdGlvblByb3AgPSAnV2Via2l0VHJhbnNpdGlvbic7XG4gICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICB9XG4gIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcbiAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICB9XG59XG5cbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxudmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgOiBzZXRUaW1lb3V0O1xuXG5mdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgcmFmKGZuKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICAoZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSkpLnB1c2goY2xzKTtcbiAgYWRkQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBtb2RlbCQxID0ge1xuICBpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH07XG4gICAgICBjYigpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICAgICAgc2V0VGltZW91dChjYiwgMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgZWwudHlwZSA9PT0gJ3RleHQnIHx8IGVsLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudFVwZGF0ZWQ6IGZ1bmN0aW9uIGNvbXBvbmVudFVwZGF0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcbiAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgIC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXG4gICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXG4gICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGVsLm9wdGlvbnMpO1xuICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG4gIHZhciBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG4gICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiICsgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpKSxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5vcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICBpZiAoZWwuc2VsZWN0ZWRJbmRleCAhPT0gaSkge1xuICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICBlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBvcHRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbnNbaV0pLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiAmJiAhaXNJRTkpIHtcbiAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gb3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IG9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gIG1vZGVsOiBtb2RlbCQxLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnOyB9KTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkQ2hpbGQgJiYgb2xkQ2hpbGQuZGF0YSAmJiAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkICYmIChvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICB2YXIgZiA9IGJvZHkub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2hhc01vdmUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgIGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgKSB7XG4gICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICBcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG4gICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICApO1xuICB9XG59LCAwKTtcblxuLyogICovXG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZSQzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi92dWUvZGlzdC92dWUucnVudGltZS5lc20uanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19NYXAuanMiLCJ2YXIgbWFwQ2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX21hcENhY2hlQ2xlYXInKSxcbiAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX21hcENhY2hlRGVsZXRlJyksXG4gICAgbWFwQ2FjaGVHZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZUdldCcpLFxuICAgIG1hcENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVIYXMnKSxcbiAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcENhY2hlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX01hcENhY2hlLmpzIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlR2V0LmpzIiwidmFyIGJhc2VNYXRjaGVzID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXMnKSxcbiAgICBiYXNlTWF0Y2hlc1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZU1hdGNoZXNQcm9wZXJ0eScpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBwcm9wZXJ0eSA9IHJlcXVpcmUoJy4vcHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXRlcmF0ZWU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fY2FzdFBhdGguanMiLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNLZXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faXNLZXkuanMiLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2VxLmpzIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0xlbmd0aC5qcyIsInZhciBhcnJheUxpa2VLZXlzID0gcmVxdWlyZSgnLi9fYXJyYXlMaWtlS2V5cycpLFxuICAgIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL2tleXMuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcbnZhciBidG9hID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5idG9hICYmIHdpbmRvdy5idG9hLmJpbmQod2luZG93KSkgfHwgcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J0b2EnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgbG9hZEV2ZW50ID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG4gICAgdmFyIHhEb21haW4gPSBmYWxzZTtcblxuICAgIC8vIEZvciBJRSA4LzkgQ09SUyBzdXBwb3J0XG4gICAgLy8gT25seSBzdXBwb3J0cyBQT1NUIGFuZCBHRVQgY2FsbHMgYW5kIGRvZXNuJ3QgcmV0dXJucyB0aGUgcmVzcG9uc2UgaGVhZGVycy5cbiAgICAvLyBET04nVCBkbyB0aGlzIGZvciB0ZXN0aW5nIGIvYyBYTUxIdHRwUmVxdWVzdCBpcyBtb2NrZWQsIG5vdCBYRG9tYWluUmVxdWVzdC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuICAgICAgICAhaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSB7XG4gICAgICByZXF1ZXN0ID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgbG9hZEV2ZW50ID0gJ29ubG9hZCc7XG4gICAgICB4RG9tYWluID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKCkge307XG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7fTtcbiAgICB9XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkIHx8ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0W2xvYWRFdmVudF0gPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQgJiYgIXhEb21haW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIC8vIElFIHNlbmRzIDEyMjMgaW5zdGVhZCBvZiAyMDQgKGh0dHBzOi8vZ2l0aHViLmNvbS9temFicmlza2llL2F4aW9zL2lzc3Vlcy8yMDEpXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIHZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcblxuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiBAIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVzcG9uc2UpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19TdGFjay5qcyIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYXJyYXlNYXAuanMiLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbERlZXAnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlSXNFcXVhbC5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19pc1N0cmljdENvbXBhcmFibGUuanMiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9Tb3VyY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKSxcbiAgICBzdHViRmFsc2UgPSByZXF1aXJlKCcuL3N0dWJGYWxzZScpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNCdWZmZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0J1ZmZlci5qcyIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc0Z1bmN0aW9uLmpzIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9pc1R5cGVkQXJyYXkuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4P3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0xYWQwNmQ2OFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vcmVnaXN0ZXIudnVlXCIpXG59XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9yZWdpc3Rlci52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTFhZDA2ZDY4XFxcIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3JlZ2lzdGVyLnZ1ZVwiKSxcbiAgLyogc3R5bGVzICovXG4gIGluamVjdFN0eWxlLFxuICAvKiBzY29wZUlkICovXG4gIG51bGwsXG4gIC8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xuICBudWxsXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcIi9Vc2Vycy9TZXRoL1Byb2plY3RzL2ZhbnRhc3lteDIvY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSByZWdpc3Rlci52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtMWFkMDZkNjhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi0xYWQwNmQ2OFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSc7XG5pbXBvcnQgUm91dGVyIGZyb20gJ3Z1ZS1yb3V0ZXInO1xuaW1wb3J0IGhvbWUgZnJvbSAnLi9jbGllbnQvY29tcG9uZW50cy9sZWFkZXJib2FyZC52dWUnO1xuaW1wb3J0IHJlZ2lzdGVyIGZyb20gJy4vY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlJztcbmltcG9ydCBteXRlYW0gZnJvbSAnLi9jbGllbnQvY29tcG9uZW50cy9teXRlYW0udnVlJztcblxuVnVlLnVzZShSb3V0ZXIpXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSb3V0ZXIgKCkge1xuICByZXR1cm4gbmV3IFJvdXRlcih7XG4gICAgbW9kZTogJ2hpc3RvcnknLFxuICAgIHJvdXRlczogW1xuICAgICAgeyBwYXRoOiBcIi9cIiwgY29tcG9uZW50OiBob21lIH0sXG4gICAgICB7IHBhdGg6IFwiL3JlZ2lzdGVyXCIsIGNvbXBvbmVudDogcmVnaXN0ZXIgfSxcbiAgICAgIHsgcGF0aDogXCIvbXl0ZWFtXCIsIGNvbXBvbmVudDogbXl0ZWFtIH1cbiAgICBdXG4gIH0pXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yb3V0ZXIuanMiLCJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBWdWV4IGZyb20gJ3Z1ZXgnXG5cblZ1ZS51c2UoVnVleClcblxuY29uc3Qgc3RhdGUgPSB7XG4gIHVzZXI6IHtcbiAgICB1c2VybmFtZTogJydcbiAgfSxcbiAgaXNMb2dnZWRJbjogZmFsc2UsXG4gIG1vZGFsQ29udHJvbDoge1xuICAgIHNob3dMb2dpbk1vZGFsOiBmYWxzZSxcbiAgICBzaG93UmVnaXN0ZXJNb2RhbDogZmFsc2VcbiAgfVxufVxuXG5jb25zdCBnZXR0ZXJzID0ge1xuICBnZXRVc2VyRGF0YTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzdGF0ZS51c2VyXG4gIH0sXG4gIFNob3dMb2dpbk1vZGFsOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0YXRlLm1vZGFsQ29udHJvbC5zaG93TG9naW5Nb2RhbFxuICB9LFxuICBTaG93UmVnaXN0ZXJNb2RhbDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzdGF0ZS5tb2RhbENvbnRyb2wuc2hvd1JlZ2lzdGVyTW9kYWxcbiAgfSxcbiAgR2V0QXV0aFN0YXR1czogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzdGF0ZS5pc0xvZ2dlZEluO1xuICB9XG59XG5cbmNvbnN0IG11dGF0aW9ucyA9IHtcbiAgY2hhbmdlVGVhbSAoc3RhdGUsIHJpZGVyQXJyYXkpIHtcbiAgICBzdGF0ZS51c2VyLnJpZGVycyA9IHJpZGVyQXJyYXlcbiAgfSxcbiAgc2V0TG9naW5Nb2RhbCAoc3RhdGUsIHsgc2hvdyB9KSB7XG4gICAgc3RhdGUubW9kYWxDb250cm9sLnNob3dMb2dpbk1vZGFsID0gc2hvdztcbiAgfSxcbiAgc2V0UmVnaXN0ZXJNb2RhbChzdGF0ZSwgeyBzaG93IH0pIHtcbiAgICBzdGF0ZS5tb2RhbENvbnRyb2wuc2hvd1JlZ2lzdGVyTW9kYWwgPSBzaG93XG4gIH0sXG4gIHNldFVzZXJEYXRhKHN0YXRlLCB7IHVzZXJEYXRhIH0pIHtcbiAgICBzdGF0ZS51c2VyID0gdXNlckRhdGE7XG4gIH0sXG4gIHNldExvZ2dlZEluKHN0YXRlLCB7IGxvZ2dlZEluIH0pIHtcbiAgICBzdGF0ZS5pc0xvZ2dlZEluID0gbG9nZ2VkSW47XG4gIH0sXG4gIGxvZ291dChzdGF0ZSkge1xuICAgIHN0YXRlLnVzZXIucmlkZXJzID0gW107XG4gICAgc3RhdGUudXNlciA9IHt9O1xuICAgIHN0YXRlLmlzTG9nZ2VkSW4gPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgVnVleC5TdG9yZSh7XG4gIHN0YXRlLFxuICBnZXR0ZXJzLFxuICBtdXRhdGlvbnNcbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3RvcmUvc3RvcmUuanMiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGY0ZTVkZDJcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wIS4vaW5kZXgudnVlXCIpXG59XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vaW5kZXgudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTRmNGU1ZGQyXFxcIn0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vaW5kZXgudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgaW5qZWN0U3R5bGUsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiL1VzZXJzL1NldGgvUHJvamVjdHMvZmFudGFzeW14Mi9pbmRleC52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIGluZGV4LnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi00ZjRlNWRkMlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTRmNGU1ZGQyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9pbmRleC52dWVcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBWdWUgZnJvbSAndnVlJztcbmltcG9ydCBBcHAgZnJvbSAnLi9pbmRleC52dWUnO1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyIH0gZnJvbSAnLi9yb3V0ZXInO1xuaW1wb3J0IHN0b3JlIGZyb20gJy4vc3RvcmUvc3RvcmUnO1xuXG52YXIgcm91dGVyID0gY3JlYXRlUm91dGVyKCk7XG5jb25zdCBhcHAgPSBuZXcgVnVlKHtcbiAgZWw6IFwiI2FwcFwiLFxuICByb3V0ZXIsXG4gIHN0b3JlLFxuICByZW5kZXI6IGggPT4gaChBcHApXG59KS4kbW91bnQoXCIjYXBwXCIpXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZSh1dGlscy5tZXJnZShkZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvYXhpb3MuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSB1dGlscy5tZXJnZSh7XG4gICAgICB1cmw6IGFyZ3VtZW50c1swXVxuICAgIH0sIGFyZ3VtZW50c1sxXSk7XG4gIH1cblxuICBjb25maWcgPSB1dGlscy5tZXJnZShkZWZhdWx0cywgdGhpcy5kZWZhdWx0cywgeyBtZXRob2Q6ICdnZXQnIH0sIGNvbmZpZyk7XG5cbiAgLy8gU3VwcG9ydCBiYXNlVVJMIGNvbmZpZ1xuICBpZiAoY29uZmlnLmJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwoY29uZmlnLnVybCkpIHtcbiAgICBjb25maWcudXJsID0gY29tYmluZVVSTHMoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICB9XG5cbiAgLy8gSG9vayB1cCBpbnRlcmNlcHRvcnMgbWlkZGxld2FyZVxuICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybFxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbmZ1bmN0aW9uIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKSB7XG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICBjb25maWcuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdXNpbmcgdGhlIGNvbmZpZ3VyZWQgYWRhcHRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIFRoZSBjb25maWcgdGhhdCBpcyB0byBiZSB1c2VkIGZvciB0aGUgcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2V9IFRoZSBQcm9taXNlIHRvIGJlIGZ1bGZpbGxlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpc3BhdGNoUmVxdWVzdChjb25maWcpIHtcbiAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gIC8vIEVuc3VyZSBoZWFkZXJzIGV4aXN0XG4gIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgLy8gVHJhbnNmb3JtIHJlcXVlc3QgZGF0YVxuICBjb25maWcuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgY29uZmlnLmRhdGEsXG4gICAgY29uZmlnLmhlYWRlcnMsXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcbiAgKTtcblxuICAvLyBGbGF0dGVuIGhlYWRlcnNcbiAgY29uZmlnLmhlYWRlcnMgPSB1dGlscy5tZXJnZShcbiAgICBjb25maWcuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXG4gICAgY29uZmlnLmhlYWRlcnMgfHwge31cbiAgKTtcblxuICB1dGlscy5mb3JFYWNoKFxuICAgIFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2NvbW1vbiddLFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xuICAgICAgZGVsZXRlIGNvbmZpZy5oZWFkZXJzW21ldGhvZF07XG4gICAgfVxuICApO1xuXG4gIHZhciBhZGFwdGVyID0gY29uZmlnLmFkYXB0ZXIgfHwgZGVmYXVsdHMuYWRhcHRlcjtcblxuICByZXR1cm4gYWRhcHRlcihjb25maWcpLnRoZW4oZnVuY3Rpb24gb25BZGFwdGVyUmVzb2x1dGlvbihyZXNwb25zZSkge1xuICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgcmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiBAIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgcmV0dXJuIGVycm9yO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvYnRvYS5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9XG5cbiAgICAgIGlmICghdXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKVxuKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgIH1cblxuICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgfTtcbiAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfSkoKVxuKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG4gIC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcbiAgLy8gcmVwcmVzZW50IG9uZSBieXRlXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuICAvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG4gIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbiAgcmV0dXJuIGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycihsZW4gKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vYmFzZTY0LWpzL2luZGV4LmpzIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9idWZmZXIvaW5kZXguanMiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vaWVlZTc1NC9pbmRleC5qcyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9pc2FycmF5L2luZGV4LmpzIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhVmlldztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19EYXRhVmlldy5qcyIsInZhciBoYXNoQ2xlYXIgPSByZXF1aXJlKCcuL19oYXNoQ2xlYXInKSxcbiAgICBoYXNoRGVsZXRlID0gcmVxdWlyZSgnLi9faGFzaERlbGV0ZScpLFxuICAgIGhhc2hHZXQgPSByZXF1aXJlKCcuL19oYXNoR2V0JyksXG4gICAgaGFzaEhhcyA9IHJlcXVpcmUoJy4vX2hhc2hIYXMnKSxcbiAgICBoYXNoU2V0ID0gcmVxdWlyZSgnLi9faGFzaFNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX0hhc2guanMiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX1Byb21pc2UuanMiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX1NldC5qcyIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX1NldENhY2hlLmpzIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19VaW50OEFycmF5LmpzIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19XZWFrTWFwLmpzIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2FwcGx5LmpzIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19hcnJheVNvbWUuanMiLCJ2YXIgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBjcmVhdGVCYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2NyZWF0ZUJhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VFYWNoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VFYWNoLmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlRmluZEluZGV4LmpzIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzRmxhdHRlbmFibGUgPSByZXF1aXJlKCcuL19pc0ZsYXR0ZW5hYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yT3duO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUdldEFsbEtleXMuanMiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzSW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUhhc0luLmpzIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNBcmd1bWVudHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUlzQXJndW1lbnRzLmpzIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VJc0VxdWFsRGVlcC5qcyIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZUlzVHlwZWRBcnJheS5qcyIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VLZXlzLmpzIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWFwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VNYXAuanMiLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZU1hdGNoZXMuanMiLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VNYXAgPSByZXF1aXJlKCcuL19iYXNlTWFwJyksXG4gICAgYmFzZVNvcnRCeSA9IHJlcXVpcmUoJy4vX2Jhc2VTb3J0QnknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBjb21wYXJlTXVsdGlwbGUgPSByZXF1aXJlKCcuL19jb21wYXJlTXVsdGlwbGUnKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcy5sZW5ndGggPyBpdGVyYXRlZXMgOiBbaWRlbnRpdHldLCBiYXNlVW5hcnkoYmFzZUl0ZXJhdGVlKSk7XG5cbiAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gIH0pO1xuXG4gIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU9yZGVyQnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZU9yZGVyQnkuanMiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlUHJvcGVydHkuanMiLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlUHJvcGVydHlEZWVwLmpzIiwidmFyIGJhc2VVbnNldCA9IHJlcXVpcmUoJy4vX2Jhc2VVbnNldCcpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICogaW5kZXhlcyBvciBjYXB0dXJpbmcgdGhlIHJlbW92ZWQgZWxlbWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgIGlmIChsZW5ndGggPT0gbGFzdEluZGV4IHx8IGluZGV4ICE9PSBwcmV2aW91cykge1xuICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICBpZiAoaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGluZGV4LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VVbnNldChhcnJheSwgaW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVB1bGxBdDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlUHVsbEF0LmpzIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VSZXN0LmpzIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2xpY2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVNsaWNlLmpzIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU29ydEJ5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VTb3J0QnkuanMiLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19iYXNlVGltZXMuanMiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwidmFyIGNhc3RQYXRoID0gcmVxdWlyZSgnLi9fY2FzdFBhdGgnKSxcbiAgICBsYXN0ID0gcmVxdWlyZSgnLi9sYXN0JyksXG4gICAgcGFyZW50ID0gcmVxdWlyZSgnLi9fcGFyZW50JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwcm9wZXJ0eSBwYXRoIHRvIHVuc2V0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuc2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2Jhc2VVbnNldC5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhY2hlSGFzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2NhY2hlSGFzLmpzIiwidmFyIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKipcbiAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZUFzY2VuZGluZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19jb21wYXJlQXNjZW5kaW5nLmpzIiwidmFyIGNvbXBhcmVBc2NlbmRpbmcgPSByZXF1aXJlKCcuL19jb21wYXJlQXNjZW5kaW5nJyk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZU11bHRpcGxlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2NvbXBhcmVNdWx0aXBsZS5qcyIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRWFjaDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19jcmVhdGVCYXNlRWFjaC5qcyIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lUHJvcGVydHk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZXF1YWxCeVRhZy5qcyIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZXF1YWxPYmplY3RzLmpzIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19nZXRUYWcuanMiLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19nZXRWYWx1ZS5qcyIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX2hhc1BhdGguanMiLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19oYXNoQ2xlYXIuanMiLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faGFzaERlbGV0ZS5qcyIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faGFzaEdldC5qcyIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faGFzaEhhcy5qcyIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19oYXNoU2V0LmpzIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19pc0ZsYXR0ZW5hYmxlLmpzIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIHZhbHVlIGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBpbmRleCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIGluZGV4IG9yIGtleSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcmd1bWVudHMgYXJlIGZyb20gYW4gaXRlcmF0ZWUgY2FsbCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiBpbmRleDtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgICAgOiAodHlwZSA9PSAnc3RyaW5nJyAmJiBpbmRleCBpbiBvYmplY3QpXG4gICAgICApIHtcbiAgICByZXR1cm4gZXEob2JqZWN0W2luZGV4XSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0l0ZXJhdGVlQ2FsbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faXNLZXlhYmxlLmpzIiwidmFyIGNvcmVKc0RhdGEgPSByZXF1aXJlKCcuL19jb3JlSnNEYXRhJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXNrZWQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faXNNYXNrZWQuanMiLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNQcm90b3R5cGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCIvKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlQ2xlYXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVEZWxldGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlRGVsZXRlLmpzIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVTZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbGlzdENhY2hlU2V0LmpzIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVEZWxldGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlR2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVIYXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlU2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwiLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBUb0FycmF5O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX25hdGl2ZUtleXMuanMiLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX25vZGVVdGlsLmpzIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX292ZXJBcmcuanMiLCJ2YXIgYXBwbHkgPSByZXF1aXJlKCcuL19hcHBseScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggdHJhbnNmb3JtcyB0aGUgcmVzdCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICBzdGFydCA9IG5hdGl2ZU1heChzdGFydCA9PT0gdW5kZWZpbmVkID8gKGZ1bmMubGVuZ3RoIC0gMSkgOiBzdGFydCwgMCk7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3MubGVuZ3RoIC0gc3RhcnQsIDApLFxuICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gYXJnc1tzdGFydCArIGluZGV4XTtcbiAgICB9XG4gICAgaW5kZXggPSAtMTtcbiAgICB2YXIgb3RoZXJBcmdzID0gQXJyYXkoc3RhcnQgKyAxKTtcbiAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgfVxuICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG92ZXJSZXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX292ZXJSZXN0LmpzIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNsaWNlID0gcmVxdWlyZSgnLi9fYmFzZVNsaWNlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCB0byBnZXQgdGhlIHBhcmVudCB2YWx1ZSBvZi5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwYXJlbnQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubGVuZ3RoIDwgMiA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBiYXNlU2xpY2UocGF0aCwgMCwgLTEpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fcGFyZW50LmpzIiwiLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVBZGQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0Q2FjaGVIYXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fc2V0Q2FjaGVIYXMuanMiLCIvKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvQXJyYXk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fc2V0VG9BcnJheS5qcyIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fc2V0VG9TdHJpbmcuanMiLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fc2hvcnRPdXQuanMiLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19zdGFja0NsZWFyLmpzIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL19zdGFja0hhcy5qcyIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHJlTGVhZGluZ0RvdC50ZXN0KHN0cmluZykpIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9jb25zdGFudC5qcyIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vdG9JbnRlZ2VyJyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gMVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gMlxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEluZGV4O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvZmluZEluZGV4LmpzIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9nZXQuanMiLCJ2YXIgYmFzZUhhc0luID0gcmVxdWlyZSgnLi9fYmFzZUhhc0luJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0luO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvaGFzSW4uanMiLCIvKipcbiAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsYXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvbGFzdC5qcyIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvbWVtb2l6ZS5qcyIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHknKSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5RGVlcCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0eTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL3Byb3BlcnR5LmpzIiwidmFyIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VQdWxsQXQgPSByZXF1aXJlKCcuL19iYXNlUHVsbEF0Jyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSBgYXJyYXlgIHRoYXQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yXG4gKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVtb3ZlZCBlbGVtZW50cy4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkXG4gKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8uZmlsdGVyYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLiBVc2UgYF8ucHVsbGBcbiAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZW1vdmVkIGVsZW1lbnRzLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXkgPSBbMSwgMiwgMywgNF07XG4gKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAqIH0pO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAqIC8vID0+IFsxLCAzXVxuICpcbiAqIGNvbnNvbGUubG9nKGV2ZW5zKTtcbiAqIC8vID0+IFsyLCA0XVxuICovXG5mdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5kZXhlcyA9IFtdLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICBpbmRleGVzLnB1c2goaW5kZXgpO1xuICAgIH1cbiAgfVxuICBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZW1vdmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9yZW1vdmUuanMiLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpLFxuICAgIGJhc2VPcmRlckJ5ID0gcmVxdWlyZSgnLi9fYmFzZU9yZGVyQnknKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNJdGVyYXRlZUNhbGwgPSByZXF1aXJlKCcuL19pc0l0ZXJhdGVlQ2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAqIF07XG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdLCBbJ2ZyZWQnLCA0OF1dXG4gKi9cbnZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW107XG4gIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICB9XG4gIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0Qnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9zb3J0QnkuanMiLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vbG9kYXNoL3N0dWJBcnJheS5qcyIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC9zdHViRmFsc2UuanMiLCJ2YXIgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRmluaXRlO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvdG9GaW5pdGUuanMiLCJ2YXIgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMuMik7XG4gKiAvLyA9PiAzXG4gKlxuICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiAwXG4gKlxuICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9JbnRlZ2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2xvZGFzaC90b051bWJlci5qcyIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9sb2Rhc2gvdG9TdHJpbmcuanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCI8dGVtcGxhdGU+XG4gIDxkaXY+XG4gIDxkaXYgY2xhc3M9XCJsZWFkZXJib2FyZC10aXRsZVwiPlxuICAgIDIwMTggRmFudGFzeVNYIE1haW4gTGVhZ3VlXG4gIDwvZGl2PlxuICA8ZGl2IGNsYXNzPVwiY29sdW1ucyBsZWFkZXJib2FyZFwiPlxuICAgIDxkaXYgY2xhc3M9XCJjb2x1bW4gaXMtaGFsZiBpcy1vZmZzZXQtb25lLXF1YXJ0ZXJcIj5cbiAgICAgIDx0YWJsZSBjbGFzcz1cInRhYmxlIGlzLXN0cmlwZWRcIiB2LWlmPVwiZG9uZUxvYWRpbmdcIj5cbiAgICAgICAgPHRoZWFkPlxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgIDx0aD5Qb3NpdGlvbjwvdGg+XG4gICAgICAgICAgICA8dGg+VG90YWwgUG9pbnRzPC90aD5cbiAgICAgICAgICAgIDx0aD5Vc2VybmFtZTwvdGg+XG4gICAgICAgICAgICA8dGg+UG9pbnRzIEJhY2s8L3RoPlxuICAgICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGhlYWQ+XG4gICAgICAgIDx0Zm9vdD5cbiAgICAgICAgICA8dHI+XG4gICAgICAgICAgICA8dGg+UG9zaXRpb248L3RoPlxuICAgICAgICAgICAgPHRoPlRvdGFsIFBvaW50czwvdGg+XG4gICAgICAgICAgICA8dGg+VXNlcm5hbWU8L3RoPlxuICAgICAgICAgICAgPHRoPlBvaW50cyBCYWNrPC90aD5cbiAgICAgICAgICA8L3RyPlxuICAgICAgICA8L3Rmb290PlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgPHRyIHYtZm9yPVwiKHVzZXIsIGluZGV4KSBpbiBzdGFuZGluZ3NcIj5cbiAgICAgICAgICAgIDx0ZD57eyBpbmRleCArIDEgfX0uPC90ZD5cbiAgICAgICAgICAgIDx0ZD57e3VzZXIudG90YWxwb2ludHN9fTwvdGQ+XG4gICAgICAgICAgICA8dGQ+e3t1c2VyLndlZWtseXRlYW1zWzBdLnVzZXJuYW1lfX08L3RkPlxuICAgICAgICAgICAgPHRkIGNsYXNzPVwicG9pbnRzYmFja1wiPnt7IHBvaW50c2JlaGluZCh1c2VyKSB9fTwvdGQ+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgICA8ZGl2IHYtaWY9XCIhZG9uZUxvYWRpbmdcIj5cbiAgICAgICAgPHA+XCJUaGlzIGRhdGEgZG9lc24ndCBmZXRjaCBpdHNlbGYuLiBMb2FkaW5nIFJhY2UgVHJhY2tlci5cIjwvcD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuPC90ZW1wbGF0ZT5cbjxzY3JpcHQ+XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuICBleHBvcnQgZGVmYXVsdCB7XG4gICAgZGF0YSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmVMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgcmVzdWx0czogW10sXG4gICAgICAgIG1haW5MZWFndWVVc2VyczogW10sXG4gICAgICAgIHdlZWtseXRlYW1zOiBbXVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIHN0YW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW5MZWFndWVVc2Vycy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgdmFyIGFQb2ludHMgPSAwO1xuICAgICAgICAgIHZhciBiUG9pbnRzID0gMDtcbiAgICAgICAgICBhLndlZWtseXRlYW1zLmZvckVhY2godGVhbSA9PiB7IGFQb2ludHMgKz0gdGVhbS5wbGFjZSB9KVxuICAgICAgICAgIGIud2Vla2x5dGVhbXMuZm9yRWFjaCh0ZWFtID0+IHsgYlBvaW50cyArPSB0ZWFtLnBsYWNlIH0pXG4gICAgICAgICAgcmV0dXJuIGFQb2ludHMgLSBiUG9pbnRzO1xuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIG5ld3N0YW5kaW5nczogZnVuY3Rpb24oKSB7XG5cbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZWQoKSB7XG4gICAgICBheGlvcy5nZXQoJy9NYWluTGVhZ3VlU3RhbmRpbmdzJylcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICB0aGlzLm1haW5MZWFndWVVc2VycyA9IGRhdGEuZGF0YTtcbiAgICAgICAgdGhpcy5tYWluTGVhZ3VlVXNlcnMuZm9yRWFjaCgodXNlcikgPT4ge1xuICAgICAgICAgIHVzZXIudG90YWxwb2ludHMgPSAwXG4gICAgICAgICAgdXNlci53ZWVrbHl0ZWFtcy5mb3JFYWNoKHd0ID0+IHsgdXNlci50b3RhbHBvaW50cyArPSB3dC5wbGFjZSB9KVxuICAgICAgICAgIHVzZXIud2Vla2x5dGVhbXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuZG9uZUxvYWRpbmcgPSB0cnVlO1xuICAgICAgfSlcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgIHBvaW50c2JlaGluZDogZnVuY3Rpb24odXNlcikge1xuICAgICAgICB2YXIgb2JqSW5kZXggPSB0aGlzLnN0YW5kaW5ncy5pbmRleE9mKHVzZXIpO1xuICAgICAgICBpZiAob2JqSW5kZXggIT0gMCkge1xuICAgICAgICAgIHJldHVybiB1c2VyLnRvdGFscG9pbnRzIC0gdGhpcy5zdGFuZGluZ3NbMF0udG90YWxwb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICctJ1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBiZWZvcmVDcmVhdGUoKSB7XG4gICAgLy8gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgLy8gICAgICBheGlvcy5nZXQoJy9SYWNlUmVzdWx0cycpXG4gICAgLy8gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAvLyAgICAgICAgY29uc29sZS50aW1lKCk7XG4gICAgLy8gICAgICAgIHZhciByZXN1bHRzID0gZGF0YS5kYXRhLkI7XG4gICAgLy8gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xuICAgIC8vICAgICAgICB0aGlzLm1haW5MZWFndWVVc2Vycy5mb3JFYWNoKHVzZXIgPT4ge1xuICAgIC8vICAgICAgICAgIHVzZXIudG90YWxwb2ludHMgPSAwO1xuICAgIC8vICAgICAgICAgIHVzZXIucmlkZXJzLmZvckVhY2gocmlkZXIgPT4ge1xuICAgIC8vICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKHJlc3VsdCA9PiB7XG4gICAgLy8gICAgICAgICAgICAgIGlmIChyZXN1bHQuRi5zbGljZSgwLCAtMSkgPT0gcmlkZXIubmFtZSkge1xuICAgIC8vICAgICAgICAgICAgICAgIHJpZGVyLnBvaW50cyA9IHJlc3VsdC5BO1xuICAgIC8vICAgICAgICAgICAgICB9XG4gICAgLy8gICAgICAgICAgICB9KVxuICAgIC8vICAgICAgICAgICAgdXNlci50b3RhbHBvaW50cyArPSByaWRlci5wb2ludHM7XG4gICAgLy8gICAgICAgICAgfSlcbiAgICAvLyAgICAgICAgfSlcbiAgICAvLyAgICAgICBjb25zb2xlLnRpbWVFbmQoKTtcbiAgICAvLyAgICAgICB0aGlzLmRvbmVMb2FkaW5nID0gdHJ1ZTtcbiAgICAvLyAgICAgICBjb25zb2xlLmxvZyh0aGlzLm1haW5MZWFndWVVc2VycylcbiAgICAvLyAgICAgfSlcbiAgICAvLyAgICB9LCAzMDAwKTtcbiAgICAvLyAgIGF4aW9zLmdldCgnL2dldE1haW5MZWFndWVJbmZvJylcbiAgICAvLyAgIC50aGVuKGRhdGEgPT4ge1xuICAgIC8vICAgICBjb25zb2xlLmxvZyhkYXRhLmRhdGEpO1xuICAgIC8vICAgICBkYXRhLmRhdGEuZm9yRWFjaCh1c2VyID0+IHtcbiAgICAvLyAgICAgICB0aGlzLm1haW5MZWFndWVVc2Vycy5wdXNoKHVzZXIpXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICB9KVxuICAgIC8vIH1cbiAgfVxuPC9zY3JpcHQ+XG48c3R5bGU+XG4gIC5wb2ludHNiYWNrOiB7XG4gICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcbiAgICBjb2xvcjogI2ZmMzg2MDtcbiAgfVxuICAubGVhZGVyYm9hcmQge1xuICAgIG1hcmdpbi10b3A6IDUwcHg7XG4gIH1cbiAgdGFibGUgdGQsIHRoIHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXIgIWltcG9ydGFudDtcbiAgfVxuICAubGVhZGVyYm9hcmQtbWFpbiB7XG4gICAgbWFyZ2luLXRvcDogMjVweDtcbiAgfVxuICAubGVhZGVyYm9hcmQtdGl0bGUge1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgICBmb250LXdlaWdodDogNzAwO1xuICB9XG48L3N0eWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxlYWRlcmJvYXJkLnZ1ZT84YTM2NWI4NCIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1vZGFsXCIgdi1iaW5kOmNsYXNzPVwieydpcy1hY3RpdmUnOiBzaG93fVwiIGlkPVwibG9naW5Nb2RhbFwiPlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1iYWNrZ3JvdW5kXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNhcmRcIj5cbiAgICAgIDxoZWFkZXIgY2xhc3M9XCJtb2RhbC1jYXJkLWhlYWRcIj5cbiAgICAgICAgPHAgY2xhc3M9XCJtb2RhbC1jYXJkLXRpdGxlXCI+VXNlciBMb2dpbjwvcD5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImRlbGV0ZVwiIEBjbGljaz1cInNldExvZ2luTW9kYWwoeyBzaG93OiAhU2hvd0xvZ2luTW9kYWwgfSlcIj48L2J1dHRvbj5cbiAgICAgIDwvaGVhZGVyPlxuICAgICAgPHNlY3Rpb24gY2xhc3M9XCJtb2RhbC1jYXJkLWJvZHlcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XCJyZWctdXNlcm5hbWVcIiBjbGFzcz1cImxhYmVsXCI+VXNlcm5hbWU6IDwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbFwiPlxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImlucHV0XCIgdi1tb2RlbD1cInVzZXJuYW1lXCIvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgICA8bGFiZWwgZm9yPVwicmVnLXBhc3N3b3JkXCIgY2xhc3M9XCJsYWJlbFwiPlBhc3N3b3JkOiA8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2xcIj5cbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiIGNsYXNzPVwiaW5wdXRcIiBpZD1cInJlZy1wYXNzd29yZFwiIHYtbW9kZWw9XCJwYXNzd29yZFwiLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvc2VjdGlvbj5cbiAgICAgIDxmb290ZXIgY2xhc3M9XCJtb2RhbC1jYXJkLWZvb3RcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBpcy1wcmltYXJ5XCIgdi1iaW5kOmNsYXNzPVwieyAnaXMtbG9hZGluZyc6IGlzTG9hZGluZyB9XCIgdi1vbjpjbGljaz1cInN1Ym1pdFwiIHR5cGU9XCJidXR0b25cIiB2YWx1ZT1cIkxvZ2luXCIgaWQ9XCJzdWJtaXQtbG9naW5cIj5Mb2dpbjwvYnV0dG9uPlxuICAgICAgICAgIDxhIGNsYXNzPVwiYnV0dG9uXCIgQGNsaWNrPVwic2V0TG9naW5Nb2RhbCh7IHNob3c6ICFTaG93TG9naW5Nb2RhbCB9KVwiPkNhbmNlbDwvYT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Zvb3Rlcj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5cbiAgPC90ZW1wbGF0ZT5cbiAgPHNjcmlwdD5cbiAgaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbiAgaW1wb3J0IHsgbWFwTXV0YXRpb25zLCBtYXBHZXR0ZXJzIH0gZnJvbSAndnVleCc7XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdXNlcm5hbWU6ICcnLFxuICAgICAgICAgIHBhc3N3b3JkOiAnJyxcbiAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb21wdXRlZDogbWFwR2V0dGVycyhbXG4gICAgICAgICdTaG93TG9naW5Nb2RhbCdcbiAgICAgIF0pLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc2hvdzoge1xuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIC4uLm1hcE11dGF0aW9ucyhbXG4gICAgICAgICAgJ3NldExvZ2luTW9kYWwnLFxuICAgICAgICAgICdzZXRVc2VyRGF0YScsXG4gICAgICAgICAgJ3NldExvZ2dlZEluJ1xuICAgICAgICBdKSxcbiAgICAgICAgc3VibWl0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICBheGlvcy5wb3N0KCcvbG9naW4nLCB7XG4gICAgICAgICAgICB1c2VybmFtZTogdGhpcy51c2VybmFtZSxcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLnBhc3N3b3JkXG4gICAgICAgICAgfSkudGhlbihkYXRhID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNldFVzZXJEYXRhKHsgdXNlckRhdGE6IGRhdGEuZGF0YSB9KVxuICAgICAgICAgICAgdGhpcy5zZXRMb2dnZWRJbih7IGxvZ2dlZEluOiB0cnVlIH0pXG4gICAgICAgICAgICB0aGlzLnNldExvZ2luTW9kYWwoeyBzaG93OiBmYWxzZSB9KVxuICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2dpbiBlcnJvcjogXCIsIGVycilcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gIH1cbjwvc2NyaXB0PlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxvZ2luLnZ1ZT85MzVkZDZkNCIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICA8ZGl2IGNsYXNzPVwicGFnZS10aXRsZVwiPk1ZIFRFQU0gLSBURUFNIFNFTEVDVElPTiBGT1IgV0VFSyB7eyBjdXJyZW50d2VlayB9fTwvZGl2PlxuICAgIDxhIGNsYXNzPVwiYnV0dG9uIGlzLXN1Y2Nlc3Mgc2F2ZS1idXR0b25cIiBAY2xpY2s9XCJTYXZlVGVhbVwiPlNhdmUgVGVhbTwvYT5cbiAgICA8cCBjbGFzcz1cInBhZ2Utc3ViaGVhZGVyXCI+V2VlayB7eyBjdXJyZW50d2VlayB9fSBCYWxhbmNlOiAke3tkb2xsYXJzfX08L3A+XG4gICAgPCEtLSA8ZGl2IGNsYXNzPVwicmlkZXJzLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzcz1cImNhcmQgcmlkZXItYmxvY2tcIiB2LWZvcj1cInJpZGVyIGluIHNlbGVjdGVkcmlkZXJzXCI+XG4gICAgICAgIDxoZWFkZXIgY2xhc3M9XCJjYXJkLWhlYWRlclwiPlxuICAgICAgICAgIDxwIGNsYXNzPVwiY2FyZC1oZWFkZXItdGl0bGVcIj5cbiAgICAgICAgICAgIHt7cmlkZXIubmFtZX19IC0ge3tyaWRlci5yaWRlcl9udW1iZXJ9fVxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25cIiB2LWlmPVwicmlkZXIubmFtZSAhPT0gJ09QRU4gU0xPVCdcIiBAY2xpY2s9XCJyZW1vdmVSYWNlcihyaWRlcilcIj5cbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXRpbWVzXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L2hlYWRlcj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNhcmQtY29udGVudFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICA8aW1nIDpzcmM9XCJyaWRlci5hdmF0YXJfdXJsXCIgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxmb290ZXIgY2xhc3M9XCJjYXJkLWZvb3RlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb290ZXItcm93XCI+XG4gICAgICAgICAgICBDb3N0OiA8c3Bhbj4ke3tyaWRlci5jb3N0fX08L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZvb3Rlci1yb3dcIj5cbiAgICAgICAgICAgIEF2ZyBGaW5pc2g6IDxzcGFuPnt7cmlkZXIuYXZlcmFnZUZpbmlzaH19PC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb290ZXItcm93XCI+XG4gICAgICAgICAgICBIaWdoZXN0IEZpbmlzaDogPHNwYW4+e3tyaWRlci5oaWdoZXN0RmluaXNofX08L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZvb3Rlci1yb3dcIj5cbiAgICAgICAgICAgIExvd2VzdCBGaW5pc2g6IDxzcGFuPnt7cmlkZXIubG93ZXN0RmluaXNofX08L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZm9vdGVyPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPHAgY2xhc3M9XCJwYWdlLXRpdGxlXCI+QVZBSUxBQkxFIFJJREVSUzwvcD4gLS0+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGUgaXMtc3RyaXBlZFwiPlxuICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgPHRyPlxuICAgICAgICAgICAgPHRoIEBjbGljaz1cInNvcnRCeVByaWNlXCI+UHJpY2VcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCI+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1jYXJldC11cFwiIHYtaWY9XCJDb3N0U29ydEJ5QXNjXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtY2FyZXQtZG93blwiIHYtZWxzZSBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICA8dGg+UmFjZXIgTmFtZTwvdGg+XG4gICAgICAgICAgICA8dGg+UmFjZXIgTnVtYmVyPC90aD5cbiAgICAgICAgICAgIDx0aD5IaWdoZXN0IEZpbmlzaDwvdGg+XG4gICAgICAgICAgICA8dGg+TG93ZXN0IEZpbmlzaDwvdGg+XG4gICAgICAgICAgICA8dGg+QXZlcmFnZSBGaW5pc2g8L3RoPlxuICAgICAgICAgICAgPHRoPkFjdGlvbjwvdGg+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgPC90aGVhZD5cbiAgICAgICAgPHRmb290PlxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgIDx0aD5QcmljZTwvdGg+XG4gICAgICAgICAgICA8dGg+UmFjZXIgTmFtZTwvdGg+XG4gICAgICAgICAgICA8dGg+UmFjZXIgTnVtYmVyPC90aD5cbiAgICAgICAgICAgIDx0aD5IaWdoZXN0IEZpbmlzaDwvdGg+XG4gICAgICAgICAgICA8dGg+TG93ZXN0IEZpbmlzaDwvdGg+XG4gICAgICAgICAgICA8dGg+QXZlcmFnZSBGaW5pc2g8L3RoPlxuICAgICAgICAgICAgPHRoPkFjdGlvbjwvdGg+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgPC90Zm9vdD5cbiAgICAgICAgPHRib2R5PlxuICAgICAgICAgIDx0ciB2LWZvcj1cInJpZGVyIGluIHBhZ2luYXRlZFJpZGVyc1wiPlxuICAgICAgICAgICAgPHRkPiR7e3JpZGVyLmNvc3R9fTwvdGQ+XG4gICAgICAgICAgICA8dGQ+e3tyaWRlci5uYW1lfX08L3RkPlxuICAgICAgICAgICAgPHRkPnt7cmlkZXIucmlkZXJfbnVtYmVyfX08L3RkPlxuICAgICAgICAgICAgPHRkPnt7cmlkZXIuaGlnaGVzdEZpbmlzaH19PC90ZD5cbiAgICAgICAgICAgIDx0ZD57e3JpZGVyLmxvd2VzdEZpbmlzaH19PC90ZD5cbiAgICAgICAgICAgIDx0ZD57e3JpZGVyLmF2ZXJhZ2VGaW5pc2h9fTwvdGQ+XG4gICAgICAgICAgICA8dGQ+PGEgaHJlZj1cIiMhXCIgdi1pZj1cInNob3dTZWxlY3QgJiYgcmlkZXIuY29zdCA8PSBkb2xsYXJzXCIgQGNsaWNrPVwiYWRkUmFjZXIocmlkZXIpXCI+U0VMRUNUPC9hPjwvdGQ+XG4gICAgICAgICAgPC90cj5cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgICA8ZGl2IGNsYXNzPVwiY3VzdG9tLXBhZ2luYXRpb25cIj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8YSBjbGFzcz1cInBhZ2luYXRpb24tcHJldmlvdXNcIiBAY2xpY2s9XCJwYWdlLS1cIiB2LWJpbmQ6Y2xhc3M9XCJ7ICdoaWRlLXBhZ2luYXRpb24tYnV0dG9uJyA6IGhpZGVQcmV2aW91cyB9XCI+UHJldmlvdXM8L2E+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxhIGNsYXNzPVwicGFnaW5hdGlvbi1udW1iZXJcIj57e3BhZ2V9fS97e3BhZ2luYXRpb25QYWdlc319PC9hPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8YSBjbGFzcz1cInBhZ2luYXRpb24tbmV4dFwiIEBjbGljaz1cInBhZ2UrK1wiIHYtYmluZDpjbGFzcz1cInsgJ2hpZGUtcGFnaW5hdGlvbi1idXR0b24nIDogaGlkZU5leHQgfVwiPk5leHQgcGFnZTwvYT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IG1hcEdldHRlcnMgfSBmcm9tICd2dWV4JztcbmltcG9ydCBfZmluZEluZGV4IGZyb20gJ2xvZGFzaC9maW5kSW5kZXgnO1xuaW1wb3J0IF9zb3J0QnkgZnJvbSAnbG9kYXNoL3NvcnRCeSc7XG5pbXBvcnQgX3JlbW92ZSBmcm9tICdsb2Rhc2gvcmVtb3ZlJztcbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIGRhdGEoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50d2VlazogMCxcbiAgICAgICAgc2VsZWN0ZWRyaWRlcnM6IFtdLFxuICAgICAgICBhdmFpbGFibGVSaWRlcnM6IFtdLFxuICAgICAgICBDb3N0U29ydEJ5QXNjOiB0cnVlLFxuICAgICAgICBwYWdlOiAxXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgLi4ubWFwR2V0dGVycyhbXG4gICAgICAgICdnZXRVc2VyRGF0YSdcbiAgICAgIF0pLFxuICAgICAgZG9sbGFycygpIHtcbiAgICAgICAgdmFyIHRvdGFsID0gODtcbiAgICAgICAgdGhpcy5zZWxlY3RlZHJpZGVycy5mb3JFYWNoKHJpZGVyID0+IHtcbiAgICAgICAgICB0b3RhbCAtPSByaWRlci5jb3N0O1xuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICB9LFxuICAgICAgaGlkZVByZXZpb3VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlIDw9IDE7XG4gICAgICB9LFxuICAgICAgaGlkZU5leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2UgPj0gdGhpcy5wYWdpbmF0aW9uUGFnZXM7XG4gICAgICB9LFxuICAgICAgcGFnaW5hdGVkUmlkZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5wYWdlID09IDEpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcImVudGlyZSBhcnJheVwiLCB0aGlzLmF2YWlsYWJsZVJpZGVycylcbiAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmF2YWlsYWJsZVJpZGVycy5zbGljZSgwLCAxMCkpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZVJpZGVycy5zbGljZSgwLCAxMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGJlZ2luU2xpY2UgPSB0aGlzLnBhZ2UgKiAxMCAtIDk7XG4gICAgICAgICAgdmFyIGVuZFNsaWNlID0gYmVnaW5TbGljZSArIDEwO1xuICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYXZhaWxhYmxlUmlkZXJzKVxuICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYXZhaWxhYmxlUmlkZXJzLnNsaWNlKGJlZ2luU2xpY2UsIGVuZFNsaWNlKSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdmFpbGFibGVSaWRlcnMuc2xpY2UoYmVnaW5TbGljZSwgZW5kU2xpY2UpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFnaW5hdGlvblBhZ2VzKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYXZhaWxhYmxlUmlkZXJzLmxlbmd0aCAvIDEwKTtcbiAgICAgIH0sXG4gICAgICBzaG93U2VsZWN0KCkge1xuICAgICAgICB2YXIgb3BlblNsb3RzID0gdGhpcy5zZWxlY3RlZHJpZGVycy5zb21lKChyaWRlcikgPT4ge3JldHVybiByaWRlci5uYW1lID09IFwiT1BFTiBTTE9UXCJ9KTtcbiAgICAgICAgdmFyIGxvd2VzdENvc3RBdmFpbGFibGUgPSBfc29ydEJ5KHRoaXMuYXZhaWxhYmxlUmlkZXJzLCBvID0+IHsgcmV0dXJuIG8uY29zdCB9KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJzaG93U2VsZWN0XCIsIGxvd2VzdENvc3RBdmFpbGFibGVbMF0pXG4gICAgICAgIGlmICgodGhpcy5kb2xsYXJzID49IGxvd2VzdENvc3RBdmFpbGFibGVbMF0uY29zdCkgJiYgb3BlblNsb3RzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgcmVtb3ZlUmFjZXIocmFjZXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJyZW1vdmVkIHJhY2Vyc1wiLCByYWNlcik7XG4gICAgICAgIHZhciBzZWxlY3RlZFJhY2VySW5kZXggPSBfZmluZEluZGV4KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIG8gPT4geyByZXR1cm4gby5yaWRlcmlkID09PSByYWNlci5yaWRlcmlkIH0pO1xuICAgICAgICB2YXIgb3BlblNwYWNlID0ge1xuICAgICAgICAgIGF2YXRhcl91cmw6ICdodHRwOi8vd3d3LnNob3BhYXJkdmFyay5jb20vbWVkaWEvY2F0YWxvZy9wcm9kdWN0L1cvUy9XUy0xODY1NS5qcGcnLFxuICAgICAgICAgIGNvc3Q6IDAsXG4gICAgICAgICAgaGlnaGVzdEZpbmlzaDogJy0nLFxuICAgICAgICAgIGxvd2VzdEZpbmlzaDogJy0nLFxuICAgICAgICAgIG5hbWU6ICdPUEVOIFNMT1QnLFxuICAgICAgICAgIHJpZGVyX251bWJlcjogMCxcbiAgICAgICAgICByaWRlcmlkOiAwLFxuICAgICAgICAgIGxlYWd1ZWlkOiAxLFxuICAgICAgICAgIHNlYXNvbl93ZWVrc2lkOiB0aGlzLmN1cnJlbnR3ZWVrXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdmFpbGFibGVSaWRlcnMucHVzaChyYWNlcik7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnNlbGVjdGVkcmlkZXJzLCBzZWxlY3RlZFJhY2VySW5kZXgsIG9wZW5TcGFjZSlcbiAgICAgICAgLy9jYWxsIHRvIHNhdmUgdG8gREI7XG4gICAgICB9LFxuICAgICAgYWRkUmFjZXIocmFjZXIpIHtcbiAgICAgICAgdmFyIG9wZW5TbG90SW5kZXggPSBfZmluZEluZGV4KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIG8gPT4geyByZXR1cm4gby5uYW1lID09IFwiT1BFTiBTTE9UXCIgfSk7XG4gICAgICAgIF9yZW1vdmUodGhpcy5hdmFpbGFibGVSaWRlcnMsIG8gPT4geyByZXR1cm4gby5yaWRlcmlkID09IHJhY2VyLnJpZGVyaWQgfSlcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIG9wZW5TbG90SW5kZXgsIHJhY2VyKTtcbiAgICAgIH0sXG4gICAgICBzb3J0QnlQcmljZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuQ29zdFNvcnRCeUFzYykge1xuICAgICAgICAgIHRoaXMuQ29zdFNvcnRCeUFzYyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMucGFnaW5hdGVkUmlkZXJzID0gdGhpcy5wYWdpbmF0ZWRSaWRlcnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEuY29zdCA+IGIuY29zdCkge1xuICAgICAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhLmNvc3QgPCBiLmNvc3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLkNvc3RTb3J0QnlBc2MgPSB0cnVlO1xuICAgICAgICAgIHRoaXMucGFnaW5hdGVkUmlkZXJzID0gdGhpcy5wYWdpbmF0ZWRSaWRlcnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEuY29zdCA+IGIuY29zdCkge1xuICAgICAgICAgICAgICByZXR1cm4gMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEuY29zdCA8IGIuY29zdCkge1xuICAgICAgICAgICAgICByZXR1cm4gLTFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFNhdmVUZWFtKCkge1xuICAgICAgICBheGlvcy5wb3N0KFwiL1NhdmVUZWFtXCIsIHRoaXMuc2VsZWN0ZWRyaWRlcnMpXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgYmVmb3JlQ3JlYXRlKCkge1xuICAgICAgYXhpb3MuZ2V0KCcvQ3VycmVudE15VGVhbU1vZGVsJylcbiAgICAgIC50aGVuKGRhdGEgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcImRhdGFcIiwgZGF0YS5kYXRhKTtcbiAgICAgICAgdGhpcy5jdXJyZW50d2VlayA9IGRhdGEuZGF0YS5DdXJyZW50VGVhbVswXS5zZWFzb25fd2Vla3NpZDtcbiAgICAgICAgdGhpcy5hdmFpbGFibGVSaWRlcnMgPSBfc29ydEJ5KGRhdGEuZGF0YS5BdmFpbGFibGVSaWRlcnMsIG8gPT4geyByZXR1cm4gby5jb3N0IH0pO1xuICAgICAgICB0aGlzLnNlbGVjdGVkcmlkZXJzID0gZGF0YS5kYXRhLkN1cnJlbnRUZWFtO1xuICAgICAgfSlcbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIm1vdW50ZWRcIiwgdGhpcy5nZXRVc2VyRGF0YSlcbiAgICB9XG4gIH1cbjwvc2NyaXB0PlxuPHN0eWxlPlxuICAucmlkZXJzLWNvbnRhaW5lciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIH1cbiAgLnJpZGVyLWJsb2NrIHtcbiAgICBtaW4td2lkdGg6IDE1cmVtO1xuICAgIGJvcmRlcjogMXB4IHNvbGlkICNkZWRlZGU7XG4gICAgbWFyZ2luOiAxcmVtO1xuICAgIGJveC1zaGFkb3c6IDFweCAxcHggMXB4ICNjZWNlY2U7XG4gICAgcGFkZGluZzogMXJlbTtcbiAgICBtYXgtd2lkdGg6IDE1cmVtO1xuICB9XG4gIC5wYWdlLXRpdGxlIHtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgfVxuICAucGFnZS10aXRsZSB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XG4gIH1cbiAgLnBhZ2Utc3ViaGVhZGVyIHtcbiAgICB0ZXh0LWFsaWduOmNlbnRlcjtcbiAgfVxuICAuY2FyZC1mb290ZXIge1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYm9yZGVyOiAxcHggc29saWQgI2VlZTtcbiAgfVxuICAuY2FyZC1jb250ZW50IHtcbiAgICBtaW4taGVpZ2h0OiAxMXJlbTtcbiAgICBtYXgtaGVpZ2h0OiAxMXJlbTtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIG1hcmdpbi1ib3R0b206IDFyZW07XG4gIH1cbiAgLmNhcmQtZm9vdGVyIGRpdjpudGgtY2hpbGQoZXZlbikge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNlZWU7XG4gIH1cbiAgLmZvb3Rlci1yb3cge1xuICAgIGRpc3BsYXk6ZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIH1cbiAgcC5jYXJkLWhlYWRlci10aXRsZSB7XG4gICAgZGlzcGxheTpmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuICB9XG4gIHAgc3Bhbi5pY29uIHtcbiAgICBjb2xvcjogI2ZmMzg2MDtcbiAgfVxuICB0aDpob3ZlciB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICB9XG4gIC5zYXZlLWJ1dHRvbiB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICB9XG4gIC5oaWRlLXBhZ2luYXRpb24tYnV0dG9uIHtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cbiAgLmN1c3RvbS1wYWdpbmF0aW9uIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgfVxuPC9zdHlsZT5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBteXRlYW0udnVlPzc1ZDM1ZDJhIiwiXG4gIDx0ZW1wbGF0ZT5cbiAgICA8bmF2IGNsYXNzPVwibmF2YmFyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWJyYW5kXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbVwiPlxuICAgICAgICAgIEZBTlRBU1lNWFxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1idXJnZXIgYnVyZ2VyXCIgZGF0YS10YXJnZXQ9XCJuYXZNZW51XCI+XG4gICAgICAgICAgPHNwYW4+PC9zcGFuPlxuICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cbiAgICAgICAgICA8c3Bhbj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLW1lbnVcIiBpZD1cIm5hdk1lbnVcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1zdGFydFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCI+XG4gICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtaG9tZVwiPjwvaT5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cIi9cIj5Ib21lPC9yb3V0ZXItbGluaz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibmF2YmFyLWl0ZW1cIiB2LWlmPVwiR2V0QXV0aFN0YXR1c1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCIgdi1pZj1cIkdldEF1dGhTdGF0dXNcIj5cbiAgICAgICAgICAgICAgPGkgY2xhc3M9XCJmYSBmYS1tb3RvcmN5Y2xlXCI+PC9pPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPHJvdXRlci1saW5rIHRvPVwiL215dGVhbVwiPk15IFRlYW08L3JvdXRlci1saW5rPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCI+XG4gICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtZ2F2ZWxcIj48L2k+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8YSBocmVmPVwiIyFcIj5SdWxlczwvYT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItZW5kXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1pdGVtXCIgdi1pZj1cIiFHZXRBdXRoU3RhdHVzXCIgQGNsaWNrPVwic2V0UmVnaXN0ZXJNb2RhbCh7IHNob3c6ICFTaG93UmVnaXN0ZXJNb2RhbCB9KVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCI+XG4gICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtcGVuY2lsLXNxdWFyZS1vXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPGEgaHJlZj1cIiMhXCI+UmVnaXN0ZXI8L2E+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1pdGVtXCIgdi1pZj1cIiFHZXRBdXRoU3RhdHVzXCIgQGNsaWNrPVwic2V0TG9naW5Nb2RhbCh7IHNob3c6ICFTaG93TG9naW5Nb2RhbCB9KVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCI+XG4gICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtc2lnbi1pblwiPjwvaT5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxhIGhyZWY9XCIjIVwiPkxvZ2luPC9hPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuYXZiYXItaXRlbVwiIHYtaWY9XCJHZXRBdXRoU3RhdHVzXCI+XG4gICAgICAgICAgICA8YSBocmVmPVwiIyFcIj5XZWxjb21lLCB7eyBnZXRVc2VyRGF0YS51c2VybmFtZSB9fSE8L2E+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5hdmJhci1pdGVtXCIgdi1pZj1cIkdldEF1dGhTdGF0dXNcIiBAY2xpY2s9XCJzZXRMb2dnZWRJbih7IGlzTG9nZ2VkSW46ICFHZXRBdXRoU3RhdHVzIH0pXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25cIiB2LWlmPVwiR2V0QXV0aFN0YXR1c1wiPlxuICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLXNpZ24tb3V0XCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPGEgaHJlZj1cIiMhXCIgQGNsaWNrPVwibG9nb3V0XCI+TG9nb3V0PC9hPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPHJlZ2lzdGVyIDpzaG93PVwiU2hvd1JlZ2lzdGVyTW9kYWxcIj48L3JlZ2lzdGVyPlxuICAgICAgPGxvZ2luIHYtYmluZDpzaG93PVwiU2hvd0xvZ2luTW9kYWxcIj48L2xvZ2luPlxuICAgIDwvbmF2PlxuICA8L3RlbXBsYXRlPlxuICA8c2NyaXB0PlxuICAgIGltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG4gICAgaW1wb3J0IHsgbWFwR2V0dGVycywgbWFwTXV0YXRpb25zIH0gZnJvbSAndnVleCc7XG4gICAgaW1wb3J0IHJlZ2lzdGVyIGZyb20gJy4vcmVnaXN0ZXIudnVlJztcbiAgICBpbXBvcnQgbG9naW4gZnJvbSAnLi9sb2dpbi52dWUnO1xuICAgIGV4cG9ydCBkZWZhdWx0IHtcbiAgICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiAge1xuICAgICAgICAgIHVzZXJuYW1lOiAnJyxcbiAgICAgICAgICBwYXNzd29yZDogJycsXG4gICAgICAgICAgc2hvd1JlZ2lzdGVyTW9kYWw6IGZhbHNlLFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29tcHV0ZWQ6IG1hcEdldHRlcnMoW1xuICAgICAgICAnU2hvd0xvZ2luTW9kYWwnLFxuICAgICAgICAnU2hvd1JlZ2lzdGVyTW9kYWwnLFxuICAgICAgICAnZ2V0VXNlckRhdGEnLFxuICAgICAgICAnR2V0QXV0aFN0YXR1cydcbiAgICAgIF0pLFxuICAgICAgbW91bnRlZCgpIHtcbiAgICAgICAgLy8gR2V0IGFsbCBcIm5hdmJhci1idXJnZXJcIiBlbGVtZW50c1xuICAgICAgICB2YXIgJG5hdmJhckJ1cmdlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubmF2YmFyLWJ1cmdlcicpLCAwKTtcbiAgICAgICAgY29uc29sZS5sb2coJG5hdmJhckJ1cmdlcnMpO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IG5hdiBidXJnZXJzXG4gICAgICAgIGlmICgkbmF2YmFyQnVyZ2Vycy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAvLyBBZGQgYSBjbGljayBldmVudCBvbiBlYWNoIG9mIHRoZW1cbiAgICAgICAgICAkbmF2YmFyQnVyZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICgkZWwpIHtcbiAgICAgICAgICAgICRlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcblxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRhcmdldCBmcm9tIHRoZSBcImRhdGEtdGFyZ2V0XCIgYXR0cmlidXRlXG4gICAgICAgICAgICAgIHZhciB0YXJnZXQgPSAkZWwuZGF0YXNldC50YXJnZXQ7XG4gICAgICAgICAgICAgIHZhciAkdGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KTtcblxuICAgICAgICAgICAgICAvLyBUb2dnbGUgdGhlIGNsYXNzIG9uIGJvdGggdGhlIFwibmF2YmFyLWJ1cmdlclwiIGFuZCB0aGUgXCJuYXZiYXItbWVudVwiXG4gICAgICAgICAgICAgICRlbC5jbGFzc0xpc3QudG9nZ2xlKCdpcy1hY3RpdmUnKTtcbiAgICAgICAgICAgICAgJHRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKCdpcy1hY3RpdmUnKTtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICBheGlvcy5nZXQoJy9sb2dpbnJlZnJlc2gnKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEuZGF0YSlcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEuZGF0YS51c2VybmFtZSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVc2VyIElzIEF1dGhlbnRpY2F0ZWRcIilcbiAgICAgICAgICAgIHRoaXMuc2V0VXNlckRhdGEoeyB1c2VyRGF0YTogZGF0YS5kYXRhIH0pXG4gICAgICAgICAgICB0aGlzLnNldExvZ2dlZEluKHsgbG9nZ2VkSW46IHRydWUgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJsb2dpbiByZWZyZXNoIGVycm9yXCIsIGVycik7XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICAuLi5tYXBNdXRhdGlvbnMoW1xuICAgICAgICAgICdzZXRSZWdpc3Rlck1vZGFsJyxcbiAgICAgICAgICAnc2V0TG9naW5Nb2RhbCcsXG4gICAgICAgICAgJ3NldExvZ2dlZEluJyxcbiAgICAgICAgICAnc2V0VXNlckRhdGEnLFxuICAgICAgICAgICdsb2dvdXQnXG4gICAgICAgIF0pLFxuICAgICAgICBsb2dvdXQoKSB7XG4gICAgICAgICAgYXhpb3MuZ2V0KCdsb2dvdXQnKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2dvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuJHJvdXRlci5wdXNoKFwiL1wiKTtcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29tcG9uZW50czoge1xuICAgICAgICAncmVnaXN0ZXInOiByZWdpc3RlcixcbiAgICAgICAgJ2xvZ2luJzogbG9naW5cbiAgICAgIH1cbiAgICB9XG4gIDwvc2NyaXB0PlxuICA8c3R5bGU+XG4gICAgLm5hdmJhci1tZW51IHtcbiAgICAgIHBhZGRpbmc6IDAgMTAwcHggMCA1MHB4O1xuICAgIH1cbiAgICAuaWNvbiB7XG4gICAgICBtYXJnaW4tcmlnaHQ6IDVweDtcbiAgICAgIGNvbG9yOiAjMDBkMWIyO1xuICAgIH1cbiAgPC9zdHlsZT5cbn0pXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbmF2YmFyLnZ1ZT8yNDRjYzg2YyIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1vZGFsXCIgdi1iaW5kOmNsYXNzPVwieydpcy1hY3RpdmUnOiBTaG93UmVnaXN0ZXJNb2RhbH1cIiBpZD1cInJlZ2lzdGVyTW9kYWxcIj5cbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYmFja2dyb3VuZFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jYXJkXCI+XG4gICAgICA8aGVhZGVyIGNsYXNzPVwibW9kYWwtY2FyZC1oZWFkXCI+XG4gICAgICAgIDxwIGNsYXNzPVwibW9kYWwtY2FyZC10aXRsZVwiPk5ldyBVc2VyIFJlZ2lzdHJhdGlvbjwvcD5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImRlbGV0ZVwiIEBjbGljaz1cInNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiAhU2hvd1JlZ2lzdGVyTW9kYWx9KVwiPjwvYnV0dG9uPlxuICAgICAgPC9oZWFkZXI+XG4gICAgICA8c2VjdGlvbiBjbGFzcz1cIm1vZGFsLWNhcmQtYm9keVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XG4gICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImxhYmVsXCI+VXNlcm5hbWU6IDwvbGFiZWw+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJpbnB1dFwiIHYtYmluZDpjbGFzcz1cInsgJ2lzLWRhbmdlcic6IGludmFsaWRVc2VybmFtZSB9XCIgaWQ9XCJyZWctdXNlcm5hbWVcIiB2LW1vZGVsPVwidXNlcm5hbWVcIiBwbGFjZWhvbGRlcj1cIlVzZXJuYW1lXCIgcmVxdWlyZWQ+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIj5cbiAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtdXNlclwiPjwvaT5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cbiAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwibGFiZWxcIj5FbWFpbDogPC9sYWJlbD5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2wgaGFzLWljb25zLWxlZnRcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImVtYWlsXCIgY2xhc3M9XCJpbnB1dFwiIHYtYmluZDpjbGFzcz1cInsgJ2lzLWRhbmdlcic6IGludmFsaWRFbWFpbCB9XCIgIGlkPVwicmVnLWVtYWlsXCIgdi1tb2RlbD1cImVtYWlsXCIgcGxhY2Vob2xkZXI9XCJFbWFpbFwiIHJlcXVpcmVkPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImZhIGZhLWVudmVsb3BlXCI+PC9pPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWVsZFwiPlxuICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJsYWJlbFwiPlBhc3N3b3JkOiA8L2xhYmVsPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwicGFzc3dvcmRcIiBjbGFzcz1cImlucHV0XCIgdi1iaW5kOmNsYXNzPVwieyAnaXMtZGFuZ2VyJzogYmxhbmtQYXNzd29yZCB9XCIgaWQ9XCJyZWctcGFzc3dvcmRcIiB2LW1vZGVsPVwicGFzc3dvcmRcIiBwbGFjZWhvbGRlcj1cIlBhc3N3b3JkXCIgcmVxdWlyZWQ+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIj5cbiAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwiZmEgZmEtbG9ja1wiPjwvaT5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGRcIj5cbiAgICAgICAgICAgICAgUkVDQVBUQ0hBIFBMQUNFSE9MREVSXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJlcnJvck1lc3NhZ2VcIiB2LWZvcj1cImVycm9yIGluIGVycm9yTWVzc2FnZVwiIHYtaWY9XCJlcnJvck1lc3NhZ2UgIT0gJydcIj5cbiAgICAgICAgICAgICAge3sgZXJyb3IgfX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvc2VjdGlvbj5cbiAgICAgIDxmb290ZXIgY2xhc3M9XCJtb2RhbC1jYXJkLWZvb3RcIj5cbiAgICAgICAgPGEgY2xhc3M9XCJidXR0b24gaXMtc3VjY2Vzc1wiIEBjbGljaz1cIlJlZ2lzdGVyXCIgdi1iaW5kOmNsYXNzPVwieyAnaXMtbG9hZGluZyc6IGlzTG9hZGluZyB9XCI+UmVnaXN0ZXI8L2E+XG4gICAgICAgIDxhIGNsYXNzPVwiYnV0dG9uXCIgQGNsaWNrPVwic2V0UmVnaXN0ZXJNb2RhbCh7IHNob3c6ICFTaG93UmVnaXN0ZXJNb2RhbCB9KVwiPkNhbmNlbDwvYT5cbiAgICAgIDwvZm9vdGVyPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBtYXBHZXR0ZXJzLCBtYXBNdXRhdGlvbnMgfSBmcm9tICd2dWV4JztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBkYXRhKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXNlcm5hbWU6ICcnLFxuICAgICAgICBlbWFpbDogJycsXG4gICAgICAgIHBhc3N3b3JkOiAnJyxcbiAgICAgICAgZXJyb3JNZXNzYWdlOiBbXSxcbiAgICAgICAgaW52YWxpZFVzZXJuYW1lOiBmYWxzZSxcbiAgICAgICAgaW52YWxpZEVtYWlsOiBmYWxzZSxcbiAgICAgICAgYmxhbmtQYXNzd29yZDogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiBtYXBHZXR0ZXJzKFtcbiAgICAgICdTaG93UmVnaXN0ZXJNb2RhbCcsXG4gICAgICAnZ2V0VXNlckRhdGEnXG4gICAgXSksXG4gICAgbWV0aG9kczoge1xuICAgICAgLi4ubWFwTXV0YXRpb25zKFtcbiAgICAgICAgJ3NldFJlZ2lzdGVyTW9kYWwnLFxuICAgICAgICAnc2V0VXNlckRhdGEnLFxuICAgICAgICAnc2V0TG9nZ2VkSW4nXG4gICAgICBdKSxcbiAgICAgIFJlZ2lzdGVyKCkge1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlID0gW107XG4gICAgICAgIHRoaXMuaW52YWxpZEVtYWlsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxhbmtQYXNzd29yZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmludmFsaWRVc2VybmFtZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5SZWdpc3RyYXRpb25Jc1ZhbGlkKCkpIHtcblxuICAgICAgICAgIGF4aW9zLnBvc3QoJy9yZWdpc3RlcicsIHtcbiAgICAgICAgICAgIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lLFxuICAgICAgICAgICAgZW1haWw6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICBwYXNzd29yZDogdGhpcy5wYXNzd29yZFxuICAgICAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaXNGYWxzZSA9ICFkYXRhLmRhdGEuRXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpc0ZhbHNlXCIsIGlzRmFsc2UpXG4gICAgICAgICAgICBpZiAoIWRhdGEuZGF0YS5FcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRVc2VyRGF0YSh7IHVzZXJEYXRhOiBkYXRhLmRhdGEgfSlcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJnZXRVc2VyRGF0YVwiLCB0aGlzLmdldFVzZXJEYXRhKVxuICAgICAgICAgICAgICB0aGlzLnNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiBmYWxzZSB9KVxuICAgICAgICAgICAgICB0aGlzLnNldExvZ2dlZEluKHsgbG9nZ2VkSW46IHRydWUgfSlcbiAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy4kc3RvcmUuc3RhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UucHVzaChkYXRhLmRhdGEuRXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtc2cuaW5kZXhPZihcIlVzZXJuYW1lXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZFVzZXJuYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1zZy5pbmRleE9mKFwiRW1haWxcIikgPi0xKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRFbWFpbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFJlZ2lzdHJhdGlvbklzVmFsaWQoKSB7XG4gICAgICAgIHZhciBlbWFpbFZhbGlkYXRpb24gPSB0aGlzLmVtYWlsLm1hdGNoKG5ldyBSZWdFeHAoL14oKFtePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC8pLCBcImlcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKGVtYWlsVmFsaWRhdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmVtYWlsID09IFwiXCIpIHtcbiAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZS5wdXNoKFwiVXNlcm5hbWUgY2Fubm90IGJlIGxlZnQgZW1wdHkuXCIpXG4gICAgICAgICAgdGhpcy5pbnZhbGlkVXNlcm5hbWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbWFpbFZhbGlkYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlLnB1c2goXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbC5cIilcbiAgICAgICAgICB0aGlzLmludmFsaWRFbWFpbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFzc3dvcmQgPT0gJycgfHwgdGhpcy5wYXNzd29yZC5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UucHVzaChcIlBhc3N3b3JkIGNhbm5vdCBiZSBsZWZ0IGVtcHR5IGFuZCBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycy5cIilcbiAgICAgICAgICB0aGlzLmJsYW5rUGFzc3dvcmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVycm9yTWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD5cbjxzdHlsZT5cbiAgLmVycm9yTWVzc2FnZSB7XG4gICAgY29sb3I6ICNmZjM4NjA7XG4gIH1cbjwvc3R5bGU+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVnaXN0ZXIudnVlP2JlMTA4NmQyIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGlkPVwiYXBwXCI+XG4gICAgPG5hdmlnYXRpb24+PC9uYXZpZ2F0aW9uPlxuICAgIDxyb3V0ZXItdmlldz48L3JvdXRlci12aWV3PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZT5cbjwvc3R5bGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgbmF2YmFyIGZyb20gJy4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZSc7XG5leHBvcnQgZGVmYXVsdCB7XG4gIGNvbXB1dGVkOiB7XG4gICAgdXNlcm5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLnN0YXRlLnVzZXJuYW1lXG4gICAgfSxcbiAgICBpc0xvZ2dlZEluOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5zdGF0ZS5pc0xvZ2dlZEluXG4gICAgfVxuICB9LFxuICBjb21wb25lbnRzOiB7XG4gICAgJ25hdmlnYXRpb24nOiBuYXZiYXJcbiAgfVxufVxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gaW5kZXgudnVlP2RmYzQ0OWVlIiwiLyoqXG4gICogdnVlLXJvdXRlciB2Mi41LjNcbiAgKiAoYykgMjAxNyBFdmFuIFlvdVxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuLyogICovXG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKChcIlt2dWUtcm91dGVyXSBcIiArIG1lc3NhZ2UpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm4gKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZGl0aW9uKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSk7XG4gIH1cbn1cblxudmFyIFZpZXcgPSB7XG4gIG5hbWU6ICdyb3V0ZXItdmlldycsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoXywgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuXG4gICAgZGF0YS5yb3V0ZXJWaWV3ID0gdHJ1ZTtcblxuICAgIC8vIGRpcmVjdGx5IHVzZSBwYXJlbnQgY29udGV4dCdzIGNyZWF0ZUVsZW1lbnQoKSBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgY29tcG9uZW50cyByZW5kZXJlZCBieSByb3V0ZXItdmlldyBjYW4gcmVzb2x2ZSBuYW1lZCBzbG90c1xuICAgIHZhciBoID0gcGFyZW50LiRjcmVhdGVFbGVtZW50O1xuICAgIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgICB2YXIgcm91dGUgPSBwYXJlbnQuJHJvdXRlO1xuICAgIHZhciBjYWNoZSA9IHBhcmVudC5fcm91dGVyVmlld0NhY2hlIHx8IChwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSA9IHt9KTtcblxuICAgIC8vIGRldGVybWluZSBjdXJyZW50IHZpZXcgZGVwdGgsIGFsc28gY2hlY2sgdG8gc2VlIGlmIHRoZSB0cmVlXG4gICAgLy8gaGFzIGJlZW4gdG9nZ2xlZCBpbmFjdGl2ZSBidXQga2VwdC1hbGl2ZS5cbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHZhciBpbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuJHZub2RlICYmIHBhcmVudC4kdm5vZGUuZGF0YS5yb3V0ZXJWaWV3KSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Ll9pbmFjdGl2ZSkge1xuICAgICAgICBpbmFjdGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgZGF0YS5yb3V0ZXJWaWV3RGVwdGggPSBkZXB0aDtcblxuICAgIC8vIHJlbmRlciBwcmV2aW91cyB2aWV3IGlmIHRoZSB0cmVlIGlzIGluYWN0aXZlIGFuZCBrZXB0LWFsaXZlXG4gICAgaWYgKGluYWN0aXZlKSB7XG4gICAgICByZXR1cm4gaChjYWNoZVtuYW1lXSwgZGF0YSwgY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZWQgPSByb3V0ZS5tYXRjaGVkW2RlcHRoXTtcbiAgICAvLyByZW5kZXIgZW1wdHkgbm9kZSBpZiBubyBtYXRjaGVkIHJvdXRlXG4gICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICBjYWNoZVtuYW1lXSA9IG51bGw7XG4gICAgICByZXR1cm4gaCgpXG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudCA9IGNhY2hlW25hbWVdID0gbWF0Y2hlZC5jb21wb25lbnRzW25hbWVdO1xuXG4gICAgLy8gYXR0YWNoIGluc3RhbmNlIHJlZ2lzdHJhdGlvbiBob29rXG4gICAgLy8gdGhpcyB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBpbmplY3RlZCBsaWZlY3ljbGUgaG9va3NcbiAgICBkYXRhLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgdmFsKSB7XG4gICAgICAvLyB2YWwgY291bGQgYmUgdW5kZWZpbmVkIGZvciB1bnJlZ2lzdHJhdGlvblxuICAgICAgdmFyIGN1cnJlbnQgPSBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgKHZhbCAmJiBjdXJyZW50ICE9PSB2bSkgfHxcbiAgICAgICAgKCF2YWwgJiYgY3VycmVudCA9PT0gdm0pXG4gICAgICApIHtcbiAgICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWxzbyByZWdpc2V0ZXIgaW5zdGFuY2UgaW4gcHJlcGF0Y2ggaG9va1xuICAgIC8vIGluIGNhc2UgdGhlIHNhbWUgY29tcG9uZW50IGluc3RhbmNlIGlzIHJldXNlZCBhY3Jvc3MgZGlmZmVyZW50IHJvdXRlc1xuICAgIDsoZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSkpLnByZXBhdGNoID0gZnVuY3Rpb24gKF8sIHZub2RlKSB7XG4gICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIH07XG5cbiAgICAvLyByZXNvbHZlIHByb3BzXG4gICAgZGF0YS5wcm9wcyA9IHJlc29sdmVQcm9wcyhyb3V0ZSwgbWF0Y2hlZC5wcm9wcyAmJiBtYXRjaGVkLnByb3BzW25hbWVdKTtcblxuICAgIHJldHVybiBoKGNvbXBvbmVudCwgZGF0YSwgY2hpbGRyZW4pXG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlc29sdmVQcm9wcyAocm91dGUsIGNvbmZpZykge1xuICBzd2l0Y2ggKHR5cGVvZiBjb25maWcpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiBjb25maWdcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gY29uZmlnKHJvdXRlKVxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGNvbmZpZyA/IHJvdXRlLnBhcmFtcyA6IHVuZGVmaW5lZFxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwicHJvcHMgaW4gXFxcIlwiICsgKHJvdXRlLnBhdGgpICsgXCJcXFwiIGlzIGEgXCIgKyAodHlwZW9mIGNvbmZpZykgKyBcIiwgXCIgK1xuICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYm9vbGVhbi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZW5jb2RlUmVzZXJ2ZVJFID0gL1shJygpKl0vZztcbnZhciBlbmNvZGVSZXNlcnZlUmVwbGFjZXIgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTsgfTtcbnZhciBjb21tYVJFID0gLyUyQy9nO1xuXG4vLyBmaXhlZCBlbmNvZGVVUklDb21wb25lbnQgd2hpY2ggaXMgbW9yZSBjb25mb3JtYW50IHRvIFJGQzM5ODY6XG4vLyAtIGVzY2FwZXMgWyEnKCkqXVxuLy8gLSBwcmVzZXJ2ZSBjb21tYXNcbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKVxuICAucmVwbGFjZShlbmNvZGVSZXNlcnZlUkUsIGVuY29kZVJlc2VydmVSZXBsYWNlcilcbiAgLnJlcGxhY2UoY29tbWFSRSwgJywnKTsgfTtcblxudmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXJ5IChcbiAgcXVlcnksXG4gIGV4dHJhUXVlcnksXG4gIF9wYXJzZVF1ZXJ5XG4pIHtcbiAgaWYgKCBleHRyYVF1ZXJ5ID09PSB2b2lkIDAgKSBleHRyYVF1ZXJ5ID0ge307XG5cbiAgdmFyIHBhcnNlID0gX3BhcnNlUXVlcnkgfHwgcGFyc2VRdWVyeTtcbiAgdmFyIHBhcnNlZFF1ZXJ5O1xuICB0cnkge1xuICAgIHBhcnNlZFF1ZXJ5ID0gcGFyc2UocXVlcnkgfHwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBlLm1lc3NhZ2UpO1xuICAgIHBhcnNlZFF1ZXJ5ID0ge307XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIGV4dHJhUXVlcnkpIHtcbiAgICB2YXIgdmFsID0gZXh0cmFRdWVyeVtrZXldO1xuICAgIHBhcnNlZFF1ZXJ5W2tleV0gPSBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwuc2xpY2UoKSA6IHZhbDtcbiAgfVxuICByZXR1cm4gcGFyc2VkUXVlcnlcbn1cblxuZnVuY3Rpb24gcGFyc2VRdWVyeSAocXVlcnkpIHtcbiAgdmFyIHJlcyA9IHt9O1xuXG4gIHF1ZXJ5ID0gcXVlcnkudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cbiAgaWYgKCFxdWVyeSkge1xuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIHF1ZXJ5LnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgcGFydHMgPSBwYXJhbS5yZXBsYWNlKC9cXCsvZywgJyAnKS5zcGxpdCgnPScpO1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydHMuc2hpZnQoKSk7XG4gICAgdmFyIHZhbCA9IHBhcnRzLmxlbmd0aCA+IDBcbiAgICAgID8gZGVjb2RlKHBhcnRzLmpvaW4oJz0nKSlcbiAgICAgIDogbnVsbDtcblxuICAgIGlmIChyZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXNba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzW2tleV0pKSB7XG4gICAgICByZXNba2V5XS5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trZXldID0gW3Jlc1trZXldLCB2YWxdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlRdWVyeSAob2JqKSB7XG4gIHZhciByZXMgPSBvYmogPyBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHZhbCA9IG9ialtrZXldO1xuXG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG5cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZW5jb2RlKGtleSlcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YWwuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG4gICAgICAgIGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsMiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwyKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsKVxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfSkuam9pbignJicpIDogbnVsbDtcbiAgcmV0dXJuIHJlcyA/IChcIj9cIiArIHJlcykgOiAnJ1xufVxuXG4vKiAgKi9cblxuXG52YXIgdHJhaWxpbmdTbGFzaFJFID0gL1xcLz8kLztcblxuZnVuY3Rpb24gY3JlYXRlUm91dGUgKFxuICByZWNvcmQsXG4gIGxvY2F0aW9uLFxuICByZWRpcmVjdGVkRnJvbSxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIHN0cmluZ2lmeVF1ZXJ5JCQxID0gcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnN0cmluZ2lmeVF1ZXJ5O1xuICB2YXIgcm91dGUgPSB7XG4gICAgbmFtZTogbG9jYXRpb24ubmFtZSB8fCAocmVjb3JkICYmIHJlY29yZC5uYW1lKSxcbiAgICBtZXRhOiAocmVjb3JkICYmIHJlY29yZC5tZXRhKSB8fCB7fSxcbiAgICBwYXRoOiBsb2NhdGlvbi5wYXRoIHx8ICcvJyxcbiAgICBoYXNoOiBsb2NhdGlvbi5oYXNoIHx8ICcnLFxuICAgIHF1ZXJ5OiBsb2NhdGlvbi5xdWVyeSB8fCB7fSxcbiAgICBwYXJhbXM6IGxvY2F0aW9uLnBhcmFtcyB8fCB7fSxcbiAgICBmdWxsUGF0aDogZ2V0RnVsbFBhdGgobG9jYXRpb24sIHN0cmluZ2lmeVF1ZXJ5JCQxKSxcbiAgICBtYXRjaGVkOiByZWNvcmQgPyBmb3JtYXRNYXRjaChyZWNvcmQpIDogW11cbiAgfTtcbiAgaWYgKHJlZGlyZWN0ZWRGcm9tKSB7XG4gICAgcm91dGUucmVkaXJlY3RlZEZyb20gPSBnZXRGdWxsUGF0aChyZWRpcmVjdGVkRnJvbSwgc3RyaW5naWZ5UXVlcnkkJDEpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHJvdXRlKVxufVxuXG4vLyB0aGUgc3RhcnRpbmcgcm91dGUgdGhhdCByZXByZXNlbnRzIHRoZSBpbml0aWFsIHN0YXRlXG52YXIgU1RBUlQgPSBjcmVhdGVSb3V0ZShudWxsLCB7XG4gIHBhdGg6ICcvJ1xufSk7XG5cbmZ1bmN0aW9uIGZvcm1hdE1hdGNoIChyZWNvcmQpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB3aGlsZSAocmVjb3JkKSB7XG4gICAgcmVzLnVuc2hpZnQocmVjb3JkKTtcbiAgICByZWNvcmQgPSByZWNvcmQucGFyZW50O1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0RnVsbFBhdGggKFxuICByZWYsXG4gIF9zdHJpbmdpZnlRdWVyeVxuKSB7XG4gIHZhciBwYXRoID0gcmVmLnBhdGg7XG4gIHZhciBxdWVyeSA9IHJlZi5xdWVyeTsgaWYgKCBxdWVyeSA9PT0gdm9pZCAwICkgcXVlcnkgPSB7fTtcbiAgdmFyIGhhc2ggPSByZWYuaGFzaDsgaWYgKCBoYXNoID09PSB2b2lkIDAgKSBoYXNoID0gJyc7XG5cbiAgdmFyIHN0cmluZ2lmeSA9IF9zdHJpbmdpZnlRdWVyeSB8fCBzdHJpbmdpZnlRdWVyeTtcbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyBzdHJpbmdpZnkocXVlcnkpICsgaGFzaFxufVxuXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZSAoYSwgYikge1xuICBpZiAoYiA9PT0gU1RBUlQpIHtcbiAgICByZXR1cm4gYSA9PT0gYlxuICB9IGVsc2UgaWYgKCFiKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoYS5wYXRoICYmIGIucGF0aCkge1xuICAgIHJldHVybiAoXG4gICAgICBhLnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcnKSA9PT0gYi5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpXG4gICAgKVxuICB9IGVsc2UgaWYgKGEubmFtZSAmJiBiLm5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5uYW1lID09PSBiLm5hbWUgJiZcbiAgICAgIGEuaGFzaCA9PT0gYi5oYXNoICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucXVlcnksIGIucXVlcnkpICYmXG4gICAgICBpc09iamVjdEVxdWFsKGEucGFyYW1zLCBiLnBhcmFtcylcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFcXVhbCAoYSwgYikge1xuICBpZiAoIGEgPT09IHZvaWQgMCApIGEgPSB7fTtcbiAgaWYgKCBiID09PSB2b2lkIDAgKSBiID0ge307XG5cbiAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gU3RyaW5nKGFba2V5XSkgPT09IFN0cmluZyhiW2tleV0pOyB9KVxufVxuXG5mdW5jdGlvbiBpc0luY2x1ZGVkUm91dGUgKGN1cnJlbnQsIHRhcmdldCkge1xuICByZXR1cm4gKFxuICAgIGN1cnJlbnQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKS5pbmRleE9mKFxuICAgICAgdGFyZ2V0LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJylcbiAgICApID09PSAwICYmXG4gICAgKCF0YXJnZXQuaGFzaCB8fCBjdXJyZW50Lmhhc2ggPT09IHRhcmdldC5oYXNoKSAmJlxuICAgIHF1ZXJ5SW5jbHVkZXMoY3VycmVudC5xdWVyeSwgdGFyZ2V0LnF1ZXJ5KVxuICApXG59XG5cbmZ1bmN0aW9uIHF1ZXJ5SW5jbHVkZXMgKGN1cnJlbnQsIHRhcmdldCkge1xuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgaWYgKCEoa2V5IGluIGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyogICovXG5cbi8vIHdvcmsgYXJvdW5kIHdlaXJkIGZsb3cgYnVnXG52YXIgdG9UeXBlcyA9IFtTdHJpbmcsIE9iamVjdF07XG52YXIgZXZlbnRUeXBlcyA9IFtTdHJpbmcsIEFycmF5XTtcblxudmFyIExpbmsgPSB7XG4gIG5hbWU6ICdyb3V0ZXItbGluaycsXG4gIHByb3BzOiB7XG4gICAgdG86IHtcbiAgICAgIHR5cGU6IHRvVHlwZXMsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYSdcbiAgICB9LFxuICAgIGV4YWN0OiBCb29sZWFuLFxuICAgIGFwcGVuZDogQm9vbGVhbixcbiAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV2ZW50OiB7XG4gICAgICB0eXBlOiBldmVudFR5cGVzLFxuICAgICAgZGVmYXVsdDogJ2NsaWNrJ1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByb3V0ZXIgPSB0aGlzLiRyb3V0ZXI7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLiRyb3V0ZTtcbiAgICB2YXIgcmVmID0gcm91dGVyLnJlc29sdmUodGhpcy50bywgY3VycmVudCwgdGhpcy5hcHBlbmQpO1xuICAgIHZhciBsb2NhdGlvbiA9IHJlZi5sb2NhdGlvbjtcbiAgICB2YXIgcm91dGUgPSByZWYucm91dGU7XG4gICAgdmFyIGhyZWYgPSByZWYuaHJlZjtcblxuICAgIHZhciBjbGFzc2VzID0ge307XG4gICAgdmFyIGdsb2JhbEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0FjdGl2ZUNsYXNzO1xuICAgIHZhciBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID0gcm91dGVyLm9wdGlvbnMubGlua0V4YWN0QWN0aXZlQ2xhc3M7XG4gICAgLy8gU3VwcG9ydCBnbG9iYWwgZW1wdHkgYWN0aXZlIGNsYXNzXG4gICAgdmFyIGFjdGl2ZUNsYXNzRmFsbGJhY2sgPSBnbG9iYWxBY3RpdmVDbGFzcyA9PSBudWxsXG4gICAgICAgICAgICA/ICdyb3V0ZXItbGluay1hY3RpdmUnXG4gICAgICAgICAgICA6IGdsb2JhbEFjdGl2ZUNsYXNzO1xuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2sgPSBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gJ3JvdXRlci1saW5rLWV4YWN0LWFjdGl2ZSdcbiAgICAgICAgICAgIDogZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcztcbiAgICB2YXIgYWN0aXZlQ2xhc3MgPSB0aGlzLmFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gYWN0aXZlQ2xhc3NGYWxsYmFja1xuICAgICAgICAgICAgOiB0aGlzLmFjdGl2ZUNsYXNzO1xuICAgIHZhciBleGFjdEFjdGl2ZUNsYXNzID0gdGhpcy5leGFjdEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrXG4gICAgICAgICAgICA6IHRoaXMuZXhhY3RBY3RpdmVDbGFzcztcbiAgICB2YXIgY29tcGFyZVRhcmdldCA9IGxvY2F0aW9uLnBhdGhcbiAgICAgID8gY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24sIG51bGwsIHJvdXRlcilcbiAgICAgIDogcm91dGU7XG5cbiAgICBjbGFzc2VzW2V4YWN0QWN0aXZlQ2xhc3NdID0gaXNTYW1lUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XG4gICAgY2xhc3Nlc1thY3RpdmVDbGFzc10gPSB0aGlzLmV4YWN0XG4gICAgICA/IGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc11cbiAgICAgIDogaXNJbmNsdWRlZFJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuXG4gICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGd1YXJkRXZlbnQoZSkpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5yZXBsYWNlKSB7XG4gICAgICAgICAgcm91dGVyLnJlcGxhY2UobG9jYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvdXRlci5wdXNoKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb24gPSB7IGNsaWNrOiBndWFyZEV2ZW50IH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5ldmVudCkpIHtcbiAgICAgIHRoaXMuZXZlbnQuZm9yRWFjaChmdW5jdGlvbiAoZSkgeyBvbltlXSA9IGhhbmRsZXI7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBvblt0aGlzLmV2ZW50XSA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjbGFzczogY2xhc3Nlc1xuICAgIH07XG5cbiAgICBpZiAodGhpcy50YWcgPT09ICdhJykge1xuICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgZGF0YS5hdHRycyA9IHsgaHJlZjogaHJlZiB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaW5kIHRoZSBmaXJzdCA8YT4gY2hpbGQgYW5kIGFwcGx5IGxpc3RlbmVyIGFuZCBocmVmXG4gICAgICB2YXIgYSA9IGZpbmRBbmNob3IodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG4gICAgICBpZiAoYSkge1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSA8YT4gaXMgYSBzdGF0aWMgbm9kZVxuICAgICAgICBhLmlzU3RhdGljID0gZmFsc2U7XG4gICAgICAgIHZhciBleHRlbmQgPSBfVnVlLnV0aWwuZXh0ZW5kO1xuICAgICAgICB2YXIgYURhdGEgPSBhLmRhdGEgPSBleHRlbmQoe30sIGEuZGF0YSk7XG4gICAgICAgIGFEYXRhLm9uID0gb247XG4gICAgICAgIHZhciBhQXR0cnMgPSBhLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGEuZGF0YS5hdHRycyk7XG4gICAgICAgIGFBdHRycy5ocmVmID0gaHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSA8YT4gY2hpbGQsIGFwcGx5IGxpc3RlbmVyIHRvIHNlbGZcbiAgICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoKHRoaXMudGFnLCBkYXRhLCB0aGlzLiRzbG90cy5kZWZhdWx0KVxuICB9XG59O1xuXG5mdW5jdGlvbiBndWFyZEV2ZW50IChlKSB7XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdpdGggY29udHJvbCBrZXlzXG4gIGlmIChlLm1ldGFLZXkgfHwgZS5jdHJsS2V5IHx8IGUuc2hpZnRLZXkpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2hlbiBwcmV2ZW50RGVmYXVsdCBjYWxsZWRcbiAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBvbiByaWdodCBjbGlja1xuICBpZiAoZS5idXR0b24gIT09IHVuZGVmaW5lZCAmJiBlLmJ1dHRvbiAhPT0gMCkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCBpZiBgdGFyZ2V0PVwiX2JsYW5rXCJgXG4gIGlmIChlLmN1cnJlbnRUYXJnZXQgJiYgZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSkge1xuICAgIHZhciB0YXJnZXQgPSBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKTtcbiAgICBpZiAoL1xcYl9ibGFua1xcYi9pLnRlc3QodGFyZ2V0KSkgeyByZXR1cm4gfVxuICB9XG4gIC8vIHRoaXMgbWF5IGJlIGEgV2VleCBldmVudCB3aGljaCBkb2Vzbid0IGhhdmUgdGhpcyBtZXRob2RcbiAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZmluZEFuY2hvciAoY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuKSB7XG4gICAgdmFyIGNoaWxkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAnYScpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4gJiYgKGNoaWxkID0gZmluZEFuY2hvcihjaGlsZC5jaGlsZHJlbikpKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgX1Z1ZTtcblxuZnVuY3Rpb24gaW5zdGFsbCAoVnVlKSB7XG4gIGlmIChpbnN0YWxsLmluc3RhbGxlZCkgeyByZXR1cm4gfVxuICBpbnN0YWxsLmluc3RhbGxlZCA9IHRydWU7XG5cbiAgX1Z1ZSA9IFZ1ZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy4kcm9vdC5fcm91dGVyIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy4kcm9vdC5fcm91dGUgfVxuICB9KTtcblxuICB2YXIgaXNEZWYgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9O1xuXG4gIHZhciByZWdpc3Rlckluc3RhbmNlID0gZnVuY3Rpb24gKHZtLCBjYWxsVmFsKSB7XG4gICAgdmFyIGkgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gICAgaWYgKGlzRGVmKGkpICYmIGlzRGVmKGkgPSBpLmRhdGEpICYmIGlzRGVmKGkgPSBpLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSkpIHtcbiAgICAgIGkodm0sIGNhbGxWYWwpO1xuICAgIH1cbiAgfTtcblxuICBWdWUubWl4aW4oe1xuICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlICgpIHtcbiAgICAgIGlmIChpc0RlZih0aGlzLiRvcHRpb25zLnJvdXRlcikpIHtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gdGhpcy4kb3B0aW9ucy5yb3V0ZXI7XG4gICAgICAgIHRoaXMuX3JvdXRlci5pbml0KHRoaXMpO1xuICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLCAnX3JvdXRlJywgdGhpcy5fcm91dGVyLmhpc3RvcnkuY3VycmVudCk7XG4gICAgICB9XG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIHRoaXMpO1xuICAgIH0sXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci12aWV3JywgVmlldyk7XG4gIFZ1ZS5jb21wb25lbnQoJ3JvdXRlci1saW5rJywgTGluayk7XG5cbiAgdmFyIHN0cmF0cyA9IFZ1ZS5jb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuICAvLyB1c2UgdGhlIHNhbWUgaG9vayBtZXJnaW5nIHN0cmF0ZWd5IGZvciByb3V0ZSBob29rc1xuICBzdHJhdHMuYmVmb3JlUm91dGVFbnRlciA9IHN0cmF0cy5iZWZvcmVSb3V0ZUxlYXZlID0gc3RyYXRzLmNyZWF0ZWQ7XG59XG5cbi8qICAqL1xuXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlUGF0aCAoXG4gIHJlbGF0aXZlLFxuICBiYXNlLFxuICBhcHBlbmRcbikge1xuICB2YXIgZmlyc3RDaGFyID0gcmVsYXRpdmUuY2hhckF0KDApO1xuICBpZiAoZmlyc3RDaGFyID09PSAnLycpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVcbiAgfVxuXG4gIGlmIChmaXJzdENoYXIgPT09ICc/JyB8fCBmaXJzdENoYXIgPT09ICcjJykge1xuICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmVcbiAgfVxuXG4gIHZhciBzdGFjayA9IGJhc2Uuc3BsaXQoJy8nKTtcblxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgLy8gLSBub3QgYXBwZW5kaW5nXG4gIC8vIC0gYXBwZW5kaW5nIHRvIHRyYWlsaW5nIHNsYXNoIChsYXN0IHNlZ21lbnQgaXMgZW1wdHkpXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBwYXRoXG4gIHZhciBzZWdtZW50cyA9IHJlbGF0aXZlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gJy4nKSB7XG4gICAgICBzdGFjay5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gIGlmIChzdGFja1swXSAhPT0gJycpIHtcbiAgICBzdGFjay51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjay5qb2luKCcvJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBoYXNoID0gJyc7XG4gIHZhciBxdWVyeSA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgaGFzaCA9IHBhdGguc2xpY2UoaGFzaEluZGV4KTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgaWYgKHF1ZXJ5SW5kZXggPj0gMCkge1xuICAgIHF1ZXJ5ID0gcGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcXVlcnlJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblBhdGggKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvXFwvL2csICcvJylcbn1cblxudmFyIGluZGV4JDEgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xudmFyIGluZGV4ID0gcGF0aFRvUmVnZXhwO1xudmFyIHBhcnNlXzEgPSBwYXJzZTtcbnZhciBjb21waWxlXzEgPSBjb21waWxlO1xudmFyIHRva2Vuc1RvRnVuY3Rpb25fMSA9IHRva2Vuc1RvRnVuY3Rpb247XG52YXIgdG9rZW5zVG9SZWdFeHBfMSA9IHRva2Vuc1RvUmVnRXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBrZXkgPSAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgcGF0aCA9ICcnO1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nO1xuICB2YXIgcmVzO1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF07XG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV07XG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleDtcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KTtcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoO1xuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdO1xuICAgIHZhciBwcmVmaXggPSByZXNbMl07XG4gICAgdmFyIG5hbWUgPSByZXNbM107XG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF07XG4gICAgdmFyIGdyb3VwID0gcmVzWzVdO1xuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XTtcbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN107XG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgICAgIHBhdGggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXg7XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyO1xuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cDtcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSk7XG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKTtcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJyc7XG4gICAgdmFyIGRhdGEgPSBvYmogfHwge307XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhdGggKz0gdG9rZW47XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXTtcbiAgICAgIHZhciBzZWdtZW50O1xuXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIHBhcnRpYWwgc2VnbWVudCBwcmVmaXhlcy5cbiAgICAgICAgICBpZiAodG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCQxKHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKTtcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBzZWdtZW50ID0gdG9rZW4uYXN0ZXJpc2sgPyBlbmNvZGVBc3Rlcmlzayh2YWx1ZSkgOiBlbmNvZGUodmFsdWUpO1xuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50O1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzO1xuICByZXR1cm4gcmVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGZsYWdzIGZvciBhIHJlZ2V4cCBmcm9tIHRoZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmbGFncyAob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSk7XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWluZGV4JDEoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9ICcnO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KTtcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknO1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKTtcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXI7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPyc7XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnO1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpbmRleCQxKGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpbmRleCQxKHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuXG5pbmRleC5wYXJzZSA9IHBhcnNlXzE7XG5pbmRleC5jb21waWxlID0gY29tcGlsZV8xO1xuaW5kZXgudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25fMTtcbmluZGV4LnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBfMTtcblxuLyogICovXG5cbnZhciByZWdleHBDb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBmaWxsUGFyYW1zIChcbiAgcGF0aCxcbiAgcGFyYW1zLFxuICByb3V0ZU1zZ1xuKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZpbGxlciA9XG4gICAgICByZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gfHxcbiAgICAgIChyZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gPSBpbmRleC5jb21waWxlKHBhdGgpKTtcbiAgICByZXR1cm4gZmlsbGVyKHBhcmFtcyB8fCB7fSwgeyBwcmV0dHk6IHRydWUgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCAoXCJtaXNzaW5nIHBhcmFtIGZvciBcIiArIHJvdXRlTXNnICsgXCI6IFwiICsgKGUubWVzc2FnZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlTWFwIChcbiAgcm91dGVzLFxuICBvbGRQYXRoTGlzdCxcbiAgb2xkUGF0aE1hcCxcbiAgb2xkTmFtZU1hcFxuKSB7XG4gIC8vIHRoZSBwYXRoIGxpc3QgaXMgdXNlZCB0byBjb250cm9sIHBhdGggbWF0Y2hpbmcgcHJpb3JpdHlcbiAgdmFyIHBhdGhMaXN0ID0gb2xkUGF0aExpc3QgfHwgW107XG4gIHZhciBwYXRoTWFwID0gb2xkUGF0aE1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbmFtZU1hcCA9IG9sZE5hbWVNYXAgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByb3V0ZXMuZm9yRWFjaChmdW5jdGlvbiAocm91dGUpIHtcbiAgICBhZGRSb3V0ZVJlY29yZChwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCwgcm91dGUpO1xuICB9KTtcblxuICAvLyBlbnN1cmUgd2lsZGNhcmQgcm91dGVzIGFyZSBhbHdheXMgYXQgdGhlIGVuZFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChwYXRoTGlzdFtpXSA9PT0gJyonKSB7XG4gICAgICBwYXRoTGlzdC5wdXNoKHBhdGhMaXN0LnNwbGljZShpLCAxKVswXSk7XG4gICAgICBsLS07XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoTGlzdDogcGF0aExpc3QsXG4gICAgcGF0aE1hcDogcGF0aE1hcCxcbiAgICBuYW1lTWFwOiBuYW1lTWFwXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUm91dGVSZWNvcmQgKFxuICBwYXRoTGlzdCxcbiAgcGF0aE1hcCxcbiAgbmFtZU1hcCxcbiAgcm91dGUsXG4gIHBhcmVudCxcbiAgbWF0Y2hBc1xuKSB7XG4gIHZhciBwYXRoID0gcm91dGUucGF0aDtcbiAgdmFyIG5hbWUgPSByb3V0ZS5uYW1lO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChwYXRoICE9IG51bGwsIFwiXFxcInBhdGhcXFwiIGlzIHJlcXVpcmVkIGluIGEgcm91dGUgY29uZmlndXJhdGlvbi5cIik7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZW9mIHJvdXRlLmNvbXBvbmVudCAhPT0gJ3N0cmluZycsXG4gICAgICBcInJvdXRlIGNvbmZpZyBcXFwiY29tcG9uZW50XFxcIiBmb3IgcGF0aDogXCIgKyAoU3RyaW5nKHBhdGggfHwgbmFtZSkpICsgXCIgY2Fubm90IGJlIGEgXCIgK1xuICAgICAgXCJzdHJpbmcgaWQuIFVzZSBhbiBhY3R1YWwgY29tcG9uZW50IGluc3RlYWQuXCJcbiAgICApO1xuICB9XG5cbiAgdmFyIG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChwYXRoLCBwYXJlbnQpO1xuICB2YXIgcmVjb3JkID0ge1xuICAgIHBhdGg6IG5vcm1hbGl6ZWRQYXRoLFxuICAgIHJlZ2V4OiBjb21waWxlUm91dGVSZWdleChub3JtYWxpemVkUGF0aCksXG4gICAgY29tcG9uZW50czogcm91dGUuY29tcG9uZW50cyB8fCB7IGRlZmF1bHQ6IHJvdXRlLmNvbXBvbmVudCB9LFxuICAgIGluc3RhbmNlczoge30sXG4gICAgbmFtZTogbmFtZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBtYXRjaEFzOiBtYXRjaEFzLFxuICAgIHJlZGlyZWN0OiByb3V0ZS5yZWRpcmVjdCxcbiAgICBiZWZvcmVFbnRlcjogcm91dGUuYmVmb3JlRW50ZXIsXG4gICAgbWV0YTogcm91dGUubWV0YSB8fCB7fSxcbiAgICBwcm9wczogcm91dGUucHJvcHMgPT0gbnVsbFxuICAgICAgPyB7fVxuICAgICAgOiByb3V0ZS5jb21wb25lbnRzXG4gICAgICAgID8gcm91dGUucHJvcHNcbiAgICAgICAgOiB7IGRlZmF1bHQ6IHJvdXRlLnByb3BzIH1cbiAgfTtcblxuICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAvLyBXYXJuIGlmIHJvdXRlIGlzIG5hbWVkIGFuZCBoYXMgYSBkZWZhdWx0IGNoaWxkIHJvdXRlLlxuICAgIC8vIElmIHVzZXJzIG5hdmlnYXRlIHRvIHRoaXMgcm91dGUgYnkgbmFtZSwgdGhlIGRlZmF1bHQgY2hpbGQgd2lsbFxuICAgIC8vIG5vdCBiZSByZW5kZXJlZCAoR0ggSXNzdWUgIzYyOSlcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHJvdXRlLm5hbWUgJiYgcm91dGUuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIC9eXFwvPyQvLnRlc3QoY2hpbGQucGF0aCk7IH0pKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJOYW1lZCBSb3V0ZSAnXCIgKyAocm91dGUubmFtZSkgKyBcIicgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS4gXCIgK1xuICAgICAgICAgIFwiV2hlbiBuYXZpZ2F0aW5nIHRvIHRoaXMgbmFtZWQgcm91dGUgKDp0bz1cXFwie25hbWU6ICdcIiArIChyb3V0ZS5uYW1lKSArIFwiJ1xcXCIpLCBcIiArXG4gICAgICAgICAgXCJ0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSB3aWxsIG5vdCBiZSByZW5kZXJlZC4gUmVtb3ZlIHRoZSBuYW1lIGZyb20gXCIgK1xuICAgICAgICAgIFwidGhpcyByb3V0ZSBhbmQgdXNlIHRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IGNoaWxkIHJvdXRlIGZvciBuYW1lZCBcIiArXG4gICAgICAgICAgXCJsaW5rcyBpbnN0ZWFkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJvdXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGRNYXRjaEFzID0gbWF0Y2hBc1xuICAgICAgICA/IGNsZWFuUGF0aCgobWF0Y2hBcyArIFwiL1wiICsgKGNoaWxkLnBhdGgpKSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBhZGRSb3V0ZVJlY29yZChwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCwgY2hpbGQsIHJlY29yZCwgY2hpbGRNYXRjaEFzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyb3V0ZS5hbGlhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocm91dGUuYWxpYXMpKSB7XG4gICAgICByb3V0ZS5hbGlhcy5mb3JFYWNoKGZ1bmN0aW9uIChhbGlhcykge1xuICAgICAgICB2YXIgYWxpYXNSb3V0ZSA9IHtcbiAgICAgICAgICBwYXRoOiBhbGlhcyxcbiAgICAgICAgICBjaGlsZHJlbjogcm91dGUuY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICAgICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIGFsaWFzUm91dGUsIHBhcmVudCwgcmVjb3JkLnBhdGgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbGlhc1JvdXRlID0ge1xuICAgICAgICBwYXRoOiByb3V0ZS5hbGlhcyxcbiAgICAgICAgY2hpbGRyZW46IHJvdXRlLmNoaWxkcmVuXG4gICAgICB9O1xuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIGFsaWFzUm91dGUsIHBhcmVudCwgcmVjb3JkLnBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcGF0aE1hcFtyZWNvcmQucGF0aF0pIHtcbiAgICBwYXRoTGlzdC5wdXNoKHJlY29yZC5wYXRoKTtcbiAgICBwYXRoTWFwW3JlY29yZC5wYXRoXSA9IHJlY29yZDtcbiAgfVxuXG4gIGlmIChuYW1lKSB7XG4gICAgaWYgKCFuYW1lTWFwW25hbWVdKSB7XG4gICAgICBuYW1lTWFwW25hbWVdID0gcmVjb3JkO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhbWF0Y2hBcykge1xuICAgICAgd2FybihcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiRHVwbGljYXRlIG5hbWVkIHJvdXRlcyBkZWZpbml0aW9uOiBcIiArXG4gICAgICAgIFwieyBuYW1lOiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBwYXRoOiBcXFwiXCIgKyAocmVjb3JkLnBhdGgpICsgXCJcXFwiIH1cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGlsZVJvdXRlUmVnZXggKHBhdGgpIHtcbiAgdmFyIHJlZ2V4ID0gaW5kZXgocGF0aCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGtleXMgPSB7fTtcbiAgICByZWdleC5rZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgd2Fybigha2V5c1trZXkubmFtZV0sIChcIkR1cGxpY2F0ZSBwYXJhbSBrZXlzIGluIHJvdXRlIHdpdGggcGF0aDogXFxcIlwiICsgcGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICBrZXlzW2tleS5uYW1lXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZ2V4XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGggKHBhdGgsIHBhcmVudCkge1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICBpZiAocGF0aFswXSA9PT0gJy8nKSB7IHJldHVybiBwYXRoIH1cbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7IHJldHVybiBwYXRoIH1cbiAgcmV0dXJuIGNsZWFuUGF0aCgoKHBhcmVudC5wYXRoKSArIFwiL1wiICsgcGF0aCkpXG59XG5cbi8qICAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICBhcHBlbmQsXG4gIHJvdXRlclxuKSB7XG4gIHZhciBuZXh0ID0gdHlwZW9mIHJhdyA9PT0gJ3N0cmluZycgPyB7IHBhdGg6IHJhdyB9IDogcmF3O1xuICAvLyBuYW1lZCB0YXJnZXRcbiAgaWYgKG5leHQubmFtZSB8fCBuZXh0Ll9ub3JtYWxpemVkKSB7XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIC8vIHJlbGF0aXZlIHBhcmFtc1xuICBpZiAoIW5leHQucGF0aCAmJiBuZXh0LnBhcmFtcyAmJiBjdXJyZW50KSB7XG4gICAgbmV4dCA9IGFzc2lnbih7fSwgbmV4dCk7XG4gICAgbmV4dC5fbm9ybWFsaXplZCA9IHRydWU7XG4gICAgdmFyIHBhcmFtcyA9IGFzc2lnbihhc3NpZ24oe30sIGN1cnJlbnQucGFyYW1zKSwgbmV4dC5wYXJhbXMpO1xuICAgIGlmIChjdXJyZW50Lm5hbWUpIHtcbiAgICAgIG5leHQubmFtZSA9IGN1cnJlbnQubmFtZTtcbiAgICAgIG5leHQucGFyYW1zID0gcGFyYW1zO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5tYXRjaGVkKSB7XG4gICAgICB2YXIgcmF3UGF0aCA9IGN1cnJlbnQubWF0Y2hlZFtjdXJyZW50Lm1hdGNoZWQubGVuZ3RoIC0gMV0ucGF0aDtcbiAgICAgIG5leHQucGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJwYXRoIFwiICsgKGN1cnJlbnQucGF0aCkpKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oZmFsc2UsIFwicmVsYXRpdmUgcGFyYW1zIG5hdmlnYXRpb24gcmVxdWlyZXMgYSBjdXJyZW50IHJvdXRlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIHZhciBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKG5leHQucGF0aCB8fCAnJyk7XG4gIHZhciBiYXNlUGF0aCA9IChjdXJyZW50ICYmIGN1cnJlbnQucGF0aCkgfHwgJy8nO1xuICB2YXIgcGF0aCA9IHBhcnNlZFBhdGgucGF0aFxuICAgID8gcmVzb2x2ZVBhdGgocGFyc2VkUGF0aC5wYXRoLCBiYXNlUGF0aCwgYXBwZW5kIHx8IG5leHQuYXBwZW5kKVxuICAgIDogYmFzZVBhdGg7XG5cbiAgdmFyIHF1ZXJ5ID0gcmVzb2x2ZVF1ZXJ5KFxuICAgIHBhcnNlZFBhdGgucXVlcnksXG4gICAgbmV4dC5xdWVyeSxcbiAgICByb3V0ZXIgJiYgcm91dGVyLm9wdGlvbnMucGFyc2VRdWVyeVxuICApO1xuXG4gIHZhciBoYXNoID0gbmV4dC5oYXNoIHx8IHBhcnNlZFBhdGguaGFzaDtcbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykge1xuICAgIGhhc2ggPSBcIiNcIiArIGhhc2g7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ24gKGEsIGIpIHtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBhW2tleV0gPSBiW2tleV07XG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuLyogICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2hlciAoXG4gIHJvdXRlcyxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIHJlZiA9IGNyZWF0ZVJvdXRlTWFwKHJvdXRlcyk7XG4gIHZhciBwYXRoTGlzdCA9IHJlZi5wYXRoTGlzdDtcbiAgdmFyIHBhdGhNYXAgPSByZWYucGF0aE1hcDtcbiAgdmFyIG5hbWVNYXAgPSByZWYubmFtZU1hcDtcblxuICBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICAgIGNyZWF0ZVJvdXRlTWFwKHJvdXRlcywgcGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2ggKFxuICAgIHJhdyxcbiAgICBjdXJyZW50Um91dGUsXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24ocmF3LCBjdXJyZW50Um91dGUsIGZhbHNlLCByb3V0ZXIpO1xuICAgIHZhciBuYW1lID0gbG9jYXRpb24ubmFtZTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB2YXIgcmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4ocmVjb3JkLCAoXCJSb3V0ZSB3aXRoIG5hbWUgJ1wiICsgbmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICB9XG4gICAgICB2YXIgcGFyYW1OYW1lcyA9IHJlY29yZC5yZWdleC5rZXlzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gIWtleS5vcHRpb25hbDsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkubmFtZTsgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24ucGFyYW1zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRSb3V0ZSAmJiB0eXBlb2YgY3VycmVudFJvdXRlLnBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnRSb3V0ZS5wYXJhbXMpIHtcbiAgICAgICAgICBpZiAoIShrZXkgaW4gbG9jYXRpb24ucGFyYW1zKSAmJiBwYXJhbU5hbWVzLmluZGV4T2Yoa2V5KSA+IC0xKSB7XG4gICAgICAgICAgICBsb2NhdGlvbi5wYXJhbXNba2V5XSA9IGN1cnJlbnRSb3V0ZS5wYXJhbXNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICBsb2NhdGlvbi5wYXRoID0gZmlsbFBhcmFtcyhyZWNvcmQucGF0aCwgbG9jYXRpb24ucGFyYW1zLCAoXCJuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpKTtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvY2F0aW9uLnBhdGgpIHtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhMaXN0W2ldO1xuICAgICAgICB2YXIgcmVjb3JkJDEgPSBwYXRoTWFwW3BhdGhdO1xuICAgICAgICBpZiAobWF0Y2hSb3V0ZShyZWNvcmQkMS5yZWdleCwgbG9jYXRpb24ucGF0aCwgbG9jYXRpb24ucGFyYW1zKSkge1xuICAgICAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkJDEsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBubyBtYXRjaFxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gIH1cblxuICBmdW5jdGlvbiByZWRpcmVjdCAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uXG4gICkge1xuICAgIHZhciBvcmlnaW5hbFJlZGlyZWN0ID0gcmVjb3JkLnJlZGlyZWN0O1xuICAgIHZhciByZWRpcmVjdCA9IHR5cGVvZiBvcmlnaW5hbFJlZGlyZWN0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gb3JpZ2luYWxSZWRpcmVjdChjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCBudWxsLCByb3V0ZXIpKVxuICAgICAgICA6IG9yaWdpbmFsUmVkaXJlY3Q7XG5cbiAgICBpZiAodHlwZW9mIHJlZGlyZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmVkaXJlY3QgPSB7IHBhdGg6IHJlZGlyZWN0IH07XG4gICAgfVxuXG4gICAgaWYgKCFyZWRpcmVjdCB8fCB0eXBlb2YgcmVkaXJlY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuXG4gICAgdmFyIHJlID0gcmVkaXJlY3Q7XG4gICAgdmFyIG5hbWUgPSByZS5uYW1lO1xuICAgIHZhciBwYXRoID0gcmUucGF0aDtcbiAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHBhcmFtcyA9IGxvY2F0aW9uLnBhcmFtcztcbiAgICBxdWVyeSA9IHJlLmhhc093blByb3BlcnR5KCdxdWVyeScpID8gcmUucXVlcnkgOiBxdWVyeTtcbiAgICBoYXNoID0gcmUuaGFzT3duUHJvcGVydHkoJ2hhc2gnKSA/IHJlLmhhc2ggOiBoYXNoO1xuICAgIHBhcmFtcyA9IHJlLmhhc093blByb3BlcnR5KCdwYXJhbXMnKSA/IHJlLnBhcmFtcyA6IHBhcmFtcztcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICAvLyByZXNvbHZlZCBuYW1lZCBkaXJlY3RcbiAgICAgIHZhciB0YXJnZXRSZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KHRhcmdldFJlY29yZCwgKFwicmVkaXJlY3QgZmFpbGVkOiBuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG5vdCBmb3VuZC5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIGlmIChwYXRoKSB7XG4gICAgICAvLyAxLiByZXNvbHZlIHJlbGF0aXZlIHJlZGlyZWN0XG4gICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHBhdGgsIHJlY29yZCk7XG4gICAgICAvLyAyLiByZXNvbHZlIHBhcmFtc1xuICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJyZWRpcmVjdCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgcmF3UGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBwYXRoOiByZXNvbHZlZFBhdGgsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaFxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWxpYXMgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICBtYXRjaEFzXG4gICkge1xuICAgIHZhciBhbGlhc2VkUGF0aCA9IGZpbGxQYXJhbXMobWF0Y2hBcywgbG9jYXRpb24ucGFyYW1zLCAoXCJhbGlhc2VkIHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyBtYXRjaEFzICsgXCJcXFwiXCIpKTtcbiAgICB2YXIgYWxpYXNlZE1hdGNoID0gbWF0Y2goe1xuICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICBwYXRoOiBhbGlhc2VkUGF0aFxuICAgIH0pO1xuICAgIGlmIChhbGlhc2VkTWF0Y2gpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gYWxpYXNlZE1hdGNoLm1hdGNoZWQ7XG4gICAgICB2YXIgYWxpYXNlZFJlY29yZCA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IGFsaWFzZWRNYXRjaC5wYXJhbXM7XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKGFsaWFzZWRSZWNvcmQsIGxvY2F0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVJvdXRlIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQucmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiByZWRpcmVjdChyZWNvcmQsIHJlZGlyZWN0ZWRGcm9tIHx8IGxvY2F0aW9uKVxuICAgIH1cbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5tYXRjaEFzKSB7XG4gICAgICByZXR1cm4gYWxpYXMocmVjb3JkLCBsb2NhdGlvbiwgcmVjb3JkLm1hdGNoQXMpXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSwgcm91dGVyKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgYWRkUm91dGVzOiBhZGRSb3V0ZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlIChcbiAgcmVnZXgsXG4gIHBhdGgsXG4gIHBhcmFtc1xuKSB7XG4gIHZhciBtID0gcGF0aC5tYXRjaChyZWdleCk7XG5cbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmb3IgKHZhciBpID0gMSwgbGVuID0gbS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBrZXkgPSByZWdleC5rZXlzW2kgLSAxXTtcbiAgICB2YXIgdmFsID0gdHlwZW9mIG1baV0gPT09ICdzdHJpbmcnID8gZGVjb2RlVVJJQ29tcG9uZW50KG1baV0pIDogbVtpXTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBwYXJhbXNba2V5Lm5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVSZWNvcmRQYXRoIChwYXRoLCByZWNvcmQpIHtcbiAgcmV0dXJuIHJlc29sdmVQYXRoKHBhdGgsIHJlY29yZC5wYXJlbnQgPyByZWNvcmQucGFyZW50LnBhdGggOiAnLycsIHRydWUpXG59XG5cbi8qICAqL1xuXG5cbnZhciBwb3NpdGlvblN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuZnVuY3Rpb24gc2V0dXBTY3JvbGwgKCkge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAgIGlmIChlLnN0YXRlICYmIGUuc3RhdGUua2V5KSB7XG4gICAgICBzZXRTdGF0ZUtleShlLnN0YXRlLmtleSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU2Nyb2xsIChcbiAgcm91dGVyLFxuICB0byxcbiAgZnJvbSxcbiAgaXNQb3Bcbikge1xuICBpZiAoIXJvdXRlci5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiZWhhdmlvciA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICBpZiAoIWJlaGF2aW9yKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydCh0eXBlb2YgYmVoYXZpb3IgPT09ICdmdW5jdGlvbicsIFwic2Nyb2xsQmVoYXZpb3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgLy8gd2FpdCB1bnRpbCByZS1yZW5kZXIgZmluaXNoZXMgYmVmb3JlIHNjcm9sbGluZ1xuICByb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB2YXIgc2hvdWxkU2Nyb2xsID0gYmVoYXZpb3IodG8sIGZyb20sIGlzUG9wID8gcG9zaXRpb24gOiBudWxsKTtcbiAgICBpZiAoIXNob3VsZFNjcm9sbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBpc09iamVjdCA9IHR5cGVvZiBzaG91bGRTY3JvbGwgPT09ICdvYmplY3QnO1xuICAgIGlmIChpc09iamVjdCAmJiB0eXBlb2Ygc2hvdWxkU2Nyb2xsLnNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzaG91bGRTY3JvbGwuc2VsZWN0b3IpO1xuICAgICAgaWYgKGVsKSB7XG4gICAgICAgIHBvc2l0aW9uID0gZ2V0RWxlbWVudFBvc2l0aW9uKGVsKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICAgICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QgJiYgaXNWYWxpZFBvc2l0aW9uKHNob3VsZFNjcm9sbCkpIHtcbiAgICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHBvc2l0aW9uU3RvcmVba2V5XSA9IHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHJldHVybiBwb3NpdGlvblN0b3JlW2tleV1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50UG9zaXRpb24gKGVsKSB7XG4gIHZhciBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGRvY1JlY3QgPSBkb2NFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHg6IGVsUmVjdC5sZWZ0IC0gZG9jUmVjdC5sZWZ0LFxuICAgIHk6IGVsUmVjdC50b3AgLSBkb2NSZWN0LnRvcFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiBpc051bWJlcihvYmoueCkgfHwgaXNOdW1iZXIob2JqLnkpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcidcbn1cblxuLyogICovXG5cbnZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9IGluQnJvd3NlciAmJiAoZnVuY3Rpb24gKCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoXG4gICAgKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmXG4gICAgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJlxuICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTFcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnlcbn0pKCk7XG5cbi8vIHVzZSBVc2VyIFRpbWluZyBhcGkgKGlmIHByZXNlbnQpIGZvciBtb3JlIGFjY3VyYXRlIGtleSBwcmVjaXNpb25cbnZhciBUaW1lID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93XG4gID8gd2luZG93LnBlcmZvcm1hbmNlXG4gIDogRGF0ZTtcblxudmFyIF9rZXkgPSBnZW5LZXkoKTtcblxuZnVuY3Rpb24gZ2VuS2V5ICgpIHtcbiAgcmV0dXJuIFRpbWUubm93KCkudG9GaXhlZCgzKVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUtleSAoKSB7XG4gIHJldHVybiBfa2V5XG59XG5cbmZ1bmN0aW9uIHNldFN0YXRlS2V5IChrZXkpIHtcbiAgX2tleSA9IGtleTtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXRlICh1cmwsIHJlcGxhY2UpIHtcbiAgc2F2ZVNjcm9sbFBvc2l0aW9uKCk7XG4gIC8vIHRyeS4uLmNhdGNoIHRoZSBwdXNoU3RhdGUgY2FsbCB0byBnZXQgYXJvdW5kIFNhZmFyaVxuICAvLyBET00gRXhjZXB0aW9uIDE4IHdoZXJlIGl0IGxpbWl0cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzXG4gIHZhciBoaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBfa2V5IH0sICcnLCB1cmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfa2V5ID0gZ2VuS2V5KCk7XG4gICAgICBoaXN0b3J5LnB1c2hTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB3aW5kb3cubG9jYXRpb25bcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdhc3NpZ24nXSh1cmwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAodXJsKSB7XG4gIHB1c2hTdGF0ZSh1cmwsIHRydWUpO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcnVuUXVldWUgKHF1ZXVlLCBmbiwgY2IpIHtcbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gcXVldWUubGVuZ3RoKSB7XG4gICAgICBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocXVldWVbaW5kZXhdKSB7XG4gICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGVwKDApO1xufVxuXG4vKiAgKi9cblxudmFyIEhpc3RvcnkgPSBmdW5jdGlvbiBIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIHRoaXMuYmFzZSA9IG5vcm1hbGl6ZUJhc2UoYmFzZSk7XG4gIC8vIHN0YXJ0IHdpdGggYSByb3V0ZSBvYmplY3QgdGhhdCBzdGFuZHMgZm9yIFwibm93aGVyZVwiXG4gIHRoaXMuY3VycmVudCA9IFNUQVJUO1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gIHRoaXMucmVhZHlDYnMgPSBbXTtcbiAgdGhpcy5yZWFkeUVycm9yQ2JzID0gW107XG4gIHRoaXMuZXJyb3JDYnMgPSBbXTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbiAoY2IpIHtcbiAgdGhpcy5jYiA9IGNiO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgY2IoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlYWR5Q2JzLnB1c2goY2IpO1xuICAgIGlmIChlcnJvckNiKSB7XG4gICAgICB0aGlzLnJlYWR5RXJyb3JDYnMucHVzaChlcnJvckNiKTtcbiAgICB9XG4gIH1cbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yIChlcnJvckNiKSB7XG4gIHRoaXMuZXJyb3JDYnMucHVzaChlcnJvckNiKTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25UbyAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgcm91dGUgPSB0aGlzLnJvdXRlci5tYXRjaChsb2NhdGlvbiwgdGhpcy5jdXJyZW50KTtcbiAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihyb3V0ZSwgZnVuY3Rpb24gKCkge1xuICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XG4gICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB0aGlzJDEuZW5zdXJlVVJMKCk7XG5cbiAgICAvLyBmaXJlIHJlYWR5IGNicyBvbmNlXG4gICAgaWYgKCF0aGlzJDEucmVhZHkpIHtcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzJDEucmVhZHlDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2Iocm91dGUpOyB9KTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAob25BYm9ydCkge1xuICAgICAgb25BYm9ydChlcnIpO1xuICAgIH1cbiAgICBpZiAoZXJyICYmICF0aGlzJDEucmVhZHkpIHtcbiAgICAgIHRoaXMkMS5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzJDEucmVhZHlFcnJvckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihlcnIpOyB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUsIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChpc0Vycm9yKGVycikpIHtcbiAgICAgIGlmICh0aGlzJDEuZXJyb3JDYnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMkMS5lcnJvckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYihlcnIpOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oZmFsc2UsICd1bmNhdWdodCBlcnJvciBkdXJpbmcgcm91dGUgbmF2aWdhdGlvbjonKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBvbkFib3J0ICYmIG9uQWJvcnQoZXJyKTtcbiAgfTtcbiAgaWYgKFxuICAgIGlzU2FtZVJvdXRlKHJvdXRlLCBjdXJyZW50KSAmJlxuICAgIC8vIGluIHRoZSBjYXNlIHRoZSByb3V0ZSBtYXAgaGFzIGJlZW4gZHluYW1pY2FsbHkgYXBwZW5kZWQgdG9cbiAgICByb3V0ZS5tYXRjaGVkLmxlbmd0aCA9PT0gY3VycmVudC5tYXRjaGVkLmxlbmd0aFxuICApIHtcbiAgICB0aGlzLmVuc3VyZVVSTCgpO1xuICAgIHJldHVybiBhYm9ydCgpXG4gIH1cblxuICB2YXIgcmVmID0gcmVzb2x2ZVF1ZXVlKHRoaXMuY3VycmVudC5tYXRjaGVkLCByb3V0ZS5tYXRjaGVkKTtcbiAgICB2YXIgdXBkYXRlZCA9IHJlZi51cGRhdGVkO1xuICAgIHZhciBkZWFjdGl2YXRlZCA9IHJlZi5kZWFjdGl2YXRlZDtcbiAgICB2YXIgYWN0aXZhdGVkID0gcmVmLmFjdGl2YXRlZDtcblxuICB2YXIgcXVldWUgPSBbXS5jb25jYXQoXG4gICAgLy8gaW4tY29tcG9uZW50IGxlYXZlIGd1YXJkc1xuICAgIGV4dHJhY3RMZWF2ZUd1YXJkcyhkZWFjdGl2YXRlZCksXG4gICAgLy8gZ2xvYmFsIGJlZm9yZSBob29rc1xuICAgIHRoaXMucm91dGVyLmJlZm9yZUhvb2tzLFxuICAgIC8vIGluLWNvbXBvbmVudCB1cGRhdGUgaG9va3NcbiAgICBleHRyYWN0VXBkYXRlSG9va3ModXBkYXRlZCksXG4gICAgLy8gaW4tY29uZmlnIGVudGVyIGd1YXJkc1xuICAgIGFjdGl2YXRlZC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uYmVmb3JlRW50ZXI7IH0pLFxuICAgIC8vIGFzeW5jIGNvbXBvbmVudHNcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnRzKGFjdGl2YXRlZClcbiAgKTtcblxuICB0aGlzLnBlbmRpbmcgPSByb3V0ZTtcbiAgdmFyIGl0ZXJhdG9yID0gZnVuY3Rpb24gKGhvb2ssIG5leHQpIHtcbiAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICByZXR1cm4gYWJvcnQoKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaG9vayhyb3V0ZSwgY3VycmVudCwgZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIGlmICh0byA9PT0gZmFsc2UgfHwgaXNFcnJvcih0bykpIHtcbiAgICAgICAgICAvLyBuZXh0KGZhbHNlKSAtPiBhYm9ydCBuYXZpZ2F0aW9uLCBlbnN1cmUgY3VycmVudCBVUkxcbiAgICAgICAgICB0aGlzJDEuZW5zdXJlVVJMKHRydWUpO1xuICAgICAgICAgIGFib3J0KHRvKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0eXBlb2YgdG8gPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgKHR5cGVvZiB0byA9PT0gJ29iamVjdCcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHRvLnBhdGggPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICB0eXBlb2YgdG8ubmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICApKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBuZXh0KCcvJykgb3IgbmV4dCh7IHBhdGg6ICcvJyB9KSAtPiByZWRpcmVjdFxuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gJ29iamVjdCcgJiYgdG8ucmVwbGFjZSkge1xuICAgICAgICAgICAgdGhpcyQxLnJlcGxhY2UodG8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzJDEucHVzaCh0byk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbmZpcm0gdHJhbnNpdGlvbiBhbmQgcGFzcyBvbiB0aGUgdmFsdWVcbiAgICAgICAgICBuZXh0KHRvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYWJvcnQoZSk7XG4gICAgfVxuICB9O1xuXG4gIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBwb3N0RW50ZXJDYnMgPSBbXTtcbiAgICB2YXIgaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5jdXJyZW50ID09PSByb3V0ZTsgfTtcbiAgICAvLyB3YWl0IHVudGlsIGFzeW5jIGNvbXBvbmVudHMgYXJlIHJlc29sdmVkIGJlZm9yZVxuICAgIC8vIGV4dHJhY3RpbmcgaW4tY29tcG9uZW50IGVudGVyIGd1YXJkc1xuICAgIHZhciBlbnRlckd1YXJkcyA9IGV4dHJhY3RFbnRlckd1YXJkcyhhY3RpdmF0ZWQsIHBvc3RFbnRlckNicywgaXNWYWxpZCk7XG4gICAgdmFyIHF1ZXVlID0gZW50ZXJHdWFyZHMuY29uY2F0KHRoaXMkMS5yb3V0ZXIucmVzb2x2ZUhvb2tzKTtcbiAgICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0KClcbiAgICAgIH1cbiAgICAgIHRoaXMkMS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIG9uQ29tcGxldGUocm91dGUpO1xuICAgICAgaWYgKHRoaXMkMS5yb3V0ZXIuYXBwKSB7XG4gICAgICAgIHRoaXMkMS5yb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcG9zdEVudGVyQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKCk7IH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS51cGRhdGVSb3V0ZSA9IGZ1bmN0aW9uIHVwZGF0ZVJvdXRlIChyb3V0ZSkge1xuICB2YXIgcHJldiA9IHRoaXMuY3VycmVudDtcbiAgdGhpcy5jdXJyZW50ID0gcm91dGU7XG4gIHRoaXMuY2IgJiYgdGhpcy5jYihyb3V0ZSk7XG4gIHRoaXMucm91dGVyLmFmdGVySG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgIGhvb2sgJiYgaG9vayhyb3V0ZSwgcHJldik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplQmFzZSAoYmFzZSkge1xuICBpZiAoIWJhc2UpIHtcbiAgICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgICAvLyByZXNwZWN0IDxiYXNlPiB0YWdcbiAgICAgIHZhciBiYXNlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgICBiYXNlID0gKGJhc2VFbCAmJiBiYXNlRWwuZ2V0QXR0cmlidXRlKCdocmVmJykpIHx8ICcvJztcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSA9ICcvJztcbiAgICB9XG4gIH1cbiAgLy8gbWFrZSBzdXJlIHRoZXJlJ3MgdGhlIHN0YXJ0aW5nIHNsYXNoXG4gIGlmIChiYXNlLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgYmFzZSA9ICcvJyArIGJhc2U7XG4gIH1cbiAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gIHJldHVybiBiYXNlLnJlcGxhY2UoL1xcLyQvLCAnJylcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXVlIChcbiAgY3VycmVudCxcbiAgbmV4dFxuKSB7XG4gIHZhciBpO1xuICB2YXIgbWF4ID0gTWF0aC5tYXgoY3VycmVudC5sZW5ndGgsIG5leHQubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgaWYgKGN1cnJlbnRbaV0gIT09IG5leHRbaV0pIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdXBkYXRlZDogbmV4dC5zbGljZSgwLCBpKSxcbiAgICBhY3RpdmF0ZWQ6IG5leHQuc2xpY2UoaSksXG4gICAgZGVhY3RpdmF0ZWQ6IGN1cnJlbnQuc2xpY2UoaSlcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0R3VhcmRzIChcbiAgcmVjb3JkcyxcbiAgbmFtZSxcbiAgYmluZCxcbiAgcmV2ZXJzZVxuKSB7XG4gIHZhciBndWFyZHMgPSBmbGF0TWFwQ29tcG9uZW50cyhyZWNvcmRzLCBmdW5jdGlvbiAoZGVmLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSkge1xuICAgIHZhciBndWFyZCA9IGV4dHJhY3RHdWFyZChkZWYsIG5hbWUpO1xuICAgIGlmIChndWFyZCkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZ3VhcmQpXG4gICAgICAgID8gZ3VhcmQubWFwKGZ1bmN0aW9uIChndWFyZCkgeyByZXR1cm4gYmluZChndWFyZCwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpOyB9KVxuICAgICAgICA6IGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmbGF0dGVuKHJldmVyc2UgPyBndWFyZHMucmV2ZXJzZSgpIDogZ3VhcmRzKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0R3VhcmQgKFxuICBkZWYsXG4gIGtleVxuKSB7XG4gIGlmICh0eXBlb2YgZGVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZXh0ZW5kIG5vdyBzbyB0aGF0IGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQuXG4gICAgZGVmID0gX1Z1ZS5leHRlbmQoZGVmKTtcbiAgfVxuICByZXR1cm4gZGVmLm9wdGlvbnNba2V5XVxufVxuXG5mdW5jdGlvbiBleHRyYWN0TGVhdmVHdWFyZHMgKGRlYWN0aXZhdGVkKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGRlYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVMZWF2ZScsIGJpbmRHdWFyZCwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFVwZGF0ZUhvb2tzICh1cGRhdGVkKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKHVwZGF0ZWQsICdiZWZvcmVSb3V0ZVVwZGF0ZScsIGJpbmRHdWFyZClcbn1cblxuZnVuY3Rpb24gYmluZEd1YXJkIChndWFyZCwgaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kUm91dGVHdWFyZCAoKSB7XG4gICAgICByZXR1cm4gZ3VhcmQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVudGVyR3VhcmRzIChcbiAgYWN0aXZhdGVkLFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhhY3RpdmF0ZWQsICdiZWZvcmVSb3V0ZUVudGVyJywgZnVuY3Rpb24gKGd1YXJkLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgcmV0dXJuIGJpbmRFbnRlckd1YXJkKGd1YXJkLCBtYXRjaCwga2V5LCBjYnMsIGlzVmFsaWQpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGJpbmRFbnRlckd1YXJkIChcbiAgZ3VhcmQsXG4gIG1hdGNoLFxuICBrZXksXG4gIGNicyxcbiAgaXNWYWxpZFxuKSB7XG4gIHJldHVybiBmdW5jdGlvbiByb3V0ZUVudGVyR3VhcmQgKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgcmV0dXJuIGd1YXJkKHRvLCBmcm9tLCBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIG5leHQoY2IpO1xuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gIzc1MFxuICAgICAgICAgIC8vIGlmIGEgcm91dGVyLXZpZXcgaXMgd3JhcHBlZCB3aXRoIGFuIG91dC1pbiB0cmFuc2l0aW9uLFxuICAgICAgICAgIC8vIHRoZSBpbnN0YW5jZSBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIGF0IHRoaXMgdGltZS5cbiAgICAgICAgICAvLyB3ZSB3aWxsIG5lZWQgdG8gcG9sbCBmb3IgcmVnaXN0cmF0aW9uIHVudGlsIGN1cnJlbnQgcm91dGVcbiAgICAgICAgICAvLyBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgICAgICAgcG9sbChjYiwgbWF0Y2guaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvbGwgKFxuICBjYiwgLy8gc29tZWhvdyBmbG93IGNhbm5vdCBpbmZlciB0aGlzIGlzIGEgZnVuY3Rpb25cbiAgaW5zdGFuY2VzLFxuICBrZXksXG4gIGlzVmFsaWRcbikge1xuICBpZiAoaW5zdGFuY2VzW2tleV0pIHtcbiAgICBjYihpbnN0YW5jZXNba2V5XSk7XG4gIH0gZWxzZSBpZiAoaXNWYWxpZCgpKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBwb2xsKGNiLCBpbnN0YW5jZXMsIGtleSwgaXNWYWxpZCk7XG4gICAgfSwgMTYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudHMgKG1hdGNoZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHZhciBoYXNBc3luYyA9IGZhbHNlO1xuICAgIHZhciBwZW5kaW5nID0gMDtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gICAgZmxhdE1hcENvbXBvbmVudHMobWF0Y2hlZCwgZnVuY3Rpb24gKGRlZiwgXywgbWF0Y2gsIGtleSkge1xuICAgICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uIGFuZCBkb2Vzbid0IGhhdmUgY2lkIGF0dGFjaGVkLFxuICAgICAgLy8gYXNzdW1lIGl0J3MgYW4gYXN5bmMgY29tcG9uZW50IHJlc29sdmUgZnVuY3Rpb24uXG4gICAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIFZ1ZSdzIGRlZmF1bHQgYXN5bmMgcmVzb2x2aW5nIG1lY2hhbmlzbSBiZWNhdXNlXG4gICAgICAvLyB3ZSB3YW50IHRvIGhhbHQgdGhlIG5hdmlnYXRpb24gdW50aWwgdGhlIGluY29taW5nIGNvbXBvbmVudCBoYXMgYmVlblxuICAgICAgLy8gcmVzb2x2ZWQuXG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWYuY2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzQXN5bmMgPSB0cnVlO1xuICAgICAgICBwZW5kaW5nKys7XG5cbiAgICAgICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXNvbHZlZERlZikge1xuICAgICAgICAgIC8vIHNhdmUgcmVzb2x2ZWQgb24gYXN5bmMgZmFjdG9yeSBpbiBjYXNlIGl0J3MgdXNlZCBlbHNld2hlcmVcbiAgICAgICAgICBkZWYucmVzb2x2ZWQgPSB0eXBlb2YgcmVzb2x2ZWREZWYgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcmVzb2x2ZWREZWZcbiAgICAgICAgICAgIDogX1Z1ZS5leHRlbmQocmVzb2x2ZWREZWYpO1xuICAgICAgICAgIG1hdGNoLmNvbXBvbmVudHNba2V5XSA9IHJlc29sdmVkRGVmO1xuICAgICAgICAgIHBlbmRpbmctLTtcbiAgICAgICAgICBpZiAocGVuZGluZyA8PSAwKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgdmFyIG1zZyA9IFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50IFwiICsga2V5ICsgXCI6IFwiICsgcmVhc29uO1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihmYWxzZSwgbXNnKTtcbiAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IGlzRXJyb3IocmVhc29uKVxuICAgICAgICAgICAgICA/IHJlYXNvblxuICAgICAgICAgICAgICA6IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgbmV4dChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IGRlZihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBuZXcgc3ludGF4IGluIFZ1ZSAyLjNcbiAgICAgICAgICAgIHZhciBjb21wID0gcmVzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGlmIChjb21wICYmIHR5cGVvZiBjb21wLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgY29tcC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWhhc0FzeW5jKSB7IG5leHQoKTsgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsYXRNYXBDb21wb25lbnRzIChcbiAgbWF0Y2hlZCxcbiAgZm5cbikge1xuICByZXR1cm4gZmxhdHRlbihtYXRjaGVkLm1hcChmdW5jdGlvbiAobSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBmbihcbiAgICAgIG0uY29tcG9uZW50c1trZXldLFxuICAgICAgbS5pbnN0YW5jZXNba2V5XSxcbiAgICAgIG0sIGtleVxuICAgICk7IH0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuIChhcnIpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFycilcbn1cblxuLy8gaW4gV2VicGFjayAyLCByZXF1aXJlLmVuc3VyZSBub3cgYWxzbyByZXR1cm5zIGEgUHJvbWlzZVxuLy8gc28gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9ucyBtYXkgZ2V0IGNhbGxlZCBhbiBleHRyYSB0aW1lXG4vLyBpZiB0aGUgdXNlciB1c2VzIGFuIGFycm93IGZ1bmN0aW9uIHNob3J0aGFuZCB0aGF0IGhhcHBlbnMgdG9cbi8vIHJldHVybiB0aGF0IFByb21pc2UuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgeyByZXR1cm4gfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Vycm9yIChlcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlcnIpLmluZGV4T2YoJ0Vycm9yJykgPiAtMVxufVxuXG4vKiAgKi9cblxuXG52YXIgSFRNTDVIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhUTUw1SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcblxuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcblxuICAgIGlmIChleHBlY3RTY3JvbGwpIHtcbiAgICAgIHNldHVwU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8oZ2V0TG9jYXRpb24odGhpcyQxLmJhc2UpLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuICAgICAgICAgIGhhbmRsZVNjcm9sbChyb3V0ZXIsIHJvdXRlLCB0aGlzJDEuY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSFRNTDVIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIVE1MNUhpc3Rvcnk7XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICBwdXNoU3RhdGUoY2xlYW5QYXRoKHRoaXMkMS5iYXNlICsgcm91dGUuZnVsbFBhdGgpKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZVN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmVuc3VyZVVSTCA9IGZ1bmN0aW9uIGVuc3VyZVVSTCAocHVzaCkge1xuICAgIGlmIChnZXRMb2NhdGlvbih0aGlzLmJhc2UpICE9PSB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gY2xlYW5QYXRoKHRoaXMuYmFzZSArIHRoaXMuY3VycmVudC5mdWxsUGF0aCk7XG4gICAgICBwdXNoID8gcHVzaFN0YXRlKGN1cnJlbnQpIDogcmVwbGFjZVN0YXRlKGN1cnJlbnQpO1xuICAgIH1cbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldExvY2F0aW9uKHRoaXMuYmFzZSlcbiAgfTtcblxuICByZXR1cm4gSFRNTDVIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbmZ1bmN0aW9uIGdldExvY2F0aW9uIChiYXNlKSB7XG4gIHZhciBwYXRoID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICBpZiAoYmFzZSAmJiBwYXRoLmluZGV4T2YoYmFzZSkgPT09IDApIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZShiYXNlLmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyB3aW5kb3cubG9jYXRpb24uc2VhcmNoICsgd2luZG93LmxvY2F0aW9uLmhhc2hcbn1cblxuLyogICovXG5cblxudmFyIEhhc2hIaXN0b3J5ID0gKGZ1bmN0aW9uIChIaXN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIEhhc2hIaXN0b3J5IChyb3V0ZXIsIGJhc2UsIGZhbGxiYWNrKSB7XG4gICAgSGlzdG9yeSQkMS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgLy8gY2hlY2sgaGlzdG9yeSBmYWxsYmFjayBkZWVwbGlua2luZ1xuICAgIGlmIChmYWxsYmFjayAmJiBjaGVja0ZhbGxiYWNrKHRoaXMuYmFzZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbnN1cmVTbGFzaCgpO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgSGFzaEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIYXNoSGlzdG9yeTtcblxuICAvLyB0aGlzIGlzIGRlbGF5ZWQgdW50aWwgdGhlIGFwcCBtb3VudHNcbiAgLy8gdG8gYXZvaWQgdGhlIGhhc2hjaGFuZ2UgbGlzdGVuZXIgYmVpbmcgZmlyZWQgdG9vIGVhcmx5XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zZXR1cExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFlbnN1cmVTbGFzaCgpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcyQxLnRyYW5zaXRpb25UbyhnZXRIYXNoKCksIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaEhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudC5mdWxsUGF0aDtcbiAgICBpZiAoZ2V0SGFzaCgpICE9PSBjdXJyZW50KSB7XG4gICAgICBwdXNoID8gcHVzaEhhc2goY3VycmVudCkgOiByZXBsYWNlSGFzaChjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEhhc2goKVxuICB9O1xuXG4gIHJldHVybiBIYXNoSGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBjaGVja0ZhbGxiYWNrIChiYXNlKSB7XG4gIHZhciBsb2NhdGlvbiA9IGdldExvY2F0aW9uKGJhc2UpO1xuICBpZiAoIS9eXFwvIy8udGVzdChsb2NhdGlvbikpIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShcbiAgICAgIGNsZWFuUGF0aChiYXNlICsgJy8jJyArIGxvY2F0aW9uKVxuICAgICk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVTbGFzaCAoKSB7XG4gIHZhciBwYXRoID0gZ2V0SGFzaCgpO1xuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmVwbGFjZUhhc2goJy8nICsgcGF0aCk7XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZXRIYXNoICgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zbGljZShpbmRleCArIDEpXG59XG5cbmZ1bmN0aW9uIHB1c2hIYXNoIChwYXRoKSB7XG4gIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhhc2ggKHBhdGgpIHtcbiAgdmFyIGkgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKFxuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNsaWNlKDAsIGkgPj0gMCA/IGkgOiAwKSArICcjJyArIHBhdGhcbiAgKTtcbn1cblxuLyogICovXG5cblxudmFyIEFic3RyYWN0SGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBBYnN0cmFjdEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLmluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkkJDEgKSBBYnN0cmFjdEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeSQkMTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFic3RyYWN0SGlzdG9yeTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCArIDEpLmNvbmNhdChyb3V0ZSk7XG4gICAgICB0aGlzJDEuaW5kZXgrKztcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXgpLmNvbmNhdChyb3V0ZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHRhcmdldEluZGV4ID0gdGhpcy5pbmRleCArIG47XG4gICAgaWYgKHRhcmdldEluZGV4IDwgMCB8fCB0YXJnZXRJbmRleCA+PSB0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciByb3V0ZSA9IHRoaXMuc3RhY2tbdGFyZ2V0SW5kZXhdO1xuICAgIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5pbmRleCA9IHRhcmdldEluZGV4O1xuICAgICAgdGhpcyQxLnVwZGF0ZVJvdXRlKHJvdXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIGN1cnJlbnQgPyBjdXJyZW50LmZ1bGxQYXRoIDogJy8nXG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKCkge1xuICAgIC8vIG5vb3BcbiAgfTtcblxuICByZXR1cm4gQWJzdHJhY3RIaXN0b3J5O1xufShIaXN0b3J5KSk7XG5cbi8qICAqL1xuXG52YXIgVnVlUm91dGVyID0gZnVuY3Rpb24gVnVlUm91dGVyIChvcHRpb25zKSB7XG4gIGlmICggb3B0aW9ucyA9PT0gdm9pZCAwICkgb3B0aW9ucyA9IHt9O1xuXG4gIHRoaXMuYXBwID0gbnVsbDtcbiAgdGhpcy5hcHBzID0gW107XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuYmVmb3JlSG9va3MgPSBbXTtcbiAgdGhpcy5yZXNvbHZlSG9va3MgPSBbXTtcbiAgdGhpcy5hZnRlckhvb2tzID0gW107XG4gIHRoaXMubWF0Y2hlciA9IGNyZWF0ZU1hdGNoZXIob3B0aW9ucy5yb3V0ZXMgfHwgW10sIHRoaXMpO1xuXG4gIHZhciBtb2RlID0gb3B0aW9ucy5tb2RlIHx8ICdoYXNoJztcbiAgdGhpcy5mYWxsYmFjayA9IG1vZGUgPT09ICdoaXN0b3J5JyAmJiAhc3VwcG9ydHNQdXNoU3RhdGU7XG4gIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgbW9kZSA9ICdoYXNoJztcbiAgfVxuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIG1vZGUgPSAnYWJzdHJhY3QnO1xuICB9XG4gIHRoaXMubW9kZSA9IG1vZGU7XG5cbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSAnaGlzdG9yeSc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSFRNTDVIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhhc2hIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSwgdGhpcy5mYWxsYmFjayk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Fic3RyYWN0JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBBYnN0cmFjdEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgKFwiaW52YWxpZCBtb2RlOiBcIiArIG1vZGUpKTtcbiAgICAgIH1cbiAgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY3VycmVudFJvdXRlOiB7fSB9O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2ggKFxuICByYXcsXG4gIGN1cnJlbnQsXG4gIHJlZGlyZWN0ZWRGcm9tXG4pIHtcbiAgcmV0dXJuIHRoaXMubWF0Y2hlci5tYXRjaChyYXcsIGN1cnJlbnQsIHJlZGlyZWN0ZWRGcm9tKVxufTtcblxucHJvdG90eXBlQWNjZXNzb3JzLmN1cnJlbnRSb3V0ZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhpc3RvcnkgJiYgdGhpcy5oaXN0b3J5LmN1cnJlbnRcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKGFwcCAvKiBWdWUgY29tcG9uZW50IGluc3RhbmNlICovKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnQoXG4gICAgaW5zdGFsbC5pbnN0YWxsZWQsXG4gICAgXCJub3QgaW5zdGFsbGVkLiBNYWtlIHN1cmUgdG8gY2FsbCBgVnVlLnVzZShWdWVSb3V0ZXIpYCBcIiArXG4gICAgXCJiZWZvcmUgY3JlYXRpbmcgcm9vdCBpbnN0YW5jZS5cIlxuICApO1xuXG4gIHRoaXMuYXBwcy5wdXNoKGFwcCk7XG5cbiAgLy8gbWFpbiBhcHAgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgaWYgKHRoaXMuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmFwcCA9IGFwcDtcblxuICB2YXIgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcblxuICBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhUTUw1SGlzdG9yeSkge1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9IGVsc2UgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIYXNoSGlzdG9yeSkge1xuICAgIHZhciBzZXR1cEhhc2hMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhpc3Rvcnkuc2V0dXBMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKFxuICAgICAgaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSxcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXJcbiAgICApO1xuICB9XG5cbiAgaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgdGhpcyQxLmFwcHMuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7XG4gICAgICBhcHAuX3JvdXRlID0gcm91dGU7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmJlZm9yZUhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlUmVzb2x2ZSA9IGZ1bmN0aW9uIGJlZm9yZVJlc29sdmUgKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5yZXNvbHZlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiBhZnRlckVhY2ggKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5hZnRlckhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiLCBlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uRXJyb3IoZXJyb3JDYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucHVzaChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgdGhpcy5oaXN0b3J5LmdvKG4pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gYmFjayAoKSB7XG4gIHRoaXMuZ28oLTEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gZm9yd2FyZCAoKSB7XG4gIHRoaXMuZ28oMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdldE1hdGNoZWRDb21wb25lbnRzID0gZnVuY3Rpb24gZ2V0TWF0Y2hlZENvbXBvbmVudHMgKHRvKSB7XG4gIHZhciByb3V0ZSA9IHRvXG4gICAgPyB0by5tYXRjaGVkXG4gICAgICA/IHRvXG4gICAgICA6IHRoaXMucmVzb2x2ZSh0bykucm91dGVcbiAgICA6IHRoaXMuY3VycmVudFJvdXRlO1xuICBpZiAoIXJvdXRlKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgcm91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG0uY29tcG9uZW50c1trZXldXG4gICAgfSlcbiAgfSkpXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChcbiAgdG8sXG4gIGN1cnJlbnQsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKFxuICAgIHRvLFxuICAgIGN1cnJlbnQgfHwgdGhpcy5oaXN0b3J5LmN1cnJlbnQsXG4gICAgYXBwZW5kLFxuICAgIHRoaXNcbiAgKTtcbiAgdmFyIHJvdXRlID0gdGhpcy5tYXRjaChsb2NhdGlvbiwgY3VycmVudCk7XG4gIHZhciBmdWxsUGF0aCA9IHJvdXRlLnJlZGlyZWN0ZWRGcm9tIHx8IHJvdXRlLmZ1bGxQYXRoO1xuICB2YXIgYmFzZSA9IHRoaXMuaGlzdG9yeS5iYXNlO1xuICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYoYmFzZSwgZnVsbFBhdGgsIHRoaXMubW9kZSk7XG4gIHJldHVybiB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHJvdXRlOiByb3V0ZSxcbiAgICBocmVmOiBocmVmLFxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgbm9ybWFsaXplZFRvOiBsb2NhdGlvbixcbiAgICByZXNvbHZlZDogcm91dGVcbiAgfVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZGRSb3V0ZXMgPSBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICB0aGlzLm1hdGNoZXIuYWRkUm91dGVzKHJvdXRlcyk7XG4gIGlmICh0aGlzLmhpc3RvcnkuY3VycmVudCAhPT0gU1RBUlQpIHtcbiAgICB0aGlzLmhpc3RvcnkudHJhbnNpdGlvblRvKHRoaXMuaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWdWVSb3V0ZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJIb29rIChsaXN0LCBmbikge1xuICBsaXN0LnB1c2goZm4pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gbGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7IGxpc3Quc3BsaWNlKGksIDEpOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSHJlZiAoYmFzZSwgZnVsbFBhdGgsIG1vZGUpIHtcbiAgdmFyIHBhdGggPSBtb2RlID09PSAnaGFzaCcgPyAnIycgKyBmdWxsUGF0aCA6IGZ1bGxQYXRoO1xuICByZXR1cm4gYmFzZSA/IGNsZWFuUGF0aChiYXNlICsgJy8nICsgcGF0aCkgOiBwYXRoXG59XG5cblZ1ZVJvdXRlci5pbnN0YWxsID0gaW5zdGFsbDtcblZ1ZVJvdXRlci52ZXJzaW9uID0gJzIuNS4zJztcblxuaWYgKGluQnJvd3NlciAmJiB3aW5kb3cuVnVlKSB7XG4gIHdpbmRvdy5WdWUudXNlKFZ1ZVJvdXRlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZVJvdXRlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuZXNtLmpzIiwiLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBsaXN0IGZvcm1hdCBwcm9kdWNlZCBieSBjc3MtbG9hZGVyIGludG8gc29tZXRoaW5nXG4gKiBlYXNpZXIgdG8gbWFuaXB1bGF0ZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaXN0VG9TdHlsZXMgKHBhcmVudElkLCBsaXN0KSB7XG4gIHZhciBzdHlsZXMgPSBbXVxuICB2YXIgbmV3U3R5bGVzID0ge31cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgdmFyIGlkID0gaXRlbVswXVxuICAgIHZhciBjc3MgPSBpdGVtWzFdXG4gICAgdmFyIG1lZGlhID0gaXRlbVsyXVxuICAgIHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdXG4gICAgdmFyIHBhcnQgPSB7XG4gICAgICBpZDogcGFyZW50SWQgKyAnOicgKyBpLFxuICAgICAgY3NzOiBjc3MsXG4gICAgICBtZWRpYTogbWVkaWEsXG4gICAgICBzb3VyY2VNYXA6IHNvdXJjZU1hcFxuICAgIH1cbiAgICBpZiAoIW5ld1N0eWxlc1tpZF0pIHtcbiAgICAgIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7IGlkOiBpZCwgcGFydHM6IFtwYXJ0XSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLnBvaW50c2JhY2s6IHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxuICBjb2xvcjogI2ZmMzg2MDtcXG59XFxuLmxlYWRlcmJvYXJkIHtcXG4gIG1hcmdpbi10b3A6IDUwcHg7XFxufVxcbnRhYmxlIHRkLCB0aCB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXIgIWltcG9ydGFudDtcXG59XFxuLmxlYWRlcmJvYXJkLW1haW4ge1xcbiAgbWFyZ2luLXRvcDogMjVweDtcXG59XFxuLmxlYWRlcmJvYXJkLXRpdGxlIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9Vc2Vycy9TZXRoL1Byb2plY3RzL2ZhbnRhc3lteDIvY2xpZW50L2NvbXBvbmVudHMvbGVhZGVyYm9hcmQudnVlPzhhMzY1Yjg0XCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUEwSEE7RUFDQSxvQkFBQTtFQUNBLGVBQUE7Q0FDQTtBQUNBO0VBQ0EsaUJBQUE7Q0FDQTtBQUNBO0VBQ0EsOEJBQUE7Q0FDQTtBQUNBO0VBQ0EsaUJBQUE7Q0FDQTtBQUNBO0VBQ0EsbUJBQUE7RUFDQSwyQkFBQTtFQUNBLGlCQUFBO0NBQ0FcIixcImZpbGVcIjpcImxlYWRlcmJvYXJkLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8ZGl2PlxcbiAgPGRpdiBjbGFzcz1cXFwibGVhZGVyYm9hcmQtdGl0bGVcXFwiPlxcbiAgICAyMDE4IEZhbnRhc3lTWCBNYWluIExlYWd1ZVxcbiAgPC9kaXY+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb2x1bW5zIGxlYWRlcmJvYXJkXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiY29sdW1uIGlzLWhhbGYgaXMtb2Zmc2V0LW9uZS1xdWFydGVyXFxcIj5cXG4gICAgICA8dGFibGUgY2xhc3M9XFxcInRhYmxlIGlzLXN0cmlwZWRcXFwiIHYtaWY9XFxcImRvbmVMb2FkaW5nXFxcIj5cXG4gICAgICAgIDx0aGVhZD5cXG4gICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgIDx0aD5Qb3NpdGlvbjwvdGg+XFxuICAgICAgICAgICAgPHRoPlRvdGFsIFBvaW50czwvdGg+XFxuICAgICAgICAgICAgPHRoPlVzZXJuYW1lPC90aD5cXG4gICAgICAgICAgICA8dGg+UG9pbnRzIEJhY2s8L3RoPlxcbiAgICAgICAgICA8L3RyPlxcbiAgICAgICAgPC90aGVhZD5cXG4gICAgICAgIDx0Zm9vdD5cXG4gICAgICAgICAgPHRyPlxcbiAgICAgICAgICAgIDx0aD5Qb3NpdGlvbjwvdGg+XFxuICAgICAgICAgICAgPHRoPlRvdGFsIFBvaW50czwvdGg+XFxuICAgICAgICAgICAgPHRoPlVzZXJuYW1lPC90aD5cXG4gICAgICAgICAgICA8dGg+UG9pbnRzIEJhY2s8L3RoPlxcbiAgICAgICAgICA8L3RyPlxcbiAgICAgICAgPC90Zm9vdD5cXG4gICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgPHRyIHYtZm9yPVxcXCIodXNlciwgaW5kZXgpIGluIHN0YW5kaW5nc1xcXCI+XFxuICAgICAgICAgICAgPHRkPnt7IGluZGV4ICsgMSB9fS48L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e3VzZXIudG90YWxwb2ludHN9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7dXNlci53ZWVrbHl0ZWFtc1swXS51c2VybmFtZX19PC90ZD5cXG4gICAgICAgICAgICA8dGQgY2xhc3M9XFxcInBvaW50c2JhY2tcXFwiPnt7IHBvaW50c2JlaGluZCh1c2VyKSB9fTwvdGQ+XFxuICAgICAgICAgIDwvdHI+XFxuICAgICAgICA8L3Rib2R5PlxcbiAgICAgIDwvdGFibGU+XFxuICAgICAgPGRpdiB2LWlmPVxcXCIhZG9uZUxvYWRpbmdcXFwiPlxcbiAgICAgICAgPHA+XFxcIlRoaXMgZGF0YSBkb2Vzbid0IGZldGNoIGl0c2VsZi4uIExvYWRpbmcgUmFjZSBUcmFja2VyLlxcXCI8L3A+XFxuICAgICAgPC9kaXY+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG48c2NyaXB0PlxcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XFxuICBleHBvcnQgZGVmYXVsdCB7XFxuICAgIGRhdGEoKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGRvbmVMb2FkaW5nOiBmYWxzZSxcXG4gICAgICAgIHJlc3VsdHM6IFtdLFxcbiAgICAgICAgbWFpbkxlYWd1ZVVzZXJzOiBbXSxcXG4gICAgICAgIHdlZWtseXRlYW1zOiBbXVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcHV0ZWQ6IHtcXG4gICAgICBzdGFuZGluZ3M6IGZ1bmN0aW9uKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbkxlYWd1ZVVzZXJzLnNvcnQoKGEsIGIpID0+IHtcXG4gICAgICAgICAgdmFyIGFQb2ludHMgPSAwO1xcbiAgICAgICAgICB2YXIgYlBvaW50cyA9IDA7XFxuICAgICAgICAgIGEud2Vla2x5dGVhbXMuZm9yRWFjaCh0ZWFtID0+IHsgYVBvaW50cyArPSB0ZWFtLnBsYWNlIH0pXFxuICAgICAgICAgIGIud2Vla2x5dGVhbXMuZm9yRWFjaCh0ZWFtID0+IHsgYlBvaW50cyArPSB0ZWFtLnBsYWNlIH0pXFxuICAgICAgICAgIHJldHVybiBhUG9pbnRzIC0gYlBvaW50cztcXG4gICAgICAgIH0pXFxuICAgICAgfSxcXG4gICAgICBuZXdzdGFuZGluZ3M6IGZ1bmN0aW9uKCkge1xcblxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgY3JlYXRlZCgpIHtcXG4gICAgICBheGlvcy5nZXQoJy9NYWluTGVhZ3VlU3RhbmRpbmdzJylcXG4gICAgICAudGhlbihkYXRhID0+IHtcXG4gICAgICAgIHRoaXMubWFpbkxlYWd1ZVVzZXJzID0gZGF0YS5kYXRhO1xcbiAgICAgICAgdGhpcy5tYWluTGVhZ3VlVXNlcnMuZm9yRWFjaCgodXNlcikgPT4ge1xcbiAgICAgICAgICB1c2VyLnRvdGFscG9pbnRzID0gMFxcbiAgICAgICAgICB1c2VyLndlZWtseXRlYW1zLmZvckVhY2god3QgPT4geyB1c2VyLnRvdGFscG9pbnRzICs9IHd0LnBsYWNlIH0pXFxuICAgICAgICAgIHVzZXIud2Vla2x5dGVhbXMuc29ydCgoYSwgYikgPT4ge1xcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH0pXFxuICAgICAgICB0aGlzLmRvbmVMb2FkaW5nID0gdHJ1ZTtcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgcG9pbnRzYmVoaW5kOiBmdW5jdGlvbih1c2VyKSB7XFxuICAgICAgICB2YXIgb2JqSW5kZXggPSB0aGlzLnN0YW5kaW5ncy5pbmRleE9mKHVzZXIpO1xcbiAgICAgICAgaWYgKG9iakluZGV4ICE9IDApIHtcXG4gICAgICAgICAgcmV0dXJuIHVzZXIudG90YWxwb2ludHMgLSB0aGlzLnN0YW5kaW5nc1swXS50b3RhbHBvaW50cztcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAnLSdcXG4gICAgICB9XFxuICAgIH1cXG4gICAgLy8gYmVmb3JlQ3JlYXRlKCkge1xcbiAgICAvLyAgICBzZXRUaW1lb3V0KCgpID0+IHtcXG4gICAgLy8gICAgICBheGlvcy5nZXQoJy9SYWNlUmVzdWx0cycpXFxuICAgIC8vICAgICAgLnRoZW4oZGF0YSA9PiB7XFxuICAgIC8vICAgICAgICBjb25zb2xlLnRpbWUoKTtcXG4gICAgLy8gICAgICAgIHZhciByZXN1bHRzID0gZGF0YS5kYXRhLkI7XFxuICAgIC8vICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHRzKTtcXG4gICAgLy8gICAgICAgIHRoaXMubWFpbkxlYWd1ZVVzZXJzLmZvckVhY2godXNlciA9PiB7XFxuICAgIC8vICAgICAgICAgIHVzZXIudG90YWxwb2ludHMgPSAwO1xcbiAgICAvLyAgICAgICAgICB1c2VyLnJpZGVycy5mb3JFYWNoKHJpZGVyID0+IHtcXG4gICAgLy8gICAgICAgICAgICByZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcXG4gICAgLy8gICAgICAgICAgICAgIGlmIChyZXN1bHQuRi5zbGljZSgwLCAtMSkgPT0gcmlkZXIubmFtZSkge1xcbiAgICAvLyAgICAgICAgICAgICAgICByaWRlci5wb2ludHMgPSByZXN1bHQuQTtcXG4gICAgLy8gICAgICAgICAgICAgIH1cXG4gICAgLy8gICAgICAgICAgICB9KVxcbiAgICAvLyAgICAgICAgICAgIHVzZXIudG90YWxwb2ludHMgKz0gcmlkZXIucG9pbnRzO1xcbiAgICAvLyAgICAgICAgICB9KVxcbiAgICAvLyAgICAgICAgfSlcXG4gICAgLy8gICAgICAgY29uc29sZS50aW1lRW5kKCk7XFxuICAgIC8vICAgICAgIHRoaXMuZG9uZUxvYWRpbmcgPSB0cnVlO1xcbiAgICAvLyAgICAgICBjb25zb2xlLmxvZyh0aGlzLm1haW5MZWFndWVVc2VycylcXG4gICAgLy8gICAgIH0pXFxuICAgIC8vICAgIH0sIDMwMDApO1xcbiAgICAvLyAgIGF4aW9zLmdldCgnL2dldE1haW5MZWFndWVJbmZvJylcXG4gICAgLy8gICAudGhlbihkYXRhID0+IHtcXG4gICAgLy8gICAgIGNvbnNvbGUubG9nKGRhdGEuZGF0YSk7XFxuICAgIC8vICAgICBkYXRhLmRhdGEuZm9yRWFjaCh1c2VyID0+IHtcXG4gICAgLy8gICAgICAgdGhpcy5tYWluTGVhZ3VlVXNlcnMucHVzaCh1c2VyKVxcbiAgICAvLyAgICAgfSlcXG4gICAgLy8gICB9KVxcbiAgICAvLyB9XFxuICB9XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbiAgLnBvaW50c2JhY2s6IHtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gICAgY29sb3I6ICNmZjM4NjA7XFxuICB9XFxuICAubGVhZGVyYm9hcmQge1xcbiAgICBtYXJnaW4tdG9wOiA1MHB4O1xcbiAgfVxcbiAgdGFibGUgdGQsIHRoIHtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyICFpbXBvcnRhbnQ7XFxuICB9XFxuICAubGVhZGVyYm9hcmQtbWFpbiB7XFxuICAgIG1hcmdpbi10b3A6IDI1cHg7XFxuICB9XFxuICAubGVhZGVyYm9hcmQtdGl0bGUge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgICBmb250LXdlaWdodDogNzAwO1xcbiAgfVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtMGNiYjAyYzhcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbGVhZGVyYm9hcmQudnVlXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5lcnJvck1lc3NhZ2Uge1xcbiAgY29sb3I6ICNmZjM4NjA7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMvU2V0aC9Qcm9qZWN0cy9mYW50YXN5bXgyL2NsaWVudC9jb21wb25lbnRzL3JlZ2lzdGVyLnZ1ZT9iZTEwODZkMlwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBOElBO0VBQ0EsZUFBQTtDQUNBXCIsXCJmaWxlXCI6XCJyZWdpc3Rlci52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgPGRpdiBjbGFzcz1cXFwibW9kYWxcXFwiIHYtYmluZDpjbGFzcz1cXFwieydpcy1hY3RpdmUnOiBTaG93UmVnaXN0ZXJNb2RhbH1cXFwiIGlkPVxcXCJyZWdpc3Rlck1vZGFsXFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwibW9kYWwtYmFja2dyb3VuZFxcXCI+PC9kaXY+XFxuICAgIDxkaXYgY2xhc3M9XFxcIm1vZGFsLWNhcmRcXFwiPlxcbiAgICAgIDxoZWFkZXIgY2xhc3M9XFxcIm1vZGFsLWNhcmQtaGVhZFxcXCI+XFxuICAgICAgICA8cCBjbGFzcz1cXFwibW9kYWwtY2FyZC10aXRsZVxcXCI+TmV3IFVzZXIgUmVnaXN0cmF0aW9uPC9wPlxcbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiZGVsZXRlXFxcIiBAY2xpY2s9XFxcInNldFJlZ2lzdGVyTW9kYWwoeyBzaG93OiAhU2hvd1JlZ2lzdGVyTW9kYWx9KVxcXCI+PC9idXR0b24+XFxuICAgICAgPC9oZWFkZXI+XFxuICAgICAgPHNlY3Rpb24gY2xhc3M9XFxcIm1vZGFsLWNhcmQtYm9keVxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50XFxcIj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZFxcXCI+XFxuICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XFxcImxhYmVsXFxcIj5Vc2VybmFtZTogPC9sYWJlbD5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRyb2wgaGFzLWljb25zLWxlZnRcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGV4dFxcXCIgY2xhc3M9XFxcImlucHV0XFxcIiB2LWJpbmQ6Y2xhc3M9XFxcInsgJ2lzLWRhbmdlcic6IGludmFsaWRVc2VybmFtZSB9XFxcIiBpZD1cXFwicmVnLXVzZXJuYW1lXFxcIiB2LW1vZGVsPVxcXCJ1c2VybmFtZVxcXCIgcGxhY2Vob2xkZXI9XFxcIlVzZXJuYW1lXFxcIiByZXF1aXJlZD5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24gaXMtc21hbGwgaXMtbGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXVzZXJcXFwiPjwvaT5cXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZmllbGRcXFwiPlxcbiAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVxcXCJsYWJlbFxcXCI+RW1haWw6IDwvbGFiZWw+XFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XFxcIj5cXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImVtYWlsXFxcIiBjbGFzcz1cXFwiaW5wdXRcXFwiIHYtYmluZDpjbGFzcz1cXFwieyAnaXMtZGFuZ2VyJzogaW52YWxpZEVtYWlsIH1cXFwiICBpZD1cXFwicmVnLWVtYWlsXFxcIiB2LW1vZGVsPVxcXCJlbWFpbFxcXCIgcGxhY2Vob2xkZXI9XFxcIkVtYWlsXFxcIiByZXF1aXJlZD5cXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb24gaXMtc21hbGwgaXMtbGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWVudmVsb3BlXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz1cXFwibGFiZWxcXFwiPlBhc3N3b3JkOiA8L2xhYmVsPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJwYXNzd29yZFxcXCIgY2xhc3M9XFxcImlucHV0XFxcIiB2LWJpbmQ6Y2xhc3M9XFxcInsgJ2lzLWRhbmdlcic6IGJsYW5rUGFzc3dvcmQgfVxcXCIgaWQ9XFxcInJlZy1wYXNzd29yZFxcXCIgdi1tb2RlbD1cXFwicGFzc3dvcmRcXFwiIHBsYWNlaG9sZGVyPVxcXCJQYXNzd29yZFxcXCIgcmVxdWlyZWQ+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1sb2NrXFxcIj48L2k+XFxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImZpZWxkXFxcIj5cXG4gICAgICAgICAgICAgIFJFQ0FQVENIQSBQTEFDRUhPTERFUlxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImVycm9yTWVzc2FnZVxcXCIgdi1mb3I9XFxcImVycm9yIGluIGVycm9yTWVzc2FnZVxcXCIgdi1pZj1cXFwiZXJyb3JNZXNzYWdlICE9ICcnXFxcIj5cXG4gICAgICAgICAgICAgIHt7IGVycm9yIH19XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L3NlY3Rpb24+XFxuICAgICAgPGZvb3RlciBjbGFzcz1cXFwibW9kYWwtY2FyZC1mb290XFxcIj5cXG4gICAgICAgIDxhIGNsYXNzPVxcXCJidXR0b24gaXMtc3VjY2Vzc1xcXCIgQGNsaWNrPVxcXCJSZWdpc3RlclxcXCIgdi1iaW5kOmNsYXNzPVxcXCJ7ICdpcy1sb2FkaW5nJzogaXNMb2FkaW5nIH1cXFwiPlJlZ2lzdGVyPC9hPlxcbiAgICAgICAgPGEgY2xhc3M9XFxcImJ1dHRvblxcXCIgQGNsaWNrPVxcXCJzZXRSZWdpc3Rlck1vZGFsKHsgc2hvdzogIVNob3dSZWdpc3Rlck1vZGFsIH0pXFxcIj5DYW5jZWw8L2E+XFxuICAgICAgPC9mb290ZXI+XFxuICAgIDwvZGl2PlxcbiAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c2NyaXB0PlxcbmltcG9ydCB7IG1hcEdldHRlcnMsIG1hcE11dGF0aW9ucyB9IGZyb20gJ3Z1ZXgnO1xcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XFxuICBleHBvcnQgZGVmYXVsdCB7XFxuICAgIGRhdGEoKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHVzZXJuYW1lOiAnJyxcXG4gICAgICAgIGVtYWlsOiAnJyxcXG4gICAgICAgIHBhc3N3b3JkOiAnJyxcXG4gICAgICAgIGVycm9yTWVzc2FnZTogW10sXFxuICAgICAgICBpbnZhbGlkVXNlcm5hbWU6IGZhbHNlLFxcbiAgICAgICAgaW52YWxpZEVtYWlsOiBmYWxzZSxcXG4gICAgICAgIGJsYW5rUGFzc3dvcmQ6IGZhbHNlLFxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZVxcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgY29tcHV0ZWQ6IG1hcEdldHRlcnMoW1xcbiAgICAgICdTaG93UmVnaXN0ZXJNb2RhbCcsXFxuICAgICAgJ2dldFVzZXJEYXRhJ1xcbiAgICBdKSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgIC4uLm1hcE11dGF0aW9ucyhbXFxuICAgICAgICAnc2V0UmVnaXN0ZXJNb2RhbCcsXFxuICAgICAgICAnc2V0VXNlckRhdGEnLFxcbiAgICAgICAgJ3NldExvZ2dlZEluJ1xcbiAgICAgIF0pLFxcbiAgICAgIFJlZ2lzdGVyKCkge1xcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSBbXTtcXG4gICAgICAgIHRoaXMuaW52YWxpZEVtYWlsID0gZmFsc2U7XFxuICAgICAgICB0aGlzLmJsYW5rUGFzc3dvcmQgPSBmYWxzZTtcXG4gICAgICAgIHRoaXMuaW52YWxpZFVzZXJuYW1lID0gZmFsc2U7XFxuICAgICAgICBpZiAodGhpcy5SZWdpc3RyYXRpb25Jc1ZhbGlkKCkpIHtcXG5cXG4gICAgICAgICAgYXhpb3MucG9zdCgnL3JlZ2lzdGVyJywge1xcbiAgICAgICAgICAgIHVzZXJuYW1lOiB0aGlzLnVzZXJuYW1lLFxcbiAgICAgICAgICAgIGVtYWlsOiB0aGlzLmVtYWlsLFxcbiAgICAgICAgICAgIHBhc3N3b3JkOiB0aGlzLnBhc3N3b3JkXFxuICAgICAgICAgIH0pLnRoZW4oZGF0YSA9PiB7XFxuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XFxuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcXG4gICAgICAgICAgICB2YXIgaXNGYWxzZSA9ICFkYXRhLmRhdGEuRXJyb3JNZXNzYWdlO1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJpc0ZhbHNlXFxcIiwgaXNGYWxzZSlcXG4gICAgICAgICAgICBpZiAoIWRhdGEuZGF0YS5FcnJvck1lc3NhZ2UpIHtcXG4gICAgICAgICAgICAgIHRoaXMuc2V0VXNlckRhdGEoeyB1c2VyRGF0YTogZGF0YS5kYXRhIH0pXFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiZ2V0VXNlckRhdGFcXFwiLCB0aGlzLmdldFVzZXJEYXRhKVxcbiAgICAgICAgICAgICAgdGhpcy5zZXRSZWdpc3Rlck1vZGFsKHsgc2hvdzogZmFsc2UgfSlcXG4gICAgICAgICAgICAgIHRoaXMuc2V0TG9nZ2VkSW4oeyBsb2dnZWRJbjogdHJ1ZSB9KVxcbiAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy4kc3RvcmUuc3RhdGUpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZS5wdXNoKGRhdGEuZGF0YS5FcnJvck1lc3NhZ2UpO1xcbiAgICAgICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UuZm9yRWFjaChtc2cgPT4ge1xcbiAgICAgICAgICAgICAgICBpZiAobXNnLmluZGV4T2YoXFxcIlVzZXJuYW1lXFxcIikgPiAtMSkge1xcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZFVzZXJuYW1lID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBpZiAobXNnLmluZGV4T2YoXFxcIkVtYWlsXFxcIikgPi0xKSB7XFxuICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkRW1haWwgPSB0cnVlO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSlcXG5cXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIFJlZ2lzdHJhdGlvbklzVmFsaWQoKSB7XFxuICAgICAgICB2YXIgZW1haWxWYWxpZGF0aW9uID0gdGhpcy5lbWFpbC5tYXRjaChuZXcgUmVnRXhwKC9eKChbXjw+KClcXFxcW1xcXFxdXFxcXFxcXFwuLDs6XFxcXHNAXFxcIl0rKFxcXFwuW148PigpXFxcXFtcXFxcXVxcXFxcXFxcLiw7OlxcXFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxcXFtbMC05XXsxLDN9XFxcXC5bMC05XXsxLDN9XFxcXC5bMC05XXsxLDN9XFxcXC5bMC05XXsxLDN9XSl8KChbYS16QS1aXFxcXC0wLTldK1xcXFwuKStbYS16QS1aXXsyLH0pKSQvKSwgXFxcImlcXFwiKTtcXG4gICAgICAgIGNvbnNvbGUubG9nKGVtYWlsVmFsaWRhdGlvbik7XFxuICAgICAgICBpZiAodGhpcy5lbWFpbCA9PSBcXFwiXFxcIikge1xcbiAgICAgICAgICB0aGlzLmVycm9yTWVzc2FnZS5wdXNoKFxcXCJVc2VybmFtZSBjYW5ub3QgYmUgbGVmdCBlbXB0eS5cXFwiKVxcbiAgICAgICAgICB0aGlzLmludmFsaWRVc2VybmFtZSA9IHRydWU7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoZW1haWxWYWxpZGF0aW9uID09IG51bGwpIHtcXG4gICAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UucHVzaChcXFwiUGxlYXNlIGVudGVyIGEgdmFsaWQgZW1haWwuXFxcIilcXG4gICAgICAgICAgdGhpcy5pbnZhbGlkRW1haWwgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMucGFzc3dvcmQgPT0gJycgfHwgdGhpcy5wYXNzd29yZC5sZW5ndGggPCA2KSB7XFxuICAgICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlLnB1c2goXFxcIlBhc3N3b3JkIGNhbm5vdCBiZSBsZWZ0IGVtcHR5IGFuZCBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycy5cXFwiKVxcbiAgICAgICAgICB0aGlzLmJsYW5rUGFzc3dvcmQgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JNZXNzYWdlLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbiAgLmVycm9yTWVzc2FnZSB7XFxuICAgIGNvbG9yOiAjZmYzODYwO1xcbiAgfVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtMWFkMDZkNjhcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvcmVnaXN0ZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAxOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5yaWRlcnMtY29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuLnJpZGVyLWJsb2NrIHtcXG4gIG1pbi13aWR0aDogMTVyZW07XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZGVkZWRlO1xcbiAgbWFyZ2luOiAxcmVtO1xcbiAgYm94LXNoYWRvdzogMXB4IDFweCAxcHggI2NlY2VjZTtcXG4gIHBhZGRpbmc6IDFyZW07XFxuICBtYXgtd2lkdGg6IDE1cmVtO1xcbn1cXG4ucGFnZS10aXRsZSB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcbi5wYWdlLXRpdGxlIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXG59XFxuLnBhZ2Utc3ViaGVhZGVyIHtcXG4gIHRleHQtYWxpZ246Y2VudGVyO1xcbn1cXG4uY2FyZC1mb290ZXIge1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxufVxcbi5jYXJkLWNvbnRlbnQge1xcbiAgbWluLWhlaWdodDogMTFyZW07XFxuICBtYXgtaGVpZ2h0OiAxMXJlbTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbn1cXG4uY2FyZC1mb290ZXIgZGl2Om50aC1jaGlsZChldmVuKSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbn1cXG4uZm9vdGVyLXJvdyB7XFxuICBkaXNwbGF5OmZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcbnAuY2FyZC1oZWFkZXItdGl0bGUge1xcbiAgZGlzcGxheTpmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxufVxcbnAgc3Bhbi5pY29uIHtcXG4gIGNvbG9yOiAjZmYzODYwO1xcbn1cXG50aDpob3ZlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcbi5zYXZlLWJ1dHRvbiB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxufVxcbi5oaWRlLXBhZ2luYXRpb24tYnV0dG9uIHtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcXG59XFxuLmN1c3RvbS1wYWdpbmF0aW9uIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMvU2V0aC9Qcm9qZWN0cy9mYW50YXN5bXgyL2NsaWVudC9jb21wb25lbnRzL215dGVhbS52dWU/NzVkMzVkMmFcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQStOQTtFQUNBLGNBQUE7RUFDQSxnQkFBQTtFQUNBLHdCQUFBO0NBQ0E7QUFDQTtFQUNBLGlCQUFBO0VBQ0EsMEJBQUE7RUFDQSxhQUFBO0VBQ0EsZ0NBQUE7RUFDQSxjQUFBO0VBQ0EsaUJBQUE7Q0FDQTtBQUNBO0VBQ0EsbUJBQUE7RUFDQSwyQkFBQTtFQUNBLGlCQUFBO0NBQ0E7QUFDQTtFQUNBLG1CQUFBO0VBQ0EsMkJBQUE7RUFDQSxpQkFBQTtDQUNBO0FBQ0E7RUFDQSxrQkFBQTtDQUNBO0FBQ0E7RUFDQSx1QkFBQTtFQUNBLHVCQUFBO0NBQ0E7QUFDQTtFQUNBLGtCQUFBO0VBQ0Esa0JBQUE7RUFDQSxpQkFBQTtFQUNBLG9CQUFBO0NBQ0E7QUFDQTtFQUNBLHVCQUFBO0NBQ0E7QUFDQTtFQUNBLGFBQUE7RUFDQSwrQkFBQTtDQUNBO0FBQ0E7RUFDQSxhQUFBO0VBQ0EsOEJBQUE7Q0FDQTtBQUNBO0VBQ0EsZUFBQTtDQUNBO0FBQ0E7RUFDQSxnQkFBQTtDQUNBO0FBQ0E7RUFDQSxnQkFBQTtDQUNBO0FBQ0E7RUFDQSxtQkFBQTtDQUNBO0FBQ0E7RUFDQSxjQUFBO0VBQ0EsK0JBQUE7Q0FDQVwiLFwiZmlsZVwiOlwibXl0ZWFtLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8ZGl2IGNsYXNzPVxcXCJjb250ZW50XFxcIj5cXG4gICAgPGRpdiBjbGFzcz1cXFwicGFnZS10aXRsZVxcXCI+TVkgVEVBTSAtIFRFQU0gU0VMRUNUSU9OIEZPUiBXRUVLIHt7IGN1cnJlbnR3ZWVrIH19PC9kaXY+XFxuICAgIDxhIGNsYXNzPVxcXCJidXR0b24gaXMtc3VjY2VzcyBzYXZlLWJ1dHRvblxcXCIgQGNsaWNrPVxcXCJTYXZlVGVhbVxcXCI+U2F2ZSBUZWFtPC9hPlxcbiAgICA8cCBjbGFzcz1cXFwicGFnZS1zdWJoZWFkZXJcXFwiPldlZWsge3sgY3VycmVudHdlZWsgfX0gQmFsYW5jZTogJHt7ZG9sbGFyc319PC9wPlxcbiAgICA8IS0tIDxkaXYgY2xhc3M9XFxcInJpZGVycy1jb250YWluZXJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmQgcmlkZXItYmxvY2tcXFwiIHYtZm9yPVxcXCJyaWRlciBpbiBzZWxlY3RlZHJpZGVyc1xcXCI+XFxuICAgICAgICA8aGVhZGVyIGNsYXNzPVxcXCJjYXJkLWhlYWRlclxcXCI+XFxuICAgICAgICAgIDxwIGNsYXNzPVxcXCJjYXJkLWhlYWRlci10aXRsZVxcXCI+XFxuICAgICAgICAgICAge3tyaWRlci5uYW1lfX0gLSB7e3JpZGVyLnJpZGVyX251bWJlcn19XFxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvblxcXCIgdi1pZj1cXFwicmlkZXIubmFtZSAhPT0gJ09QRU4gU0xPVCdcXFwiIEBjbGljaz1cXFwicmVtb3ZlUmFjZXIocmlkZXIpXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXRpbWVzXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICA8L3A+XFxuICAgICAgICA8L2hlYWRlcj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImNhcmQtY29udGVudFxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgIDxpbWcgOnNyYz1cXFwicmlkZXIuYXZhdGFyX3VybFxcXCIgLz5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxmb290ZXIgY2xhc3M9XFxcImNhcmQtZm9vdGVyXFxcIj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9vdGVyLXJvd1xcXCI+XFxuICAgICAgICAgICAgQ29zdDogPHNwYW4+JHt7cmlkZXIuY29zdH19PC9zcGFuPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZm9vdGVyLXJvd1xcXCI+XFxuICAgICAgICAgICAgQXZnIEZpbmlzaDogPHNwYW4+e3tyaWRlci5hdmVyYWdlRmluaXNofX08L3NwYW4+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb290ZXItcm93XFxcIj5cXG4gICAgICAgICAgICBIaWdoZXN0IEZpbmlzaDogPHNwYW4+e3tyaWRlci5oaWdoZXN0RmluaXNofX08L3NwYW4+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmb290ZXItcm93XFxcIj5cXG4gICAgICAgICAgICBMb3dlc3QgRmluaXNoOiA8c3Bhbj57e3JpZGVyLmxvd2VzdEZpbmlzaH19PC9zcGFuPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZm9vdGVyPlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gICAgPHAgY2xhc3M9XFxcInBhZ2UtdGl0bGVcXFwiPkFWQUlMQUJMRSBSSURFUlM8L3A+IC0tPlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiPlxcbiAgICAgIDx0YWJsZSBjbGFzcz1cXFwidGFibGUgaXMtc3RyaXBlZFxcXCI+XFxuICAgICAgICA8dGhlYWQ+XFxuICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICA8dGggQGNsaWNrPVxcXCJzb3J0QnlQcmljZVxcXCI+UHJpY2VcXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj5cXG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWNhcmV0LXVwXFxcIiB2LWlmPVxcXCJDb3N0U29ydEJ5QXNjXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9pPlxcbiAgICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtY2FyZXQtZG93blxcXCIgdi1lbHNlIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L2k+XFxuICAgICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgPC90aD5cXG4gICAgICAgICAgICA8dGg+UmFjZXIgTmFtZTwvdGg+XFxuICAgICAgICAgICAgPHRoPlJhY2VyIE51bWJlcjwvdGg+XFxuICAgICAgICAgICAgPHRoPkhpZ2hlc3QgRmluaXNoPC90aD5cXG4gICAgICAgICAgICA8dGg+TG93ZXN0IEZpbmlzaDwvdGg+XFxuICAgICAgICAgICAgPHRoPkF2ZXJhZ2UgRmluaXNoPC90aD5cXG4gICAgICAgICAgICA8dGg+QWN0aW9uPC90aD5cXG4gICAgICAgICAgPC90cj5cXG4gICAgICAgIDwvdGhlYWQ+XFxuICAgICAgICA8dGZvb3Q+XFxuICAgICAgICAgIDx0cj5cXG4gICAgICAgICAgICA8dGg+UHJpY2U8L3RoPlxcbiAgICAgICAgICAgIDx0aD5SYWNlciBOYW1lPC90aD5cXG4gICAgICAgICAgICA8dGg+UmFjZXIgTnVtYmVyPC90aD5cXG4gICAgICAgICAgICA8dGg+SGlnaGVzdCBGaW5pc2g8L3RoPlxcbiAgICAgICAgICAgIDx0aD5Mb3dlc3QgRmluaXNoPC90aD5cXG4gICAgICAgICAgICA8dGg+QXZlcmFnZSBGaW5pc2g8L3RoPlxcbiAgICAgICAgICAgIDx0aD5BY3Rpb248L3RoPlxcbiAgICAgICAgICA8L3RyPlxcbiAgICAgICAgPC90Zm9vdD5cXG4gICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgPHRyIHYtZm9yPVxcXCJyaWRlciBpbiBwYWdpbmF0ZWRSaWRlcnNcXFwiPlxcbiAgICAgICAgICAgIDx0ZD4ke3tyaWRlci5jb3N0fX08L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e3JpZGVyLm5hbWV9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7cmlkZXIucmlkZXJfbnVtYmVyfX08L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e3JpZGVyLmhpZ2hlc3RGaW5pc2h9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPnt7cmlkZXIubG93ZXN0RmluaXNofX08L3RkPlxcbiAgICAgICAgICAgIDx0ZD57e3JpZGVyLmF2ZXJhZ2VGaW5pc2h9fTwvdGQ+XFxuICAgICAgICAgICAgPHRkPjxhIGhyZWY9XFxcIiMhXFxcIiB2LWlmPVxcXCJzaG93U2VsZWN0ICYmIHJpZGVyLmNvc3QgPD0gZG9sbGFyc1xcXCIgQGNsaWNrPVxcXCJhZGRSYWNlcihyaWRlcilcXFwiPlNFTEVDVDwvYT48L3RkPlxcbiAgICAgICAgICA8L3RyPlxcbiAgICAgICAgPC90Ym9keT5cXG4gICAgICA8L3RhYmxlPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcImN1c3RvbS1wYWdpbmF0aW9uXFxcIj5cXG4gICAgICAgIDxkaXY+XFxuICAgICAgICAgIDxhIGNsYXNzPVxcXCJwYWdpbmF0aW9uLXByZXZpb3VzXFxcIiBAY2xpY2s9XFxcInBhZ2UtLVxcXCIgdi1iaW5kOmNsYXNzPVxcXCJ7ICdoaWRlLXBhZ2luYXRpb24tYnV0dG9uJyA6IGhpZGVQcmV2aW91cyB9XFxcIj5QcmV2aW91czwvYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgICAgPGRpdj5cXG4gICAgICAgICAgPGEgY2xhc3M9XFxcInBhZ2luYXRpb24tbnVtYmVyXFxcIj57e3BhZ2V9fS97e3BhZ2luYXRpb25QYWdlc319PC9hPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2PlxcbiAgICAgICAgICA8YSBjbGFzcz1cXFwicGFnaW5hdGlvbi1uZXh0XFxcIiBAY2xpY2s9XFxcInBhZ2UrK1xcXCIgdi1iaW5kOmNsYXNzPVxcXCJ7ICdoaWRlLXBhZ2luYXRpb24tYnV0dG9uJyA6IGhpZGVOZXh0IH1cXFwiPk5leHQgcGFnZTwvYT5cXG4gICAgICAgIDwvZGl2PlxcbiAgICAgIDwvZGl2PlxcbiAgICA8L2Rpdj5cXG4gIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHNjcmlwdD5cXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xcbmltcG9ydCB7IG1hcEdldHRlcnMgfSBmcm9tICd2dWV4JztcXG5pbXBvcnQgX2ZpbmRJbmRleCBmcm9tICdsb2Rhc2gvZmluZEluZGV4JztcXG5pbXBvcnQgX3NvcnRCeSBmcm9tICdsb2Rhc2gvc29ydEJ5JztcXG5pbXBvcnQgX3JlbW92ZSBmcm9tICdsb2Rhc2gvcmVtb3ZlJztcXG4gIGV4cG9ydCBkZWZhdWx0IHtcXG4gICAgZGF0YSgpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgY3VycmVudHdlZWs6IDAsXFxuICAgICAgICBzZWxlY3RlZHJpZGVyczogW10sXFxuICAgICAgICBhdmFpbGFibGVSaWRlcnM6IFtdLFxcbiAgICAgICAgQ29zdFNvcnRCeUFzYzogdHJ1ZSxcXG4gICAgICAgIHBhZ2U6IDFcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGNvbXB1dGVkOiB7XFxuICAgICAgLi4ubWFwR2V0dGVycyhbXFxuICAgICAgICAnZ2V0VXNlckRhdGEnXFxuICAgICAgXSksXFxuICAgICAgZG9sbGFycygpIHtcXG4gICAgICAgIHZhciB0b3RhbCA9IDg7XFxuICAgICAgICB0aGlzLnNlbGVjdGVkcmlkZXJzLmZvckVhY2gocmlkZXIgPT4ge1xcbiAgICAgICAgICB0b3RhbCAtPSByaWRlci5jb3N0O1xcbiAgICAgICAgfSlcXG4gICAgICAgIHJldHVybiB0b3RhbDtcXG4gICAgICB9LFxcbiAgICAgIGhpZGVQcmV2aW91cygpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2UgPD0gMTtcXG4gICAgICB9LFxcbiAgICAgIGhpZGVOZXh0KCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZSA+PSB0aGlzLnBhZ2luYXRpb25QYWdlcztcXG4gICAgICB9LFxcbiAgICAgIHBhZ2luYXRlZFJpZGVycygpIHtcXG4gICAgICAgIGlmICh0aGlzLnBhZ2UgPT0gMSkge1xcbiAgICAgICAgICBjb25zb2xlLmxvZyhcXFwiZW50aXJlIGFycmF5XFxcIiwgdGhpcy5hdmFpbGFibGVSaWRlcnMpXFxuICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYXZhaWxhYmxlUmlkZXJzLnNsaWNlKDAsIDEwKSk7XFxuICAgICAgICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZVJpZGVycy5zbGljZSgwLCAxMCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgYmVnaW5TbGljZSA9IHRoaXMucGFnZSAqIDEwIC0gOTtcXG4gICAgICAgICAgdmFyIGVuZFNsaWNlID0gYmVnaW5TbGljZSArIDEwO1xcbiAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmF2YWlsYWJsZVJpZGVycylcXG4gICAgICAgICAgY29uc29sZS5sb2codGhpcy5hdmFpbGFibGVSaWRlcnMuc2xpY2UoYmVnaW5TbGljZSwgZW5kU2xpY2UpKVxcbiAgICAgICAgICByZXR1cm4gdGhpcy5hdmFpbGFibGVSaWRlcnMuc2xpY2UoYmVnaW5TbGljZSwgZW5kU2xpY2UpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgcGFnaW5hdGlvblBhZ2VzKCkge1xcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmF2YWlsYWJsZVJpZGVycy5sZW5ndGggLyAxMCk7XFxuICAgICAgfSxcXG4gICAgICBzaG93U2VsZWN0KCkge1xcbiAgICAgICAgdmFyIG9wZW5TbG90cyA9IHRoaXMuc2VsZWN0ZWRyaWRlcnMuc29tZSgocmlkZXIpID0+IHtyZXR1cm4gcmlkZXIubmFtZSA9PSBcXFwiT1BFTiBTTE9UXFxcIn0pO1xcbiAgICAgICAgdmFyIGxvd2VzdENvc3RBdmFpbGFibGUgPSBfc29ydEJ5KHRoaXMuYXZhaWxhYmxlUmlkZXJzLCBvID0+IHsgcmV0dXJuIG8uY29zdCB9KTtcXG4gICAgICAgIGNvbnNvbGUubG9nKFxcXCJzaG93U2VsZWN0XFxcIiwgbG93ZXN0Q29zdEF2YWlsYWJsZVswXSlcXG4gICAgICAgIGlmICgodGhpcy5kb2xsYXJzID49IGxvd2VzdENvc3RBdmFpbGFibGVbMF0uY29zdCkgJiYgb3BlblNsb3RzKSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgbWV0aG9kczoge1xcbiAgICAgIHJlbW92ZVJhY2VyKHJhY2VyKSB7XFxuICAgICAgICBjb25zb2xlLmxvZyhcXFwicmVtb3ZlZCByYWNlcnNcXFwiLCByYWNlcik7XFxuICAgICAgICB2YXIgc2VsZWN0ZWRSYWNlckluZGV4ID0gX2ZpbmRJbmRleCh0aGlzLnNlbGVjdGVkcmlkZXJzLCBvID0+IHsgcmV0dXJuIG8ucmlkZXJpZCA9PT0gcmFjZXIucmlkZXJpZCB9KTtcXG4gICAgICAgIHZhciBvcGVuU3BhY2UgPSB7XFxuICAgICAgICAgIGF2YXRhcl91cmw6ICdodHRwOi8vd3d3LnNob3BhYXJkdmFyay5jb20vbWVkaWEvY2F0YWxvZy9wcm9kdWN0L1cvUy9XUy0xODY1NS5qcGcnLFxcbiAgICAgICAgICBjb3N0OiAwLFxcbiAgICAgICAgICBoaWdoZXN0RmluaXNoOiAnLScsXFxuICAgICAgICAgIGxvd2VzdEZpbmlzaDogJy0nLFxcbiAgICAgICAgICBuYW1lOiAnT1BFTiBTTE9UJyxcXG4gICAgICAgICAgcmlkZXJfbnVtYmVyOiAwLFxcbiAgICAgICAgICByaWRlcmlkOiAwLFxcbiAgICAgICAgICBsZWFndWVpZDogMSxcXG4gICAgICAgICAgc2Vhc29uX3dlZWtzaWQ6IHRoaXMuY3VycmVudHdlZWtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuYXZhaWxhYmxlUmlkZXJzLnB1c2gocmFjZXIpO1xcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIHNlbGVjdGVkUmFjZXJJbmRleCwgb3BlblNwYWNlKVxcbiAgICAgICAgLy9jYWxsIHRvIHNhdmUgdG8gREI7XFxuICAgICAgfSxcXG4gICAgICBhZGRSYWNlcihyYWNlcikge1xcbiAgICAgICAgdmFyIG9wZW5TbG90SW5kZXggPSBfZmluZEluZGV4KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIG8gPT4geyByZXR1cm4gby5uYW1lID09IFxcXCJPUEVOIFNMT1RcXFwiIH0pO1xcbiAgICAgICAgX3JlbW92ZSh0aGlzLmF2YWlsYWJsZVJpZGVycywgbyA9PiB7IHJldHVybiBvLnJpZGVyaWQgPT0gcmFjZXIucmlkZXJpZCB9KVxcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc2VsZWN0ZWRyaWRlcnMsIG9wZW5TbG90SW5kZXgsIHJhY2VyKTtcXG4gICAgICB9LFxcbiAgICAgIHNvcnRCeVByaWNlKCkge1xcbiAgICAgICAgaWYgKHRoaXMuQ29zdFNvcnRCeUFzYykge1xcbiAgICAgICAgICB0aGlzLkNvc3RTb3J0QnlBc2MgPSBmYWxzZTtcXG4gICAgICAgICAgdGhpcy5wYWdpbmF0ZWRSaWRlcnMgPSB0aGlzLnBhZ2luYXRlZFJpZGVycy5zb3J0KChhLCBiKSA9PiB7XFxuICAgICAgICAgICAgaWYgKGEuY29zdCA+IGIuY29zdCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIC0xXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChhLmNvc3QgPCBiLmNvc3QpIHtcXG4gICAgICAgICAgICAgIHJldHVybiAxXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiAwXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLkNvc3RTb3J0QnlBc2MgPSB0cnVlO1xcbiAgICAgICAgICB0aGlzLnBhZ2luYXRlZFJpZGVycyA9IHRoaXMucGFnaW5hdGVkUmlkZXJzLnNvcnQoKGEsIGIpID0+IHtcXG4gICAgICAgICAgICBpZiAoYS5jb3N0ID4gYi5jb3N0KSB7XFxuICAgICAgICAgICAgICByZXR1cm4gMVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoYS5jb3N0IDwgYi5jb3N0KSB7XFxuICAgICAgICAgICAgICByZXR1cm4gLTFcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIDBcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgICB9LFxcbiAgICAgIFNhdmVUZWFtKCkge1xcbiAgICAgICAgYXhpb3MucG9zdChcXFwiL1NhdmVUZWFtXFxcIiwgdGhpcy5zZWxlY3RlZHJpZGVycylcXG4gICAgICAgIC50aGVuKGRhdGEgPT4ge1xcbiAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcXG4gICAgICAgIH0pXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBiZWZvcmVDcmVhdGUoKSB7XFxuICAgICAgYXhpb3MuZ2V0KCcvQ3VycmVudE15VGVhbU1vZGVsJylcXG4gICAgICAudGhlbihkYXRhID0+IHtcXG4gICAgICAgIGNvbnNvbGUubG9nKFxcXCJkYXRhXFxcIiwgZGF0YS5kYXRhKTtcXG4gICAgICAgIHRoaXMuY3VycmVudHdlZWsgPSBkYXRhLmRhdGEuQ3VycmVudFRlYW1bMF0uc2Vhc29uX3dlZWtzaWQ7XFxuICAgICAgICB0aGlzLmF2YWlsYWJsZVJpZGVycyA9IF9zb3J0QnkoZGF0YS5kYXRhLkF2YWlsYWJsZVJpZGVycywgbyA9PiB7IHJldHVybiBvLmNvc3QgfSk7XFxuICAgICAgICB0aGlzLnNlbGVjdGVkcmlkZXJzID0gZGF0YS5kYXRhLkN1cnJlbnRUZWFtO1xcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIG1vdW50ZWQoKSB7XFxuICAgICAgY29uc29sZS5sb2coXFxcIm1vdW50ZWRcXFwiLCB0aGlzLmdldFVzZXJEYXRhKVxcbiAgICB9XFxuICB9XFxuPC9zY3JpcHQ+XFxuPHN0eWxlPlxcbiAgLnJpZGVycy1jb250YWluZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LXdyYXA6IHdyYXA7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgfVxcbiAgLnJpZGVyLWJsb2NrIHtcXG4gICAgbWluLXdpZHRoOiAxNXJlbTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2RlZGVkZTtcXG4gICAgbWFyZ2luOiAxcmVtO1xcbiAgICBib3gtc2hhZG93OiAxcHggMXB4IDFweCAjY2VjZWNlO1xcbiAgICBwYWRkaW5nOiAxcmVtO1xcbiAgICBtYXgtd2lkdGg6IDE1cmVtO1xcbiAgfVxcbiAgLnBhZ2UtdGl0bGUge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgICBmb250LXdlaWdodDogNzAwO1xcbiAgfVxcbiAgLnBhZ2UtdGl0bGUge1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xcbiAgICBmb250LXdlaWdodDogNzAwO1xcbiAgfVxcbiAgLnBhZ2Utc3ViaGVhZGVyIHtcXG4gICAgdGV4dC1hbGlnbjpjZW50ZXI7XFxuICB9XFxuICAuY2FyZC1mb290ZXIge1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjZWVlO1xcbiAgfVxcbiAgLmNhcmQtY29udGVudCB7XFxuICAgIG1pbi1oZWlnaHQ6IDExcmVtO1xcbiAgICBtYXgtaGVpZ2h0OiAxMXJlbTtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gIH1cXG4gIC5jYXJkLWZvb3RlciBkaXY6bnRoLWNoaWxkKGV2ZW4pIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIH1cXG4gIC5mb290ZXItcm93IHtcXG4gICAgZGlzcGxheTpmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICB9XFxuICBwLmNhcmQtaGVhZGVyLXRpdGxlIHtcXG4gICAgZGlzcGxheTpmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcXG4gIH1cXG4gIHAgc3Bhbi5pY29uIHtcXG4gICAgY29sb3I6ICNmZjM4NjA7XFxuICB9XFxuICB0aDpob3ZlciB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG4gIC5zYXZlLWJ1dHRvbiB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gIH1cXG4gIC5oaWRlLXBhZ2luYXRpb24tYnV0dG9uIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgfVxcbiAgLmN1c3RvbS1wYWdpbmF0aW9uIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgfVxcbjwvc3R5bGU+XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtMzgxNzNkMGVcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbXl0ZWFtLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMTk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcblxcblxcblxcblxcblxcblxcblxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiXCIsXCJmaWxlXCI6XCJpbmRleC52dWVcIixcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTRmNGU1ZGQyXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2luZGV4LnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodHJ1ZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4ubmF2YmFyLW1lbnUge1xcbiAgcGFkZGluZzogMCAxMDBweCAwIDUwcHg7XFxufVxcbi5pY29uIHtcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcbiAgY29sb3I6ICMwMGQxYjI7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMvU2V0aC9Qcm9qZWN0cy9mYW50YXN5bXgyL2NsaWVudC9jb21wb25lbnRzL25hdmJhci52dWU/MjQ0Y2M4NmNcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQTBJQTtFQUNBLHdCQUFBO0NBQ0E7QUFDQTtFQUNBLGtCQUFBO0VBQ0EsZUFBQTtDQUNBXCIsXCJmaWxlXCI6XCJuYXZiYXIudnVlXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIlxcbiAgPHRlbXBsYXRlPlxcbiAgICA8bmF2IGNsYXNzPVxcXCJuYXZiYXJcXFwiPlxcbiAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1icmFuZFxcXCI+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaXRlbVxcXCI+XFxuICAgICAgICAgIEZBTlRBU1lNWFxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItYnVyZ2VyIGJ1cmdlclxcXCIgZGF0YS10YXJnZXQ9XFxcIm5hdk1lbnVcXFwiPlxcbiAgICAgICAgICA8c3Bhbj48L3NwYW4+XFxuICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cXG4gICAgICAgICAgPHNwYW4+PC9zcGFuPlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLW1lbnVcXFwiIGlkPVxcXCJuYXZNZW51XFxcIj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1zdGFydFxcXCI+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1pdGVtXFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwiaWNvblxcXCI+XFxuICAgICAgICAgICAgICA8aSBjbGFzcz1cXFwiZmEgZmEtaG9tZVxcXCI+PC9pPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICA8cm91dGVyLWxpbmsgdG89XFxcIi9cXFwiPkhvbWU8L3JvdXRlci1saW5rPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWl0ZW1cXFwiIHYtaWY9XFxcIkdldEF1dGhTdGF0dXNcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIiB2LWlmPVxcXCJHZXRBdXRoU3RhdHVzXFxcIj5cXG4gICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1tb3RvcmN5Y2xlXFxcIj48L2k+XFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgIDxyb3V0ZXItbGluayB0bz1cXFwiL215dGVhbVxcXCI+TXkgVGVhbTwvcm91dGVyLWxpbms+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaXRlbVxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb25cXFwiPlxcbiAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLWdhdmVsXFxcIj48L2k+XFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcIiMhXFxcIj5SdWxlczwvYT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1lbmRcXFwiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJuYXZiYXItaXRlbVxcXCIgdi1pZj1cXFwiIUdldEF1dGhTdGF0dXNcXFwiIEBjbGljaz1cXFwic2V0UmVnaXN0ZXJNb2RhbCh7IHNob3c6ICFTaG93UmVnaXN0ZXJNb2RhbCB9KVxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb25cXFwiPlxcbiAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXBlbmNpbC1zcXVhcmUtb1xcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjwvaT5cXG4gICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiIyFcXFwiPlJlZ2lzdGVyPC9hPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWl0ZW1cXFwiIHYtaWY9XFxcIiFHZXRBdXRoU3RhdHVzXFxcIiBAY2xpY2s9XFxcInNldExvZ2luTW9kYWwoeyBzaG93OiAhU2hvd0xvZ2luTW9kYWwgfSlcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj5cXG4gICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJmYSBmYS1zaWduLWluXFxcIj48L2k+XFxuICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgIDxhIGhyZWY9XFxcIiMhXFxcIj5Mb2dpbjwvYT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm5hdmJhci1pdGVtXFxcIiB2LWlmPVxcXCJHZXRBdXRoU3RhdHVzXFxcIj5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjIVxcXCI+V2VsY29tZSwge3sgZ2V0VXNlckRhdGEudXNlcm5hbWUgfX0hPC9hPlxcbiAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPGRpdiBjbGFzcz1cXFwibmF2YmFyLWl0ZW1cXFwiIHYtaWY9XFxcIkdldEF1dGhTdGF0dXNcXFwiIEBjbGljaz1cXFwic2V0TG9nZ2VkSW4oeyBpc0xvZ2dlZEluOiAhR2V0QXV0aFN0YXR1cyB9KVxcXCI+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImljb25cXFwiIHYtaWY9XFxcIkdldEF1dGhTdGF0dXNcXFwiPlxcbiAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcImZhIGZhLXNpZ24tb3V0XFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9pPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjIVxcXCIgQGNsaWNrPVxcXCJsb2dvdXRcXFwiPkxvZ291dDwvYT5cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgICA8L2Rpdj5cXG4gICAgICA8cmVnaXN0ZXIgOnNob3c9XFxcIlNob3dSZWdpc3Rlck1vZGFsXFxcIj48L3JlZ2lzdGVyPlxcbiAgICAgIDxsb2dpbiB2LWJpbmQ6c2hvdz1cXFwiU2hvd0xvZ2luTW9kYWxcXFwiPjwvbG9naW4+XFxuICAgIDwvbmF2PlxcbiAgPC90ZW1wbGF0ZT5cXG4gIDxzY3JpcHQ+XFxuICAgIGltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XFxuICAgIGltcG9ydCB7IG1hcEdldHRlcnMsIG1hcE11dGF0aW9ucyB9IGZyb20gJ3Z1ZXgnO1xcbiAgICBpbXBvcnQgcmVnaXN0ZXIgZnJvbSAnLi9yZWdpc3Rlci52dWUnO1xcbiAgICBpbXBvcnQgbG9naW4gZnJvbSAnLi9sb2dpbi52dWUnO1xcbiAgICBleHBvcnQgZGVmYXVsdCB7XFxuICAgICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiAge1xcbiAgICAgICAgICB1c2VybmFtZTogJycsXFxuICAgICAgICAgIHBhc3N3b3JkOiAnJyxcXG4gICAgICAgICAgc2hvd1JlZ2lzdGVyTW9kYWw6IGZhbHNlLFxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgY29tcHV0ZWQ6IG1hcEdldHRlcnMoW1xcbiAgICAgICAgJ1Nob3dMb2dpbk1vZGFsJyxcXG4gICAgICAgICdTaG93UmVnaXN0ZXJNb2RhbCcsXFxuICAgICAgICAnZ2V0VXNlckRhdGEnLFxcbiAgICAgICAgJ0dldEF1dGhTdGF0dXMnXFxuICAgICAgXSksXFxuICAgICAgbW91bnRlZCgpIHtcXG4gICAgICAgIC8vIEdldCBhbGwgXFxcIm5hdmJhci1idXJnZXJcXFwiIGVsZW1lbnRzXFxuICAgICAgICB2YXIgJG5hdmJhckJ1cmdlcnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubmF2YmFyLWJ1cmdlcicpLCAwKTtcXG4gICAgICAgIGNvbnNvbGUubG9nKCRuYXZiYXJCdXJnZXJzKTtcXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbmF2IGJ1cmdlcnNcXG4gICAgICAgIGlmICgkbmF2YmFyQnVyZ2Vycy5sZW5ndGggPiAwKSB7XFxuXFxuICAgICAgICAgIC8vIEFkZCBhIGNsaWNrIGV2ZW50IG9uIGVhY2ggb2YgdGhlbVxcbiAgICAgICAgICAkbmF2YmFyQnVyZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICgkZWwpIHtcXG4gICAgICAgICAgICAkZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XFxuXFxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRhcmdldCBmcm9tIHRoZSBcXFwiZGF0YS10YXJnZXRcXFwiIGF0dHJpYnV0ZVxcbiAgICAgICAgICAgICAgdmFyIHRhcmdldCA9ICRlbC5kYXRhc2V0LnRhcmdldDtcXG4gICAgICAgICAgICAgIHZhciAkdGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFyZ2V0KTtcXG5cXG4gICAgICAgICAgICAgIC8vIFRvZ2dsZSB0aGUgY2xhc3Mgb24gYm90aCB0aGUgXFxcIm5hdmJhci1idXJnZXJcXFwiIGFuZCB0aGUgXFxcIm5hdmJhci1tZW51XFxcIlxcbiAgICAgICAgICAgICAgJGVsLmNsYXNzTGlzdC50b2dnbGUoJ2lzLWFjdGl2ZScpO1xcbiAgICAgICAgICAgICAgJHRhcmdldC5jbGFzc0xpc3QudG9nZ2xlKCdpcy1hY3RpdmUnKTtcXG5cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICBjcmVhdGVkKCkge1xcbiAgICAgICAgYXhpb3MuZ2V0KCcvbG9naW5yZWZyZXNoJykudGhlbihkYXRhID0+IHtcXG4gICAgICAgICAgY29uc29sZS5sb2coZGF0YS5kYXRhKVxcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEuZGF0YS51c2VybmFtZSAhPSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJVc2VyIElzIEF1dGhlbnRpY2F0ZWRcXFwiKVxcbiAgICAgICAgICAgIHRoaXMuc2V0VXNlckRhdGEoeyB1c2VyRGF0YTogZGF0YS5kYXRhIH0pXFxuICAgICAgICAgICAgdGhpcy5zZXRMb2dnZWRJbih7IGxvZ2dlZEluOiB0cnVlIH0pXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XFxuICAgICAgICAgIGNvbnNvbGUubG9nKFxcXCJsb2dpbiByZWZyZXNoIGVycm9yXFxcIiwgZXJyKTtcXG4gICAgICAgIH0pXFxuICAgICAgfSxcXG4gICAgICBtZXRob2RzOiB7XFxuICAgICAgICAuLi5tYXBNdXRhdGlvbnMoW1xcbiAgICAgICAgICAnc2V0UmVnaXN0ZXJNb2RhbCcsXFxuICAgICAgICAgICdzZXRMb2dpbk1vZGFsJyxcXG4gICAgICAgICAgJ3NldExvZ2dlZEluJyxcXG4gICAgICAgICAgJ3NldFVzZXJEYXRhJyxcXG4gICAgICAgICAgJ2xvZ291dCdcXG4gICAgICAgIF0pLFxcbiAgICAgICAgbG9nb3V0KCkge1xcbiAgICAgICAgICBheGlvcy5nZXQoJ2xvZ291dCcpLnRoZW4oZGF0YSA9PiB7XFxuICAgICAgICAgICAgdGhpcy5sb2dvdXQoKTtcXG4gICAgICAgICAgICB0aGlzLiRyb3V0ZXIucHVzaChcXFwiL1xcXCIpO1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAgIH0sXFxuICAgICAgY29tcG9uZW50czoge1xcbiAgICAgICAgJ3JlZ2lzdGVyJzogcmVnaXN0ZXIsXFxuICAgICAgICAnbG9naW4nOiBsb2dpblxcbiAgICAgIH1cXG4gICAgfVxcbiAgPC9zY3JpcHQ+XFxuICA8c3R5bGU+XFxuICAgIC5uYXZiYXItbWVudSB7XFxuICAgICAgcGFkZGluZzogMCAxMDBweCAwIDUwcHg7XFxuICAgIH1cXG4gICAgLmljb24ge1xcbiAgICAgIG1hcmdpbi1yaWdodDogNXB4O1xcbiAgICAgIGNvbG9yOiAjMDBkMWIyO1xcbiAgICB9XFxuICA8L3N0eWxlPlxcbn0pXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNzc0YzYzOTVcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMGNiYjAyYzhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2xlYWRlcmJvYXJkLnZ1ZVwiKVxufVxudmFyIENvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpKFxuICAvKiBzY3JpcHQgKi9cbiAgcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wIS4vbGVhZGVyYm9hcmQudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0wY2JiMDJjOFxcXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9sZWFkZXJib2FyZC52dWVcIiksXG4gIC8qIHN0eWxlcyAqL1xuICBpbmplY3RTdHlsZSxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCIvVXNlcnMvU2V0aC9Qcm9qZWN0cy9mYW50YXN5bXgyL2NsaWVudC9jb21wb25lbnRzL2xlYWRlcmJvYXJkLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGtleSAhPT0gXCJkZWZhdWx0XCIgJiYga2V5LnN1YnN0cigwLCAyKSAhPT0gXCJfX1wifSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5pZiAoQ29tcG9uZW50Lm9wdGlvbnMuZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gbGVhZGVyYm9hcmQudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTBjYmIwMmM4XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMGNiYjAyYzhcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9jb21wb25lbnRzL2xlYWRlcmJvYXJkLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9sb2dpbi52dWVcIiksXG4gIC8qIHRlbXBsYXRlICovXG4gIHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LTIxZDdkNmY0XFxcIn0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2xvZ2luLnZ1ZVwiKSxcbiAgLyogc3R5bGVzICovXG4gIG51bGwsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiL1VzZXJzL1NldGgvUHJvamVjdHMvZmFudGFzeW14Mi9jbGllbnQvY29tcG9uZW50cy9sb2dpbi52dWVcIlxuaWYgKENvbXBvbmVudC5lc01vZHVsZSAmJiBPYmplY3Qua2V5cyhDb21wb25lbnQuZXNNb2R1bGUpLnNvbWUoZnVuY3Rpb24gKGtleSkge3JldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7Y29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuaWYgKENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwpIHtjb25zb2xlLmVycm9yKFwiW3Z1ZS1sb2FkZXJdIGxvZ2luLnZ1ZTogZnVuY3Rpb25hbCBjb21wb25lbnRzIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggdGVtcGxhdGVzLCB0aGV5IHNob3VsZCB1c2UgcmVuZGVyIGZ1bmN0aW9ucy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yMWQ3ZDZmNFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTIxZDdkNmY0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9jbGllbnQvY29tcG9uZW50cy9sb2dpbi52dWVcbi8vIG1vZHVsZSBpZCA9IDIwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTM4MTczZDBlXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9teXRlYW0udnVlXCIpXG59XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9teXRlYW0udnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0zODE3M2QwZVxcXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9teXRlYW0udnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgaW5qZWN0U3R5bGUsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiL1VzZXJzL1NldGgvUHJvamVjdHMvZmFudGFzeW14Mi9jbGllbnQvY29tcG9uZW50cy9teXRlYW0udnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBteXRlYW0udnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTM4MTczZDBlXCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtMzgxNzNkMGVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9jb21wb25lbnRzL215dGVhbS52dWVcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTc3NGM2Mzk1XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9uYXZiYXIudnVlXCIpXG59XG52YXIgQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIikoXG4gIC8qIHNjcmlwdCAqL1xuICByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAhLi9uYXZiYXIudnVlXCIpLFxuICAvKiB0ZW1wbGF0ZSAqL1xuICByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi03NzRjNjM5NVxcXCJ9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9uYXZiYXIudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgaW5qZWN0U3R5bGUsXG4gIC8qIHNjb3BlSWQgKi9cbiAgbnVsbCxcbiAgLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG4gIG51bGxcbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwiL1VzZXJzL1NldGgvUHJvamVjdHMvZmFudGFzeW14Mi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBuYXZiYXIudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCB0ZW1wbGF0ZXMsIHRoZXkgc2hvdWxkIHVzZSByZW5kZXIgZnVuY3Rpb25zLlwiKX1cblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTc3NGM2Mzk1XCIsIENvbXBvbmVudC5vcHRpb25zKVxuICB9IGVsc2Uge1xuICAgIGhvdEFQSS5yZWxvYWQoXCJkYXRhLXYtNzc0YzYzOTVcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2NsaWVudC9jb21wb25lbnRzL25hdmJhci52dWVcbi8vIG1vZHVsZSBpZCA9IDIwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cz17cmVuZGVyOmZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ2RpdicsIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImxlYWRlcmJvYXJkLXRpdGxlXCJcbiAgfSwgW192bS5fdihcIlxcbiAgICAyMDE4IEZhbnRhc3lTWCBNYWluIExlYWd1ZVxcbiAgXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29sdW1ucyBsZWFkZXJib2FyZFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbHVtbiBpcy1oYWxmIGlzLW9mZnNldC1vbmUtcXVhcnRlclwiXG4gIH0sIFsoX3ZtLmRvbmVMb2FkaW5nKSA/IF9jKCd0YWJsZScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJ0YWJsZSBpcy1zdHJpcGVkXCJcbiAgfSwgW192bS5fbSgwKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3Rmb290JywgW19jKCd0cicsIFtfYygndGgnLCBbX3ZtLl92KFwiUG9zaXRpb25cIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlRvdGFsIFBvaW50c1wiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCBbX3ZtLl92KFwiVXNlcm5hbWVcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlBvaW50cyBCYWNrXCIpXSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGJvZHknLCBfdm0uX2woKF92bS5zdGFuZGluZ3MpLCBmdW5jdGlvbih1c2VyLCBpbmRleCkge1xuICAgIHJldHVybiBfYygndHInLCBbX2MoJ3RkJywgW192bS5fdihfdm0uX3MoaW5kZXggKyAxKSArIFwiLlwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCBbX3ZtLl92KF92bS5fcyh1c2VyLnRvdGFscG9pbnRzKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywgW192bS5fdihfdm0uX3ModXNlci53ZWVrbHl0ZWFtc1swXS51c2VybmFtZSkpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcInBvaW50c2JhY2tcIlxuICAgIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5wb2ludHNiZWhpbmQodXNlcikpKV0pXSlcbiAgfSkpXSwgMSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgKCFfdm0uZG9uZUxvYWRpbmcpID8gX2MoJ2RpdicsIFtfYygncCcsIFtfdm0uX3YoXCJcXFwiVGhpcyBkYXRhIGRvZXNuJ3QgZmV0Y2ggaXRzZWxmLi4gTG9hZGluZyBSYWNlIFRyYWNrZXIuXFxcIlwiKV0pXSkgOiBfdm0uX2UoKV0pXSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCd0aGVhZCcsIFtfYygndHInLCBbX2MoJ3RoJywgW192bS5fdihcIlBvc2l0aW9uXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJUb3RhbCBQb2ludHNcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlVzZXJuYW1lXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJQb2ludHMgQmFja1wiKV0pXSldKVxufV19XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTBjYmIwMmM4XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMGNiYjAyYzhcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL2xlYWRlcmJvYXJkLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsXCIsXG4gICAgY2xhc3M6IHtcbiAgICAgICdpcy1hY3RpdmUnOiBfdm0uU2hvd1JlZ2lzdGVyTW9kYWxcbiAgICB9LFxuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwicmVnaXN0ZXJNb2RhbFwiXG4gICAgfVxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1iYWNrZ3JvdW5kXCJcbiAgfSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWwtY2FyZFwiXG4gIH0sIFtfYygnaGVhZGVyJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsLWNhcmQtaGVhZFwiXG4gIH0sIFtfYygncCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkLXRpdGxlXCJcbiAgfSwgW192bS5fdihcIk5ldyBVc2VyIFJlZ2lzdHJhdGlvblwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnYnV0dG9uJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImRlbGV0ZVwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBfdm0uc2V0UmVnaXN0ZXJNb2RhbCh7XG4gICAgICAgICAgc2hvdzogIV92bS5TaG93UmVnaXN0ZXJNb2RhbFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3NlY3Rpb24nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWwtY2FyZC1ib2R5XCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29udGVudFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZpZWxkXCJcbiAgfSwgW19jKCdsYWJlbCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsYWJlbFwiXG4gIH0sIFtfdm0uX3YoXCJVc2VybmFtZTogXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiXG4gIH0sIFtfYygnaW5wdXQnLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgdmFsdWU6IChfdm0udXNlcm5hbWUpLFxuICAgICAgZXhwcmVzc2lvbjogXCJ1c2VybmFtZVwiXG4gICAgfV0sXG4gICAgc3RhdGljQ2xhc3M6IFwiaW5wdXRcIixcbiAgICBjbGFzczoge1xuICAgICAgJ2lzLWRhbmdlcic6IF92bS5pbnZhbGlkVXNlcm5hbWVcbiAgICB9LFxuICAgIGF0dHJzOiB7XG4gICAgICBcInR5cGVcIjogXCJ0ZXh0XCIsXG4gICAgICBcImlkXCI6IFwicmVnLXVzZXJuYW1lXCIsXG4gICAgICBcInBsYWNlaG9sZGVyXCI6IFwiVXNlcm5hbWVcIixcbiAgICAgIFwicmVxdWlyZWRcIjogXCJcIlxuICAgIH0sXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwidmFsdWVcIjogKF92bS51c2VybmFtZSlcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImlucHV0XCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuOyB9XG4gICAgICAgIF92bS51c2VybmFtZSA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfdm0uX20oMCldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZpZWxkXCJcbiAgfSwgW19jKCdsYWJlbCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsYWJlbFwiXG4gIH0sIFtfdm0uX3YoXCJFbWFpbDogXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiXG4gIH0sIFtfYygnaW5wdXQnLCB7XG4gICAgZGlyZWN0aXZlczogW3tcbiAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgIHJhd05hbWU6IFwidi1tb2RlbFwiLFxuICAgICAgdmFsdWU6IChfdm0uZW1haWwpLFxuICAgICAgZXhwcmVzc2lvbjogXCJlbWFpbFwiXG4gICAgfV0sXG4gICAgc3RhdGljQ2xhc3M6IFwiaW5wdXRcIixcbiAgICBjbGFzczoge1xuICAgICAgJ2lzLWRhbmdlcic6IF92bS5pbnZhbGlkRW1haWxcbiAgICB9LFxuICAgIGF0dHJzOiB7XG4gICAgICBcInR5cGVcIjogXCJlbWFpbFwiLFxuICAgICAgXCJpZFwiOiBcInJlZy1lbWFpbFwiLFxuICAgICAgXCJwbGFjZWhvbGRlclwiOiBcIkVtYWlsXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFwiXCJcbiAgICB9LFxuICAgIGRvbVByb3BzOiB7XG4gICAgICBcInZhbHVlXCI6IChfdm0uZW1haWwpXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAgXCJpbnB1dFwiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgaWYgKCRldmVudC50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybjsgfVxuICAgICAgICBfdm0uZW1haWwgPSAkZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX3ZtLl9tKDEpXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmaWVsZFwiXG4gIH0sIFtfYygnbGFiZWwnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibGFiZWxcIlxuICB9LCBbX3ZtLl92KFwiUGFzc3dvcmQ6IFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbnRyb2wgaGFzLWljb25zLWxlZnRcIlxuICB9LCBbX2MoJ2lucHV0Jywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgIHZhbHVlOiAoX3ZtLnBhc3N3b3JkKSxcbiAgICAgIGV4cHJlc3Npb246IFwicGFzc3dvcmRcIlxuICAgIH1dLFxuICAgIHN0YXRpY0NsYXNzOiBcImlucHV0XCIsXG4gICAgY2xhc3M6IHtcbiAgICAgICdpcy1kYW5nZXInOiBfdm0uYmxhbmtQYXNzd29yZFxuICAgIH0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcInBhc3N3b3JkXCIsXG4gICAgICBcImlkXCI6IFwicmVnLXBhc3N3b3JkXCIsXG4gICAgICBcInBsYWNlaG9sZGVyXCI6IFwiUGFzc3dvcmRcIixcbiAgICAgIFwicmVxdWlyZWRcIjogXCJcIlxuICAgIH0sXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwidmFsdWVcIjogKF92bS5wYXNzd29yZClcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImlucHV0XCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuOyB9XG4gICAgICAgIF92bS5wYXNzd29yZCA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBfdm0uX3YoXCIgXCIpLCBfdm0uX20oMildKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZpZWxkXCJcbiAgfSwgW192bS5fdihcIlxcbiAgICAgICAgICAgIFJFQ0FQVENIQSBQTEFDRUhPTERFUlxcbiAgICAgICAgICBcIildKSwgX3ZtLl92KFwiIFwiKSwgX3ZtLl9sKChfdm0uZXJyb3JNZXNzYWdlKSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICByZXR1cm4gKF92bS5lcnJvck1lc3NhZ2UgIT0gJycpID8gX2MoJ2RpdicsIHtcbiAgICAgIHN0YXRpY0NsYXNzOiBcImVycm9yTWVzc2FnZVwiXG4gICAgfSwgW192bS5fdihcIlxcbiAgICAgICAgICAgIFwiICsgX3ZtLl9zKGVycm9yKSArIFwiXFxuICAgICAgICAgIFwiKV0pIDogX3ZtLl9lKClcbiAgfSldLCAyKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZm9vdGVyJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsLWNhcmQtZm9vdFwiXG4gIH0sIFtfYygnYScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJidXR0b24gaXMtc3VjY2Vzc1wiLFxuICAgIGNsYXNzOiB7XG4gICAgICAnaXMtbG9hZGluZyc6IF92bS5pc0xvYWRpbmdcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5SZWdpc3RlclxuICAgIH1cbiAgfSwgW192bS5fdihcIlJlZ2lzdGVyXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCdhJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImJ1dHRvblwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBfdm0uc2V0UmVnaXN0ZXJNb2RhbCh7XG4gICAgICAgICAgc2hvdzogIV92bS5TaG93UmVnaXN0ZXJNb2RhbFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW192bS5fdihcIkNhbmNlbFwiKV0pXSldKV0pXG59LHN0YXRpY1JlbmRlckZuczogW2Z1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCJcbiAgfSwgW19jKCdpJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZhIGZhLXVzZXJcIlxuICB9KV0pXG59LGZ1bmN0aW9uICgpe3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO1xuICByZXR1cm4gX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaWNvbiBpcy1zbWFsbCBpcy1sZWZ0XCJcbiAgfSwgW19jKCdpJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZhIGZhLWVudmVsb3BlXCJcbiAgfSldKVxufSxmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImljb24gaXMtc21hbGwgaXMtbGVmdFwiXG4gIH0sIFtfYygnaScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmYSBmYS1sb2NrXCJcbiAgfSldKVxufV19XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTFhZDA2ZDY4XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMWFkMDZkNjhcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL3JlZ2lzdGVyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsXCIsXG4gICAgY2xhc3M6IHtcbiAgICAgICdpcy1hY3RpdmUnOiBfdm0uc2hvd1xuICAgIH0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJsb2dpbk1vZGFsXCJcbiAgICB9XG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsLWJhY2tncm91bmRcIlxuICB9KSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkXCJcbiAgfSwgW19jKCdoZWFkZXInLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWwtY2FyZC1oZWFkXCJcbiAgfSwgW19jKCdwJywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm1vZGFsLWNhcmQtdGl0bGVcIlxuICB9LCBbX3ZtLl92KFwiVXNlciBMb2dpblwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnYnV0dG9uJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImRlbGV0ZVwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBfdm0uc2V0TG9naW5Nb2RhbCh7XG4gICAgICAgICAgc2hvdzogIV92bS5TaG93TG9naW5Nb2RhbFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3NlY3Rpb24nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibW9kYWwtY2FyZC1ib2R5XCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29udGVudFwiXG4gIH0sIFtfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZpZWxkXCJcbiAgfSwgW19jKCdsYWJlbCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJsYWJlbFwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcImZvclwiOiBcInJlZy11c2VybmFtZVwiXG4gICAgfVxuICB9LCBbX3ZtLl92KFwiVXNlcm5hbWU6IFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbnRyb2xcIlxuICB9LCBbX2MoJ2lucHV0Jywge1xuICAgIGRpcmVjdGl2ZXM6IFt7XG4gICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgIHZhbHVlOiAoX3ZtLnVzZXJuYW1lKSxcbiAgICAgIGV4cHJlc3Npb246IFwidXNlcm5hbWVcIlxuICAgIH1dLFxuICAgIHN0YXRpY0NsYXNzOiBcImlucHV0XCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcInRleHRcIlxuICAgIH0sXG4gICAgZG9tUHJvcHM6IHtcbiAgICAgIFwidmFsdWVcIjogKF92bS51c2VybmFtZSlcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImlucHV0XCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBpZiAoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpIHsgcmV0dXJuOyB9XG4gICAgICAgIF92bS51c2VybmFtZSA9ICRldmVudC50YXJnZXQudmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH0pXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmaWVsZFwiXG4gIH0sIFtfYygnbGFiZWwnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibGFiZWxcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJmb3JcIjogXCJyZWctcGFzc3dvcmRcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIlBhc3N3b3JkOiBcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJjb250cm9sXCJcbiAgfSwgW19jKCdpbnB1dCcsIHtcbiAgICBkaXJlY3RpdmVzOiBbe1xuICAgICAgbmFtZTogXCJtb2RlbFwiLFxuICAgICAgcmF3TmFtZTogXCJ2LW1vZGVsXCIsXG4gICAgICB2YWx1ZTogKF92bS5wYXNzd29yZCksXG4gICAgICBleHByZXNzaW9uOiBcInBhc3N3b3JkXCJcbiAgICB9XSxcbiAgICBzdGF0aWNDbGFzczogXCJpbnB1dFwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcInR5cGVcIjogXCJwYXNzd29yZFwiLFxuICAgICAgXCJpZFwiOiBcInJlZy1wYXNzd29yZFwiXG4gICAgfSxcbiAgICBkb21Qcm9wczoge1xuICAgICAgXCJ2YWx1ZVwiOiAoX3ZtLnBhc3N3b3JkKVxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiaW5wdXRcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIGlmICgkZXZlbnQudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm47IH1cbiAgICAgICAgX3ZtLnBhc3N3b3JkID0gJGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfSldKV0pXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2Zvb3RlcicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJtb2RhbC1jYXJkLWZvb3RcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmaWVsZFwiXG4gIH0sIFtfYygnYnV0dG9uJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImJ1dHRvbiBpcy1wcmltYXJ5XCIsXG4gICAgY2xhc3M6IHtcbiAgICAgICdpcy1sb2FkaW5nJzogX3ZtLmlzTG9hZGluZ1xuICAgIH0sXG4gICAgYXR0cnM6IHtcbiAgICAgIFwidHlwZVwiOiBcImJ1dHRvblwiLFxuICAgICAgXCJ2YWx1ZVwiOiBcIkxvZ2luXCIsXG4gICAgICBcImlkXCI6IFwic3VibWl0LWxvZ2luXCJcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5zdWJtaXRcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJMb2dpblwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnYScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJidXR0b25cIixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgX3ZtLnNldExvZ2luTW9kYWwoe1xuICAgICAgICAgIHNob3c6ICFfdm0uU2hvd0xvZ2luTW9kYWxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJDYW5jZWxcIildKV0pXSldKV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5tb2R1bGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTIxZDdkNmY0XCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMjFkN2Q2ZjRcIn0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL2xvZ2luLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbnRlbnRcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJwYWdlLXRpdGxlXCJcbiAgfSwgW192bS5fdihcIk1ZIFRFQU0gLSBURUFNIFNFTEVDVElPTiBGT1IgV0VFSyBcIiArIF92bS5fcyhfdm0uY3VycmVudHdlZWspKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnYScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJidXR0b24gaXMtc3VjY2VzcyBzYXZlLWJ1dHRvblwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5TYXZlVGVhbVxuICAgIH1cbiAgfSwgW192bS5fdihcIlNhdmUgVGVhbVwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygncCcsIHtcbiAgICBzdGF0aWNDbGFzczogXCJwYWdlLXN1YmhlYWRlclwiXG4gIH0sIFtfdm0uX3YoXCJXZWVrIFwiICsgX3ZtLl9zKF92bS5jdXJyZW50d2VlaykgKyBcIiBCYWxhbmNlOiAkXCIgKyBfdm0uX3MoX3ZtLmRvbGxhcnMpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbnRhaW5lclwiXG4gIH0sIFtfYygndGFibGUnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwidGFibGUgaXMtc3RyaXBlZFwiXG4gIH0sIFtfYygndGhlYWQnLCBbX2MoJ3RyJywgW19jKCd0aCcsIHtcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0uc29ydEJ5UHJpY2VcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJQcmljZVxcbiAgICAgICAgICAgIFwiKSwgX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaWNvblwiXG4gIH0sIFsoX3ZtLkNvc3RTb3J0QnlBc2MpID8gX2MoJ2knLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmEgZmEtY2FyZXQtdXBcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICAgIH1cbiAgfSkgOiBfYygnaScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmYSBmYS1jYXJldC1kb3duXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcbiAgICB9XG4gIH0pXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlJhY2VyIE5hbWVcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIlJhY2VyIE51bWJlclwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCBbX3ZtLl92KFwiSGlnaGVzdCBGaW5pc2hcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIkxvd2VzdCBGaW5pc2hcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIkF2ZXJhZ2UgRmluaXNoXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJBY3Rpb25cIildKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCd0Zm9vdCcsIFtfYygndHInLCBbX2MoJ3RoJywgW192bS5fdihcIlByaWNlXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJSYWNlciBOYW1lXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJSYWNlciBOdW1iZXJcIildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RoJywgW192bS5fdihcIkhpZ2hlc3QgRmluaXNoXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJMb3dlc3QgRmluaXNoXCIpXSksIF92bS5fdihcIiBcIiksIF9jKCd0aCcsIFtfdm0uX3YoXCJBdmVyYWdlIEZpbmlzaFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGgnLCBbX3ZtLl92KFwiQWN0aW9uXCIpXSldKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGJvZHknLCBfdm0uX2woKF92bS5wYWdpbmF0ZWRSaWRlcnMpLCBmdW5jdGlvbihyaWRlcikge1xuICAgIHJldHVybiBfYygndHInLCBbX2MoJ3RkJywgW192bS5fdihcIiRcIiArIF92bS5fcyhyaWRlci5jb3N0KSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywgW192bS5fdihfdm0uX3MocmlkZXIubmFtZSkpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIFtfdm0uX3YoX3ZtLl9zKHJpZGVyLnJpZGVyX251bWJlcikpXSksIF92bS5fdihcIiBcIiksIF9jKCd0ZCcsIFtfdm0uX3YoX3ZtLl9zKHJpZGVyLmhpZ2hlc3RGaW5pc2gpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCBbX3ZtLl92KF92bS5fcyhyaWRlci5sb3dlc3RGaW5pc2gpKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygndGQnLCBbX3ZtLl92KF92bS5fcyhyaWRlci5hdmVyYWdlRmluaXNoKSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ3RkJywgWyhfdm0uc2hvd1NlbGVjdCAmJiByaWRlci5jb3N0IDw9IF92bS5kb2xsYXJzKSA/IF9jKCdhJywge1xuICAgICAgYXR0cnM6IHtcbiAgICAgICAgXCJocmVmXCI6IFwiIyFcIlxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgX3ZtLmFkZFJhY2VyKHJpZGVyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW192bS5fdihcIlNFTEVDVFwiKV0pIDogX3ZtLl9lKCldKV0pXG4gIH0pKV0sIDEpLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImN1c3RvbS1wYWdpbmF0aW9uXCJcbiAgfSwgW19jKCdkaXYnLCBbX2MoJ2EnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwicGFnaW5hdGlvbi1wcmV2aW91c1wiLFxuICAgIGNsYXNzOiB7XG4gICAgICAnaGlkZS1wYWdpbmF0aW9uLWJ1dHRvbic6IF92bS5oaWRlUHJldmlvdXNcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBfdm0ucGFnZS0tXG4gICAgICB9XG4gICAgfVxuICB9LCBbX3ZtLl92KFwiUHJldmlvdXNcIildKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2JywgW19jKCdhJywge1xuICAgIHN0YXRpY0NsYXNzOiBcInBhZ2luYXRpb24tbnVtYmVyXCJcbiAgfSwgW192bS5fdihfdm0uX3MoX3ZtLnBhZ2UpICsgXCIvXCIgKyBfdm0uX3MoX3ZtLnBhZ2luYXRpb25QYWdlcykpXSldKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIFtfYygnYScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJwYWdpbmF0aW9uLW5leHRcIixcbiAgICBjbGFzczoge1xuICAgICAgJ2hpZGUtcGFnaW5hdGlvbi1idXR0b24nOiBfdm0uaGlkZU5leHRcbiAgICB9LFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBfdm0ucGFnZSsrXG4gICAgICB9XG4gICAgfVxuICB9LCBbX3ZtLl92KFwiTmV4dCBwYWdlXCIpXSldKV0pXSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi0zODE3M2QwZVwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTM4MTczZDBlXCJ9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9teXRlYW0udnVlXG4vLyBtb2R1bGUgaWQgPSAyMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaWRcIjogXCJhcHBcIlxuICAgIH1cbiAgfSwgW19jKCduYXZpZ2F0aW9uJyksIF92bS5fdihcIiBcIiksIF9jKCdyb3V0ZXItdmlldycpXSwgMSlcbn0sc3RhdGljUmVuZGVyRm5zOiBbXX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtNGY0ZTVkZDJcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi00ZjRlNWRkMlwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vaW5kZXgudnVlXG4vLyBtb2R1bGUgaWQgPSAyMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCduYXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibmF2YmFyXCJcbiAgfSwgW192bS5fbSgwKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItbWVudVwiLFxuICAgIGF0dHJzOiB7XG4gICAgICBcImlkXCI6IFwibmF2TWVudVwiXG4gICAgfVxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItc3RhcnRcIlxuICB9LCBbX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItaXRlbVwiXG4gIH0sIFtfdm0uX20oMSksIF92bS5fdihcIiBcIiksIF9jKCdyb3V0ZXItbGluaycsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJ0b1wiOiBcIi9cIlxuICAgIH1cbiAgfSwgW192bS5fdihcIkhvbWVcIildKV0sIDEpLCBfdm0uX3YoXCIgXCIpLCAoX3ZtLkdldEF1dGhTdGF0dXMpID8gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItaXRlbVwiXG4gIH0sIFsoX3ZtLkdldEF1dGhTdGF0dXMpID8gX2MoJ3NwYW4nLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiaWNvblwiXG4gIH0sIFtfYygnaScsIHtcbiAgICBzdGF0aWNDbGFzczogXCJmYSBmYS1tb3RvcmN5Y2xlXCJcbiAgfSldKSA6IF92bS5fZSgpLCBfdm0uX3YoXCIgXCIpLCBfYygncm91dGVyLWxpbmsnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwidG9cIjogXCIvbXl0ZWFtXCJcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJNeSBUZWFtXCIpXSldLCAxKSA6IF92bS5fZSgpLCBfdm0uX3YoXCIgXCIpLCBfdm0uX20oMildKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItZW5kXCJcbiAgfSwgWyghX3ZtLkdldEF1dGhTdGF0dXMpID8gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItaXRlbVwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICBfdm0uc2V0UmVnaXN0ZXJNb2RhbCh7XG4gICAgICAgICAgc2hvdzogIV92bS5TaG93UmVnaXN0ZXJNb2RhbFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW192bS5fbSgzKSwgX3ZtLl92KFwiIFwiKSwgX2MoJ2EnLCB7XG4gICAgYXR0cnM6IHtcbiAgICAgIFwiaHJlZlwiOiBcIiMhXCJcbiAgICB9XG4gIH0sIFtfdm0uX3YoXCJSZWdpc3RlclwiKV0pXSkgOiBfdm0uX2UoKSwgX3ZtLl92KFwiIFwiKSwgKCFfdm0uR2V0QXV0aFN0YXR1cykgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm5hdmJhci1pdGVtXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5zZXRMb2dpbk1vZGFsKHtcbiAgICAgICAgICBzaG93OiAhX3ZtLlNob3dMb2dpbk1vZGFsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9LCBbX3ZtLl9tKDQpLCBfdm0uX3YoXCIgXCIpLCBfYygnYScsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJocmVmXCI6IFwiIyFcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIkxvZ2luXCIpXSldKSA6IF92bS5fZSgpLCBfdm0uX3YoXCIgXCIpLCAoX3ZtLkdldEF1dGhTdGF0dXMpID8gX2MoJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJuYXZiYXItaXRlbVwiXG4gIH0sIFtfYygnYScsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJocmVmXCI6IFwiIyFcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIldlbGNvbWUsIFwiICsgX3ZtLl9zKF92bS5nZXRVc2VyRGF0YS51c2VybmFtZSkgKyBcIiFcIildKV0pIDogX3ZtLl9lKCksIF92bS5fdihcIiBcIiksIChfdm0uR2V0QXV0aFN0YXR1cykgPyBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm5hdmJhci1pdGVtXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIF92bS5zZXRMb2dnZWRJbih7XG4gICAgICAgICAgaXNMb2dnZWRJbjogIV92bS5HZXRBdXRoU3RhdHVzXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9LCBbKF92bS5HZXRBdXRoU3RhdHVzKSA/IF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImljb25cIlxuICB9LCBbX2MoJ2knLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmEgZmEtc2lnbi1vdXRcIixcbiAgICBhdHRyczoge1xuICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICAgIH1cbiAgfSldKSA6IF92bS5fZSgpLCBfdm0uX3YoXCIgXCIpLCBfYygnYScsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJocmVmXCI6IFwiIyFcIlxuICAgIH0sXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLmxvZ291dFxuICAgIH1cbiAgfSwgW192bS5fdihcIkxvZ291dFwiKV0pXSkgOiBfdm0uX2UoKV0pXSksIF92bS5fdihcIiBcIiksIF9jKCdyZWdpc3RlcicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJzaG93XCI6IF92bS5TaG93UmVnaXN0ZXJNb2RhbFxuICAgIH1cbiAgfSksIF92bS5fdihcIiBcIiksIF9jKCdsb2dpbicsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJzaG93XCI6IF92bS5TaG93TG9naW5Nb2RhbFxuICAgIH1cbiAgfSldLCAxKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibmF2YmFyLWJyYW5kXCJcbiAgfSwgW19jKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibmF2YmFyLWl0ZW1cIlxuICB9LCBbX3ZtLl92KFwiXFxuICAgICAgRkFOVEFTWU1YXFxuICAgIFwiKV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm5hdmJhci1idXJnZXIgYnVyZ2VyXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiZGF0YS10YXJnZXRcIjogXCJuYXZNZW51XCJcbiAgICB9XG4gIH0sIFtfYygnc3BhbicpLCBfdm0uX3YoXCIgXCIpLCBfYygnc3BhbicpLCBfdm0uX3YoXCIgXCIpLCBfYygnc3BhbicpXSldKVxufSxmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImljb25cIlxuICB9LCBbX2MoJ2knLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmEgZmEtaG9tZVwiXG4gIH0pXSlcbn0sZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcIm5hdmJhci1pdGVtXCJcbiAgfSwgW19jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImljb25cIlxuICB9LCBbX2MoJ2knLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmEgZmEtZ2F2ZWxcIlxuICB9KV0pLCBfdm0uX3YoXCIgXCIpLCBfYygnYScsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJocmVmXCI6IFwiIyFcIlxuICAgIH1cbiAgfSwgW192bS5fdihcIlJ1bGVzXCIpXSldKVxufSxmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtcbiAgcmV0dXJuIF9jKCdzcGFuJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImljb25cIlxuICB9LCBbX2MoJ2knLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZmEgZmEtcGVuY2lsLXNxdWFyZS1vXCIsXG4gICAgYXR0cnM6IHtcbiAgICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCJcbiAgICB9XG4gIH0pXSlcbn0sZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnc3BhbicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJpY29uXCJcbiAgfSwgW19jKCdpJywge1xuICAgIHN0YXRpY0NsYXNzOiBcImZhIGZhLXNpZ24taW5cIlxuICB9KV0pXG59XX1cbm1vZHVsZS5leHBvcnRzLnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikucmVyZW5kZXIoXCJkYXRhLXYtNzc0YzYzOTVcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi03NzRjNjM5NVwifSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbmF2YmFyLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMjExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0wY2JiMDJjOFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbGVhZGVyYm9hcmQudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCIxYzgzNTNiMlwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0wY2JiMDJjOFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbGVhZGVyYm9hcmQudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTBjYmIwMmM4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9sZWFkZXJib2FyZC52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtMGNiYjAyYzhcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vY2xpZW50L2NvbXBvbmVudHMvbGVhZGVyYm9hcmQudnVlXG4vLyBtb2R1bGUgaWQgPSAyMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTFhZDA2ZDY4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9yZWdpc3Rlci52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjAzMGRiYjc4XCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTFhZDA2ZDY4XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9yZWdpc3Rlci52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMWFkMDZkNjhcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL3JlZ2lzdGVyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0xYWQwNmQ2OFwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9yZWdpc3Rlci52dWVcbi8vIG1vZHVsZSBpZCA9IDIxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzgxNzNkMGVcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL215dGVhbS52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1wiKShcIjUwMjYyYWEzXCIsIGNvbnRlbnQsIGZhbHNlKTtcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcbmlmKG1vZHVsZS5ob3QpIHtcbiAvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuIGlmKCFjb250ZW50LmxvY2Fscykge1xuICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTM4MTczZDBlXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9teXRlYW0udnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTM4MTczZDBlXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9teXRlYW0udnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLXN0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+L3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTM4MTczZDBlXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOmZhbHNlfSEuL34vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2NsaWVudC9jb21wb25lbnRzL215dGVhbS52dWVcbi8vIG1vZHVsZSBpZCA9IDIxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTRmNGU1ZGQyXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCEuL2luZGV4LnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCIwMTNiMGQyOFwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNGY0ZTVkZDJcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOmZhbHNlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vaW5kZXgudnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi00ZjRlNWRkMlxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9pbmRleC52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtc3R5bGUtbG9hZGVyIS4vfi9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL34vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNGY0ZTVkZDJcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6ZmFsc2V9IS4vfi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vaW5kZXgudnVlXG4vLyBtb2R1bGUgaWQgPSAyMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTc3NGM2Mzk1XFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjpmYWxzZX0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9uYXZiYXIudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI3MGNkYzExM1wiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi03NzRjNjM5NVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbmF2YmFyLnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi03NzRjNjM5NVxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6ZmFsc2V9IS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wIS4vbmF2YmFyLnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3Z1ZS1zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vfi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi03NzRjNjM5NVwiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAhLi9jbGllbnQvY29tcG9uZW50cy9uYXZiYXIudnVlXG4vLyBtb2R1bGUgaWQgPSAyMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==